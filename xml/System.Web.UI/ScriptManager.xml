<Type Name="ScriptManager" FullName="System.Web.UI.ScriptManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a9923660b999d64c484a67da8c88091d677e8639" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34317739" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ScriptManager : System.Web.UI.Control, System.Web.UI.IPostBackDataHandler, System.Web.UI.IPostBackEventHandler, System.Web.UI.IScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ScriptManager extends System.Web.UI.Control implements class System.Web.UI.IPostBackDataHandler, class System.Web.UI.IPostBackEventHandler, class System.Web.UI.IScriptManager" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ScriptManager&#xA;Inherits Control&#xA;Implements IPostBackDataHandler, IPostBackEventHandler, IScriptManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ScriptManager : System::Web::UI::Control, System::Web::UI::IPostBackDataHandler, System::Web::UI::IPostBackEventHandler, System::Web::UI::IScriptManager" />
  <AssemblyInfo>
    <AssemblyName>System.Web.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.IPostBackDataHandler</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IPostBackEventHandler</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IScriptManager</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Scripts")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ScriptManagerDesigner, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Drawing.ToolboxBitmap(typeof(EmbeddedResourceFinder), "System.Web.Resources.ScriptManager.bmp")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>为 Web 和应用程序服务管理 ASP.NET Ajax 脚本库和脚本文件、局部页面呈现以及客户端代理类生成。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本主题内容：  
  
-   [介绍](#introduction)  
  
-   [局部页面呈现](#partial_page_rendering)  
  
-   [主控页、 用户控件，与其他子组件使用 ScriptManager 控件](#using_the_scriptmanager_control_with_master_pages__user_controls__and_other_child_components)  
  
-   [脚本管理和注册](#script_management_and_registration)  
  
-   [Web 服务引用](#web_service_references)  
  
-   [本地化](#localization)  
  
-   [错误处理](#error_handling)  
  
-   [声明性语法](#declarative_syntax)  
  
<a name="introduction"></a>   
## <a name="introduction"></a>介绍  
 <xref:System.Web.UI.ScriptManager>控件是在 ASP.NET 中的 Ajax 功能的核心。 控件管理页面上的所有 ASP.NET Ajax 资源。 这包括将 Microsoft Ajax Library 脚本下载到浏览器和协调使用启用的部分页面更新<xref:System.Web.UI.UpdatePanel>控件。 此外，<xref:System.Web.UI.ScriptManager>控制，你可以执行以下操作：  
  
-   注册适用于部分页面更新的脚本。 若要管理你的脚本和核心库之间的依赖关系，你注册任何脚本是在 Microsoft Ajax Library 脚本之后加载。  
  
-   指定是否发布或调试脚本发送到浏览器。  
  
-   提供对 Web 服务方法中访问脚本通过注册 Web 服务用于<xref:System.Web.UI.ScriptManager>控件。  
  
-   提供对 ASP.NET 身份验证、 角色和配置文件的访问，请从客户端脚本的应用程序服务通过注册这些服务用于<xref:System.Web.UI.ScriptManager>控件。  
  
-   支持 ECMAScript (JavaScript)、 和浏览器中的函数的区域性特定的显示。  
  
-   通过使用访问嵌入的脚本文件或独立的脚本文件的本地化资源<xref:System.Web.UI.ScriptReferenceBase.ResourceUICultures%2A>属性<xref:System.Web.UI.ScriptReference>控件。  
  
-   注册实现的服务器控件<xref:System.Web.UI.IExtenderControl>或<xref:System.Web.UI.IScriptControl>接口与<xref:System.Web.UI.ScriptManager>控制，以便在呈现脚本所需的客户端组件和行为。  
  
<a name="partial_page_rendering"></a>   
## <a name="partial-page-rendering"></a>局部页面呈现  
 ASP.NET 页能够支持局部页面呈现受以下因素：  
  
-   <xref:System.Web.UI.ScriptManager>控件的<xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A>属性必须为`true`（默认值）。  
  
-   必须有至少一个<xref:System.Web.UI.UpdatePanel>页上的控件。  
  
-   <xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A>属性必须为`true`（默认值）。 如果<xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A>未显式设置属性，其值基于浏览器功能。  
  
 你可以重写的值<xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A>属性在运行时期间或之前已在页面的<xref:System.Web.UI.Control.Init>事件。 如果你尝试在该页面的后更改此属性<xref:System.Web.UI.Control.Init>事件已发生的<xref:System.InvalidOperationException>引发异常。  
  
 当支持局部页面呈现时，<xref:System.Web.UI.ScriptManager>控件呈现脚本，以启用异步回发和局部页面更新。 通过使用指定的页后，可以更新区域<xref:System.Web.UI.UpdatePanel>控件。 <xref:System.Web.UI.ScriptManager>控制处理异步回发和刷新仅的区域的页必须进行更新。 有关在局部页面呈现的详细信息，请参阅[局部页面呈现概述](http://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49)。 有关导致更新的条件的详细信息，请参阅[UpdatePanel 控件概述](http://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a)。  
  
<a name="using_the_scriptmanager_control_with_master_pages__user_controls__and_other_child_components"></a>   
## <a name="using-the-scriptmanager-control-with-master-pages-user-controls-and-other-child-components"></a>主控页、 用户控件，与其他子组件使用 ScriptManager 控件  
 一个页只能包含一个<xref:System.Web.UI.ScriptManager>其层次结构中的控件。 若要注册服务和嵌套的页、 用户控件或组件的脚本，如果父页已<xref:System.Web.UI.ScriptManager>控制，请使用<xref:System.Web.UI.ScriptManagerProxy>控件。 有关详细信息，请参阅[UpdatePanel 控件使用母版页](http://msdn.microsoft.com/library/b1c974d5-a6b2-4bb3-a3cc-61dd9dc0e1d6)  
  
<a name="script_management_and_registration"></a>   
## <a name="script-management-and-registration"></a>脚本管理和注册  
 <xref:System.Web.UI.ScriptManager>控制，你可以将则呈现的脚本注册为页面的一部分。 <xref:System.Web.UI.ScriptManager>控件注册方法可以分为以下三个类别：  
  
-   确保维护脚本依赖 Microsoft Ajax 库的注册方法。  
  
-   注册方法不依赖于 Microsoft Ajax 库中，但与兼容<xref:System.Web.UI.UpdatePanel>控件。  
  
-   注册方法，支持使用<xref:System.Web.UI.UpdatePanel>控件。  
  
 有关如何创建和用于在 ASP.NET Ajax 脚本的详细信息，请参阅[是通过使用 Microsoft Ajax 库中创建自定义客户端脚本](http://msdn.microsoft.com/library/285e3a65-b42e-42c5-952d-baf184057899)。  
  
### <a name="registering-script-that-is-dependent-on-the-microsoft-ajax-library"></a>注册依赖于 Microsoft Ajax 库的脚本  
 你可以使用以下方法可保证维护 Microsoft Ajax 库的任何依赖的方式注册脚本文件。  
  
|方法|定义|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A>|注册一个实现的服务器控件<xref:System.Web.UI.IScriptControl>用于定义客户端对象的接口。 <xref:System.Web.UI.ScriptManager>控件呈现支持客户端对象的脚本。|  
|<xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A>|注册一个实现的服务器控件<xref:System.Web.UI.IExtenderControl>用于定义客户端对象的接口。 <xref:System.Web.UI.ScriptManager>控件呈现支持客户端对象的脚本。|  
  
### <a name="registering-partial-page-update-compatible-scripts"></a>注册局部页面的更新兼容脚本  
 你可以使用以下方法来注册脚本文件不依赖于 Microsoft Ajax Library 但与兼容<xref:System.Web.UI.UpdatePanel>控件。 这些方法对应于的类似方法<xref:System.Web.UI.ClientScriptManager>控件。 如果你是在内部使用的呈现脚本<xref:System.Web.UI.UpdatePanel>控制，请确保调用的方法的<xref:System.Web.UI.ScriptManager>控件。  
  
|方法|定义|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A>|将值添加到 JavaScript 数组。 如果数组不存在，则创建它。|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A>|呈现`script`页打开之后的元素`<form>`标记。 作为字符串参数指定了脚本。|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A>|呈现`script`页打开之后的元素`<form>`标记。 通过将设置指定的脚本内容`src`属性设为指向脚本文件的 URL。|  
|<xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A>|呈现`script`页打开之后的元素`<form>`标记。 脚本内容指定的程序集中的资源名称。 `src`属性会自动填充的 URL 通过从程序集中检索命名的脚本的 HTTP 处理程序调用。|  
|<xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A>|呈现自定义的名称/值特性对 (expando) 指定的控件的标记中。|  
|<xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A>|呈现的隐藏的字段。|  
|<xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A>|注册一个脚本在响应中执行的脚本`form`元素的`submit`事件。 `onSubmit`属性引用指定的脚本。|  
|<xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A>|呈现一个启动脚本块之前页面的右`</form>`标记。 要呈现的脚本被指定为字符串参数。|  
  
 当你注册方法时，你指定用于该脚本的类型/密钥对。 如果已注册具有相同的类型/密钥对的脚本，则未注册的新脚本。 同样，如果已注册的脚本的类型/资源名称对存在，`script`引用该资源的元素不会再次添加。 当你注册 expando 属性的一个以前注册的属性时，会引发异常。 允许的数组值重复的注册。  
  
 当调用<xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A>或<xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A>方法，避免注册执行内联函数的脚本。 相反，应注册脚本，其中包含如事件处理程序的函数定义或自定义类定义你的应用程序。  
  
### <a name="registration-methods-for-updatepanel-controls"></a>UpdatePanel 控件的注册方法  
 你可以使用以下方法以自定义部分页面更新，当你使用<xref:System.Web.UI.UpdatePanel>控件。  
  
|方法|定义|  
|------------|----------------|  
|<xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A>|将控件注册为异步回发的触发器。|  
|<xref:System.Web.UI.ScriptManager.RegisterDataItem%2A>|在局部页面呈现期间将自定义数据发送到多个控件。|  
|<xref:System.Web.UI.ScriptManager.RegisterDispose%2A>|注册控件中的 dispose 脚本<xref:System.Web.UI.UpdatePanel>控件。 在更新或删除 <xref:System.Web.UI.UpdatePanel> 控件时会执行脚本。 Dispose 方法用于客户端组件，是 Microsoft Ajax 库的一部分且必须在不再使用组件时释放资源。|  
|<xref:System.Web.UI.ScriptManager.RegisterPostBackControl%2A>|将控件注册为完整的回发的触发器。 此方法用于内的控件<xref:System.Web.UI.UpdatePanel>将执行异步回发的控件。|  
  
<a name="web_service_references"></a>   
## <a name="web-service-references"></a>Web 服务引用  
 你可以注册 Web 服务以从客户端脚本中调用通过创建<xref:System.Web.UI.ServiceReference>对象并将其添加到<xref:System.Web.UI.ScriptManager.Services%2A>集合<xref:System.Web.UI.ScriptManager>控件。 ASP.NET 生成每个客户端代理对象<xref:System.Web.UI.ServiceReference>对象在<xref:System.Web.UI.ScriptManager.Services%2A>集合。 你可以以编程方式添加<xref:System.Web.UI.ServiceReference>对象添加到<xref:System.Web.UI.ScriptManager.Services%2A>集合用于在运行时注册 Web 服务。  
  
 有关如何访问脚本中的 Web 服务的详细信息，请参阅[公开 Web 服务迁移到 ASP.NET AJAX 中的客户端脚本](http://msdn.microsoft.com/library/fe3f6e9e-0acd-44c9-bf0f-0a8598fc13b8)和[从 ASP.NET AJAX 中的客户端脚本调用 Web 服务](http://msdn.microsoft.com/library/fc06c224-f01a-45be-94af-bd71afbc07b0)。  
  
<a name="localization"></a>   
## <a name="localization"></a>本地化  
 <xref:System.Web.UI.ScriptManager>控件在所呈现的页面上，指向相应的本地化的脚本文件是脚本文件嵌入到程序集或独立的脚本文件中，但也生成引用。  
  
 当<xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A>属性设置为`true`、<xref:System.Web.UI.ScriptManager>控件中检索本地化的资源 （例如本地化的字符串） 的当前区域性，如果它们存在。 <xref:System.Web.UI.ScriptManager>控件提供使用本地化的资源的以下功能：  
  
-   **脚本嵌入到程序集中的文件**。 <xref:System.Web.UI.ScriptManager>控件确定要发送到浏览器的区域性特定或回退区域性脚本文件。 通过使用特定于区域性的执行这<xref:System.Resources.NeutralResourcesLanguageAttribute>程序集属性、 与程序集和浏览器的 UI 区域性打包在一起 （如果有） 的资源。  
  
-   **独立的脚本文件**。 <xref:System.Web.UI.ScriptManager>控件定义的通过使用支持的 UI 区域性列表<xref:System.Web.UI.ScriptReferenceBase.ResourceUICultures%2A>属性<xref:System.Web.UI.ScriptReference>对象。  
  
-   **在调试模式下**。 <xref:System.Web.UI.ScriptManager>控件尝试呈现包含调试信息的区域性特定的脚本文件。 例如，如果页处于调试模式下，当前区域性设置为 en MX 控件呈现脚本文件，如具有名称`scriptname`.en MX.debug.js，如果该文件存在。 如果文件不存在，将呈现的调试文件的适当的回退区域性。  
  
 有关如何将本地化资源的详细信息，请参阅[本地化资源组件库概述](http://msdn.microsoft.com/library/e6b15435-57c1-4dd1-9bd3-5d4c509685bb)。  
  
<a name="error_handling"></a>   
## <a name="error-handling"></a>错误处理  
 当异步回发期间出现页面错误<xref:System.Web.UI.ScriptManager.AsyncPostBackError>引发事件。 在该服务器上的错误会发送到客户端的方式取决于<xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A>属性，<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A>属性，且 Web.config 文件的自定义错误部分。 有关详细信息，请参阅[UpdatePanel 控件的自定义错误处理](http://msdn.microsoft.com/library/e15e7ffb-e4b2-4a89-b99e-16624a5861d0)。  
  
<a name="declarative_syntax"></a>   
## <a name="declarative-syntax"></a>声明性语法  
  
```  
<asp:ScriptManager  
    AllowCustomErrorsRedirect="True|False"  
    AsyncPostBackErrorMessage="string"  
    AsyncPostBackTimeout="integer"  
    AuthenticationService-Path="uri"  
    EnablePageMethods="True|False"  
    EnablePartialRendering="True|False"  
    EnableScriptGlobalization="True|False"  
    EnableScriptLocalization="True|False"  
    EnableTheming="True|False"  
    EnableViewState="True|False"  
    ID="string"  
    LoadScriptsBeforeUI="True|False"  
    OnAsyncPostBackError="AsyncPostBackError event handler"  
    OnDataBinding="DataBinding event handler"  
    OnDisposed="Disposed event handler"  
    OnInit="Init event handler"  
    OnLoad="Load event handler"  
    OnPreRender="PreRender event handler"  
    OnResolveScriptReference="ResolveScriptReference event handler"  
    OnUnload="Unload event handler"  
    ProfileService-LoadProperties="string"  
    ProfileService-Path="uri"  
    RoleService-LoadRoles="True|False"  
    RoleService-Path="uri"  
    runat="server"  
    ScriptMode="Auto|Inherit|Debug|Release"  
    ScriptPath="string"  
    SkinID="string"  
    SupportsPartialRendering="True|False"  
    Visible="True|False"  
>  
        <AuthenticationService  
            Path="uri"  
        />  
        <ProfileService  
            LoadProperties="string"  
            Path="uri"  
        />  
        <RoleService  
            LoadRoles="True|False"  
            Path="uri"  
        />  
        <Scripts>  
            <asp:ScriptReference  
                Assembly="string"  
                IgnoreScriptPath="True|False"  
                Name="string"  
                NotifyScriptLoaded="True|False"  
                Path="string"  
                ResourceUICultures="string"  
                ScriptMode="Auto|Debug|Inherit|Release"  
            />  
        </Scripts>  
        <Services>  
            <asp:ServiceReference  
                InlineScript="True|False"  
                Path="string"  
            />  
        </Services>  
</asp:ScriptManager>  
```  
  
   
  
## Examples  
 下面的示例演示使用不同方案<xref:System.Web.UI.ScriptManager>控件。  
  
 **启用部分页面更新**  
  
 下面的示例演示如何使用<xref:System.Web.UI.ScriptManager>控件来启用局部页面更新。 在此示例中，<xref:System.Web.UI.WebControls.Calendar>和<xref:System.Web.UI.WebControls.DropDownList>控件位于<xref:System.Web.UI.UpdatePanel>控件。 默认情况下，值<xref:System.Web.UI.UpdatePanel.UpdateMode%2A>属性是<xref:System.Web.UI.UpdatePanelUpdateMode.Always>，和的值<xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A>属性是`true`。 因此，子控件的面板会导致异步回发。  
  
 [!code-aspx-csharp[System.Web.UI.UpdatePanel#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.UpdatePanel/CS/UpdatePanelExample1CS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.UpdatePanel#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.UpdatePanel/VB/UpdatePanelExample1VB.aspx#1)]  
  
 **处理局部页面的更新错误并注册脚本**  
  
 下面的示例演示如何提供自定义错误处理在局部页面更新过程。 默认情况下，在局部页面更新过程中发生错误时被显示一个 JavaScript 消息框。 此示例演示如何使用自定义错误处理程序通过提供的处理程序<xref:System.Web.UI.ScriptManager.AsyncPostBackError>事件，并通过设置<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A>事件处理程序中的属性。 你还可以设置<xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A>属性指定在局部页面更新过程中发生错误时如何使用 Web.config 文件的自定义错误部分。 在此示例中，默认值的<xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A>使用属性。 这意味着如果 Web.config 文件包含的元素，该元素将确定错误的显示方式。 有关详细信息，请参阅[customErrors 元素 （ASP.NET 设置架构）](http://msdn.microsoft.com/library/288c32e2-df1f-4548-abda-de6b4cb989a6)。  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.OnAsyncPostBackError#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.OnAsyncPostBackError/CS/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.OnAsyncPostBackError#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.OnAsyncPostBackError/VB/default.aspx#1)]  
  
 **全球化的日期和浏览器中显示的时间**  
  
 下面的示例演示如何设置<xref:System.Web.UI.ScriptManager.EnableScriptGlobalization%2A>属性，以便该客户端脚本可以在浏览器中显示的特定于区域性的日期和时间。 在示例中，`Culture`指令的特性设置为`auto`。 因此，在当前的浏览器设置中指定的第一个语言确定的区域性和 UI 区域性页。 有关详细信息，请参阅[如何： 为 ASP.NET 网页全球化设置区域性和 UI 区域性](http://msdn.microsoft.com/library/76091f86-f967-4687-a40f-de87bd8cc9a0)。  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.EnableScriptGlobalization#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.EnableScriptGlobalization/CS/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.EnableScriptGlobalization#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.EnableScriptGlobalization/VB/default.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.ScriptManagerProxy" />
    <altmember cref="T:System.Web.UI.UpdatePanel" />
    <altmember cref="T:System.Web.UI.ClientScriptManager" />
    <altmember cref="T:System.Web.UI.ScriptMode" />
    <altmember cref="T:System.Web.UI.ScriptReference" />
    <altmember cref="T:System.Web.UI.ServiceReference" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ScriptManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ScriptManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.ScriptManager" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数初始化由使用的内部字段<xref:System.Web.UI.ScriptManager>控件跟踪页、 控制和部署信息。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHistoryPoint">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建一个历史时间点，并将其添加到浏览器的历史记录堆栈中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这些方法重载使你能够在浏览器中定义服务器状态和 （可选） 的历史记录条目的标题。 在创建历史时间点时，序列化和加密的数据会追加到网页的 URL 和浏览器的历史记录堆栈中包括一个条目。 状态数据可用于引发任何后续服务器导航事件时重新创建该页面。 有关详细信息，请参阅[管理浏览器历史记录中使用服务器控件](http://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (System.Collections.Specialized.NameValueCollection state, string title);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(class System.Collections.Specialized.NameValueCollection state, string title) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.Collections.Specialized.NameValueCollection,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (state As NameValueCollection, title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::Collections::Specialized::NameValueCollection ^ state, System::String ^ title);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="state">包含状态数据的键/值对的集合。</param>
        <param name="title">将作为此状态的标题添加到浏览器的历史记录堆栈中的文本。</param>
        <summary>使用指定的状态数据集合和状态标题创建历史时间点，然后将它添加到浏览器的历史记录堆栈中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于创建历史时间点，如果你想要保存的状态数据的多个键/值对。 在创建历史时间点时，序列化和加密的数据会追加到网页的 URL 和浏览器的历史记录堆栈中包括一个条目。 如果`title`参数是`null`，为历史记录堆栈中的状态条目的标题使用的网页标题。  
  
 状态数据可用于引发任何后续服务器导航事件时重新创建该页面。 有关详细信息，请参阅[管理浏览器历史记录中使用服务器控件](http://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (string key, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(string key, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (key As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::String ^ key, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">标识网页状态的键/值对的键部分。</param>
        <param name="value">标识网页状态的键/值对的值部分。</param>
        <summary>使用指定的状态键和状态值创建历史时间点，然后将它添加到浏览器的历史记录堆栈中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法时你只想要保存一个值来标识状态创建历史时间点。 在创建历史时间点时，序列化和加密的数据会追加到网页的 URL 和浏览器的历史记录堆栈中包括一个条目。 网页的标题用作历史记录堆栈中的状态条目的标题。  
  
 状态数据可用于引发任何后续服务器导航事件时重新创建该页面。 有关详细信息，请参阅[管理浏览器历史记录中使用服务器控件](http://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHistoryPoint">
      <MemberSignature Language="C#" Value="public void AddHistoryPoint (string key, string value, string title);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHistoryPoint(string key, string value, string title) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.AddHistoryPoint(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHistoryPoint (key As String, value As String, title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHistoryPoint(System::String ^ key, System::String ^ value, System::String ^ title);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">标识网页状态的键/值对的键部分。</param>
        <param name="value">标识网页状态的键/值对的值部分。</param>
        <param name="title">将作为此状态的标题添加到浏览器的历史记录堆栈中的文本。</param>
        <summary>使用指定的状态键、状态值和状态标题创建历史时间点，然后将它添加到浏览器的历史记录堆栈中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法时要用于保存一个值来标识的状态和状态标题创建历史时间点。 在创建历史时间点时，序列化和加密的数据会追加到网页的 URL 和浏览器的历史记录堆栈中包括一个条目。 如果`title`参数是`null`，为历史记录堆栈中的状态条目的标题使用的网页标题。  
  
 状态数据可用于引发任何后续服务器导航事件时重新创建该页面。 有关详细信息，请参阅[管理浏览器历史记录中使用服务器控件](http://msdn.microsoft.com/library/bad617c8-f84c-4d94-8852-60af400810e9)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AjaxFrameworkAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly AjaxFrameworkAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly AjaxFrameworkAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AjaxFrameworkAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AjaxFrameworkAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ AjaxFrameworkAssembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取页上组件所使用的 Ajax framework 程序集。</summary>
        <value>Ajax framework 程序集。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AjaxFrameworkMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.AjaxFrameworkMode AjaxFrameworkMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.AjaxFrameworkMode AjaxFrameworkMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AjaxFrameworkMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AjaxFrameworkMode As AjaxFrameworkMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::AjaxFrameworkMode AjaxFrameworkMode { System::Web::UI::AjaxFrameworkMode get(); void set(System::Web::UI::AjaxFrameworkMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.AjaxFrameworkMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定将如何将 Microsoft Ajax 客户端库的客户端脚本包括到客户端上。</summary>
        <value>一个 <see cref="T:System.Web.UI.AjaxFrameworkMode" /> 枚举值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.ScriptManager.AjaxFrameworkMode%2A>属性以启用所有 Microsoft Ajax 脚本文件，来禁用所有 Microsoft Ajax 脚本文件，或显式包括各个脚本文件。  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Web.UI.ScriptManager.AjaxFrameworkMode%2A>属性`Explicit`以便指明指明脚本可以显式指定。  
  
```  
<asp:ScriptManager ID="sm1" AjaxFrameworkMode="Explicit" runat="server">   
<Scripts>   
    <asp:ScriptReference Name="MicrosoftAjaxCore.js" />   
    <asp:ScriptReference Name="MicrosoftAjaxComponentModel.js" />    
    <asp:ScriptReference Name="MicrosoftAjaxSerialization.js" />   
    <asp:ScriptReference Name="MicrosoftAjaxNetwork.js" />       
</Scripts>   
</asp:ScriptManager>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.AjaxFrameworkMode" />
      </Docs>
    </Member>
    <Member MemberName="AllowCustomErrorsRedirect">
      <MemberSignature Language="C#" Value="public bool AllowCustomErrorsRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowCustomErrorsRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowCustomErrorsRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowCustomErrorsRedirect { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值确定异步回发出现错误时是否使用 Web.config 文件的自定义错误部分。</summary>
        <value>如果使用 Web.config 文件中的自定义错误设置来确定异步回发期间的错误行为，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackError>异步回发期间页错误时引发事件。 服务器上的错误发送给客户端的方式取决于<xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A>属性，<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A>属性，且 Web.config 文件的自定义错误部分。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackError">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt; AsyncPostBackError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.AsyncPostBackErrorEventArgs&gt; AsyncPostBackError" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AsyncPostBackError As EventHandler(Of AsyncPostBackErrorEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::AsyncPostBackErrorEventArgs ^&gt; ^ AsyncPostBackError;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.AsyncPostBackErrorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当异步回发期间出现页面错误时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackError>异步回发期间页错误时引发事件。 服务器上的错误发送给客户端的方式取决于<xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A>属性，<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A>属性，且 Web.config 文件的自定义错误部分。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Web.UI.ScriptManager.AsyncPostBackError>事件设置<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A>服务器异常错误消息的属性 （它将发送到客户端）。  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.OnAsyncPostBackError(System.Web.UI.AsyncPostBackErrorEventArgs)" />
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackErrorMessage">
      <MemberSignature Language="C#" Value="public string AsyncPostBackErrorMessage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AsyncPostBackErrorMessage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPostBackErrorMessage As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AsyncPostBackErrorMessage { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置异步回发期间发生未处理的服务器异常时发送到客户端的错误消息。</summary>
        <value>错误消息。 默认值为空字符串("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackError>异步回发期间页错误时引发事件。 服务器上的错误发送给客户端的方式取决于<xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A>属性，<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A>属性，且 Web.config 文件的自定义错误部分。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Web.UI.ScriptManager.AsyncPostBackError>事件设置<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A>服务器异常错误消息的属性 （它将发送到客户端）。  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackSourceElementID">
      <MemberSignature Language="C#" Value="public string AsyncPostBackSourceElementID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AsyncPostBackSourceElementID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackSourceElementID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncPostBackSourceElementID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AsyncPostBackSourceElementID { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManagerInternal.AsyncPostBackSourceElementID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取引发异步回发的控件的唯一 ID。</summary>
        <value>如果控件具有 ID，则为它的唯一 ID；否则，为空字符串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackSourceElementID%2A>属性包含的值的控件 ID 的引发异步回发，可以是以下之一：  
  
-   来自中控件的回发<xref:System.Web.UI.UpdatePanel>控制其<xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A>属性设置为`true`（默认值）。  
  
-   为触发器的控件回发<xref:System.Web.UI.UpdatePanel>控件。  
  
-   从通过调用注册的控件回发<xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A>方法<xref:System.Web.UI.ScriptManager>控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPostBackTimeout">
      <MemberSignature Language="C#" Value="public int AsyncPostBackTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AsyncPostBackTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AsyncPostBackTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPostBackTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AsyncPostBackTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(90)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示在未收到响应时异步回发超时前的时间（以秒为单位）。</summary>
        <value>一个表示超时的整数（以秒为单位）。 默认值为 90 秒。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationService">
      <MemberSignature Language="C#" Value="public System.Web.UI.AuthenticationServiceManager AuthenticationService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.AuthenticationServiceManager AuthenticationService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.AuthenticationService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AuthenticationService As AuthenticationServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::AuthenticationServiceManager ^ AuthenticationService { System::Web::UI::AuthenticationServiceManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.AuthenticationServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与当前 <see cref="T:System.Web.UI.ScriptManager" /> 实例关联的 <see cref="T:System.Web.UI.AuthenticationServiceManager" /> 对象。</summary>
        <value>当前 <see cref="T:System.Web.UI.ScriptManager" /> 实例的 <see cref="T:System.Web.UI.AuthenticationServiceManager" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.AuthenticationServiceManager>此属性返回的对象表示向该页面注册的身份验证服务。 可以在中定义的身份验证服务<xref:System.Web.UI.ScriptManager>控件或关联<xref:System.Web.UI.ScriptManagerProxy>控件。  
  
 你可以使用 ASP.NET 身份验证服务，或使用自定义身份验证服务。 你可以在标记中添加自定义的服务，通过包括`AuthenticationService`内的元素`asp:ScriptManager`元素在页面上，如下面的示例中所示。  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <AuthenticationService Path="MyAuthenticationService.asmx" />  
</asp:ScriptManager>  
```  
  
 你可以以编程方式配置<xref:System.Web.UI.AuthenticationServiceManager>对象。 注册服务<xref:System.Web.UI.ScriptManager>控件在页面的<xref:System.Web.UI.Control.PreRender>生命周期阶段。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientNavigateHandler">
      <MemberSignature Language="C#" Value="public string ClientNavigateHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientNavigateHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ClientNavigateHandler" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientNavigateHandler As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientNavigateHandler { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在客户端上处理 [Sys.Application.navigate](http://msdn.microsoft.com/library/79ac04af-18b4-4106-9ab7-9cb10fbd0b93) 事件的方法的名称。</summary>
        <value>处理 [Sys.Application.navigate] 的方法的名称 (http://msdn.microsoft.com/library/79ac04af-18b4-4106-9ab7-9cb10fbd0b93)客户端上的事件。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositeScript">
      <MemberSignature Language="C#" Value="public System.Web.UI.CompositeScriptReference CompositeScript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.CompositeScriptReference CompositeScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.CompositeScript" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompositeScript As CompositeScriptReference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::CompositeScriptReference ^ CompositeScript { System::Web::UI::CompositeScriptReference ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.CompositeScriptReference</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对支持网页的复合脚本的引用。</summary>
        <value>对复合脚本的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[组合到一个复合脚本中的客户端脚本](http://msdn.microsoft.com/library/d0f608d0-b4c8-4795-990b-ede68c1239b3)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyPageUrl">
      <MemberSignature Language="C#" Value="public virtual string EmptyPageUrl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EmptyPageUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EmptyPageUrl" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EmptyPageUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EmptyPageUrl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor(typeof(System.Web.UI.Design.UrlEditor), typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.UrlProperty</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置空白网页的 URL。</summary>
        <value>要在目标网页为空时使用的 URL。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.EmptyPageUrl%2A>属性支持 Ajax 浏览器历史记录。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCdn">
      <MemberSignature Language="C#" Value="public bool EnableCdn { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableCdn" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableCdn" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableCdn As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableCdn { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>确定当前页是否从 CDN（内容分发网络）路径加载客户端脚本引用。</summary>
        <value>如果从 CDN 路径加载客户端脚本引用，则为 <see langword="true" />，否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 未设置此属性为`true`如果你设置<xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A>到`true`已。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCdnFallback">
      <MemberSignature Language="C#" Value="public bool EnableCdnFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableCdnFallback" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableCdnFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableCdnFallback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableCdnFallback { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在无法访问 CDN（内容分发网络）的情况下启动脚本本地副本加载。</summary>
        <value>如果启用了回退 CDN 值，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableHistory">
      <MemberSignature Language="C#" Value="public bool EnableHistory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableHistory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableHistory" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableHistory As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableHistory { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示网页是否支持历史时间点管理。</summary>
        <value>如果网页支持将历史时间点添加到浏览器的历史记录堆栈中，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.ScriptManager.EnableHistory%2A>属性以启用 Web 页中的历史记录管理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnablePageMethods">
      <MemberSignature Language="C#" Value="public bool EnablePageMethods { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnablePageMethods" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnablePageMethods" />
      <MemberSignature Language="VB.NET" Value="Public Property EnablePageMethods As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnablePageMethods { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示能否从客户端脚本调用 ASP.NET 页中公共静态页方法。</summary>
        <value>如果可以从客户端脚本将 ASP.NET 页上的静态页方法作为 Web 方法调用，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以将静态页方法添加到 ASP.NET 页，并将其标记作为 Web 方法。 然后就像它们是 Web 服务，但不会创建单独的.asmx 文件的一部分，可以从脚本中调用这些方法。 若要在页面上创建 Web 方法，请导入<xref:System.Web.Services>命名空间并添加<xref:System.Web.Services.WebMethodAttribute>属性设为你想要公开的每个静态方法。 方法必须标记为公共类。  
  
 有关详细信息，请参阅[公开 Web 服务迁移到 ASP.NET AJAX 中的客户端脚本](http://msdn.microsoft.com/library/fe3f6e9e-0acd-44c9-bf0f-0a8598fc13b8)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnablePartialRendering">
      <MemberSignature Language="C#" Value="public bool EnablePartialRendering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnablePartialRendering" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
      <MemberSignature Language="VB.NET" Value="Public Property EnablePartialRendering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnablePartialRendering { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个可部分呈现页面的值，该操作转而使你可以使用 <see cref="T:System.Web.UI.UpdatePanel" /> 控件来单独更新页面区域。</summary>
        <value>如果启用了部分呈现且禁止了整页更新，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 即使<xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A>属性是`true`，可能不会在局部页面呈现。 浏览器可能不支持局部页面呈现，或<xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A>属性设置为`false`。  
  
 你可以重写的值<xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A>属性在运行时期间或之前已在页面的<xref:System.Web.UI.Control.Init>事件。 如果你尝试在该页面的后更改此属性<xref:System.Web.UI.Control.Init>事件已发生的<xref:System.InvalidOperationException>引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">发生页面的 <see cref="E:System.Web.UI.Control.Init" /> 事件后，设置 <see cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" /> 属性。</exception>
        <altmember cref="T:System.Web.UI.UpdatePanel" />
        <altmember cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" />
      </Docs>
    </Member>
    <Member MemberName="EnableScriptGlobalization">
      <MemberSignature Language="C#" Value="public bool EnableScriptGlobalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableScriptGlobalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableScriptGlobalization" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableScriptGlobalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableScriptGlobalization { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Web.UI.ScriptManager" /> 控件是否呈现支持分析和格式化区域性特定的信息的脚本。</summary>
        <value>如果可以显示区域性特定的信息，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Web.UI.ScriptManager.EnableScriptGlobalization%2A>属性设置为`true`，例如该方法的全球化的 ECMAScript (JavaScript) 函数可显示区域性特定信息。 在浏览器中、 在服务器代码中，或在网站的配置文件中，可以设置该区域性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableScriptLocalization">
      <MemberSignature Language="C#" Value="public bool EnableScriptLocalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableScriptLocalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableScriptLocalization" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableScriptLocalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableScriptLocalization { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Web.UI.ScriptManager" /> 控件是否呈现脚本文件的本地化版本。</summary>
        <value>如果将呈现本地化脚本文件，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A>属性设置为`true`、<xref:System.Web.UI.ScriptManager>对象将检索当前区域性的脚本文件，如果它们存在。 例如，页面可能指定名为 CustomScript.js 的脚本文件。 如果为 fr 的 CA，设置该区域性<xref:System.Web.UI.ScriptManager>对象将尝试检索名为 CustomScript.fr CA.js 的脚本文件。  
  
> [!NOTE]
>  若要防止脚本文件呈现两次，<xref:System.Web.UI.ScriptManager.EnableScriptLocalization%2A>异步回发期间不能修改属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableSecureHistoryState">
      <MemberSignature Language="C#" Value="public bool EnableSecureHistoryState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableSecureHistoryState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.EnableSecureHistoryState" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableSecureHistoryState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableSecureHistoryState { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否加密历史记录状态字符串。</summary>
        <value>如果应加密历史记录状态字符串，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  此属性应***永远不会***设置为`false`生产 web 站点上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrent">
      <MemberSignature Language="C#" Value="public static System.Web.UI.ScriptManager GetCurrent (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.ScriptManager GetCurrent(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetCurrent(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::ScriptManager ^ GetCurrent(System::Web::UI::Page ^ page);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">要从中检索 <see cref="T:System.Web.UI.ScriptManager" /> 的页实例。</param>
        <summary>获取给定 <see cref="T:System.Web.UI.Page" /> 对象的 <see cref="T:System.Web.UI.ScriptManager" /> 实例。</summary>
        <returns>选定 <see cref="T:System.Web.UI.Page" /> 对象的当前 <see cref="T:System.Web.UI.ScriptManager" /> 实例；如果未定义实例，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此静态方法用于确定是否<xref:System.Web.UI.ScriptManager>控件是在页中，或访问的属性和方法<xref:System.Web.UI.ScriptManager>控制当你不知道其 id。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="page" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredArrayDeclarations">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt; GetRegisteredArrayDeclarations ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredArrayDeclaration&gt; GetRegisteredArrayDeclarations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredArrayDeclarations" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredArrayDeclarations () As ReadOnlyCollection(Of RegisteredArrayDeclaration)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredArrayDeclaration ^&gt; ^ GetRegisteredArrayDeclarations();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredArrayDeclaration&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索先前已向 <see cref="T:System.Web.UI.Page" /> 对象注册的 ECMAScript (JavaScript) 数组声明的只读集合。</summary>
        <returns>一个包含数组声明的泛型集合。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterArrayDeclaration" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredClientScriptBlocks">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredClientScriptBlocks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredClientScriptBlocks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredClientScriptBlocks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredClientScriptBlocks () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredClientScriptBlocks();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索先前已向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册的客户端脚本块的只读集合。</summary>
        <returns>一个包含客户端脚本块的泛型集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 客户端脚本块中注册的<xref:System.Web.UI.ScriptManager>内的某个控件一起使用的控件<xref:System.Web.UI.UpdatePanel>控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredDisposeScripts">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt; GetRegisteredDisposeScripts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredDisposeScript&gt; GetRegisteredDisposeScripts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredDisposeScripts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredDisposeScripts () As ReadOnlyCollection(Of RegisteredDisposeScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredDisposeScript ^&gt; ^ GetRegisteredDisposeScripts();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredDisposeScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索先前已向 <see cref="T:System.Web.UI.Page" /> 对象注册的 <see langword="dispose" /> 脚本的只读集合。</summary>
        <returns>一个包含 <see langword="dispose" /> 脚本的泛型集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A`dispose`脚本时执行<xref:System.Web.UI.UpdatePanel>更新或删除控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDispose(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredExpandoAttributes">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt; GetRegisteredExpandoAttributes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredExpandoAttribute&gt; GetRegisteredExpandoAttributes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredExpandoAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredExpandoAttributes () As ReadOnlyCollection(Of RegisteredExpandoAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredExpandoAttribute ^&gt; ^ GetRegisteredExpandoAttributes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredExpandoAttribute&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索先前已向 <see cref="T:System.Web.UI.Page" /> 对象注册的自定义 (expando) 特性的只读集合。</summary>
        <returns>一个包含自定义特性的泛型集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 自定义特性是可以读取和设置由客户端脚本的名称/值对。  
  
   
  
## Examples  
 <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A>  
  
 <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A>  
  
 <xref:System.Web.UI.RegisteredExpandoAttribute>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredHiddenFields">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt; GetRegisteredHiddenFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredHiddenField&gt; GetRegisteredHiddenFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredHiddenFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredHiddenFields () As ReadOnlyCollection(Of RegisteredHiddenField)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredHiddenField ^&gt; ^ GetRegisteredHiddenFields();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredHiddenField&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索先前已向 <see cref="T:System.Web.UI.Page" /> 对象注册的隐藏字段的只读集合。</summary>
        <returns>一个包含隐藏字段的泛型集合。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.UI.RegisteredHiddenField" />
        <altmember cref="Overload:System.Web.UI.ScriptManager.RegisterHiddenField" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredOnSubmitStatements">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredOnSubmitStatements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredOnSubmitStatements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredOnSubmitStatements" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredOnSubmitStatements () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredOnSubmitStatements();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索先前已向 <see cref="T:System.Web.UI.Page" /> 对象注册的 <see langword="onsubmit" /> 语句的只读集合。</summary>
        <returns>一个包含 <see langword="onsubmit" /> 语句的泛型集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `onsubmit`语句是在提交表单时执行的 ECMAScript (JavaScript)。  
  
   
  
## Examples  
 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A>  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredStartupScripts">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt; GetRegisteredStartupScripts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Web.UI.RegisteredScript&gt; GetRegisteredStartupScripts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetRegisteredStartupScripts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRegisteredStartupScripts () As ReadOnlyCollection(Of RegisteredScript)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Web::UI::RegisteredScript ^&gt; ^ GetRegisteredStartupScripts();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Web.UI.RegisteredScript&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索先前已向 <see cref="T:System.Web.UI.Page" /> 对象注册的启动脚本的只读集合。</summary>
        <returns>一个包含启动脚本的泛型集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 启动脚本是与执行启动控件时控件关联的客户端脚本。  
  
   
  
## Examples  
 <xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A>  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>  
  
 <xref:System.Web.UI.ScriptManager.GetRegisteredStartupScripts%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStateString">
      <MemberSignature Language="C#" Value="public string GetStateString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetStateString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.GetStateString" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStateString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetStateString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索包含表示网页状态的键/值对的字符串。</summary>
        <returns>一个字符串，其中包含表示网页状态的键/值对。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，它指示是否将呈现客户端脚本库的调试版本。</summary>
        <value>如果要在调试模式下执行当前请求，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A>属性返回`false`满足以下条件之一时：  
  
-   在配置文件的元素中`retail`属性设置为`true`。 此设置将替代所有其他设置。  
  
-   <xref:System.Web.UI.ScriptManager.ScriptMode%2A>属性设置为`Auto`或`Inherit`，和中未启用调试`compilation`的应用程序根 Web.config 文件的部分。  
  
-   <xref:System.Web.UI.ScriptManager.ScriptMode%2A> 属性设置为 `Release`。  
  
    > [!NOTE]
    >  `debug`指令的特性不会影响支持 Ajax 的 ASP.NET 应用程序。 <xref:System.Web.UI.ScriptManager>控件使用的设置仅在 Web.config 文件中并在其<xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A>和<xref:System.Web.UI.ScriptManager.ScriptMode%2A>属性来确定是否呈现调试脚本。  
  
 有关详细信息，请参阅[调试和跟踪 Ajax 应用程序概述](http://msdn.microsoft.com/library/92684ea0-7bb4-4a34-9203-3aa6394ce375)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.IsDebuggingEnabled" />
      </Docs>
    </Member>
    <Member MemberName="IsInAsyncPostBack">
      <MemberSignature Language="C#" Value="public bool IsInAsyncPostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInAsyncPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsInAsyncPostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInAsyncPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInAsyncPostBack { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IScriptManagerInternal.IsInAsyncPostBack</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否要在部分呈现模式下执行当前回发。</summary>
        <value>如果要在部分呈现模式下执行当前回发，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A>属性结合<xref:System.Web.UI.Page.IsPostBack%2A>属性来区分初始页面加载、 局部页面的更新和中的整页更新<xref:System.Web.UI.Control.Load>， <xref:System.Web.UI.Page.InitComplete>，或<xref:System.Web.UI.Control.PreRender>事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
      </Docs>
    </Member>
    <Member MemberName="IsNavigating">
      <MemberSignature Language="C#" Value="public bool IsNavigating { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNavigating" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.IsNavigating" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNavigating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNavigating { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前是否正在处理 <see cref="E:System.Web.UI.ScriptManager.Navigate" /> 事件。</summary>
        <value>如果正在处理 <see cref="E:System.Web.UI.ScriptManager.Navigate" />，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.ScriptManager.IsNavigating%2A>属性来确定是否<xref:System.Web.UI.ScriptManager.Navigate>引发事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPostData">
      <MemberSignature Language="C#" Value="protected virtual bool LoadPostData (string postDataKey, System.Collections.Specialized.NameValueCollection postCollection);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LoadPostData(string postDataKey, class System.Collections.Specialized.NameValueCollection postCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LoadPostData (postDataKey As String, postCollection As NameValueCollection) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LoadPostData(System::String ^ postDataKey, System::Collections::Specialized::NameValueCollection ^ postCollection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="postDataKey" Type="System.String" />
        <Parameter Name="postCollection" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="postDataKey">控件的主要标识符。</param>
        <param name="postCollection">所有传入的后期数据的集合。</param>
        <summary>读取从浏览器发送到服务器的表单数据，并确定异步回发的源。</summary>
        <returns>如果 <see cref="T:System.Web.UI.ScriptManager" /> 控件的状态已因回发而更改，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.LoadPostData%2A>方法主要由控件开发人员用来扩展的功能<xref:System.Web.UI.ScriptManager>控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <Member MemberName="LoadScriptsBeforeUI">
      <MemberSignature Language="C#" Value="public bool LoadScriptsBeforeUI { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadScriptsBeforeUI" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.LoadScriptsBeforeUI" />
      <MemberSignature Language="VB.NET" Value="Public Property LoadScriptsBeforeUI As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool LoadScriptsBeforeUI { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是在加载页 UI 的标记之前还是在之后加载脚本。</summary>
        <value>如果在加载 UI 标记前加载脚本，则为 <see langword="true" />；如果在加载 UI 标记后加载脚本，则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A>属性确定如何在脚本<xref:System.Web.UI.ScriptManager.Scripts%2A>集合加载相对于页 UI 的标记。  
  
 当<xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A>属性是`true`、`script`元素呈现在加载页面的 UI 标记之前。 在此方案中，如果 UI 元素定义在脚本中，UI 将完全正常运行时加载。 但是，如果该脚本访问中为其实例尚未已创建的标记的 UI 元素，可能发生错误。 若要确保访问它们之前，加载了 UI 元素，处理的事件的类。  
  
 当<xref:System.Web.UI.ScriptManager.LoadScriptsBeforeUI%2A>属性是`false`、`script`元素后呈现页面的 UI 标记呈现。 在此方案中，UI 加载速度更快，但它可能不是完全正常运行如果定义其他 UI 元素的脚本具有未完成加载。  
  
 未设置此属性为`true`如果你设置<xref:System.Web.UI.ScriptManager.EnableCdn%2A>到`true`已。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.ScriptManager.Scripts" />
        <altmember cref="T:System.Web.UI.ScriptReference" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.HistoryEventArgs&gt; Navigate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.HistoryEventArgs&gt; Navigate" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.Navigate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigate As EventHandler(Of HistoryEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::HistoryEventArgs ^&gt; ^ Navigate;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.HistoryEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户点击浏览器的“后退”或“前进”按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户单击浏览器的**回**按钮，浏览器将转到以前查看过的 Url，其中包括包含历史时间点状态数据的 Url。 如果网页中的客户端代码检测到该 URL 包含历史记录状态数据，它将发出一个请求到服务器页。 回发事件，将充当和<xref:System.Web.UI.ScriptManagerProxy>服务器控件引发`Navigate`事件。 你可以处理此事件，并重新创建与事件使用传递的状态数据的根据需要在 Web 应用程序中的页。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAsyncPostBackError">
      <MemberSignature Language="C#" Value="protected internal virtual void OnAsyncPostBackError (System.Web.UI.AsyncPostBackErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnAsyncPostBackError(class System.Web.UI.AsyncPostBackErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnAsyncPostBackError(System.Web.UI.AsyncPostBackErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnAsyncPostBackError (e As AsyncPostBackErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnAsyncPostBackError(System::Web::UI::AsyncPostBackErrorEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.AsyncPostBackErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">错误事件数据。</param>
        <summary>引发 <see cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.AsyncPostBackError>异步回发期间页错误时引发事件。 服务器上的错误发送给客户端的方式取决于<xref:System.Web.UI.ScriptManager.AllowCustomErrorsRedirect%2A>属性，<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A>属性，且 Web.config 文件的自定义错误部分。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Web.UI.ScriptManager.AsyncPostBackError>事件设置<xref:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage%2A>服务器异常错误消息的属性 （它将发送到客户端）。  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/CS/ScriptManager_AsyncPostBackErrorMessageCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.AsyncPostBackErrorMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.AsyncPostBackErrorMessage/VB/ScriptManager_AsyncPostBackErrorMessageVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.ScriptManager.AsyncPostBackError" />
        <altmember cref="P:System.Web.UI.ScriptManager.AsyncPostBackErrorMessage" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件数据。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.Init" /> 事件并确保页面上只有一个 <see cref="T:System.Web.UI.ScriptManager" /> 控件。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">页面上存在多个 <see cref="T:System.Web.UI.ScriptManager" /> 实例。</exception>
        <block subset="none" type="overrides">
          <para>在重写此方法，调用基<see cref="M:System.Web.UI.ScriptManager.OnInit(System.EventArgs)" />为局部页面呈现正确处理方法，以便脚本文件。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件数据。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.PreRender" /> 事件，并为部分页面更新注册脚本文件和服务。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关 DOM 的信息，请参阅[文档对象模型 (DOM) 级别 1 规范](http://go.microsoft.com/fwlink/?LinkId=73305)World Wide Web Consortium (W3C) 网站上。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">发出部分页面请求的浏览器至少不支持 DOM Level 1.0。</exception>
        <block subset="none" type="overrides">
          <para>在重写此方法，调用基<see cref="M:System.Web.UI.ScriptManager.OnPreRender(System.EventArgs)" />为局部页面呈现正确处理方法，以便脚本块和服务。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnResolveCompositeScriptReference">
      <MemberSignature Language="C#" Value="protected virtual void OnResolveCompositeScriptReference (System.Web.UI.CompositeScriptReferenceEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResolveCompositeScriptReference(class System.Web.UI.CompositeScriptReferenceEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnResolveCompositeScriptReference(System.Web.UI.CompositeScriptReferenceEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResolveCompositeScriptReference (e As CompositeScriptReferenceEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResolveCompositeScriptReference(System::Web::UI::CompositeScriptReferenceEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.CompositeScriptReferenceEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">一个表示复合脚本引用的对象。</param>
        <summary>引发 <see cref="E:System.Web.UI.ScriptManager.ResolveCompositeScriptReference" /> 事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnResolveScriptReference">
      <MemberSignature Language="C#" Value="protected virtual void OnResolveScriptReference (System.Web.UI.ScriptReferenceEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResolveScriptReference(class System.Web.UI.ScriptReferenceEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.OnResolveScriptReference(System.Web.UI.ScriptReferenceEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResolveScriptReference (e As ScriptReferenceEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResolveScriptReference(System::Web::UI::ScriptReferenceEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.ScriptReferenceEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">一个表示当前脚本的对象。</param>
        <summary>为 <see cref="T:System.Web.UI.ScriptManager" /> 控件托管的每个脚本引用引发 <see cref="E:System.Web.UI.ScriptManager.ResolveScriptReference" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法<xref:System.Web.UI.ScriptManager.OnPreRender%2A>事件处理程序，每次为一个<xref:System.Web.UI.ScriptReference>中<xref:System.Web.UI.ScriptManager.Scripts%2A>集合。  
  
 <xref:System.Web.UI.ScriptManager.ResolveScriptReference>重复脚本条目已得到解决后，将引发事件。  
  
 重写此方法以影响单个脚本块在回发时或在局部页面更新的行为。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProfileService">
      <MemberSignature Language="C#" Value="public System.Web.UI.ProfileServiceManager ProfileService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ProfileServiceManager ProfileService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ProfileService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProfileService As ProfileServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ProfileServiceManager ^ ProfileService { System::Web::UI::ProfileServiceManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ProfileServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与当前 <see cref="T:System.Web.UI.ScriptManager" /> 实例关联的 <see cref="T:System.Web.UI.ProfileServiceManager" /> 对象。</summary>
        <value>当前 <see cref="T:System.Web.UI.ScriptManager" /> 实例的 <see cref="T:System.Web.UI.ProfileServiceManager" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ProfileServiceManager>此属性返回的对象表示向该页面注册配置文件服务。 可以在中定义配置文件服务<xref:System.Web.UI.ScriptManager>控件或关联<xref:System.Web.UI.ScriptManagerProxy>控件。  
  
 你可以使用 ASP.NET 配置文件服务，或使用自定义配置文件服务。 你可以在标记中添加自定义的服务，通过包括`ProfileService`内的元素`asp:ScriptManager`元素在页面上，如下面的示例中所示。  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <ProfileService LoadProperties="propertyA,propertyB"  
    Path="MyProfileService.asmx" />  
</asp:ScriptManager>  
```  
  
 你可以以编程方式配置<xref:System.Web.UI.ProfileServiceManager>对象。 注册服务<xref:System.Web.UI.ScriptManager>控件在页面的<xref:System.Web.UI.Control.PreRender>生命周期阶段。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePostBackEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostBackEvent (string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostBackEvent(string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RaisePostBackEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostBackEvent (eventArgument As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostBackEvent(System::String ^ eventArgument);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventArgument">表示网页历史记录状态的键/值对的字符串。</param>
        <summary>处理由 <see cref="T:System.Web.UI.ScriptManager" /> 控件引发的回发事件，并加载网页的历史记录状态。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePostDataChangedEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostDataChangedEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostDataChangedEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RaisePostDataChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostDataChangedEvent ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostDataChangedEvent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当 <see cref="T:System.Web.UI.ScriptManager" /> 控件回发到服务器时引发此控件的事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RaisePostDataChangedEvent%2A>方法主要由控件开发人员用来扩展的功能<xref:System.Web.UI.ScriptManager>控件。 默认实现为<xref:System.Web.UI.ScriptManager>控件，会引发任何事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterArrayDeclaration">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个 ECMAScript (JavaScript) 数组声明以与 <see cref="T:System.Web.UI.UpdatePanel" /> 控件内的某个控件一起使用，并将此数组添加到页面中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public static void RegisterArrayDeclaration (System.Web.UI.Control control, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterArrayDeclaration(class System.Web.UI.Control control, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterArrayDeclaration(System::Web::UI::Control ^ control, System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">正在注册数组的控件。</param>
        <param name="arrayName">要注册的数组的名称。</param>
        <param name="arrayValue">要注册的一个或多个数组值。</param>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个 ECMAScript (JavaScript) 数组声明以与 <see cref="T:System.Web.UI.UpdatePanel" /> 控件内的某个控件一起使用，并将此数组添加到页面中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你使用<xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A>方法注册客户端脚本数组，它是与兼容局部页面呈现，且没有任何 Microsoft Ajax 库依赖项。 此方法注册数组时`control`表示控件内<xref:System.Web.UI.UpdatePanel>正在更新的控件。 若要注册一个数组，每次异步回发发生时，使用<xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%28System.Web.UI.Page%2CSystem.String%2CSystem.String%29>此方法的重载。  
  
 如果你想要注册一个数组，其中不属于部分页面更新，如果你想要注册该数组只进行一次初始页呈现期间使用<xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A>方法<xref:System.Web.UI.ClientScriptManager>类。 你可以获取对引用<xref:System.Web.UI.ClientScriptManager>对象<xref:System.Web.UI.Page.ClientScript%2A>页属性。  
  
 <xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A>方法确定是否包含在指定的名称的数组`arrayName`参数已注册。 因此，该方法将添加中指定的值如果`arrayValue`。 因为要注册的数组基于<xref:System.Collections.ArrayList>类，允许重复项。 如果中的名称的已注册数组`arrayName`不存在，在创建数组中的值和`arrayValue`向其添加。  
  
 若要在数组中包含字符串文本，使用单引号 （'） 或转义的双引号括起来 (\\") 中`arrayValue`。  
  
 请注意 JavaScript 作为数组中的分隔符将逗号 （，）。 你可以通过将传递以逗号分隔的字符串中指定多个数组值`arrayValue`。 用逗号分隔两个项`arrayValue`等效于调用<xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A>方法两次，一次每个项。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayName" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Page,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public static void RegisterArrayDeclaration (System.Web.UI.Page page, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterArrayDeclaration(class System.Web.UI.Page page, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Page,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterArrayDeclaration(System::Web::UI::Page ^ page, System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">正在注册该数组的页对象。</param>
        <param name="arrayName">要注册的数组的名称。</param>
        <param name="arrayValue">要注册的一个或多个数组值。</param>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个 ECMAScript (JavaScript) 数组声明以与 <see cref="T:System.Web.UI.UpdatePanel" /> 控件内的某个控件一起使用，并将此数组添加到页面中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你使用<xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%2A>方法注册客户端脚本数组，它是与兼容局部页面呈现，且没有任何 Microsoft Ajax 库依赖项。 此方法在每次发生异步回发注册数组。 若要注册的控件，位于数组<xref:System.Web.UI.UpdatePanel>控制，以便仅在更新面板时，才注册该数组，请使用<xref:System.Web.UI.ScriptManager.RegisterArrayDeclaration%28System.Web.UI.Control%2CSystem.String%2CSystem.String%29>此方法的重载。  
  
 如果你想要注册一个数组，其中不属于部分页面更新，如果你想要注册该数组只进行一次初始页呈现期间使用<xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A>方法<xref:System.Web.UI.ClientScriptManager>类。 你可以获取对引用<xref:System.Web.UI.ClientScriptManager>对象<xref:System.Web.UI.Page.ClientScript%2A>页属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayName" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAsyncPostBackControl">
      <MemberSignature Language="C#" Value="public void RegisterAsyncPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAsyncPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterAsyncPostBackControl(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterAsyncPostBackControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">要为异步回发注册的控件。</param>
        <summary>将控件注册为异步回发的触发器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A>方法使您能够将 Web 服务器控件注册为触发器，以便他们执行异步回发而不是同步回发。 当<xref:System.Web.UI.UpdatePanel.ChildrenAsTriggers%2A>属性<xref:System.Web.UI.UpdatePanel>控件设置为`true`（这是默认值），回发控件内的<xref:System.Web.UI.UpdatePanel>控件将自动注册为异步回发的控件。  
  
 使用<xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A>方法注册外部的控件<xref:System.Web.UI.UpdatePanel>为触发器为异步回发，并可能会更新面板的内容的控件。 若要更新<xref:System.Web.UI.UpdatePanel>以编程方式控制，请调用<xref:System.Web.UI.UpdatePanel.Update%2A>方法。  
  
 你可以通过将添加触发器以声明方式`Triggers`元素<xref:System.Web.UI.UpdatePanel>控件。 在 Visual Studio 中，使用设计器的**UpdatePanelTrigger 集合编辑器**对话框。  
  
   
  
## Examples  
 下面的示例演示如何调用<xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A>方法注册<xref:System.Web.UI.WebControls.Button>控制，以便它导致更新<xref:System.Web.UI.UpdatePanel>控件的内容。 <xref:System.Web.UI.WebControls.Button>控件不是内部<xref:System.Web.UI.UpdatePanel>控件。 显示两个按钮：`Button1`和`Button2`。 `Button1` 刷新面板的内容和`Button2`刷新整个页面。  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/CS/ScriptManager1CS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/VB/ScriptManager1VB.aspx#1)]  
  
 下面的示例演示如何调用<xref:System.Web.UI.ScriptManager.RegisterAsyncPostBackControl%2A>方法来注册用户控件，以便它导致更新<xref:System.Web.UI.UpdatePanel>控件的内容。 第一个示例演示使用用户控件的页面。 第二个示例显示用户控件。  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#2](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/CS/ScriptManager2CS.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterAsyncPostBackControl#2](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterAsyncPostBackControl/VB/ScriptManager2VB.aspx#2)]  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">注册的控件不实现 <see cref="T:System.Web.UI.INamingContainer" />、<see cref="T:System.Web.UI.IPostBackDataHandler" /> 或 <see cref="T:System.Web.UI.IPostBackEventHandler" /> 接口。</exception>
        <altmember cref="P:System.Web.UI.UpdatePanel.Triggers" />
        <altmember cref="M:System.Web.UI.UpdatePanel.Update" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个客户端脚本块以与 <see cref="T:System.Web.UI.UpdatePanel" /> 控件中的某个控件一起使用，然后将该此脚本块添加到页面中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptBlock (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptBlock(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptBlock(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">正在注册客户端脚本块的控件。</param>
        <param name="type">客户端脚本块的类型。 通常使用 <see langword="typeof" /> 运算符 (C#) 或 <see langword="GetType" /> 运算符 (Visual Basic) 来指定此参数，以检索正在注册此脚本的控件的类型。</param>
        <param name="key">脚本块的唯一标识符。</param>
        <param name="script">脚本。</param>
        <param name="addScriptTags">如果要用 <see langword="&lt;script&gt;" /> 和 <see langword="&lt;/script&gt;" /> 标记括起脚本块，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个客户端脚本块以与 <see cref="T:System.Web.UI.UpdatePanel" /> 控件中的某个控件一起使用，然后将该此脚本块添加到页面中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你使用<xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A>方法注册客户端脚本块兼容具有局部页面呈现，且没有任何 Microsoft Ajax 库依赖项。 使用此方法注册的客户端脚本块被发送到页仅当`control`表示控件内<xref:System.Web.UI.UpdatePanel>正在更新的控件。 若要注册的脚本块每次异步回发发生时，使用<xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>此方法的重载。  
  
 如果你想要注册不属于部分页面更新，如果你想要注册的脚本块只进行一次初始页呈现期间使用的脚本块<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法<xref:System.Web.UI.ClientScriptManager>类。 你可以获取对引用<xref:System.Web.UI.ClientScriptManager>对象<xref:System.Web.UI.Page.ClientScript%2A>页属性。  
  
 如果`addScriptTags`是`true`、<xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A>方法将添加`<script>`脚本块的标记。 传递`false`如果你想要创建`<script>`标记你自己，如你想要设置特定的特性`<script>`标记。 如果`addScriptTags`是`false`和`script`参数包含多个脚本块，则会引发异常。  
  
 <xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%2A>方法在打开后将脚本块添加到页面`<form>`标记。 不保证的脚本块都是与它们注册的顺序相同的输出。 如果脚本块的顺序很重要，则应将脚本块连接到单个字符串 (例如，通过使用<xref:System.Text.StringBuilder>对象)，然后将它们注册为单个客户端脚本块。  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/CS/ScriptManager_RegisterClientScriptBlockCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/vb/ScriptManager_RegisterClientScriptBlockVB.aspx#1)]  
  
 [!code-xml[System.Web.UI.ScriptManager.RegisterClientScriptBlock#2](~/samples/snippets/common/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptBlock/Common/App_Data/Contacts.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">该客户端脚本块的 <paramref name="type" /> 为 <see langword="null" />。  \- 或 -  正在注册该脚本块的控件为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">正在注册该脚本块的控件不在页面的控件树中。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptBlock (System.Web.UI.Page page, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptBlock(class System.Web.UI.Page page, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptBlock(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="page">正在注册客户端脚本块的页对象。</param>
        <param name="type">客户端脚本块的类型。 通常使用 <see langword="typeof" /> 运算符 (C#) 或 <see langword="GetType" /> 运算符 (Visual Basic) 来指定此参数，以检索正在注册此脚本的控件的类型。</param>
        <param name="key">脚本块的唯一标识符。</param>
        <param name="script">要注册的脚本。</param>
        <param name="addScriptTags">如果要用 <see langword="&lt;script&gt;" /> 和 <see langword="&lt;/script&gt;" /> 标记括起脚本块，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个客户端脚本块以与 <see cref="T:System.Web.UI.UpdatePanel" /> 控件中的某个控件一起使用，然后将该此脚本块添加到页面中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你使用此方法注册一个脚本块时，每次异步回发发生时，被呈现该脚本。 若要注册脚本块内的控件<xref:System.Web.UI.UpdatePanel>控制，以便脚本已注册时，才<xref:System.Web.UI.UpdatePanel>控件更新，请使用<xref:System.Web.UI.ScriptManager.RegisterClientScriptBlock%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>此方法的重载。  
  
 如果你想要注册不属于部分页面更新，如果你想要注册的脚本块只进行一次初始页呈现期间使用的脚本块<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法<xref:System.Web.UI.ClientScriptManager>类。 你可以获取对引用<xref:System.Web.UI.ClientScriptManager>对象<xref:System.Web.UI.Page.ClientScript%2A>页属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">该脚本块的 <paramref name="type" /> 为 <see langword="null" />。  \- 或 -  正在注册该脚本块的页为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个客户端脚本文件，以便和 <see cref="T:System.Web.UI.UpdatePanel" /> 控件中的某个控件一起使用，然后将脚本文件引用添加到页面中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptInclude (System.Web.UI.Control control, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptInclude(class System.Web.UI.Control control, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptInclude(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">正在注册客户端脚本文件的控件。</param>
        <param name="type">客户端脚本文件的类型。 通常使用 typeof 运算符 (C#) 或 GetType 运算符 (Visual Basic) 来指定此参数，以检索正在注册脚本的控件的类型。</param>
        <param name="key">脚本文件的唯一标识符。</param>
        <param name="url">脚本文件的 URL。</param>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个客户端脚本文件，以便和 <see cref="T:System.Web.UI.UpdatePanel" /> 控件中的某个控件一起使用，然后将脚本文件引用添加到页面中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你使用<xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A>方法中部分页面更新注册页或属于是否正在参与的页面的客户端脚本文件。 使用此方法注册的客户端脚本文件发送到页面时，才`control`表示控件内<xref:System.Web.UI.UpdatePanel>正在更新的控件。 若要注册的脚本文件每次异步回发发生时，使用<xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%29>此方法的重载。  
  
 如果你想要注册不属于部分页面更新，如果你想要注册的脚本块只进行一次初始页呈现期间使用的脚本块<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法<xref:System.Web.UI.ClientScriptManager>类。 你可以获取对引用<xref:System.Web.UI.ClientScriptManager>对象<xref:System.Web.UI.Page.ClientScript%2A>页属性。  
  
 <xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A>方法注册页上的客户端脚本文件呈现`script`其开始标记中包含的元素`src`属性。 `url`参数用于设置`src`属性。 若要解决 Url，请使用<xref:System.Web.UI.Control.ResolveClientUrl%2A>方法。 此方法使用被调用的以解析路径的 URL 的上下文。  
  
 同时<xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A>和<xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A>方法呈现到浏览器的脚本文件。 如果已呈现具有相同类型和密钥 （对于脚本文件） 或相同类型和资源名称 （对于嵌入的资源） 的脚本，则不会再次呈现脚本。  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterClientScriptInclude#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptInclude/CS/ScriptManager_RegisterClientScriptIncludeCS.aspx#1)]  
  
 [!code-javascript[System.Web.UI.ScriptManager.RegisterClientScriptInclude#2](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterClientScriptInclude/CS/scripts/script_alertdiv.js#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">该客户端脚本文件的 <paramref name="type" /> 为 <see langword="null" />。  \- 或 -  正在注册该脚本文件的控件为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">正在注册该脚本文件的控件不在页面的控件树中。  \- 或 -  <paramref name="url" /> 为 <see langword="null" />。  \- 或 -  <paramref name="url" /> 为空。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Page,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptInclude (System.Web.UI.Page page, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptInclude(class System.Web.UI.Page page, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptInclude(System.Web.UI.Page,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptInclude(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">正在注册客户端脚本文件的页对象。</param>
        <param name="type">客户端脚本文件的类型。 通常使用 typeof 运算符 (C#) 或 GetType 运算符 (Visual Basic) 来指定此参数，以检索正在注册脚本的控件的类型。</param>
        <param name="key">脚本文件的唯一标识符。</param>
        <param name="url">脚本文件的 URL。</param>
        <summary>每次发生异步回发时都向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册客户端脚本，然后将一个脚本文件引用添加到页面中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法注册的脚本文件时，被呈现该脚本每次发生异步回发。 要注册脚本文件的控件，位于<xref:System.Web.UI.UpdatePanel>控制，以便脚本已注册时，才<xref:System.Web.UI.UpdatePanel>控件更新，请使用<xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%29>此方法的重载。  
  
 如果你想要注册不属于部分页面更新，如果你想要注册的脚本块只进行一次初始页呈现期间使用的脚本块<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法<xref:System.Web.UI.ClientScriptManager>类。 你可以获取对引用<xref:System.Web.UI.ClientScriptManager>对象<xref:System.Web.UI.Page.ClientScript%2A>页属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">该客户端脚本文件的 <paramref name="type" /> 为 <see langword="null" />。  \- 或 -  正在注册该脚本文件的页为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> 为 <see langword="null" />。  \- 或 -  <paramref name="url" /> 为空。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptResource">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册嵌入程序集中的客户端脚本，以便和正在参与局部页面呈现的控件一起使用。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptResource (System.Web.UI.Control control, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptResource(class System.Web.UI.Control control, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptResource(System::Web::UI::Control ^ control, Type ^ type, System::String ^ resourceName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">正在注册脚本的控件。</param>
        <param name="type">客户端脚本的类型。 通常使用 typeof 运算符 (C#) 或 GetType 运算符 (Visual Basic) 来指定此参数，以检索正在注册脚本的控件的类型。</param>
        <param name="resourceName">资源的标识符。</param>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册嵌入程序集中的客户端脚本，以便和正在参与局部页面呈现的控件一起使用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你使用<xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A>方法以注册与局部页面呈现，兼容的脚本没有任何 Microsoft Ajax 库依赖项。 注册使用此方法注册的脚本资源时，才`control`表示控件内<xref:System.Web.UI.UpdatePanel>更新的控件。 若要注册的脚本每次异步回发发生时，使用<xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>此方法的重载。  
  
 如果你想要注册不属于部分页面更新，如果你想要注册的脚本块只进行一次初始页呈现期间使用的脚本块<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法<xref:System.Web.UI.ClientScriptManager>类。 你可以获取对引用<xref:System.Web.UI.ClientScriptManager>对象<xref:System.Web.UI.Page.ClientScript%2A>页属性。  
  
 <xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A>当从程序集的资源访问的 HTTP 处理程序通过使用方法。 此方法包含的内容中的资源 URL`script`元素。  
  
 同时<xref:System.Web.UI.ScriptManager.RegisterClientScriptInclude%2A>和<xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%2A>方法加载到浏览器中的脚本文件。 如果已加载具有相同类型和密钥 （对于脚本文件） 或相同类型和资源名称 （对于嵌入的资源） 的脚本，脚本不会重新加载。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">该客户端资源的 <paramref name="type" /> 为 <see langword="null" />。  \- 或 -  正在注册该脚本的控件为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">正在注册该脚本的控件不在页面的控件树中。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Page,System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterClientScriptResource (System.Web.UI.Page page, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClientScriptResource(class System.Web.UI.Page page, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Page,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClientScriptResource(System::Web::UI::Page ^ page, Type ^ type, System::String ^ resourceName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">正在注册脚本的页对象。</param>
        <param name="type">客户端脚本的类型。 通常使用 typeof 运算符 (C#) 或 GetType 运算符 (Visual Basic) 来指定此参数，以检索正在注册脚本的控件的类型。</param>
        <param name="resourceName">资源的标识符。</param>
        <summary>每次发生回发时都向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册嵌入程序集中的客户端脚本文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法注册的脚本文件时，被呈现该脚本每次发生异步回发。 以注册的脚本的控件，位于<xref:System.Web.UI.UpdatePanel>控制，以便注册了脚本时，才<xref:System.Web.UI.UpdatePanel>控件更新，请使用<xref:System.Web.UI.ScriptManager.RegisterClientScriptResource%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%29>此方法的重载。  
  
 如果你想要注册不属于部分页面更新，如果你想要注册的脚本块只进行一次初始页呈现期间使用的脚本块<xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A>方法<xref:System.Web.UI.ClientScriptManager>类。 你可以获取对引用<xref:System.Web.UI.ClientScriptManager>对象<xref:System.Web.UI.Page.ClientScript%2A>页属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">该客户端资源的 <paramref name="type" /> 为 <see langword="null" />。  \- 或 -  正在注册该脚本的页为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterDataItem">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在局部页面呈现期间将自定义数据发送到多个控件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterDataItem">
      <MemberSignature Language="C#" Value="public void RegisterDataItem (System.Web.UI.Control control, string dataItem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDataItem(class System.Web.UI.Control control, string dataItem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDataItem(System::Web::UI::Control ^ control, System::String ^ dataItem);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="dataItem" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">正在接收数据的控件。</param>
        <param name="dataItem">发送到控件的数据。</param>
        <summary>在局部页面呈现期间将自定义数据发送到某个控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.ScriptManager.RegisterDataItem%2A>方法将数据发送从服务器到客户端异步回发，而不考虑是否接收数据的控件位于期间<xref:System.Web.UI.UpdatePanel>控件。  
  
 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A>可以仅在异步回发期间调用方法。 若要确定是否异步回发，请使用<xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A>属性。 此方法调用采用名为的参数的重载`isJsonSerialized`设置为`false`。 当`isJsonSerialized`参数设置为`false`，该字符串未序列化 JavaScript 对象表示法 (JSON)。 有关 JSON 格式的详细信息，请参阅[JSON 简介](http://go.microsoft.com/fwlink/?LinkId=77297)Web 站点。  
  
 注册到的数据项<xref:System.Web.UI.ScriptManager.RegisterDataItem%2A>方法可以访问客户端脚本，在过程中、 和的对象的事件。 在处理这些事件时，事件参数对象将传入的自定义数据。 例如，如果为事件提供一个处理程序，在类中，公开一个属性传递的自定义数据。  
  
   
  
## Examples  
 下面的示例演示如何将数据发送到两个<xref:System.Web.UI.WebControls.Label>期间异步回发页面上的控件。 <xref:System.Web.UI.WebControls.Label>控件不是内部<xref:System.Web.UI.UpdatePanel>控件。  
  
> [!NOTE]
>  此示例中未发送的数据为仅用于说明目的。 在实际应用中，你将使用<xref:System.Web.UI.ScriptManager.RegisterDataItem%2A>方法以从服务器中发送自定义数据。  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/CS/ScriptManagerRegisterDataItemCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/VB/ScriptManagerRegisterDataItemVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在回发期间调用 <see cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" /> 方法。</exception>
        <exception cref="T:System.ArgumentException">已为 <paramref name="control" /> 注册 <paramref name="dataItem" />。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDataItem">
      <MemberSignature Language="C#" Value="public void RegisterDataItem (System.Web.UI.Control control, string dataItem, bool isJsonSerialized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDataItem(class System.Web.UI.Control control, string dataItem, bool isJsonSerialized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDataItem(System::Web::UI::Control ^ control, System::String ^ dataItem, bool isJsonSerialized);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="dataItem" Type="System.String" />
        <Parameter Name="isJsonSerialized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">正在接收数据的页控件。</param>
        <param name="dataItem">发送到控件的数据。</param>
        <param name="isJsonSerialized">如果要将 <c>dataItem</c> 序列化为 JSON，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>在局部页面呈现期间，将自定义数据发送到某个控件，并指示数据是否为 JavaScript 对象表示法 (JSON) 格式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你使用<xref:System.Web.UI.ScriptManager.RegisterDataItem%2A>方法将数据发送从服务器到客户端异步回发，而不考虑是否接收数据的控件位于期间<xref:System.Web.UI.UpdatePanel>控件。  
  
 如果`dataItem`你注册的参数`control`未序列化为 JSON，设置`isJsonSerialized`参数`false`。 这样就避免了需要为每个字符串发送到客户端使用该函数。 有关 JSON 格式的详细信息，请参阅[JSON 简介](http://go.microsoft.com/fwlink/?LinkId=77297)Web 站点。  
  
 <xref:System.Web.UI.ScriptManager.RegisterDataItem%2A>可以仅在异步回发期间调用方法。 若要确定是否异步回发，请使用<xref:System.Web.UI.ScriptManager.IsInAsyncPostBack%2A>属性。  
  
 通过使用已注册的数据项<xref:System.Web.UI.ScriptManager.RegisterDataItem%2A>方法可以访问客户端脚本，在过程中、 和的对象的事件。 在处理这些事件时，事件参数对象将传入的自定义数据。 例如，如果为事件提供一个处理程序，在类中，公开一个属性传递的自定义数据。  
  
   
  
## Examples  
 下面的示例演示如何将数据发送到两个<xref:System.Web.UI.WebControls.Label>期间异步回发页面上的控件。 <xref:System.Web.UI.WebControls.Label>控件不是内部<xref:System.Web.UI.UpdatePanel>控件。 此示例演示不采用重载`isJsonSerialized`参数。 否则，用于检索对象的属性的过程是相同好像未使用该重载。  
  
> [!NOTE]
>  此示例中未发送的数据为仅用于说明目的。 在实际应用中，你将使用<xref:System.Web.UI.ScriptManager.RegisterDataItem%2A>方法以从服务器中发送自定义数据。 例如，你无法使用数据项发送有关是否隐藏或显示未内的元素的客户端信息<xref:System.Web.UI.UpdatePanel>控件。  
  
 [!code-aspx-csharp[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/csharp/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/CS/ScriptManagerRegisterDataItemCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ScriptManager.RegisterDataItem#1](~/samples/snippets/visualbasic/VS_Snippets_Atlas/System.Web.UI.ScriptManager.RegisterDataItem/VB/ScriptManagerRegisterDataItemVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在回发期间调用 <see cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String,System.Boolean)" /> 方法。</exception>
        <exception cref="T:System.ArgumentException">已为 <paramref name="control" /> 注册 <paramref name="dataItem" />。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterDataItem(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDispose">
      <MemberSignature Language="C#" Value="public void RegisterDispose (System.Web.UI.Control control, string disposeScript);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDispose(class System.Web.UI.Control control, string disposeScript) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterDispose(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDispose(System::Web::UI::Control ^ control, System::String ^ disposeScript);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="disposeScript" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">使用 <see langword="dispose" /> 脚本的控件。</param>
        <param name="disposeScript">
          <see langword="dispose" /> 脚本。</param>
        <summary>为 <see cref="T:System.Web.UI.UpdatePanel" /> 控件内的某个控件注册一个 <see langword="dispose" /> 脚本。 在更新或删除 <see cref="T:System.Web.UI.UpdatePanel" /> 控件时会执行脚本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.ScriptManager.RegisterDispose%2A>方法注册`dispose`控件内的脚本<xref:System.Web.UI.UpdatePanel>控件。 在异步回发，<xref:System.Web.UI.UpdatePanel>控件可以更新、 删除，或者创建。 当更新或删除任何面板`dispose`内的控件注册的脚本<xref:System.Web.UI.UpdatePanel>调用。 在典型的页面开发方案中，则不需要调用<xref:System.Web.UI.ScriptManager.RegisterDispose%2A>方法。  
  
 <xref:System.Web.UI.ScriptManager.RegisterDispose%2A>方法旨在用于由控件开发人员，以注册脚本，或者创建继承的控件<xref:System.Web.UI.IScriptControl>接口。 例如，你可能使用`dispose`脚本。 如果你通过使用合成开发的客户端控件。 在您的控件，你实现<xref:System.Web.UI.IScriptControl>和呈现单独的控件。 你注册`dispose`任何的方法项都不对应于定义的客户端组件如`Sys.TextBox`。 如果你自定义控件撰写对应于 Microsoft Ajax 库中的客户端组件的元素，不需要注册`dispose`脚本，因为`dispose`自动调用。 因此，使用<xref:System.Web.UI.ScriptManager.RegisterDispose%2A>客户端组件，是 Microsoft Ajax 库的一部分且必须在不再使用组件时释放资源的方法。  
  
 <xref:System.Web.UI.ScriptManager.RegisterDispose%2A>方法可以多次调用控件。 聚合多个脚本。 释放脚本的顺序匹配脚本已注册的顺序。  
  
 如果你注册`dispose`脚本的控件，将不在<xref:System.Web.UI.UpdatePanel>控件，将引发异常。 `dispose`脚本调用之间的类和事件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> 为 <see langword="null" />。  \- 或 -  <paramref name="disposeScript" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">页面上找不到 <paramref name="control" />。  \- 或 -  <paramref name="control" /> 不在 <see cref="T:System.Web.UI.UpdatePanel" /> 控件内。</exception>
        <altmember cref="T:System.Web.UI.IScriptControl" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public static void RegisterExpandoAttribute (System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterExpandoAttribute(class System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterExpandoAttribute(System::Web::UI::Control ^ control, System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">正在注册 expando 特性的控件。</param>
        <param name="controlId">页中包含自定义特性的控件。</param>
        <param name="attributeName">要注册的自定义特性的名称。</param>
        <param name="attributeValue">自定义特性的值。</param>
        <param name="encode">如果要编码正在注册的自定义特性，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>在 <see cref="T:System.Web.UI.ScriptManager" /> 控件中，将名称/值对注册为指定控件的自定义 (expando) 特性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你使用<xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A>方法注册的控件，与局部页面呈现，兼容的自定义 (expando) 属性没有任何 Microsoft Ajax 库依赖项。  
  
 <xref:System.Web.UI.ScriptManager.RegisterExpandoAttribute%2A>方法注册为指定的控件的自定义特性的名称/值对。 属性是动态设置从 ECMAScript (JavaScript) 保持与呈现的控件的标记 XHTML 兼容性。 设置`encode`到`true`如果你有动态属性的值中的任何字符进行转义。  
  
 如果未找到动态属性将添加到控件，出现脚本错误。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="control" /> 不在该页面的控件树中。  \- 或 -  <paramref name="controlId" /> 为 <see langword="null" />。  \- 或 -  <paramref name="controlId" /> 为空。  \- 或 -  <paramref name="attributeName" /> 为 <see langword="null" />。  \- 或 -  <paramref name="attributeName" /> 为空。  \- 或 -  <paramref name="attributeName" /> 已注册。</exception>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExtenderControl&lt;TExtenderControl&gt;">
      <MemberSignature Language="C#" Value="public void RegisterExtenderControl&lt;TExtenderControl&gt; (TExtenderControl extenderControl, System.Web.UI.Control targetControl) where TExtenderControl : System.Web.UI.Control, System.Web.UI.IExtenderControl;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterExtenderControl&lt;(class System.Web.UI.Control, class System.Web.UI.IExtenderControl) TExtenderControl&gt;(!!TExtenderControl extenderControl, class System.Web.UI.Control targetControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterExtenderControl``1(``0,System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExtenderControl(Of TExtenderControl As {Control, IExtenderControl}) (extenderControl As TExtenderControl, targetControl As Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TExtenderControl&gt;&#xA; where TExtenderControl : System::Web::UI::Control, System::Web::UI::IExtenderControl virtual void RegisterExtenderControl(TExtenderControl extenderControl, System::Web::UI::Control ^ targetControl);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterExtenderControl``1(``0,System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TExtenderControl">
          <Constraints>
            <BaseTypeName>System.Web.UI.Control</BaseTypeName>
            <InterfaceName>System.Web.UI.IExtenderControl</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="extenderControl" Type="TExtenderControl" />
        <Parameter Name="targetControl" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <typeparam name="TExtenderControl">实现 <see cref="T:System.Web.UI.IExtenderControl" /> 接口的控件。</typeparam>
        <param name="extenderControl">要注册的扩展程序控件。</param>
        <param name="targetControl">扩展程序控件扩展的脚本控件。</param>
        <summary>向当前 <see cref="T:System.Web.UI.ScriptManager" /> 实例注册扩展程序控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法主要适用于由控件开发人员使用。 调用<xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A>方法在一个自定义 ASP.NET Ajax 扩展程序控件从其`onInit`事件处理程序以注册该控件使用页。 若要参与局部页面呈现，必须注册 ASP.NET Ajax 扩展程序控件。  
  
 <xref:System.Web.UI.ScriptManager.RegisterExtenderControl%2A>方法将指定的扩展程序控件添加到扩展程序控件和它们扩展的目标脚本控件的内部列表。 此列表处理期间<xref:System.Web.UI.Control.PreRender>事件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="extenderControl" /> 为 <see langword="null" />。  \- 或 -  <paramref name="targetControl" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterHiddenField">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>注册隐藏字段。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public static void RegisterHiddenField (System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterHiddenField(class System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterHiddenField(System::Web::UI::Control ^ control, System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">正在注册隐藏字段的控件。</param>
        <param name="hiddenFieldName">要注册的隐藏字段的名称。</param>
        <param name="hiddenFieldInitialValue">隐藏字段的初始值。</param>
        <summary>针对 <see cref="T:System.Web.UI.UpdatePanel" /> 控件内的控件，向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册隐藏字段。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你使用<xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A>方法注册的隐藏的字段的与兼容局部页面呈现，且没有任何 Microsoft Ajax 库依赖项。 此方法注册隐藏的字段，当正在注册字段控件<xref:System.Web.UI.UpdatePanel>正在更新的控件。 若要注册隐藏的字段每次异步回发发生时，使用<xref:System.Web.UI.ScriptManager.RegisterHiddenField%28System.Web.UI.Page%2CSystem.String%2CSystem.String%29>此方法的重载。  
  
 如果你想要注册不属于部分页面更新，如果你想要注册的隐藏的字段仅一次初始页呈现期间使用的隐藏的字段<xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A>方法<xref:System.Web.UI.ClientScriptManager>类。 你可以获取对引用<xref:System.Web.UI.ClientScriptManager>对象<xref:System.Web.UI.Page.ClientScript%2A>页属性。  
  
 <xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A>方法创建一个隐藏`input`上呈现的 HTML 页面的元素。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> 为 <see langword="null" />。  \- 或 -  <paramref name="hiddenFieldName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="control" /> 不在该页面的控件树中。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Page,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public static void RegisterHiddenField (System.Web.UI.Page page, string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterHiddenField(class System.Web.UI.Page page, string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Page,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterHiddenField(System::Web::UI::Page ^ page, System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">正在注册隐藏字段的页对象。</param>
        <param name="hiddenFieldName">要注册的隐藏字段的名称。</param>
        <param name="hiddenFieldInitialValue">隐藏字段的初始值。</param>
        <summary>在每次异步回发期间向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册隐藏字段。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你使用<xref:System.Web.UI.ScriptManager.RegisterHiddenField%2A>方法注册的隐藏的字段的与兼容局部页面呈现，且没有任何 Microsoft Ajax 库依赖项。 此方法在每次发生异步回发注册隐藏的字段。 若要注册隐藏的字段的控件，位于<xref:System.Web.UI.UpdatePanel>控制，以便仅在更新面板时，才注册该字段，请使用<xref:System.Web.UI.ScriptManager.RegisterHiddenField%28System.Web.UI.Control%2CSystem.String%2CSystem.String%29>此方法的重载。  
  
 如果你想要注册不属于部分页面更新，如果你想要注册的隐藏的字段仅一次初始页呈现期间使用的隐藏的字段<xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A>方法<xref:System.Web.UI.ClientScriptManager>类。 你可以获取对引用<xref:System.Web.UI.ClientScriptManager>对象<xref:System.Web.UI.Page.ClientScript%2A>页属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="page" /> 为 <see langword="null" />。  \- 或 -  <paramref name="hiddenFieldName" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterNamedClientScriptResource">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>按资源名称向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册嵌入程序集中的客户端脚本，以便和正在参与局部页面呈现的控件一起使用。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterNamedClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterNamedClientScriptResource (System.Web.UI.Control control, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterNamedClientScriptResource(class System.Web.UI.Control control, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterNamedClientScriptResource(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterNamedClientScriptResource(System::Web::UI::Control ^ control, System::String ^ resourceName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">正在注册脚本的控件。</param>
        <param name="resourceName">资源的标识符。</param>
        <summary>按资源名称向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册嵌入程序集中的客户端脚本，以便和正在参与局部页面呈现的控件一起使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterNamedClientScriptResource">
      <MemberSignature Language="C#" Value="public static void RegisterNamedClientScriptResource (System.Web.UI.Page page, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterNamedClientScriptResource(class System.Web.UI.Page page, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterNamedClientScriptResource(System.Web.UI.Page,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterNamedClientScriptResource(System::Web::UI::Page ^ page, System::String ^ resourceName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">正在注册脚本的页对象。</param>
        <param name="resourceName">资源的标识符。</param>
        <summary>按资源名称向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册嵌入程序集中的客户端脚本，以便和正在参与局部页面呈现的控件一起使用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterOnSubmitStatement">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>注册在提交表单时执行的 ECMAScript (JavaScript) 代码。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public static void RegisterOnSubmitStatement (System.Web.UI.Control control, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterOnSubmitStatement(class System.Web.UI.Control control, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterOnSubmitStatement(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">正在注册 <see langword="onsubmit" /> 语句的控件。</param>
        <param name="type">客户端脚本语句的类型。 通常使用 typeof 运算符 (C#) 或 GetType 运算符 (Visual Basic) 来指定此参数，以检索正在注册脚本的控件的类型。</param>
        <param name="key">脚本语句的唯一标识符。</param>
        <param name="script">要注册的脚本。</param>
        <summary>针对与 <see cref="T:System.Web.UI.UpdatePanel" /> 控件一起使用的控件，向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册提交表单时执行的 ECMAScript (JavaScript) 代码。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A>将添加在提交表单时之前, 执行的脚本它可让你修改提交或取消它。  
  
 你使用<xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A>方法呈现`onsubmit`语句与局部页面呈现兼容并具有无 Microsoft Ajax 库依赖项。 使用此方法注册的 JavaScript 代码发送到页面中，仅当正在注册该语句的控件内时，才<xref:System.Web.UI.UpdatePanel>正在更新的控件。 若要向每个异步回发注册代码，请使用<xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%29>此方法的重载。  
  
 如果你想要注册不属于部分页面更新，如果你想要注册该代码仅一次初始页呈现期间使用的 JavaScript 代码<xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A>方法<xref:System.Web.UI.ClientScriptManager>类。 你可以获取对引用<xref:System.Web.UI.ClientScriptManager>对象<xref:System.Web.UI.Page.ClientScript%2A>页属性。  
  
 *脚本*参数<xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%2A>方法可包含使用分号 （;） 分隔的多个脚本命令。  
  
 有关 HTML 窗体的详细信息和`onsubmit`事件，请参阅[World Wide Web Consortium (W3C) 网站](http://go.microsoft.com/fwlink/?linkid=37125)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> 为 <see langword="null" />。  \- 或 -  <paramref name="type" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="control" /> 不在该页面的控件树中。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Page,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public static void RegisterOnSubmitStatement (System.Web.UI.Page page, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterOnSubmitStatement(class System.Web.UI.Page page, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Page,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterOnSubmitStatement(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="page">正在注册 <see langword="onsubmit" /> 语句的页对象。</param>
        <param name="type">客户端脚本语句的类型。 通常使用 typeof 运算符 (C#) 或 GetType 运算符 (Visual Basic) 来指定此参数，以检索正在注册脚本的控件的类型。</param>
        <param name="key">脚本语句的唯一标识符。</param>
        <param name="script">要注册的脚本。</param>
        <summary>针对与 <see cref="T:System.Web.UI.UpdatePanel" /> 控件一起使用的控件，向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册提交表单时执行的 ECMAScript (JavaScript) 代码。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法注册 JavaScript 代码将导致脚本要包含每次发生异步回发。  
  
> [!NOTE]
>  从任何早期异步回发的代码不会删除。 新的异步回发将代码附加到任何现有代码，以`onsubmit`语句。  
  
 可以注册在控件内的代码<xref:System.Web.UI.UpdatePanel>控制，以便注册该代码时，才<xref:System.Web.UI.UpdatePanel>控件更新，请使用<xref:System.Web.UI.ScriptManager.RegisterOnSubmitStatement%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%29>此方法的重载。  
  
 如果你想要注册不属于部分页面更新，如果你想要注册该代码仅一次初始页呈现期间使用的 JavaScript 代码<xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A>方法<xref:System.Web.UI.ClientScriptManager>类。 你可以获取对引用<xref:System.Web.UI.ClientScriptManager>对象<xref:System.Web.UI.Page.ClientScript%2A>页属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="page" /> 为 <see langword="null" />。  \- 或 -  <paramref name="type" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterPostBackControl">
      <MemberSignature Language="C#" Value="public void RegisterPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterPostBackControl(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterPostBackControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">要为回发注册的控件。</param>
        <summary>将控件注册为回发的触发器。 此方法用于配置 <see cref="T:System.Web.UI.UpdatePanel" /> 控件内的回发控件，若未配置，此控件将执行异步回发。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Web.UI.ScriptManager.RegisterPostBackControl%2A>方法注册内的回发控件<xref:System.Web.UI.UpdatePanel>为触发器的控件。 使用此方法注册的控件更新整个页面，而不是仅更新<xref:System.Web.UI.UpdatePanel>控件的内容。 使用外部此方法注册的回发控件<xref:System.Web.UI.UpdatePanel>控件具有没有影响，因为默认情况下这些控件不执行异步回发。  
  
 你可以通过将添加触发器以声明方式`Triggers`元素<xref:System.Web.UI.UpdatePanel>控件。 在 Visual Studio 中，使用设计器的**UpdatePanelTrigger 集合编辑器**对话框。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.UpdatePanel.Triggers" />
      </Docs>
    </Member>
    <Member MemberName="RegisterScriptControl&lt;TScriptControl&gt;">
      <MemberSignature Language="C#" Value="public void RegisterScriptControl&lt;TScriptControl&gt; (TScriptControl scriptControl) where TScriptControl : System.Web.UI.Control, System.Web.UI.IScriptControl;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptControl&lt;(class System.Web.UI.Control, class System.Web.UI.IScriptControl) TScriptControl&gt;(!!TScriptControl scriptControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptControl``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptControl(Of TScriptControl As {Control, IScriptControl}) (scriptControl As TScriptControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TScriptControl&gt;&#xA; where TScriptControl : System::Web::UI::Control, System::Web::UI::IScriptControl virtual void RegisterScriptControl(TScriptControl scriptControl);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterScriptControl``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TScriptControl">
          <Constraints>
            <BaseTypeName>System.Web.UI.Control</BaseTypeName>
            <InterfaceName>System.Web.UI.IScriptControl</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="scriptControl" Type="TScriptControl" />
      </Parameters>
      <Docs>
        <typeparam name="TScriptControl">实现 <see cref="T:System.Web.UI.IScriptControl" /> 接口的控件。</typeparam>
        <param name="scriptControl">要注册的脚本控件。</param>
        <summary>向当前 <see cref="T:System.Web.UI.ScriptManager" /> 实例注册脚本控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法主要适用于由控件开发人员使用。 调用<xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A>方法期间，从自定义 ASP.NET Ajax 脚本控件其`onInit`事件处理程序以注册该控件使用页。 参与局部页面呈现，必须注册 ASP.NET Ajax 脚本控件。  
  
 <xref:System.Web.UI.ScriptManager.RegisterScriptControl%2A>方法将指定的扩展程序控件添加到期间处理的脚本控件的内部列表<xref:System.Web.UI.Control.PreRender>事件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scriptControl" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterScriptDescriptors">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示 <see cref="T:System.Web.UI.ScriptManager" /> 控件回调到 <see cref="T:System.Web.UI.ScriptControl" /> 或 <see cref="T:System.Web.UI.ExtenderControl" /> 类，以便返回支持表示客户端控件、组件或行为的客户端对象的脚本。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterScriptDescriptors">
      <MemberSignature Language="C#" Value="public void RegisterScriptDescriptors (System.Web.UI.IExtenderControl extenderControl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptDescriptors(class System.Web.UI.IExtenderControl extenderControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptDescriptors (extenderControl As IExtenderControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterScriptDescriptors(System::Web::UI::IExtenderControl ^ extenderControl);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extenderControl" Type="System.Web.UI.IExtenderControl" />
      </Parameters>
      <Docs>
        <param name="extenderControl">将为其注册脚本描述符的扩展程序控件。</param>
        <summary>回调到 <see cref="T:System.Web.UI.ExtenderControl" /> 类以返回为支持表示客户端控件、组件或行为的客户端对象而必须呈现的实例脚本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ExtenderControl>类调用<xref:System.Web.UI.ScriptManager.RegisterScriptDescriptors%2A>方法在其<xref:System.Web.UI.Control.Render%2A>方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果派生自<see cref="T:System.Web.UI.ExtenderControl" />类并重写<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法，但你不调用基类方法，必须调用<see cref="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IExtenderControl)" />方法。这使<see cref="T:System.Web.UI.ScriptManager" />控件呈现支持该控件所表示的客户端对象的实例脚本。</para>
        </block>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterExtenderControl``1(``0,System.Web.UI.Control)" />
        <altmember cref="T:System.Web.UI.ScriptDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="RegisterScriptDescriptors">
      <MemberSignature Language="C#" Value="public void RegisterScriptDescriptors (System.Web.UI.IScriptControl scriptControl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterScriptDescriptors(class System.Web.UI.IScriptControl scriptControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IScriptControl)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterScriptDescriptors (scriptControl As IScriptControl)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterScriptDescriptors(System::Web::UI::IScriptControl ^ scriptControl);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterScriptDescriptors(System.Web.UI.IScriptControl)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptControl" Type="System.Web.UI.IScriptControl" />
      </Parameters>
      <Docs>
        <param name="scriptControl">将为其注册脚本描述符的脚本控件。</param>
        <summary>调用 <see cref="T:System.Web.UI.ScriptControl" /> 类以返回为支持表示客户端控件、组件或行为的客户端对象而必须呈现的实例脚本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptControl>类调用<xref:System.Web.UI.ScriptManager.RegisterScriptDescriptors%2A>方法在其<xref:System.Web.UI.Control.Render%2A>事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果派生自<see cref="T:System.Web.UI.ScriptControl" />类并重写<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法，但你不调用基类方法，必须调用<see cref="M:System.Web.UI.ScriptManager.RegisterScriptDescriptors(System.Web.UI.IScriptControl)" />方法。这使<see cref="T:System.Web.UI.ScriptManager" />控件呈现支持该控件所表示的客户端对象的实例脚本。</para>
        </block>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterScriptControl``1(``0)" />
        <altmember cref="T:System.Web.UI.ScriptDescriptor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个启动脚本块并将此脚本块添加到页面中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public static void RegisterStartupScript (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterStartupScript(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterStartupScript(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">正在注册客户端脚本块的控件。</param>
        <param name="type">客户端脚本块的类型。 通常使用 typeof 运算符 (C#) 或 GetType 运算符 (Visual Basic) 来指定此参数，以检索正在注册脚本的控件的类型。</param>
        <param name="key">脚本块的唯一标识符。</param>
        <param name="script">要注册的脚本。</param>
        <param name="addScriptTags">如果用 <see langword="&lt;script&gt;" /> 和 <see langword="&lt;/script&gt;" /> 标记括起此脚本块，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>使用 <see cref="T:System.Web.UI.ScriptManager" /> 控件为 <see cref="T:System.Web.UI.UpdatePanel" /> 中的某个控件注册一个启动脚本块，并将此脚本块添加到页面中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你使用<xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A>方法注册的页与兼容局部页面呈现，且一个启动脚本块没有任何 Microsoft Ajax 库依赖项。 使用此方法注册的启动脚本块发送到页面中，仅当正在注册块控件内<xref:System.Web.UI.UpdatePanel>正在更新的控件。 若要注册一个启动脚本块每次异步回发发生时，使用<xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Page%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>此方法的重载。  
  
 如果你想要注册的启动脚本的不属于部分页面更新，如果你想要注册脚本仅一次初始页呈现期间使用<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法<xref:System.Web.UI.ClientScriptManager>类。 你可以获取对引用<xref:System.Web.UI.ClientScriptManager>对象<xref:System.Web.UI.Page.ClientScript%2A>页属性。  
  
 由呈现的脚本块<xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A>方法执行时在页面完成加载，但在该页面的客户端之前`onload`引发事件。 启动脚本块位于呈现的 ASP.NET 页的底部紧前面`</form>`标记。  
  
 通过使用已注册的启动脚本块<xref:System.Web.UI.ScriptManager.RegisterStartupScript%2A>并非一定要与它们注册的顺序相同的输出。 如果启动脚本块的顺序很重要，则使用<xref:System.Text.StringBuilder>对象，以便收集的脚本块中单个字符串中，然后将它们注册所有作为单个启动脚本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> 为 <see langword="null" />。  \- 或 -  <paramref name="type" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="control" /> 不在该页面的控件树中。</exception>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public static void RegisterStartupScript (System.Web.UI.Page page, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterStartupScript(class System.Web.UI.Page page, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Page,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterStartupScript(System::Web::UI::Page ^ page, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="page">正在注册客户端脚本块的页对象。</param>
        <param name="type">客户端脚本块的类型。 通常使用 typeof 运算符 (C#) 或 GetType 运算符 (Visual Basic) 来指定此参数，以检索正在注册脚本的控件的类型。</param>
        <param name="key">脚本块的唯一标识符。</param>
        <param name="script">要注册的脚本。</param>
        <param name="addScriptTags">如果用 <see langword="&lt;script&gt;" /> 和 <see langword="&lt;/script&gt;" /> 标记括起此脚本块，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>为每个异步回发向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册一个启动脚本块，并将此脚本块添加到页面中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法以注册一个启动脚本块，它包括在每次发生异步回发。 若要注册脚本块内的控件<xref:System.Web.UI.UpdatePanel>控制，以便注册该脚本块时，才<xref:System.Web.UI.UpdatePanel>控件更新，请使用<xref:System.Web.UI.ScriptManager.RegisterStartupScript%28System.Web.UI.Control%2CSystem.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>此方法的重载。  
  
 如果你想要注册的启动脚本的不属于部分页面更新，如果你想要注册脚本仅一次初始页呈现期间使用<xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A>方法<xref:System.Web.UI.ClientScriptManager>类。 你可以获取对引用<xref:System.Web.UI.ClientScriptManager>对象<xref:System.Web.UI.Page.ClientScript%2A>页属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ScriptManager.RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">一个接收要写入页面的控件内容的对象。</param>
        <summary>使用指定的 <see cref="T:System.Web.UI.HtmlTextWriter" /> 对象将 <see cref="T:System.Web.UI.ScriptManager" /> 控件的内容呈现给浏览器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由控件开发人员用来扩展<xref:System.Web.UI.ScriptManager>控件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写此方法，调用基<see cref="M:System.Web.UI.ScriptManager.Render(System.Web.UI.HtmlTextWriter)" />方法，以便在页面上呈现定义类的客户端脚本。</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ResolveCompositeScriptReference">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt; ResolveCompositeScriptReference;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.CompositeScriptReferenceEventArgs&gt; ResolveCompositeScriptReference" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.ResolveCompositeScriptReference" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolveCompositeScriptReference As EventHandler(Of CompositeScriptReferenceEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::CompositeScriptReferenceEventArgs ^&gt; ^ ResolveCompositeScriptReference;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.CompositeScriptReferenceEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册复合脚本时发生。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveScriptReference">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt; ResolveScriptReference;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.ScriptReferenceEventArgs&gt; ResolveScriptReference" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.ScriptManager.ResolveScriptReference" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolveScriptReference As EventHandler(Of ScriptReferenceEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::ScriptReferenceEventArgs ^&gt; ^ ResolveScriptReference;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.ScriptReferenceEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在向 <see cref="T:System.Web.UI.ScriptManager" /> 控件注册 <see cref="P:System.Web.UI.ScriptManager.Scripts" /> 集合的成员时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发此事件是一次的每个成员<xref:System.Web.UI.ScriptManager.Scripts%2A>在页面的集合<xref:System.Web.UI.Control.PreRender>事件。 使用此事件脚本呈现到页之前执行的任何更新。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RoleService">
      <MemberSignature Language="C#" Value="public System.Web.UI.RoleServiceManager RoleService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.RoleServiceManager RoleService" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.RoleService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RoleService As RoleServiceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::RoleServiceManager ^ RoleService { System::Web::UI::RoleServiceManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.RoleServiceManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与当前 <see cref="T:System.Web.UI.ScriptManager" /> 实例关联的 <see cref="T:System.Web.UI.RoleServiceManager" /> 对象。</summary>
        <value>当前 <see cref="T:System.Web.UI.ScriptManager" /> 实例的 <see cref="T:System.Web.UI.RoleServiceManager" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.RoleServiceManager>此属性返回的对象表示向该页面注册角色服务。 可以在中定义的角色服务<xref:System.Web.UI.ScriptManager>控件或关联<xref:System.Web.UI.ScriptManagerProxy>控件。 你可以使用 ASP.NET 角色服务或使用自定义的角色服务。 你可以在标记中添加自定义的服务，通过包括`RoleService`内的元素`asp:ScriptManager`元素在页面上，如下面的示例中所示：  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <RoleService Path="MyRoleService.asmx" LoadRoles="True" />  
</asp:ScriptManager>  
```  
  
 你可以以编程方式配置<xref:System.Web.UI.RoleServiceManager>对象。 注册服务<xref:System.Web.UI.ScriptManager>控件在页面的<xref:System.Web.UI.Control.PreRender>生命周期阶段。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScriptMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.ScriptMode ScriptMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ScriptMode ScriptMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptMode As ScriptMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ScriptMode ScriptMode { System::Web::UI::ScriptMode get(); void set(System::Web::UI::ScriptMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定是呈现客户端脚本库的调试版本还是发布版本。</summary>
        <value>指示当前模式的枚举值。 默认值为 <see cref="F:System.Web.UI.ScriptMode.Auto" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.ScriptMode%2A>属性指定是否<xref:System.Web.UI.ScriptManager>控件应呈现调试或发布的客户端脚本库的版本。 此值可以通过在配置文件中并在页面指令中设置的值被取代。  
  
 下表列出了此属性的有效值。  
  
|“值”|定义|  
|-----------|----------------|  
|<xref:System.Web.UI.ScriptMode.Auto>|客户端脚本库用于在网页上的调试版本时`retail`配置元素的属性设置为`false`。 否则，使用客户端脚本库的发行版本。|  
|<xref:System.Web.UI.ScriptMode.Inherit>|当应用于<xref:System.Web.UI.ScriptManager.ScriptMode%2A>属性<xref:System.Web.UI.ScriptManager>对象，此值等同于<xref:System.Web.UI.ScriptMode.Auto>。|  
|<xref:System.Web.UI.ScriptMode.Debug>|调试版本的客户端脚本库使用网页中，除非`retail`配置元素的属性设置为`true`。|  
|<xref:System.Web.UI.ScriptMode.Release>|客户端脚本库的发行版本使用网页中，除非`retail`配置元素的属性设置为`false`。|  
  
> [!NOTE]
>  `debug`指令的特性不会影响支持 Ajax 的 ASP.NET 应用程序。 <xref:System.Web.UI.ScriptManager>控件使用的设置仅在 Web.config 文件中并在其<xref:System.Web.UI.ScriptManager.IsDebuggingEnabled%2A>和<xref:System.Web.UI.ScriptManager.ScriptMode%2A>属性来确定是否呈现调试脚本。  
  
 有关详细信息，请参阅[调试和跟踪 Ajax 应用程序概述](http://msdn.microsoft.com/library/92684ea0-7bb4-4a34-9203-3aa6394ce375)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Web.UI.ScriptManager.ScriptMode" /> 属性不是 <see cref="T:System.Web.UI.ScriptMode" /> 值中的其中一个。</exception>
        <altmember cref="T:System.Web.UI.ScriptMode" />
      </Docs>
    </Member>
    <Member MemberName="ScriptPath">
      <MemberSignature Language="C#" Value="public string ScriptPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScriptPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptPath" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ScriptPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This property is obsolete. Set the Path property on each individual ScriptReference instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置位置的根路径，该位置用来生成指向 ASP.NET Ajax 和自定义脚本文件的路径。</summary>
        <value>存储脚本文件的位置。 默认值为解释为相对路径的空字符串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.ScriptPath%2A>属性使您能够指定绝对、 相对的或在页面上阻止所有脚本的相对于应用程序 URL。 这包括与当前注册的自定义和第三方脚本块<xref:System.Web.UI.ScriptManager>实例。 <xref:System.Web.UI.ScriptManager.ScriptPath%2A>属性通常以声明方式的属性设置`ScriptManager`元素上的页中，但它可以还在代码中设置。  
  
 如果`path`属性或<xref:System.Web.UI.ScriptReferenceBase.Path%2A>属性设置为<xref:System.Web.UI.ScriptReference>对象在<xref:System.Web.UI.ScriptManager.Scripts%2A>集合，则路径值将覆盖<xref:System.Web.UI.ScriptManager.ScriptPath%2A>值的<xref:System.Web.UI.ScriptReference>实例。  
  
 如果没有<xref:System.Web.UI.ScriptReferenceBase.Path%2A>指定值，<xref:System.Web.UI.ScriptManager>控件搜索由定义的目录<xref:System.Web.UI.ScriptManager.ScriptPath%2A>属性并解析脚本引用其<xref:System.Web.UI.ScriptReference.Name%2A>或<xref:System.Web.UI.ScriptReference.Assembly%2A>属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScriptResourceMapping">
      <MemberSignature Language="C#" Value="public static System.Web.UI.ScriptResourceMapping ScriptResourceMapping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.UI.ScriptResourceMapping ScriptResourceMapping" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.ScriptResourceMapping" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ScriptResourceMapping As ScriptResourceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::UI::ScriptResourceMapping ^ ScriptResourceMapping { System::Web::UI::ScriptResourceMapping ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptResourceMapping</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Web.UI.ScriptResourceMapping" /> 对象。</summary>
        <value>
          <see cref="T:System.Web.UI.ScriptResourceMapping" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 静态<xref:System.Web.UI.ScriptManager.ScriptResourceMapping%2A>属性返回<xref:System.Web.UI.ScriptResourceMapping>可以包含表示脚本资源 （脚本重定向） 的位置的映射的集合对象。 可以根据名称或名称/程序集对映射的映射此集合，它可以指向<xref:System.Web.UI.ScriptResourceDefinition>对象。  
  
   
  
## Examples  
 下面的示例演示如何添加<xref:System.Web.UI.ScriptResourceDefinition>可供引用的对象<xref:System.Web.UI.ScriptManager>对象。 将以下代码添加到 Global.asax 文件`Application_Start`事件。  
  
```csharp  
ScriptResourceDefinition myScriptResDef = new ScriptResourceDefinition();  
myScriptResDef.Path = "~/Scripts/jquery-1.4.2.min.js";  
myScriptResDef.DebugPath = "~/Scripts/jquery-1.4.2.js";  
myScriptResDef.CdnPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.min.js";  
myScriptResDef.CdnDebugPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.js";  
ScriptManager.ScriptResourceMapping.AddDefinition("jquery", null, myScriptResDef);  
```  
  
```vb  
Dim myScriptResDef As New ScriptResourceDefinition()  
myScriptResDef.Path = "~/Scripts/jquery-1.4.2.min.js"  
myScriptResDef.DebugPath = "~/Scripts/jquery-1.4.2.js"  
myScriptResDef.CdnPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.min.js"  
myScriptResDef.CdnDebugPath = "http://ajax.microsoft.com/ajax/jQuery/jquery-1.4.2.js"  
ScriptManager.ScriptResourceMapping.AddDefinition("jquery", Nothing, myScriptResDef)  
```  
  
 在 ASP.NET Web 窗体页面 （.aspx 文件） 的标记，添加以下标记内的`form`元素并且在任何元素或使用 jQuery 脚本的代码之前。  
  
```  
<asp:ScriptManager ID="sm1" runat="server">  
  <Scripts>  
    <asp:ScriptReference Name="jquery"/>  
  </Scripts>  
</asp:ScriptManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scripts">
      <MemberSignature Language="C#" Value="public System.Web.UI.ScriptReferenceCollection Scripts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ScriptReferenceCollection Scripts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Scripts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scripts As ScriptReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ScriptReferenceCollection ^ Scripts { System::Web::UI::ScriptReferenceCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.CollectionEditorBase, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ScriptReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个包含 <see cref="T:System.Web.UI.ScriptReference" /> 对象（每个对象表示一个呈现给客户端的脚本文件）的 <see cref="T:System.Web.UI.ScriptReferenceCollection" /> 对象。</summary>
        <value>
          <see cref="T:System.Web.UI.ScriptManager" /> 实例的 <see cref="T:System.Web.UI.ScriptReferenceCollection" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptReferenceCollection>此属性返回的对象是一个集合的<xref:System.Web.UI.ScriptReference>对象，其中每个表示一个脚本文件。 集合包含针对 Ajax 功能，则 ASP.NET 需要的所有脚本文件和自定义脚本文件的引用。 可以在定义自定义脚本文件来呈现<xref:System.Web.UI.ScriptManager>控件或关联<xref:System.Web.UI.ScriptManagerProxy>控件。  
  
 您可以通过添加脚本文件添加到标记中的集合`asp:ScriptReference`元素与`Scripts`节点`asp:ScriptManager`元素在页面上，如下面的示例中所示。  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <Scripts>  
    <asp:ScriptReference Name="Script.js" />  
  </Scripts>  
</asp:ScriptManager>  
```  
  
 你还可以添加<xref:System.Web.UI.ScriptReference>对象传递给<xref:System.Web.UI.ScriptManager.Scripts%2A>以编程方式通过使用集合<xref:System.Collections.ObjectModel.Collection%601.Add%2A>方法<xref:System.Web.UI.ScriptReferenceCollection>类。  
  
 <xref:System.Web.UI.ScriptManager>控件在控件的过程注册脚本文件<xref:System.Web.UI.Control.PreRender>事件。  
  
 <xref:System.Web.UI.ScriptManager.Scripts%2A>集合不包含的核心 Microsoft Ajax Library 脚本。 核心库中的脚本可以呈现自动保存功能。它们无需向注册<xref:System.Web.UI.ScriptManager>控件。 但是，如果你想要重写核心脚本或任何控制脚本并替换该脚本的不同版本，则可以添加到你的版本<xref:System.Web.UI.ScriptManager.Scripts%2A>集合。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Services">
      <MemberSignature Language="C#" Value="public System.Web.UI.ServiceReferenceCollection Services { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ServiceReferenceCollection Services" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Services" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Services As ServiceReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ServiceReferenceCollection ^ Services { System::Web::UI::ServiceReferenceCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Web.UI.Design.ServiceReferenceCollectionEditor, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ServiceReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Web.UI.ServiceReferenceCollection" /> 对象，该对象包含 ASP.NET 在客户端上针对 Ajax 功能公开的每个 Web 服务的 <see cref="T:System.Web.UI.ServiceReference" /> 对象。</summary>
        <value>当前 <see cref="T:System.Web.UI.ScriptManager" /> 实例的 <see cref="T:System.Web.UI.ServiceReferenceCollection" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ServiceReferenceCollection>此属性返回的对象是一个集合的<xref:System.Web.UI.ServiceReference>对象，其中每个表示 Web 服务向注册<xref:System.Web.UI.ScriptManager>控件。 你可以定义中的服务<xref:System.Web.UI.ScriptManager>控件或关联<xref:System.Web.UI.ScriptManagerProxy>控件。  
  
 可以通过添加到标记中的集合中添加服务`asp:ServiceReference`元素`Services`内的元素`asp:ScriptManager`实例在页上，如以下示例所示。  
  
```  
<asp:ScriptManager ID="SM1" runat="server">  
  <Services>  
    <asp:ServiceReference Path="Service.asmx" />  
  </Services>  
</asp:ScriptManager>  
```  
  
 你可以以编程方式添加<xref:System.Web.UI.ServiceReference>对象传递给<xref:System.Web.UI.ScriptManager.Services%2A>使用进行收集<xref:System.Collections.ObjectModel.Collection%601.Add%2A>方法<xref:System.Web.UI.ServiceReferenceCollection>类。  
  
 注册服务<xref:System.Web.UI.ScriptManager>在页面的<xref:System.Web.UI.Control.PreRender>生命周期阶段。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetFocus">
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将浏览器焦点设置为指定控件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.SetFocus(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetFocus (clientID As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::String ^ clientID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">要接收焦点的控件的 ID。</param>
        <summary>将浏览器焦点设置为由 ID 指定的控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.SetFocus%2A>方法的工作原理类似<xref:System.Web.UI.Page.SetFocus%2A>方法<xref:System.Web.UI.Page>类。 这两种方法使具有指定 ID 控件在网页上的活动控件。 <xref:System.Web.UI.ScriptManager.SetFocus%2A>方法<xref:System.Web.UI.ScriptManager>类用于将焦点设置异步回发期间。 在回发和首次呈现页时，期间<xref:System.Web.UI.ScriptManager.SetFocus%2A>方法调用<xref:System.Web.UI.Page.SetFocus%2A>方法<xref:System.Web.UI.Page>类。  
  
 如果有多个调用<xref:System.Web.UI.ScriptManager.SetFocus%2A>方法，最后一次调用中的控件接收焦点。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.String)" />
        <altmember cref="M:System.Web.UI.ScriptManager.SetFocus(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.SetFocus(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">要接收焦点的控件。</param>
        <summary>将浏览器焦点设置为指定控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ScriptManager.SetFocus%2A>方法的工作原理类似<xref:System.Web.UI.Page.SetFocus%2A>方法<xref:System.Web.UI.Page>类。 这两种方法使指定的控件在网页上的活动控件。 <xref:System.Web.UI.ScriptManager.SetFocus%2A>方法<xref:System.Web.UI.ScriptManager>类用于将焦点设置异步回发期间。 在回发和首次呈现页时，期间<xref:System.Web.UI.ScriptManager.SetFocus%2A>方法调用<xref:System.Web.UI.Page.SetFocus%2A>方法<xref:System.Web.UI.Page>类。  
  
 如果有多个调用<xref:System.Web.UI.ScriptManager.SetFocus%2A>方法，在最后一次调用中指定的控件接收焦点。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
        <altmember cref="M:System.Web.UI.ScriptManager.SetFocus(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SupportsPartialRendering">
      <MemberSignature Language="C#" Value="public bool SupportsPartialRendering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsPartialRendering" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.SupportsPartialRendering" />
      <MemberSignature Language="VB.NET" Value="Public Property SupportsPartialRendering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsPartialRendering { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个指示客户端是否支持局部页面呈现的值。</summary>
        <value>如果客户端支持局部页面呈现，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Web.UI.ScriptManager.EnablePartialRendering%2A>属性设置为`false`、<xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A>属性返回`false`。  
  
 若要确定是否支持局部页面呈现的默认检查返回`true`当以下条件都为真：  
  
-   <xref:System.Web.Configuration.HttpCapabilitiesBase.W3CDomVersion%2A>属性值必须大于或等于 1.0。  
  
-   <xref:System.Web.Configuration.HttpCapabilitiesBase.EcmaScriptVersion%2A>属性值必须大于或等于 1.0。  
  
-   <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A>属性值必须设置为`true`。  
  
 当<xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A>属性显式设置，则不使用这些检查。  
  
 控件开发人员应使用<xref:System.Web.UI.ScriptManager.SupportsPartialRendering%2A>属性来确定他们是否应支持局部页面呈现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" /> 属性为 <see langword="false" />，而 <see cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" /> 属性原来设置为 <see langword="true" />。  \- 或 -  在 <see cref="E:System.Web.UI.Control.Init" /> 事件后设置 <see cref="P:System.Web.UI.ScriptManager.SupportsPartialRendering" /> 属性。</exception>
        <altmember cref="P:System.Web.UI.ScriptManager.EnablePartialRendering" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackDataHandler.LoadPostData">
      <MemberSignature Language="C#" Value="bool IPostBackDataHandler.LoadPostData (string postDataKey, System.Collections.Specialized.NameValueCollection postCollection);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Web.UI.IPostBackDataHandler.LoadPostData(string postDataKey, class System.Collections.Specialized.NameValueCollection postCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackDataHandler#LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Function LoadPostData (postDataKey As String, postCollection As NameValueCollection) As Boolean Implements IPostBackDataHandler.LoadPostData" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Web.UI.IPostBackDataHandler.LoadPostData(System::String ^ postDataKey, System::Collections::Specialized::NameValueCollection ^ postCollection) = System::Web::UI::IPostBackDataHandler::LoadPostData;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="postDataKey" Type="System.String" />
        <Parameter Name="postCollection" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="postDataKey">控件的密钥标识符。</param>
        <param name="postCollection">所有传入的后期数据的集合。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.Web.UI.IPostBackDataHandler.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />。</summary>
        <returns>如果 <see cref="T:System.Web.UI.ScriptManager" /> 控件的状态已因回发而更改，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Web.UI.ScriptManager> 实例强制转换为 <xref:System.Web.UI.IPostBackDataHandler> 接口时使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
        <altmember cref="M:System.Web.UI.ScriptManager.LoadPostData(System.String,System.Collections.Specialized.NameValueCollection)" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent">
      <MemberSignature Language="C#" Value="void IPostBackDataHandler.RaisePostDataChangedEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackDataHandler#RaisePostDataChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Sub RaisePostDataChangedEvent () Implements IPostBackDataHandler.RaisePostDataChangedEvent" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent() = System::Web::UI::IPostBackDataHandler::RaisePostDataChangedEvent;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Web.UI.ScriptManager> 实例强制转换为 <xref:System.Web.UI.IPostBackDataHandler> 接口时使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
        <altmember cref="M:System.Web.UI.ScriptManager.RaisePostDataChangedEvent" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IPostBackEventHandler.RaisePostBackEvent">
      <MemberSignature Language="C#" Value="void IPostBackEventHandler.RaisePostBackEvent (string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IPostBackEventHandler#RaisePostBackEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub RaisePostBackEvent (eventArgument As String) Implements IPostBackEventHandler.RaisePostBackEvent" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System::String ^ eventArgument) = System::Web::UI::IPostBackEventHandler::RaisePostBackEvent;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventArgument">表示网页历史记录状态的键/值对的字符串。</param>
        <summary>启用 <see cref="T:System.Web.UI.ScriptManager" /> 控件以处理回发事件，并加载网页的历史记录状态。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.IsSecureConnection">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IScriptManager.IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IScriptManager.IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSecureConnection As Boolean Implements IScriptManager.IsSecureConnection" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Web.UI.IScriptManager.IsSecureConnection { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterArrayDeclaration (System.Web.UI.Control control, string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterArrayDeclaration(class System.Web.UI.Control control, string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterArrayDeclaration(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterArrayDeclaration(System::Web::UI::Control ^ control, System::String ^ arrayName, System::String ^ arrayValue) = System::Web::UI::IScriptManager::RegisterArrayDeclaration;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="arrayName">To be added.</param>
        <param name="arrayValue">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptBlock (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptBlock(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptBlock(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptBlock(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags) = System::Web::UI::IScriptManager::RegisterClientScriptBlock;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <param name="addScriptTags">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptInclude (System.Web.UI.Control control, Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptInclude(class System.Web.UI.Control control, class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptInclude(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptInclude(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ url) = System::Web::UI::IScriptManager::RegisterClientScriptInclude;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="url">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterClientScriptResource (System.Web.UI.Control control, Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterClientScriptResource(class System.Web.UI.Control control, class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterClientScriptResource(System.Web.UI.Control,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterClientScriptResource(System::Web::UI::Control ^ control, Type ^ type, System::String ^ resourceName) = System::Web::UI::IScriptManager::RegisterClientScriptResource;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="resourceName">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterDispose">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterDispose (System.Web.UI.Control control, string disposeScript);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterDispose(class System.Web.UI.Control control, string disposeScript) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterDispose(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterDispose(System::Web::UI::Control ^ control, System::String ^ disposeScript) = System::Web::UI::IScriptManager::RegisterDispose;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="disposeScript" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="disposeScript">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterExpandoAttribute (System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterExpandoAttribute(class System.Web.UI.Control control, string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterExpandoAttribute(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterExpandoAttribute(System::Web::UI::Control ^ control, System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode) = System::Web::UI::IScriptManager::RegisterExpandoAttribute;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="controlId">To be added.</param>
        <param name="attributeName">To be added.</param>
        <param name="attributeValue">To be added.</param>
        <param name="encode">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterHiddenField">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterHiddenField (System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldValue);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterHiddenField(class System.Web.UI.Control control, string hiddenFieldName, string hiddenFieldValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterHiddenField(System.Web.UI.Control,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterHiddenField(System::Web::UI::Control ^ control, System::String ^ hiddenFieldName, System::String ^ hiddenFieldValue) = System::Web::UI::IScriptManager::RegisterHiddenField;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="hiddenFieldName">To be added.</param>
        <param name="hiddenFieldValue">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterOnSubmitStatement (System.Web.UI.Control control, Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterOnSubmitStatement(class System.Web.UI.Control control, class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterOnSubmitStatement(System.Web.UI.Control,System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterOnSubmitStatement(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script) = System::Web::UI::IScriptManager::RegisterOnSubmitStatement;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterPostBackControl">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterPostBackControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterPostBackControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterPostBackControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterPostBackControl(System::Web::UI::Control ^ control) = System::Web::UI::IScriptManager::RegisterPostBackControl;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IScriptManagerInternal.RegisterPostBackControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.RegisterStartupScript">
      <MemberSignature Language="C#" Value="void IScriptManager.RegisterStartupScript (System.Web.UI.Control control, Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.RegisterStartupScript(class System.Web.UI.Control control, class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#RegisterStartupScript(System.Web.UI.Control,System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.RegisterStartupScript(System::Web::UI::Control ^ control, Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags) = System::Web::UI::IScriptManager::RegisterStartupScript;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">To be added.</param>
        <param name="type">To be added.</param>
        <param name="key">To be added.</param>
        <param name="script">To be added.</param>
        <param name="addScriptTags">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IScriptManager.SetFocusInternal">
      <MemberSignature Language="C#" Value="void IScriptManager.SetFocusInternal (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IScriptManager.SetFocusInternal(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ScriptManager.System#Web#UI#IScriptManager#SetFocusInternal(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub SetFocusInternal (clientID As String) Implements IScriptManager.SetFocusInternal" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IScriptManager.SetFocusInternal(System::String ^ clientID) = System::Web::UI::IScriptManager::SetFocusInternal;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.ScriptManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>重写从 <see cref="T:System.Web.UI.Control" /> 基类继承的 <see cref="P:System.Web.UI.Control.Visible" /> 属性以防止设置此值。</summary>
        <value>在所有情况下均为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.Visible%2A>属性被重写，<xref:System.Web.UI.ScriptManager>类以防止设置此值。 A<xref:System.NotImplementedException>如果一个值分配给此属性，则会发生错误。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">将一个值分配给 <see cref="P:System.Web.UI.ScriptManager.Visible" /> 属性。</exception>
      </Docs>
    </Member>
  </Members>
</Type>