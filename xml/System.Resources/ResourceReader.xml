<Type Name="ResourceReader" FullName="System.Resources.ResourceReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="682738b4136d074223cbe025a9380b3cca9bc1d0" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30480251" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ResourceReader : System.Resources.IResourceReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ResourceReader extends System.Object implements class System.Collections.IEnumerable, class System.IDisposable, class System.Resources.IResourceReader" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ResourceReader&#xA;Implements IResourceReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceReader sealed : System::Resources::IResourceReader" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.Reader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Resources.IResourceReader</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>通过读取顺序资源名称/值对枚举二进制资源 (.resources) 文件的资源。  
  
 安全说明：带有不受信任的数据的此类中的调用数据方法存在安全风险。 仅在受信任的数据类中调用方法。 有关详细信息，请参阅 [不受信任数据的安全风险](https://docs.com/rick-anderson-1/8710/untrusted-data-security-risks)。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader>类提供的标准实现<xref:System.Resources.IResourceReader>接口。 A<xref:System.Resources.ResourceReader>实例表示独立的.resources 文件或嵌入到程序集中的.resources 文件。 它用来枚举.resources 文件中的资源和检索其名称/值对。 它不同于<xref:System.Resources.ResourceManager>类，用于从嵌入到程序集中的.resources 文件中检索指定的命名的资源。 <xref:System.Resources.ResourceManager>类用于检索的资源名称事先已知的而<xref:System.Resources.ResourceReader>类可用于检索在编译时不知道其数或准确名称的资源。 例如，应用程序可能使用的资源文件来存储被组织成各个部分，并在部分中，其中事先不知道部分或部分中的项的数量的项的配置信息。 然后可以以一般方式命名资源 (如`Section1`， `Section1Item1`， `Section1Item2`，依次类推) 并通过使用检索<xref:System.Resources.ResourceReader>对象。  
  
> [!IMPORTANT]
>  此类型实现<xref:System.IDisposable>接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，调用其<xref:System.IDisposable.Dispose%2A>中的方法`try` / `catch`块。 若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅中的"使用实现 IDisposable 的对象"部分<xref:System.IDisposable>接口主题。  
  
 有关使用<xref:System.Resources.ResourceReader>类，请参阅以下各节：  
  
-   [实例化 ResourceReader 对象](#instantiate)  
  
-   [枚举 ResourceReader 对象的资源](#enumerate)  
  
    -   [通过使用 IDictionaryEnumerator 属性检索资源](#idictionaryenumerator)  
  
    -   [通过名称和 GetResourceData 检索资源](#getresourcedata)  
  
<a name="instantiate"></a>   
## <a name="instantiating-a-resourcereader-object"></a>实例化 ResourceReader 对象  
 .Resources 文件是从文本文件或 XML.resx 文件的已编译的二进制文件[Resgen.exe （资源文件生成器）](~/docs/framework/tools/resgen-exe-resource-file-generator.md)。 A<xref:System.Resources.ResourceReader>对象可以表示独立的.resources 文件或嵌入到程序集中的.resources 文件。  
  
 若要实例化<xref:System.Resources.ResourceReader>对象读取从单独的.resources 文件，使用<xref:System.Resources.ResourceReader>类构造函数的输入的流或包含的.resources 文件名称的字符串。 下面的示例阐释了这两种方法。 第一个实例化<xref:System.Resources.ResourceReader>对象，表示名为的.resources 文件`Resources1.resources`通过使用其文件名称。 第二个实例化<xref:System.Resources.ResourceReader>对象，表示名为的.resources 文件`Resources2.resources`通过使用从文件创建一个流。  
  
 [!code-csharp[System.Resources.ResourceReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#2)]  
  
 若要创建<xref:System.Resources.ResourceReader>表示嵌入的.resources 文件中，对象实例化<xref:System.Reflection.Assembly>从程序集中嵌入.resources 文件，则在其中的对象。 其<xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType>方法返回<xref:System.IO.Stream>对象，可传递给<xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29>构造函数。 下面的示例实例化<xref:System.Resources.ResourceReader>表示嵌入的.resources 文件的对象。  
  
 [!code-csharp[System.Resources.ResourceReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#3)]
 [!code-vb[System.Resources.ResourceReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#3)]  
  
<a name="enumerate"></a>   
## <a name="enumerating-a-resourcereader-objects-resources"></a>枚举 ResourceReader 对象的资源  
 若要枚举的.resources 文件中的资源，你可以调用<xref:System.Resources.ResourceReader.GetEnumerator%2A>方法，它返回<xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType>对象。 你调用`IDictionaryEnumerator.MoveNext`方法将从一个资源移到下一步。 该方法返回`false`.resources 文件中的所有资源具有在已都枚举。  
  
> [!NOTE]
>  尽管<xref:System.Resources.ResourceReader>类实现<xref:System.Collections.IEnumerable>接口和<xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>方法，<xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType>方法不提供<xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>实现。 相反，<xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType>方法返回<xref:System.Collections.IDictionaryEnumerator>接口提供对每个资源的名称/值对的访问的对象。  
  
 你可以检索两种方式集合中的单个资源：  
  
-   可循环中的每个资源<xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType>收集和使用<xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType>要检索的资源名称和值的属性。 所有资源都是相同的类型，或你知道每个资源的数据类型时，我们建议此技术。  
  
-   你可以检索每个资源的名称，当循环访问<xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType>集合并调用<xref:System.Resources.ResourceReader.GetResourceData%2A>方法来检索资源的数据。 我们建议这种方法，你不知道每个资源的数据类型时或如果前一方法引发异常。  
  
<a name="idictionaryenumerator"></a>   
### <a name="retrieving-resources-by-using-idictionaryenumerator-properties"></a>通过使用 IDictionaryEnumerator 属性检索资源  
 枚举中的.resources 文件的资源的第一种方法涉及直接检索每个资源的名称/值对。 调用后`IDictionaryEnumerator.MoveNext`方法将移到每个资源在集合中，你可以检索资源名称从<xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType>属性和资源数据从<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>属性。  
  
 下面的示例演示如何通过使用检索的名称和值的.resources 文件中的每个资源<xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType>和<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>属性。 若要运行该示例，请创建名为 ApplicationResources.txt 来定义字符串资源的以下文本文件。  
  
```  
Title="Contact Information"  
Label1="First Name:"  
Label2="Middle Name:"  
Label3="Last Name:"  
Label4="SSN:"  
Label5="Street Address:"  
Label6="City:"  
Label7="State:"  
Label8="Zip Code:"  
Label9="Home Phone:"  
Label10="Business Phone:"  
Label11="Mobile Phone:"  
Label12="Other Phone:"  
Label13="Fax:"  
Label14="Email Address:"  
Label15="Alternate Email Address:"  
```  
  
 然后可以将文本资源文件转换为二进制文件名 ApplicationResources.resources 为通过使用以下命令：  
  
 **resgen ApplicationResources.txt**  
  
 下面的示例然后使用<xref:System.Resources.ResourceReader>类枚举独立二进制.resources 文件中的每个资源，并显示其密钥名称和相应的值。  
  
 [!code-csharp[System.Resources.ResourceReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/class1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/class1.vb#1)]  
  
 尝试检索中的资源数据<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>属性可能会引发以下异常：  
  
-   A<xref:System.FormatException>如果数据不是预期格式。  
  
-   A<xref:System.IO.FileNotFoundException>如果找不到包含数据所属的类型的程序集。  
  
-   A<xref:System.TypeLoadException>数据所属的类型不能为如果找不到。  
  
 通常情况下，将引发这些异常，如果定义了一个类型的程序集不包含与应用程序了或已被无意中删除，如果已手动修改.resources 文件或程序集是早于较旧版本一种类型。 如果引发这些异常之一，您可以通过枚举每个资源和调用来检索资源<xref:System.Resources.ResourceReader.GetResourceData%2A>方法，如以下部分所示。 此方法提供了您提供一些信息有关的数据类型<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>尝试返回的属性。  
  
<a name="getresourcedata"></a>   
### <a name="retrieving-resources-by-name-with-getresourcedata"></a>通过名称和 GetResourceData 检索资源  
 枚举中的.resources 文件的资源的第二个方法也需要通过调用在文件中的资源导航`IDictionaryEnumerator.MoveNext`方法。 对于每个资源，检索该资源的名称从<xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType>属性，然后传递给<xref:System.Resources.ResourceReader.GetResourceData%28System.String%2CSystem.String%40%2CSystem.Byte%5B%5D%40%29>方法来检索资源的数据。 这作为字节数组中返回`resourceData`自变量。  
  
 这种方法是比检索的资源名称和值从更繁琐<xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType>和<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>属性，因为它返回窗体中的资源值的实际字节数。 但是，如果尝试以检索资源引发异常，<xref:System.Resources.ResourceReader.GetResourceData%2A>方法可以帮助确定异常的源的通过提供有关资源的数据类型的信息。 表示资源的数据类型的字符串的详细信息，请参阅<xref:System.Resources.ResourceReader.GetResourceData%2A>。  
  
 下面的示例演示如何使用这种方法来检索资源并处理引发任何异常。 它以编程方式创建包含四个字符串、 一个布尔值、 一个整数，一个位图和一个自定义的二进制.resources 文件`DateTimeTZI`对象。 若要运行该示例，请执行以下操作：  
  
1.  创建名为 Library.dll 包含程序集`DateTimeTZI`结构。 下面是程序集的源代码。  
  
     [!code-csharp[System.Resources.ResourceReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/library.cs#4)]
     [!code-vb[System.Resources.ResourceReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/library.vb#4)]  
  
     通过使用以下命令来编译 C# 中的源代码：  
  
    ```  
    csc /t:library library.cs  
    ```  
  
     或者，你可以对其进行编译 Visual Basic 中使用以下命令：  
  
    ```  
    vbc library.vb /t:library  
    ```  
  
2.  编译并执行下面的源代码，这将创建一个名为 ContactResources.resources 的.resources 文件。  
  
     [!code-csharp[System.Resources.ResourceReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/createresourceex1.cs#5)]
     [!code-vb[System.Resources.ResourceReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/createresourceex1.vb#5)]  
  
     源代码文件是名为 CreateResources.cs。 你可编译它在 C# 中使用以下命令：  
  
    ```  
    csc CreateResources.cs /r:library.dll  
    ```  
  
     或者，你可以对其进行编译 Visual Basic 中使用以下命令：  
  
    ```  
    vbc CreateResources.vb /r:library.dll  
    ```  
  
3.  编译并运行以下代码以枚举 ContactResources.resources 文件中的资源。  
  
     [!code-csharp[System.Resources.ResourceReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/readresourceex1.cs#6)]
     [!code-vb[System.Resources.ResourceReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/readresourceex1.vb#6)]  
  
     修改了源代码后 (例如，通过有意引发<xref:System.FormatException>末尾`try`块) 或者重命名 Library.dll 程序集，以便在运行时不可用，你可以运行示例，以了解如何调用<xref:System.Resources.ResourceReader.GetResourceData%2A>使您能够检索或重新创建某些资源信息。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Resources.ResourceReader" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  将此对象的实例与不受信任的数据一起使用存在安全风险。 此对象仅使用受信任的数据。 有关详细信息，请参阅[数据验证](https://www.owasp.org/index.php/Data_Validation)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::IO::Stream ^ stream);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">用于读取资源的输入流。</param>
        <summary>为指定的流初始化 <see cref="T:System.Resources.ResourceReader" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29>构造函数实例化<xref:System.Resources.ResourceReader>检索从独立的.resources 文件或从.resources 文件的资源的对象嵌入到程序集中。 若要从独立.resources 文件中读取，实例化<xref:System.IO.Stream>对象，并将其传递到<xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29>构造函数。 若要从嵌入的.resources 文件中读取，调用<xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType>.resources 文件，并传入返回区分大小写的同名方法<xref:System.IO.Stream>对象传递给<xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29>构造函数。  
  
> [!IMPORTANT]
>  将此对象的实例与不受信任的数据一起使用存在安全风险。 此对象仅使用受信任的数据。 有关详细信息，请参阅[数据验证](https://www.owasp.org/index.php/Data_Validation)。  
  
   
  
## Examples  
 本部分中的示例使用名为的以下.txt 文件`PatientForm.txt`来定义应用程序使用的资源。  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 通过发出以下命令，可以编译为.resources 文件的.txt 文件：  
  
 **resgen PatientForm.txt**  
  
 下面的示例假定资源文件嵌入包含应用程序的可执行代码的程序集。 它将检索名为的资源文件`PatientForm.resources`从当前正在执行的程序集，并显示名称和值的每个及其资源。  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream1.vb#1)]  
  
 如果名为 C# 示例`Example.cs`，你可以通过使用以下命令对其进行编译：  
  
 **csc Example.cs /res:PatientForm.resources**  
  
 如果名为 Visual Basic 示例`Example.vb`，你可以通过使用以下命令对其进行编译：  
  
 **vbc Example.vb /res:PatientForm.resources**  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> 参数不可读。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.IOException">在访问 <paramref name="stream" /> 时发生 I/O 错误。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于提供序列化服务。 安全操作： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任直接调用方。 此成员不能由部分受信任或不透明的代码。</permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::String ^ fileName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要读取的源文件的路径及名称。 文件名<c></c>不区分大小写。</param>
        <summary>为指定的资源文件初始化 <see cref="T:System.Resources.ResourceReader" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.%23ctor%28System.String%29>构造函数实例化<xref:System.Resources.ResourceReader>从独立的.resources 文件中检索资源的对象。 若要从嵌入的.resources 文件中检索资源，请使用<xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29>构造函数。  
  
> [!IMPORTANT]
>  将此对象的实例与不受信任的数据一起使用存在安全风险。 此对象仅使用受信任的数据。 有关详细信息，请参阅[数据验证](https://www.owasp.org/index.php/Data_Validation)。  
  
   
  
## Examples  
 本部分中的示例使用名为的以下.txt 文件`PatientForm.txt`来定义应用程序使用的资源。  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 通过发出以下命令，可以编译为.resources 文件的此.txt 文件：  
  
 **resgen PatientForm.txt**  
  
 下面的示例枚举中的资源`PatientForm.resources`并显示名称和每个值。  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileName" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">无法找到该文件。</exception>
        <exception cref="T:System.IO.IOException">发生了 I/O 错误。</exception>
        <exception cref="T:System.BadImageFormatException">资源文件的格式无效。 例如，文件的长度可能为零。</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放与此 <see cref="T:System.Resources.ResourceReader" /> 对象相关联的所有操作系统资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.Close%2A> 可以安全地调用多次。  
  
   
  
## Examples  
 下面的示例都将通过文件的资源，并显示它找到的所有键/值对。 该代码将使用<xref:System.Resources.ResourceReader.Close%2A>方法来关闭<xref:System.Resources.ResourceReader>并释放由它的所有资源。  
  
 [!code-cpp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CPP/getenumerator.cpp#1)]
 [!code-csharp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CS/getenumerator.cs#1)]
 [!code-vb[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Resources.ResourceReader" /> 类的当前实例所使用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在完成使用的此实例时<xref:System.Resources.ResourceReader>，调用<xref:System.Resources.ResourceReader.Dispose%2A>释放此实例所使用的所有资源。 你应该可以消除进一步引用到此<xref:System.Resources.ResourceReader>实例，以便垃圾回收器才能回收而不是保留它终止的实例的内存。  
  
 <xref:System.Resources.ResourceReader.Dispose%2A> 调用私有 dispose （boolean） 方法，其中包含要释放托管和非托管资源的代码。 有关详细信息，请参阅[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 <see cref="T:System.Resources.ResourceReader" /> 对象的枚举器。</summary>
        <returns>此 <see cref="T:System.Resources.ResourceReader" /> 对象的枚举器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常情况下，通过调用枚举资源<xref:System.Resources.ResourceReader.GetEnumerator%2A>方法，然后重复调用<xref:System.Collections.IEnumerator.MoveNext%2A>方法返回<xref:System.Collections.IDictionaryEnumerator>对象，直到该方法返回`false`。 资源名称是否可从<xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType>属性; 其值从<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>属性。 该示例说明如何枚举这种方式中的资源。  
  
 实现<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>属性<xref:System.Resources.ResourceReader>类可以引发以下异常：  
  
-   <xref:System.IO.FileNotFoundException>  
  
     找不到包含数据所属的类型的程序集。  
  
-   <xref:System.FormatException>  
  
     数据不是预期格式。  
  
-   <xref:System.TypeLoadException>  
  
     找不到数据所属的类型。  
  
 可以通过调用处理的异常<xref:System.Resources.ResourceReader.GetResourceData%2A>方法来检索有关的数据类型和分配给该命名的资源的字节数组的信息。 有关详细信息，请参阅中的"检索资源的名称与 GetResourceData"一节<xref:System.Resources.ResourceReader>类主题。  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceReader>类包括返回枚举器的两个方法。 <xref:System.Resources.ResourceReader.GetEnumerator%2A>方法返回<xref:System.Collections.IDictionaryEnumerator>接口对象，并在调用时的推荐的方法枚举资源。  
  
   
  
## Examples  
 本部分中的示例使用名为的以下.txt 文件`PatientForm.txt`来定义应用程序使用的资源。  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 通过发出以下命令，可以编译为.resources 文件的.txt 文件：  
  
 **resgen PatientForm.txt**  
  
 下面的示例枚举中的资源`PatientForm.resources`并显示名称和每个值。  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">读取器已关闭或释放，因此无法访问。</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceData">
      <MemberSignature Language="C#" Value="public void GetResourceData (string resourceName, out string resourceType, out byte[] resourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetResourceData(string resourceName, [out] string&amp; resourceType, [out] unsigned int8[]&amp; resourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetResourceData(System.String,System.String@,System.Byte[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetResourceData (resourceName As String, ByRef resourceType As String, ByRef resourceData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetResourceData(System::String ^ resourceName, [Runtime::InteropServices::Out] System::String ^ % resourceType, [Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % resourceData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
        <Parameter Name="resourceType" Type="System.String&amp;" RefType="out" />
        <Parameter Name="resourceData" Type="System.Byte[]&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="resourceName">资源的名称。</param>
        <param name="resourceType">当此方法返回时，包含表示检索资源的类型名称的字符串。 此参数未经初始化即被传递。</param>
        <param name="resourceData">此方法返回时，包含一个字节数组，该字节数组为所检索类型的二进制表示形式。 此参数未经初始化即被传递。</param>
        <summary>从打开的资源文件或流检索指定资源的类型名称和数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.GetResourceData%2A>方法检索作为字节数组的已命名资源的值。 它通常是时使用<xref:System.Collections.IDictionaryEnumerator.Value%2A>属性在它试图检索资源的值时引发异常。  
  
 `resourceType` 是一个字符串，表示资源的数据类型。 它可以是任何以下值：  
  
-   字符串表示形式`ResourceTypeCode`指示该资源的数据类型的枚举成员。 `ResourceTypeCode` 是的。 若要使用的私有枚举指示特殊的二进制格式用于存储 19 常见数据类型之一。 其中包括.NET Framework 基元数据类型 (<xref:System.Boolean>， <xref:System.Byte>， <xref:System.Char>， <xref:System.Decimal>， <xref:System.Double>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.Int64>， <xref:System.Single>， <xref:System.SByte>， <xref:System.UInt16>， <xref:System.UInt32>， <xref:System.UInt64>)，以及<xref:System.String>， <xref:System.DateTime>，和<xref:System.TimeSpan>，此外，`ResourceTypeCode`枚举包括下表中显示的值。  
  
    |ResourceTypeCode value|描述|  
    |----------------------------|-----------------|  
    |`ResourceTypeCode.ByteArray`|数据为字节数组。 此数据类型通常从调用的结果<xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Byte%5B%5D%29?displayProperty=nameWithType>方法。|  
    |`ResourceTypeCode.Null`|数据为空引用。 此数据类型通常从调用的结果<xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Object%29?displayProperty=nameWithType>方法与一个对象，其值是`null`。|  
    |`ResourceTypeCode.Stream`|数据存储在流中。 此数据类型通常从调用的结果<xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%29?displayProperty=nameWithType>或<xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%2CSystem.Boolean%29?displayProperty=nameWithType>方法。|  
  
     假设`resourceData`尚未被损坏，它通常可转换从字节数组返回到其原始值通过调用<xref:System.BitConverter>或<xref:System.IO.BinaryReader>方法。  
  
-   包含其序列化的数据分配到的类型的完全限定的名称的字符串`resourceData`自变量 (例如， `System.String`)。 此外，对于不是.NET Framework 类库的一部分的类型，该字符串包括名称、 版本、 区域性和公钥的包含类型的程序集。 例如，以下字符串指示序列化的数据表示的实例`Person`键入`Extensions`命名空间，在名为具有没有公用密钥和任何指定的区域性的实用工具程序集的版本 1.0 中找到。  
  
     `Extensions.Person, Utility, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`  
  
     假设`resourceData`未损坏，以及源类型是否可用，`resourceData`可转换从字节数组返回到其原始值通过将转换到的字节数组<xref:System.IO.Stream>对象并将流传递给<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize%2A?displayProperty=nameWithType>方法。  
  
-   用于描述中的数据类型的字符串<xref:System.Resources.ResourceWriter.AddResourceData%2A?displayProperty=nameWithType>方法调用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceName" /> 不存在。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="resourceName" /> 具有无效的类型。</exception>
        <exception cref="T:System.FormatException">检索的资源数据已损坏。</exception>
        <exception cref="T:System.InvalidOperationException">当前 <see cref="T:System.Resources.ResourceReader" /> 对象未初始化，可能因其已被关闭。</exception>
        <altmember cref="M:System.Resources.ResourceWriter.AddResourceData(System.String,System.String,System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 <see cref="T:System.Resources.ResourceReader" /> 对象的枚举器。</summary>
        <returns>此 <see cref="T:System.Resources.ResourceReader" /> 对象的枚举器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.System%23Collections%23IEnumerable%23GetEnumerator%2A?displayProperty=nameWithType> 是显式接口实现。 它只能在 <xref:System.Resources.ResourceReader> 实例强制转换为 <xref:System.Collections.IEnumerable> 接口时使用。 枚举中的.resources 文件的资源的建议的方法是调用<xref:System.Collections.IEnumerator.MoveNext%2A>方法<xref:System.Collections.IDictionaryEnumerator>返回对象<xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">读取器已关闭，并且无法访问。</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
  </Members>
</Type>