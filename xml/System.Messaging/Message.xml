<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="452b72d229254f13a5d2827bfeca0ec97c6f6675" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30461091" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供对定义消息队列消息所需的属性的访问。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Messaging.Message>若要查看或从队列接收消息，或向队列发送消息时具有很好的控制消息属性的类。  
  
 <xref:System.Messaging.MessageQueue> 使用<xref:System.Messaging.Message>类在扫视或接收来自队列的消息时，因为同时<xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType>和<xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType>方法创建的新实例<xref:System.Messaging.Message>类，然后设置实例的属性。 <xref:System.Messaging.Message>类的只读属性适用于从队列检索消息时的读/写属性适用于发送和检索消息。 当<xref:System.Messaging.MessageQueue>扫视或接收来自队列的消息其<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>属性确定消息的属性中哪些检索。  
  
 <xref:System.Messaging.MessageQueue>类的<xref:System.Messaging.MessageQueue.Send%2A>方法允许你指定发送到该队列的消息的任何对象类型。 你可以使用<xref:System.Messaging.MessageQueue>实例的<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性指定的泛型消息发送到队列设置。 类型的设置包括格式化程序、 标签、 加密和身份验证。 你还可以指定的相应值<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>成员在协调消息传送应用程序以响应确认消息和报告消息时。 使用<xref:System.Messaging.Message>实例向队列发送一条消息可以灵活地访问和修改其中的许多属性-对单个消息或消息的消息的基础上。 <xref:System.Messaging.Message> 属性优先于<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>。  
  
 消息数据存储在<xref:System.Messaging.Message.Body%2A>属性和较小的范围内，<xref:System.Messaging.Message.AppSpecific%2A>和<xref:System.Messaging.Message.Extension%2A>属性。 消息数据已加密、 序列化或反序列化的内容<xref:System.Messaging.Message.Body%2A>属性会受到影响。  
  
 内容<xref:System.Messaging.Message.Body%2A>序列化属性，当使用发送消息时<xref:System.Messaging.Message.Formatter%2A>你指定的属性。 在中找到的序列化的内容<xref:System.Messaging.Message.BodyStream%2A>属性。 你还可以设置<xref:System.Messaging.Message.BodyStream%2A>属性直接，例如，若要将文件作为一条消息的数据内容发送。 你可以更改<xref:System.Messaging.Message.Body%2A>或<xref:System.Messaging.Message.Formatter%2A>属性任何时间之前发送的消息和数据时将进行序列化相应地在调用时<xref:System.Messaging.MessageQueue.Send%2A>。  
  
 属性定义<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType>属性仅适用于消息并不属于类型<xref:System.Messaging.Message>。 如果指定<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>属性<xref:System.Messaging.MessageQueue>，则具有相同的名称中的属性<xref:System.Messaging.Message>实例发送到该队列原因要忽略这些默认属性。  
  
 有关的实例的初始属性值的列表<xref:System.Messaging.Message>，请参阅<xref:System.Messaging.Message.%23ctor%2A>构造函数。  
  
   
  
## Examples  
 下面的代码示例演示了格式设置消息正文使用<xref:System.Messaging.BinaryMessageFormatter>。  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 下面的代码示例演示了格式设置消息正文使用<xref:System.Messaging.XmlMessageFormatter>。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Messaging.Message" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Messaging.Message" /> 类的新实例（主体为空）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载来创建的新实例<xref:System.Messaging.Message>具有空主体的类。  
  
 指定<xref:System.Messaging.Message.Body%2A>属性或<xref:System.Messaging.Message.BodyStream%2A>属性在发送之前<xref:System.Messaging.Message>对象。 <xref:System.Messaging.Message.Body%2A>属性可以是任何可序列化的对象，如文本字符串、 结构对象、 类实例或嵌入的对象。  
  
 除非你将写入消息的内容直接<xref:System.Messaging.Message.BodyStream%2A>属性，设置<xref:System.Messaging.Message.Formatter%2A>属性后，发送消息。 正文将序列使用<xref:System.Messaging.Message.Formatter%2A>属性的值时<xref:System.Messaging.MessageQueue.Send%2A>方法调用<xref:System.Messaging.MessageQueue>实例。  
  
 <xref:System.Messaging.XmlMessageFormatter>松散耦合的因此不需要时使用此格式键入发送方和接收方将相同对象。 <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>数据序列化为二进制表示形式。 <xref:System.Messaging.ActiveXMessageFormatter>发送或接收 COM 组件时使用。  
  
 下表显示的实例的初始属性值<xref:System.Messaging.Message>。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 1.0 版|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|空字符串 ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|一个零长度的字节数组|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|一个零长度的字节数组|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|一个零长度的字节数组|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|空字符串 ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|一个零长度的字节数组|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 下面的代码示例将两个不同的优先级别的消息发送到队列，并随后检索它们。  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">要序列化到消息体中的对象。</param>
        <summary>通过用 <see cref="T:System.Messaging.Message" /> 将指定的对象序列化到消息体中，初始化 <see cref="T:System.Messaging.XmlMessageFormatter" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载来创建的新实例<xref:System.Messaging.Message>类，该类包含<xref:System.Messaging.Message.Body%2A>指定的`body`参数。 `body`参数可以是任何可序列化，如文本字符串、 结构对象、 类实例或嵌入的对象的对象。 正文将序列使用<xref:System.Messaging.XmlMessageFormatter>除非您更改<xref:System.Messaging.Message.Formatter%2A>属性之前<xref:System.Messaging.Message>发送。 如果你更改<xref:System.Messaging.Message.Body%2A>或<xref:System.Messaging.Message.Formatter%2A>属性之前调用的任何时候<xref:System.Messaging.MessageQueue.Send%2A>，消息会根据新的属性值进行序列化。  
  
 <xref:System.Messaging.XmlMessageFormatter>松散耦合的因此不需要时使用此格式键入发送方和接收方将相同对象。 <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>数据序列化为二进制表示形式。 <xref:System.Messaging.ActiveXMessageFormatter>发送或接收 COM 组件时使用。  
  
 下表显示的实例的初始属性值<xref:System.Messaging.Message>。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 1.0 版|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` 参数。|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|空字符串 ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|一个零长度的字节数组|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|一个零长度的字节数组|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|一个零长度的字节数组|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|空字符串 ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|一个零长度的字节数组|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 下面的代码示例创建一个新队列、 发送一条消息，包含到其中，订单，然后检索它。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">要序列化到消息体中的对象。</param>
        <param name="formatter">
          <see cref="T:System.Messaging.IMessageFormatter" />，指定用于序列化消息体的格式化程序。</param>
        <summary>初始化 <see cref="T:System.Messaging.Message" /> 类的新实例，使用指定的格式化程序将指定的对象序列化到消息体中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载来创建的新实例<xref:System.Messaging.Message>类，该类包含<xref:System.Messaging.Message.Body%2A>指定的`body`参数且使用任何有效的格式化程序进行序列化正文。 `body`参数是可序列化，如文本字符串、 结构对象、 类实例或嵌入的对象的任何对象。 如果你更改<xref:System.Messaging.Message.Body%2A>或<xref:System.Messaging.Message.Formatter%2A>属性之前调用的任何时候<xref:System.Messaging.MessageQueue.Send%2A>，消息会根据新的属性值进行序列化。  
  
 <xref:System.Messaging.XmlMessageFormatter>松散耦合的因此不需要时使用此格式键入发送方和接收方将相同对象。 <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>数据序列化为二进制表示形式。 <xref:System.Messaging.ActiveXMessageFormatter>发送或接收 COM 组件时使用。  
  
 下表显示的实例的初始属性值<xref:System.Messaging.Message>。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 1.0 版|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` 参数。|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|空字符串 ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|一个零长度的字节数组|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|一个零长度的字节数组|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|一个零长度的字节数组|  
|<xref:System.Messaging.Message.Formatter%2A>|`formatter` 参数。|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|空字符串 ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|一个零长度的字节数组|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置返回给发送应用程序的确认消息的类型。</summary>
        <value>
          <see cref="T:System.Messaging.AcknowledgeTypes" /> 值之一，该值表示系统在管理队列中传递的确认消息类型，以及在何种条件下将确认消息返回发送应用程序。 默认值为 <see langword="None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AcknowledgeType%2A>属性指定发送应用程序请求的确认消息的类型。 设置<xref:System.Messaging.Message.AcknowledgeType%2A>发送消息以请求特定事件的通知之前的属性 — 例如，消息到达其目标队列、 正在检索消息或阻止一条消息到达或从正在检索的超时目标队列中。  
  
 消息队列的确认将消息发送到返回通知<xref:System.Messaging.Message.AdministrationQueue%2A>指定原始消息属性。 确认消息的<xref:System.Messaging.Message.Acknowledgment%2A>属性指示确认它所表示的类型。 例如，如果发送确认消息，因为消息未到达之前目标<xref:System.Messaging.Message.TimeToReachQueue%2A>间隔过期，<xref:System.Messaging.Message.Acknowledgment%2A>的确认消息的属性将包含值`ReachQueueTimeout`。  
  
   
  
## Examples  
 下面的代码示例发送和接收一条包含订单到和从队列消息。 它特别请求肯定确认当原始消息到达或已从队列中检索。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息经过筛选后忽略了 <see cref="P:System.Messaging.Message.AcknowledgeType" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该消息表示的确认分类。</summary>
        <value>
          <see cref="T:System.Messaging.Acknowledgment" /> 枚举值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你将收到来自管理队列时，读取<xref:System.Messaging.Message.Acknowledgment%2A>属性以验证原始消息的状态。  
  
 当消息发送到其目标队列时，消息队列可以请求将数据发送确认消息。 例如，使用消息到达并被检索在指定超时值，也可能表明发生了什么错误传递失败的情况下，可以指示此类消息。 目标队列返回确认消息，并将其发布到原始消息中指定的管理队列<xref:System.Messaging.Message.AdministrationQueue%2A>属性。 <xref:System.Messaging.Message.Id%2A>的确认消息的属性标识的确认消息，不是原始消息。 你可以在该确认找到原始消息的标识符<xref:System.Messaging.Message>实例的<xref:System.Messaging.Message.CorrelationId%2A>属性。  
  
 如果此<xref:System.Messaging.Message>实例表示发送确认消息，<xref:System.Messaging.Message.Acknowledgment%2A>属性指定的确认类型。 否则为<xref:System.Messaging.Message.Acknowledgment%2A>属性包含值`Normal`。  
  
 使用<xref:System.Messaging.Message.AcknowledgeType%2A>以指定将在其下返回确认的情况的原始消息的属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
 或  
  
 消息队列经过筛选后忽略了 <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置接收由消息队列生成的确认消息的队列。</summary>
        <value>
          <see cref="T:System.Messaging.MessageQueue" />，指定用于系统生成的确认消息的管理队列。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中指定的队列<xref:System.Messaging.Message.AdministrationQueue%2A>属性可以是任何非事务性队列。 发送到管理队列的确认消息可以指示原始消息是否到达了目标队列，以及是否被从该队列中移除。  
  
 当<xref:System.Messaging.Message.AcknowledgeType%2A>属性以外的任何值`None`，发送应用程序必须指定要用作管理队列的队列。  
  
   
  
## Examples  
 下面的代码示例发送和接收一条包含订单到和从队列消息。 它特别请求肯定确认当原始消息到达或已从队列中检索。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.AdministrationQueue" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置应用程序特定的附加信息。</summary>
        <value>应用程序特定的信息。 默认值为零。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AppSpecific%2A>属性包含可用于组织不同类型的消息的应用程序特定信息。 例如，可使用应用程序特定的索引。 要解释的应用程序负责<xref:System.Messaging.Message.AppSpecific%2A>属性信息。  
  
 只要有可能，应将消息数据包含在消息的正文中而不是<xref:System.Messaging.Message.AppSpecific%2A>属性。  
  
 在使用外部队列，使用<xref:System.Messaging.Message.Extension%2A>属性指定在消息队列中不存在的消息属性。 与<xref:System.Messaging.Message.AppSpecific%2A>属性，它是要了解的内容的应用程序的责任<xref:System.Messaging.Message.Extension%2A>属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.AppSpecific" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取消息到达目标队列的时间。</summary>
        <value>
          <see cref="T:System.DateTime" />，表示消息到达目标队列的时间。 该时间被从 GMT 调整为目标队列驻留的计算机上的本地时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息的<xref:System.Messaging.Message.TimeToBeReceived%2A>属性指示必须从目标队列收到的消息的速度。 <xref:System.Messaging.Message.TimeToBeReceived%2A>属性计时器将开始发送消息，不在消息到达队列中时。  
  
   
  
## Examples  
 下面的代码示例显示一条消息的值<xref:System.Messaging.Message.ArrivedTime%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
 或  
  
 消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.ArrivedTime" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示发送方 ID 是否应附在消息中。</summary>
        <value>
          如果 <see cref="P:System.Messaging.Message.SenderId" /> 应附在消息中，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderId%2A>属性是表示发送用户的标识符的字节数组。 发件人 ID 由消息队列设置，并且用于通过接收队列管理器来验证发件人是否有权访问队列。  
  
 发件人 ID，则发送应用程序，消息队列应不验证消息的发件人，也不验证发件人的访问权限表示缺少权限到接收队列。 <xref:System.Messaging.Message.SenderId%2A>值得仅当消息已验证时它已达到目标队列。 消息队列接受仅经过身份验证的消息，并且如果到达目标队列时被拒绝<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>或<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>属性是`false`。  
  
> [!CAUTION]
>  如果消息被拒绝，它或者被发送到死信队列 (如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`true`)，或它将被忽略。 当一条消息未能到达队列时，你可以请求确认。 否则为在<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`false`消息可能会丢失而不发出警告。  
  
   
  
## Examples  
 下面的代码示例获取和设置的消息的值<xref:System.Messaging.Message.AttachSenderId%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.AttachSenderId" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示消息是否已验证。</summary>
        <value>
          如果在消息进入队列时请求了验证，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Authenticated%2A>属性只由应用程序时它是与消息交互，并尝试确定是否已请求身份验证。 如果消息已在队列中，消息已验证。 相反，如果<xref:System.Messaging.Message.Authenticated%2A>属性是`true`，接收队列管理器身份验证消息，当收到该消息。  
  
 无法确定消息是否未通过查看其属性通过身份验证。 消息队列丢弃身份验证失败之前它们传递到队列的消息。 但是，你可以请求如果传送失败防止消息到达队列中，会发送确认消息。  
  
   
  
## Examples  
 下面的代码示例显示一条消息的值<xref:System.Messaging.Message.Authenticated%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
 或  
  
 消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.Authenticated" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于生成消息数字签名的加密提供程序的名称。</summary>
        <value>用于生成消息数字签名的加密提供程序的名称。 默认值为 Microsoft 基础加密提供程序版本 1.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常使用<xref:System.Messaging.Message.AuthenticationProviderName%2A>时使用外部队列。 消息队列需要的身份验证提供程序名称和加密服务提供程序 （身份验证提供程序） 来验证发送到外部队列的消息和消息传递给消息的数字签名的身份验证提供程序类型从外队列的队列。  
  
 发送邮件时，始终设置<xref:System.Messaging.Message.AuthenticationProviderName%2A>和<xref:System.Messaging.Message.ConnectorType%2A>属性组合在一起。 如果连接器类型还未设置，发送消息，消息队列将忽略身份验证提供程序名称。  
  
 <xref:System.Messaging.Message.AuthenticationProviderName%2A>属性不能为`null`，但它可以是空字符串 ("")。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未能设置 <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> 属性。  
  
 或  
  
 消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> 属性。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> 被设置成了 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于生成消息数字签名的加密提供程序类型。</summary>
        <value>
          <see cref="T:System.Messaging.CryptographicProviderType" /> 值之一。 默认值为 <see langword="RSA_FULL" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常使用<xref:System.Messaging.Message.AuthenticationProviderType%2A>时使用外部的队列，以指定的加密服务提供程序是与消息关联的属性。 消息队列需要的身份验证提供程序名称和加密服务提供程序 （身份验证提供程序） 来验证发送到外部队列的消息和消息传递给消息的数字签名的身份验证提供程序类型从外队列的队列。  
  
 仅`RsaFull`旨在与消息一起使用。  
  
 发送邮件时，始终设置<xref:System.Messaging.Message.AuthenticationProviderType%2A>和<xref:System.Messaging.Message.ConnectorType%2A>属性组合在一起。 如果连接器类型还未设置，发送消息，消息队列将忽略的身份验证提供程序类型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未能设置 <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> 属性。  
  
 或  
  
 消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置消息的内容。</summary>
        <value>指定消息内容的对象。 该对象可以是字符串、日期、货币、数字、字节数组或任何托管对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息的<xref:System.Messaging.Message.Body%2A>属性通常包含与消息关联的数据。 虽然你还可以发送应用程序特定数据<xref:System.Messaging.Message.AppSpecific%2A>和<xref:System.Messaging.Message.Extension%2A>属性，您应包含在消息数据<xref:System.Messaging.Message.Body%2A>只要有可能的消息。 仅<xref:System.Messaging.Message.Body%2A>属性内容将被序列化或加密。  
  
 <xref:System.Messaging.Message.Body%2A>属性可以包含任何对象，其大小不超过 4 MB。 如果你使用<xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType>发送的类型不是任何对象<xref:System.Messaging.Message>到<xref:System.Messaging.MessageQueue>，该对象将位于<xref:System.Messaging.Message.Body%2A>属性<xref:System.Messaging.Message>返回实例<xref:System.Messaging.MessageQueue.Peek%2A>或<xref:System.Messaging.MessageQueue.Receive%2A>。  
  
 中的字符串自变量`MessageQueue.Send("hello.")`是一个示例是一般的对象。  
  
 <xref:System.Messaging.Message.BodyType%2A>属性指示消息正文中存储的信息的类型。 消息队列使用此信息来标识的类型<xref:System.Messaging.Message.Body%2A>属性内容。  
  
 指定<xref:System.Messaging.Message.Body%2A>属性或<xref:System.Messaging.Message.BodyStream%2A>属性在发送之前<xref:System.Messaging.Message>对象。 <xref:System.Messaging.Message.Body%2A>属性可以是任何可序列化对象，例如文本字符串、 结构对象、 类实例或嵌入的对象。  
  
 除非你将写入消息的内容直接<xref:System.Messaging.Message.BodyStream%2A>属性，设置<xref:System.Messaging.Message.Formatter%2A>属性后，发送消息。 当<xref:System.Messaging.MessageQueue.Send%2A>方法调用<xref:System.Messaging.MessageQueue>实例，正文使用序列化格式化程序中包含<xref:System.Messaging.Message.Formatter%2A>属性。 如果你发送消息时未指定的值<xref:System.Messaging.Message.Formatter%2A>属性，格式化程序默认值为<xref:System.Messaging.XmlMessageFormatter>。  
  
> [!NOTE]
>  尝试设置到的消息正文<xref:System.Decimal.MaxValue>将导致<xref:System.OverflowException>时`Send`方法<xref:System.Messaging.MessageQueue>类称为和<xref:System.Messaging.ActiveXMessageFormatter>使用。  
  
   
  
## Examples  
 下面的代码示例将两个不同的优先级别的消息发送到队列，并随后检索它们。  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Messaging.Message.Formatter" /> 属性为 <see langword="null" />。  
  
 或  
  
 消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.Body" /> 属性。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置消息正文中的信息。</summary>
        <value>
          <see cref="T:System.IO.Stream" />，包含消息的 <see cref="P:System.Messaging.Message.Body" /> 中包括的已序列化信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一条消息的主体可以包含的任何类型的信息 —，字符串、 日期、 货币、 数字、 字节，数组或任何托管的对象。 此信息序列化为<xref:System.IO.Stream>要传递给队列。  
  
 指定<xref:System.Messaging.Message.Body%2A>属性或<xref:System.Messaging.Message.BodyStream%2A>属性在发送之前<xref:System.Messaging.Message>对象。 如果你设置<xref:System.Messaging.Message.Body%2A>属性，内容序列化到<xref:System.Messaging.Message.BodyStream%2A>属性。 但是，您可以选择编写<xref:System.Messaging.Message.BodyStream%2A>直接属性。 这很有用，例如，如果想要打开的连接到文件并将其内容序列作为你的消息的正文。  
  
 除非你将写入消息的内容直接<xref:System.Messaging.Message.BodyStream%2A>属性，设置<xref:System.Messaging.Message.Formatter%2A>属性后，发送消息。 当<xref:System.Messaging.MessageQueue.Send%2A>方法调用<xref:System.Messaging.MessageQueue>实例，正文使用序列化格式化程序中包含<xref:System.Messaging.Message.Formatter%2A>属性。 如果你发送消息时未指定的值<xref:System.Messaging.Message.Formatter%2A>属性，格式化程序默认值为<xref:System.Messaging.XmlMessageFormatter>。  
  
 如果你设置<xref:System.Messaging.Message.UseEncryption%2A>属性`true`为此消息的正文，消息将被加密发送时，不是在你设置时<xref:System.Messaging.Message.Body%2A>属性。 因此，<xref:System.Messaging.Message.BodyStream%2A>永远不会加密属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.Body" /> 属性。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置消息正文所包含数据的类型。</summary>
        <value>消息体的真实类型，如字符串、日期、货币或数字。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息队列会将正文内容视为一个对象或序列化的流。 <xref:System.Messaging.Message.BodyType%2A>属性指示中的对象的类型<xref:System.Messaging.Message.Body%2A>消息的属性。  
  
 <xref:System.Messaging.XmlMessageFormatter>完成消息正文中本机类型与对象之间的绑定。 如果你使用<xref:System.Messaging.XmlMessageFormatter>，格式化程序集<xref:System.Messaging.Message.BodyType%2A>为你的属性。  
  
 此外，如下面的 C# 代码中所示，其他格式化程序可以提供绑定功能。  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 下面的代码示例显示一条消息的值<xref:System.Messaging.Message.BodyType%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.Body" /> 属性。</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示由发送应用程序设置通常由消息队列设置的某些消息属性。</summary>
        <value>由应用程序定义的 <see cref="T:System.Guid" />，与连接器应用程序或消息加密一起使用。 此 <see cref="T:System.Guid" /> 允许接收应用程序解释由发送应用程序设置、但通常由消息队列设置的消息属性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息队列要求<xref:System.Messaging.Message.ConnectorType%2A>属性设置只要应用程序设置通常由消息队列设置的消息属性。 应用程序通常使用<xref:System.Messaging.Message.ConnectorType%2A>在以下两种情况：  
  
-   每当连接器应用程序将消息传递。 <xref:System.Messaging.Message.ConnectorType%2A>告知如何解释消息的安全性和确认属性的发送和接收应用程序。  
  
-   每当发送应用程序，而不是消息队列，加密消息。 <xref:System.Messaging.Message.ConnectorType%2A>通知消息队列使用<xref:System.Messaging.Message.DestinationSymmetricKey%2A>要对消息进行解密的属性值。  
  
 必须设置<xref:System.Messaging.Message.ConnectorType%2A>属性如果设置了任何以下属性 （否则，队列将忽略这些属性在发送邮件时）：  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.ConnectorType" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置确认、报告和响应消息用以引用原始消息的消息标识符。</summary>
        <value>原始消息的 <see cref="P:System.Messaging.Message.Id" /> 属性指定的消息标识符。 消息队列在生成确认或报告消息时使用相关标识符；而应用程序在生成响应消息时使用相关标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息队列生成确认或报告消息时，它将使用相关标识符属性来指定原始消息的消息标识符。 这样，相关标识符就可将报告或确认消息与原始消息关联起来。  
  
 发送应用程序然后可以进行匹配将确认或报告与原始消息通过使用<xref:System.Messaging.Message.CorrelationId%2A>属性来标识原始消息的<xref:System.Messaging.Message.Id%2A>属性。  
  
 连接器应用程序还必须设置<xref:System.Messaging.Message.CorrelationId%2A>原始消息的消息标识符的确认消息和报告消息的属性。  
  
 当你的应用程序将响应消息发送到发送应用程序时，您可以设置<xref:System.Messaging.Message.CorrelationId%2A>的响应消息写入原始消息的消息标识符的属性。 然后，发送应用程序可以将响应消息与已发送的消息进行匹配。  
  
   
  
## Examples  
 下面的代码示例发送和接收包含订单与队列的消息。 它特别请求肯定确认当原始消息到达或已从队列中检索。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.CorrelationId" /> 属性。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.CorrelationId" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取消息的预期目标队列。</summary>
        <value>
          <see cref="T:System.Messaging.MessageQueue" />，指定消息的预期目标队列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.DestinationQueue%2A>属性通常用于确定到达日志或死信队列的消息的原始目标。 通常情况下，你不必检查此属性，因为通常从其目标队列检索消息。  
  
   
  
## Examples  
 下面的代码示例显示一条消息的值<xref:System.Messaging.Message.DestinationQueue%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
 或  
  
 消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.DestinationQueue" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于对应用程序加密的消息或发送到外部队列的消息进行加密的对称密钥。</summary>
        <value>字节值的数组，指定用于加密消息的目标对称密钥。 默认值为零长度的数组。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 两种方案需要使用<xref:System.Messaging.Message.DestinationSymmetricKey%2A>属性。 第一种是当你应用程序，而不是消息队列，对消息进行加密。 第二个是当将加密的消息发送到以外消息队列的队列系统。  
  
 设置此属性之前，必须对接收队列管理器的公共密钥的对称密钥进行加密。 当你发送应用程序加密的消息时，接收队列管理器使用对称密钥对消息发送到其目标队列之前进行解密。  
  
 如果向外队列发送一条消息，将加密的消息转发到接收应用程序的附加对称密钥与相应的连接器应用程序先接收消息。 然后，它是接收应用程序中，可以对消息使用的对称密钥进行解密的责任。  
  
 当你将设置<xref:System.Messaging.Message.DestinationSymmetricKey%2A>属性，还必须设置<xref:System.Messaging.Message.ConnectorType%2A>属性。 发送消息，消息队列会忽略<xref:System.Messaging.Message.DestinationSymmetricKey%2A>属性如果<xref:System.Messaging.Message.ConnectorType%2A>还未设置属性。  
  
 <xref:System.Messaging.Message.DestinationSymmetricKey%2A>属性具有的最大数组大小为 256。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> 属性。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置消息队列用于验证消息的数字签名。</summary>
        <value>字节值的数组，指定用于对消息进行身份验证的消息队列 1.0 数字签名。 默认值为零长度的数组。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 已发送的消息队列版本 1.0 的消息进行身份验证时，消息队列将使用数字签名。 在大多数情况下，消息队列生成，并设置<xref:System.Messaging.Message.DigitalSignature%2A>发送应用程序请求身份验证时的属性。 接收应用程序使用此属性来检索附加到消息的数字签名。  
  
 你只能使用<xref:System.Messaging.Message.DigitalSignature%2A>属性时运行消息队列 2.0 版。 请求身份验证时，发送应用程序必须指定消息队列 1.0 版签名。 如果发送应用程序发送的消息队列 2.0 版签名，此属性将包含四个字节，每个包含零的缓冲区。  
  
 <xref:System.Messaging.Message.DigitalSignature%2A>一起使用<xref:System.Messaging.Message.SenderCertificate%2A>属性，也使用连接器应用程序发送一条消息时。 在此方案中，连接器应用程序，而不是消息队列-生成的数字签名，它将根据发送消息的用户的证书。  
  
 <xref:System.Messaging.Message.DigitalSignature%2A>属性具有的最大数组大小为 256。  
  
 当你将设置<xref:System.Messaging.Message.DigitalSignature%2A>属性，还必须设置<xref:System.Messaging.Message.ConnectorType%2A>属性。 在发送一条消息，消息队列会忽略<xref:System.Messaging.Message.DigitalSignature%2A>属性如果<xref:System.Messaging.Message.ConnectorType%2A>还未设置属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.DigitalSignature" /> 属性。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.DigitalSignature" /> 属性为 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于加密私有消息体的加密算法。</summary>
        <value>
          <see cref="T:System.Messaging.EncryptionAlgorithm" /> 枚举值之一。 默认值为 <see langword="RC2" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果消息是私有 （加密），则消息前发送和在接收时解密被加密。 <xref:System.Messaging.Message.EncryptionAlgorithm%2A>属性指定用于加密私有消息的消息正文的算法。  
  
 队列可以要求该传入消息进行加密。 如果应用程序的非加密 （非专用） 消息发送到的队列，只接受私有消息，或如果它将私有消息发送到队列，只接受非私有消息，队列将拒绝该消息。 发送应用程序可以请求，这种情况下会返回否定确认消息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.EncryptionAlgorithm" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与消息关联的、应用程序定义的附加信息。</summary>
        <value>字节值的数组，提供与消息关联的、应用程序定义的信息。 默认值为零长度的数组。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Extension%2A>属性提供有关应用程序定义的信息，如与消息关联的大型二进制对象。 它负责接收应用程序可以解释的内容<xref:System.Messaging.Message.Extension%2A>属性。  
  
 如果可能，应包含在消息数据<xref:System.Messaging.Message.Body%2A>消息的属性而不是<xref:System.Messaging.Message.Extension%2A>属性。  
  
 在使用外部队列，使用<xref:System.Messaging.Message.Extension%2A>属性指定在消息队列中不存在的消息属性。  
  
 非 Microsoft 消息队列的队列系统中不存在外队列。 与此类通过连接器应用程序的队列，消息队列进行通信。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.Extension" /> 属性。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.Extension" /> 属性为 <see langword="null" />。</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于将对象序列化到消息体中，或从消息体中反序列化对象的格式化程序。</summary>
        <value>该 <see cref="T:System.Messaging.IMessageFormatter" /> 产生要写入消息体或要从消息体中读取的流。 默认值为 <see cref="T:System.Messaging.XmlMessageFormatter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Messaging.Message.Formatter%2A>属性时读取和写入一条消息。 当消息发送到队列时，序列化格式化程序<xref:System.Messaging.Message.Body%2A>属性转换成可以发送到消息队列的流。 当从队列中读取，格式化程序反序列化到消息数据<xref:System.Messaging.Message.Body%2A>属性。  
  
 除非你将写入消息的内容直接<xref:System.Messaging.Message.BodyStream%2A>属性，设置<xref:System.Messaging.Message.Formatter%2A>属性后，发送消息。 当<xref:System.Messaging.MessageQueue.Send%2A>方法调用<xref:System.Messaging.MessageQueue>实例，正文使用序列化格式化程序中包含<xref:System.Messaging.Message.Formatter%2A>属性。 如果你发送消息时未指定的值<xref:System.Messaging.Message.Formatter%2A>属性，格式化程序默认值为<xref:System.Messaging.XmlMessageFormatter>。  
  
 <xref:System.Messaging.XmlMessageFormatter>松散耦合的因此不需要时使用此格式键入发送方和接收方将相同对象。 <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>数据序列化为二进制表示形式。 <xref:System.Messaging.ActiveXMessageFormatter>发送或接收 COM 组件时使用。  
  
   
  
## Examples  
 下面的代码示例演示了格式设置消息正文使用<xref:System.Messaging.BinaryMessageFormatter>。  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 下面的代码示例演示了格式设置消息正文使用<xref:System.Messaging.XmlMessageFormatter>。  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.Formatter" /> 属性为 <see langword="null" />。</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置消息队列在验证消息或为消息创建数字签名时使用的哈希算法。</summary>
        <value>
          <see cref="T:System.Messaging.HashAlgorithm" /> 枚举值之一。 对于 Windows XP，默认值为 <see langword="SHA" />。 否则，默认为 <see langword="MD5" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在源计算机上消息队列使用的哈希算法时创建一条消息的数字签名。 目标队列管理器然后使用相同的哈希算法时将会收到该消息进行身份验证。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.HashAlgorithm" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取消息的标识符。</summary>
        <value>消息的唯一标识符，由消息队列生成。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 发送消息时，消息队列会生成消息标识符。 标识符由 20 个字节组成，包括两个项： 机<xref:System.Guid>发送计算机和计算机上消息的唯一标识符。 这两项组合在一起，就产生了一个在网络上唯一的消息标识符。  
  
 消息队列会生成的所有消息的消息标识符 — 包括确认消息和报告消息。 确认消息通常由消息队列发送响应的到达或失败的原始、 发送消息。 你可以找到<xref:System.Messaging.Message.Id%2A>属性值中的原始消息<xref:System.Messaging.Message.CorrelationId%2A>的确认消息的属性。  
  
 你还可以使用<xref:System.Messaging.Message.Id%2A>属性时将响应消息发送到响应队列。 若要将响应消息中包含的原始消息的标识符，设置<xref:System.Messaging.Message.CorrelationId%2A>到响应消息的属性<xref:System.Messaging.Message.Id%2A>原始消息的属性。 然后可以在读取响应消息的应用程序中使用响应消息的相关标识符来标识原始消息。  
  
   
  
## Examples  
 下面的代码示例发送和接收一条包含订单到和从队列消息。 它特别请求肯定确认当原始消息到达或已从队列中检索。  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
 或  
  
 消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.Id" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定不存在超时。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> 和<xref:System.Messaging.Message.TimeToReachQueue%2A>需要一个值，指定超时。对于前者，超时是允许从队列接收消息的最长时间。 对于后者，该超时是消息到达队列所允许的时间。 在这两种情况下，你可以作为的秒数指定的超时或使用<xref:System.Messaging.Message.InfiniteTimeout>，指示无超时存在。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Messaging.Message.InfiniteTimeout>字段。  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示消息是否是事务中发送的第一条消息。</summary>
        <value>
          如果消息是事务中发送的第一条消息，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收应用程序使用<xref:System.Messaging.Message.IsFirstInTransaction%2A>属性以验证消息已发送到单个队列单个事务中的第一个消息。  
  
 此属性是仅适用于消息队列版本 2.0 及更高版本。  
  
 若要验证事务边界，你可以使用<xref:System.Messaging.Message.IsFirstInTransaction%2A>属性以及其他两个属性：<xref:System.Messaging.Message.IsLastInTransaction%2A>和<xref:System.Messaging.Message.TransactionId%2A>。 前者用于检查消息是否已在该事务中发送的最后一条消息，并使用后者来检索事务的标识符。  
  
 如果只在事务中，发送一条消息<xref:System.Messaging.Message.IsFirstInTransaction%2A>和<xref:System.Messaging.Message.IsLastInTransaction%2A>属性都设置为`true`。  
  
   
  
## Examples  
 下面的代码示例显示一条消息的值<xref:System.Messaging.Message.IsFirstInTransaction%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
 或  
  
 消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.IsFirstInTransaction" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示消息是否是事务中发送的最后一条消息。</summary>
        <value>
          如果消息是单个事务中发送的最后一条消息，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收应用程序使用<xref:System.Messaging.Message.IsLastInTransaction%2A>属性以验证消息已发送到单个队列单个事务中的最后一条消息。  
  
 此属性是仅适用于消息队列版本 2.0 及更高版本。  
  
 若要验证事务边界，你可以使用<xref:System.Messaging.Message.IsLastInTransaction%2A>属性以及其他两个属性：<xref:System.Messaging.Message.IsFirstInTransaction%2A>和<xref:System.Messaging.Message.TransactionId%2A>。 前者用于检查消息是否已在该事务中发送的第一个消息，并使用后者来检索事务的标识符。  
  
 如果只在事务中，发送一条消息<xref:System.Messaging.Message.IsFirstInTransaction%2A>和<xref:System.Messaging.Message.IsLastInTransaction%2A>属性都设置为`true`。  
  
   
  
## Examples  
 下面的代码示例显示一条消息的值<xref:System.Messaging.Message.IsLastInTransaction%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
 或  
  
 消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.IsLastInTransaction" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置描述消息的应用程序定义的 Unicode 字符串。</summary>
        <value>消息的标签。 默认值为空字符串("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息标签有多种用途。 例如，可用于显示消息，或根据标签值有选择地处理消息。 标签不必是唯一的消息范围内。  
  
 消息队列和消息标签表示一个应用程序定义的值，可利用该值将标识队列或消息用人可识别的词条标识出来。 它负责解释标签的内容，其中没有任何实质意义到消息队列应用程序的应用程序。  
  
   
  
## Examples  
 下面的代码示例获取和设置的消息的值<xref:System.Messaging.Message.Label%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.Label" /> 属性。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 MSMQ 3.0 中引入。 获取消息的查找标识符。</summary>
        <value>消息的查找标识符，由消息队列生成，对消息驻留的队列是唯一的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.LookupId%2A>属性提供对消息的查找标识符的只读访问。 在 MSMQ 3.0 中引入的查找标识符是一个 64 位标识符，由消息队列生成并将其分配到每条消息时该消息会放在队列中。 查找标识符不是发送消息时生成的消息标识符相同。  
  
 消息队列会生成连接器和传出队列都将置于任何队列，包括应用程序生成的目标、 管理和报告队列，以及系统生成的日记、 死信的所有消息的查找标识符。 换而言之，这包括这两个发送由发送应用程序和由消息队列的消息。 查找标识符是唯一的队列，并且队列外部没有意义。  
  
 如果消息发送到多个目标队列，或如果消息的副本存储在计算机日志或队列日志，位于其各自的队列中时，该消息的每个副本将具有其自己的查找标识符。  
  
 <xref:System.Messaging.Message.LookupId%2A>属性仅可读消息从队列中检索。  
  
 查找标识符用于读取队列中的特定邮件。 接收应用程序后已知的一条消息的查找标识符，可以调用<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>或<xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>函数直接转到该消息和扫视或检索从队列中，与不同的是必须从队列开头处的游标和队列末尾导航  
  
 获取队列中消息的查找标识符负责应用程序。 若要获取的查找标识符的一种是创建缓存的每条消息的标识符，因为它们放置在队列中的组件时，将调用的目标队列的触发器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">未安装 MSMQ 3.0。</exception>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
 或  
  
 消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.LookupId" /> 属性。</exception>
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取消息类型：<see langword="Normal" />、<see langword="Acknowledgment" /> 或 <see langword="Report" />。</summary>
        <value>
          <see cref="P:System.Messaging.Message.MessageType" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息队列发送消息时，通常设置此属性。 消息队列消息可以是下列类型之一：  
  
-   `Normal`这典型消息从应用程序发送到队列，或响应消息返回到发送应用程序。  
  
-   `Acknowledgement`发送应用程序请求一个时，消息队列生成的。 例如，消息队列可生成肯定消息或否定消息，以指示原始消息已到达或已被读取。 消息队列会将相应的确认消息返回到发送应用程序所指定的管理队列。  
  
-   `Report`只要源队列管理器中定义报告队列消息队列生成的。 如果启用了跟踪，则每当原始消息进入或离开消息队列服务器时，消息队列都会向消息队列报告队列发送报告消息。  
  
   
  
## Examples  
 下面的代码示例显示一条消息的值<xref:System.Messaging.Message.MessageType%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
 或  
  
 消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.MessageType" /> 属性。</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置消息优先级，该优先级用于确定消息在队列中的位置。</summary>
        <value>
          <see cref="T:System.Messaging.MessagePriority" /> 值之一，表示非事务性消息的优先级。 默认值为 <see langword="Normal" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Priority%2A>属性会影响消息队列处理消息的方式这两个路由时，一旦它到达其目的地。 在路由过程中，优先级高的消息具有优先权，将会插入到目标队列的队首。 而具有相同优先级的消息则会按照到达的先后时间插入到队列中。  
  
 你可以设置非事务性消息才有意义的优先级。 消息队列将自动设置到的事务性消息的优先级`Lowest`，这将导致产生事务性消息优先级被忽略。  
  
   
  
## Examples  
 下面的代码示例将两个不同的优先级别的消息发送到队列，并随后检索它们。  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.Priority" /> 属性。</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示在出现计算机故障或网络问题时是否保证传递消息。</summary>
        <value>
          如果通过在消息传递过程中将消息保存到磁盘上来保证消息的传递，则为 <see langword="true" />；如果不能保证传递，则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Recoverable%2A>属性指示是否保证消息的传递 — 即使消息启用路由到目标队列的过程中出现计算机故障。  
  
 如果保证消息的传递，消息是本地存储在路由过程中，每个步骤直到消息成功转发到下一台计算机。 设置<xref:System.Messaging.Message.Recoverable%2A>属性`true`可能会影响吞吐量。  
  
 如果消息是事务性的消息队列会自动将消息视为可恢复，而不考虑的值<xref:System.Messaging.Message.Recoverable%2A>属性。  
  
   
  
## Examples  
 下面的代码示例获取和设置的消息的值<xref:System.Messaging.Message.Recoverable%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.Recoverable" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置接收应用程序生成的响应消息的队列。</summary>
        <value>应用程序生成的响应消息所返回到的 <see cref="T:System.Messaging.MessageQueue" />。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.ResponseQueue%2A>属性标识接收应用程序生成的响应消息，接收应用程序返回到发送应用程序的队列。 当应用程序发送其消息时，发送应用程序会指定响应队列。 任何可用队列均可指定为响应队列。  
  
 返回到响应队列的消息是应用程序特定的。 应用程序必须定义消息的内容以及收到消息时采取的操作。  
  
   
  
## Examples  
 下面的代码示例获取和设置的消息的值<xref:System.Messaging.Message.ResponseQueue%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.ResponseQueue" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置消息的安全上下文。</summary>
        <value>如果以前曾经设置该属性，则为 <see cref="T:System.Messaging.SecurityContext" /> 对象，其中包含用于消息的安全上下文；否则为 NULL。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于验证消息的安全证书。</summary>
        <value>表示安全证书的字节值数组，消息队列用该数组验证消息的发送方。 默认值为零长度的数组。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收应用程序使用<xref:System.Messaging.Message.SenderCertificate%2A>属性时该消息包含的外部安全证书。  
  
 消息队列可以进行身份验证使用一条消息的内部或外部的安全证书。 消息队列提供了内部证书，用来验证消息的完整性。 证书颁发机构提供的外部证书，这可以通过访问<xref:System.Messaging.Message.SenderCertificate%2A>消息的属性。 除了允许消息队列进行身份验证消息的外部证书允许接收应用程序中，可以进一步验证发件人。 内部证书的接收应用程序没有可用值。  
  
 必须与目录服务的消息队列系统注册的外部证书。 外部证书包含证书颁发机构、 证书用户、 证书的有效期，证书用户和证书颁发机构签名的公钥有关的信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.SenderCertificate" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取发送用户的标识符。</summary>
        <value>标识发送方的字节值数组。 接收队列管理器在对消息进行身份验证时使用标识符 — 以验证消息的发送方和发送方对队列的访问权限。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Messaging.Message.AttachSenderId%2A>属性是`false`中, 指定的发件人标识符<xref:System.Messaging.Message.SenderId%2A>属性未附加到消息，发送时。 这指示消息队列将消息发送到目标队列时，应不验证发件人。 如果<xref:System.Messaging.Message.AttachSenderId%2A>属性是`true`、<xref:System.Messaging.Message.SenderId%2A>属性值是可信仅当消息已验证。 使用<xref:System.Messaging.Message.Authenticated%2A>属性与结合<xref:System.Messaging.Message.SenderId%2A>属性以验证发件人的访问权限。  
  
 连接器应用程序是使用连接器服务器来提供消息队列和其他队列系统之间的通信的应用程序。 消息队列要求连接器应用程序提供发送方标识。 必须设置<xref:System.Messaging.Message.ConnectorType%2A>时通过连接器应用程序发送消息的属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
 或  
  
 消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.SenderId" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于发送消息的消息队列版本。</summary>
        <value>用于发送消息的消息队列版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderVersion%2A>属性是针对的某些功能非常重要。 例如，只能由 Message Queuing 2.0 及更高版本，才支持事务处理和使用数字签名进行身份验证发送 MSMQ 1.0 的消息。  
  
 发送队列管理器设置<xref:System.Messaging.Message.SenderVersion%2A>发送消息的属性。  
  
   
  
## Examples  
 下面的代码示例显示一条消息的值<xref:System.Messaging.Message.SenderVersion%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
 或  
  
 消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.SenderVersion" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取发送计算机上的源队列管理器发送消息的日期和时间。</summary>
        <value>表示消息发送时间的 <see cref="T:System.DateTime" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SentTime%2A>属性将会调整为此计算机的本地时间实例<xref:System.Messaging.Message>创建类。 此时区可能不同于源和目标队列。  
  
   
  
## Examples  
 下面的代码示例显示一条消息的值<xref:System.Messaging.Message.SentTime%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
 或  
  
 消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.SentTime" /> 属性。</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取发出消息的计算机。</summary>
        <value>发送消息的计算机的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 格式<xref:System.Messaging.Message.SourceMachine%2A>属性不包括前面两个正斜杠 (\\\\)。 例如，`myServer`是一个有效<xref:System.Messaging.Message.SourceMachine%2A>。  
  
   
  
## Examples  
 下面的代码示例显示一条消息的值<xref:System.Messaging.Message.SourceMachine%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
 或  
  
 消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.SourceMachine" /> 属性。</exception>
        <exception cref="T:System.Messaging.MessageQueueException">未能访问计算机信息和目录服务。</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要从目标队列接收消息所需的最长时间。</summary>
        <value>从目标队列接收已发送消息所需的总时间。 默认值为 <see cref="F:System.Messaging.Message.InfiniteTimeout" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A>属性指定发送的消息从目标队列接收的总时间。 时间限制包括到达目标队列和所用之前接收到消息队列中等待的时间所用的时间。  
  
> [!CAUTION]
>  在使用从属客户端计算机，请确保客户端计算机上的时钟与正在运行消息队列服务器上的时钟同步。 否则，可能会导致不可预知的行为，发送消息时其<xref:System.Messaging.Message.TimeToBeReceived%2A>属性不是<xref:System.Messaging.Message.InfiniteTimeout>。  
  
 如果指定的间隔<xref:System.Messaging.Message.TimeToBeReceived%2A>属性过期之前从队列中删除消息，消息队列将放弃两种方式之一中的消息。 如果消息的 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 属性为 `true`，则将该消息发送到死信队列。 如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`false`，则忽略此消息。  
  
 你可以设置消息的<xref:System.Messaging.Message.AcknowledgeType%2A>属性来请求，消息队列将否定确认消息发送回发送应用程序如果计时器过期之前未检索到的消息。  
  
 如果指定的值<xref:System.Messaging.Message.TimeToBeReceived%2A>属性小于指定的值<xref:System.Messaging.Message.TimeToReachQueue%2A>属性，<xref:System.Messaging.Message.TimeToBeReceived%2A>优先。  
  
 在单个事务中发送多条消息，消息队列使用<xref:System.Messaging.Message.TimeToBeReceived%2A>的第一条消息的属性。  
  
   
  
## Examples  
 下面的代码示例获取和设置的消息的值<xref:System.Messaging.Message.TimeToBeReceived%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.TimeToBeReceived" /> 属性。</exception>
        <exception cref="T:System.ArgumentException">为 <see cref="P:System.Messaging.Message.TimeToBeReceived" /> 指定的值无效。</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置消息到达队列所用的最长时间。</summary>
        <value>从发送消息的时间开始算起，消息到达目标队列的时间限制。 默认值为 <see cref="F:System.Messaging.Message.InfiniteTimeout" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定的间隔<xref:System.Messaging.Message.TimeToReachQueue%2A>属性期满在消息到达其目标之前，消息队列将放弃两种方式之一中的消息。 如果消息的 <xref:System.Messaging.Message.UseDeadLetterQueue%2A> 属性为 `true`，则将该消息发送到死信队列。 如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`false`，则忽略此消息  
  
 你可以设置他消息<xref:System.Messaging.Message.AcknowledgeType%2A>属性来请求，消息队列将否定确认消息发送回发送应用程序如果消息没有到达之前在计时器过期。  
  
 如果<xref:System.Messaging.Message.TimeToReachQueue%2A>属性设置为 0 秒，消息队列一次尝试将消息发送到其目标 — 如果队列等待消息。 如果本地队列，消息总是到达它。  
  
 如果指定的值<xref:System.Messaging.Message.TimeToReachQueue%2A>属性大于指定的值<xref:System.Messaging.Message.TimeToBeReceived%2A>属性，<xref:System.Messaging.Message.TimeToBeReceived%2A>优先。  
  
 在单个事务中发送多条消息，消息队列使用<xref:System.Messaging.Message.TimeToReachQueue%2A>的第一条消息的属性。  
  
   
  
## Examples  
 下面的代码示例获取和设置的消息的值<xref:System.Messaging.Message.TimeToReachQueue%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.TimeToReachQueue" /> 属性。</exception>
        <exception cref="T:System.ArgumentException">为 <see cref="P:System.Messaging.Message.TimeToReachQueue" /> 指定的值无效。 它可能表示负数。</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取曾包含消息的事务的标识符。</summary>
        <value>与消息关联的事务的标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接收应用程序使用<xref:System.Messaging.Message.TransactionId%2A>属性以验证消息已发送特定事务的一部分。 事务的事务标识符包含的标识符的 4 字节事务序列号后跟发送计算机 （第一个 16 位）。  
  
 此属性是仅适用于消息队列版本 2.0 及更高版本。  
  
 不保证事务标识符都是唯一的因为事务序列号不是永久性的而且它们处重新开始 2 <sup>20</sup>。 消息队列仅保证，后续的事务将具有不同的事务序列号。  
  
 你可以使用<xref:System.Messaging.Message.TransactionId%2A>属性连同<xref:System.Messaging.Message.IsFirstInTransaction%2A>和<xref:System.Messaging.Message.IsLastInTransaction%2A>若要验证事务边界的属性。  
  
   
  
## Examples  
 下面的代码示例显示一条消息的值<xref:System.Messaging.Message.TransactionId%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
 或  
  
 消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.TransactionId" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取源计算机中的事务状态队列。</summary>
        <value>源计算机中的事务状态队列，用于将确认消息发回发送应用程序。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TransactionStatusQueue%2A>属性标识阅读回执确认收到连接器应用程序的源计算机上的事务性队列。 消息队列设置的属性，并检索事务性消息发送到外部队列时，连接器应用程序将使用属性。  
  
 非 Microsoft 消息队列的队列系统中不存在外队列。 与此类通过连接器应用程序的队列，消息队列进行通信。  
  
 连接器应用程序可以使用的事务状态队列发送确认消息返回到发送应用程序。 即使发送应用程序不会请求其他确认的事务状态队列应接收这些确认。  
  
   
  
## Examples  
 下面的代码示例显示一条消息的值<xref:System.Messaging.Message.TransactionStatusQueue%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息尚未发送。 该属性只能在从队列中检索的消息上读取。  
  
 或  
  
 消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.TransactionStatusQueue" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示消息发送前是否验证了（或是否必须验证）。</summary>
        <value>
          如果发送应用程序请求对消息进行验证，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseAuthentication%2A>属性指定是否需要进行身份验证消息。 如果发送应用程序请求身份验证，消息队列创建数字签名，并使用它来发送时对消息进行签名和时将会收到该消息进行身份验证。  
  
 如果<xref:System.Messaging.Message.UseAuthentication%2A>是`false`和一条消息发送到的队列，只接受经过身份验证的消息，在到达队列时，将被拒绝消息。  
  
 无法确定消息是否未通过查看其属性通过身份验证。 它们传递到队列之前，消息队列将放弃此类消息。 但是，你可以请求如果传送失败可以阻止一条消息到达队列中发送确认消息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.UseAuthentication" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否将未能传递的消息的副本发送到死信队列。</summary>
        <value>
          如果消息传递失败应导致向死信队列发送消息的副本，则为 <see langword="true" />，否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseJournalQueue%2A>和<xref:System.Messaging.Message.UseDeadLetterQueue%2A>属性指定消息队列如何跟踪消息。 如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`true`，（的非事务性消息） 的传递失败将导致消息发送到无法传递消息的计算机上的非事务性死信队列。 传送失败可能引起消息计时器过期时，例如。  
  
 对于事务性消息的传送失败，消息队列为事务性死信队列中所有负数，有疑问的情况下在源计算机上发送消息。  
  
 当你将消息存储在死信队列时，则应该清除定期要删除不再需要的消息的队列。 存储在死信队列计数针对队列所驻留的计算机的大小配额的消息。 计算机配额由管理员设置，并分配用于存储消息的整个计算机上，而不仅仅是在单个队列的大小是指。  
  
 不要创建日志或死信队列。 这些是消息队列生成两个系统队列。  
  
   
  
## Examples  
 下面的代码示例获取和设置的消息的值<xref:System.Messaging.Message.UseDeadLetterQueue%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.UseDeadLetterQueue" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否使消息成为私有的。</summary>
        <value>
          要求消息队列加密消息时为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果消息是私有的其正文已加密之前发送和接收时解密。 若要发送私有消息，发送应用程序必须指定要使用加密和 （可选） 的加密算法。  
  
 发送私有消息时，则不需要执行的消息加密你的应用程序。 如果你的应用程序正在发送中的 Microsoft Windows 2000 企业中，该组可以对目录服务的访问的消息，消息队列可以为你加密消息正文。 在接收时私有消息，接收队列管理器将始终解密消息正文。  
  
   
  
## Examples  
 下面的代码示例获取和设置的消息的值<xref:System.Messaging.Message.UseEncryption%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.UseEncryption" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否在始发计算机的计算机日记中保留消息的副本。</summary>
        <value>
          在成功地将消息从始发计算机传输到下一个服务器后，要求在始发计算机的计算机日记中保留消息副本时为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseJournalQueue%2A>和<xref:System.Messaging.Message.UseDeadLetterQueue%2A>属性指定消息队列如何跟踪消息。 如果<xref:System.Messaging.Message.UseJournalQueue%2A>是`true`，然后在传输消息的每个步骤处的源计算机上的计算机日志保留副本。  
  
 目标队列是否在远程计算机上，发送的消息是仅复制到日记队列中。 如果目标为本地计算机上，该消息被直接发送到队列，则为没有中间步骤需要日记记录。  
  
 当将消息存储在日记队列中时，清除定期要删除不再需要的消息的队列。 针对队列所驻留的计算机的配额的日记队列计数中存储的消息。 （计算机配额设置管理员。）  
  
 不要创建日志或死信队列。 这些是消息队列生成两个系统队列。  
  
   
  
## Examples  
 下面的代码示例获取和设置的消息的值<xref:System.Messaging.Message.UseJournalQueue%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.UseJournalQueue" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否在消息向目标队列移动的过程中跟踪消息。</summary>
        <value>
          如果在发往目标队列的过程中，由原始消息产生的每个中间步骤都生成发送给系统报告队列的报告，则为 <see langword="true" />，否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseTracing%2A>属性指定是否向其目标队列移动跟踪消息的路由。 如果`true`，（由消息队列生成） 报告消息发送到报告队列每次该消息通过消息队列的路由服务器。 源队列管理器指定的报告队列。 报告队列并不局限于由消息队列; 生成的报告消息你应用程序生成的消息也可以发送到报告队列。  
  
 使用跟踪包括设置 Active Directory 和指定报表队列的消息队列企业。 管理员配置这些设置。  
  
   
  
## Examples  
 下面的代码示例获取和设置的消息的值<xref:System.Messaging.Message.UseTracing%2A>属性。  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">消息队列经过筛选后忽略了 <see cref="P:System.Messaging.Message.UseTracing" /> 属性。</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>