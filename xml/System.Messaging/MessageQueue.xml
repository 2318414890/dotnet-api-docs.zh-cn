<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MessageQueue.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-81070f4" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9d63614a-fd48-4a83-9dc4-ea1e401b6c15f362dd97709b65574ff7b9474682818d0cb2c4b1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f362dd97709b65574ff7b9474682818d0cb2c4b1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4b4804968da1dfdf71c501075a5b66957b54f2e8</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/27/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Provides access to a queue on a Message Queuing server.</source>
          <target state="translated">提供对“消息队列”服务器上的队列的访问。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>The Message Queuing technology allows applications running at different times to communicate across heterogeneous networks and systems that might be temporarily offline.</source>
          <target state="translated">消息队列技术就允许在不同时间运行的应用程序能够跨异构网络和可能是暂时处于脱机状态的系统进行通信。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>Applications send, receive, or peek (read without removing) messages from queues.</source>
          <target state="translated">应用程序发送、 接收或查看从队列中的 （而不删除读取） 消息。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>Message Queuing is an optional component of <ph id="ph1">[!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)]</ph> and Windows NT, and must be installed separately.</source>
          <target state="translated">消息队列是一个可选组件的<ph id="ph1">[!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)]</ph>和 Windows NT 中，并且必须单独安装。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class is a wrapper around Message Queuing.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>类是消息队列周围的包装器。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>There are multiple versions of Message Queuing, and using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class can result in slightly different behavior, depending on the operating system you are using.</source>
          <target state="translated">有多个版本的消息队列，以及使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>类可能会导致略有不同的行为，具体取决于操作系统使用。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>For information about specific features of each version of Message Queuing, see the topic "What's New in Message Queuing" in the Platform SDK in MSDN.</source>
          <target state="translated">有关特定功能的每个版本的消息队列的信息，请参阅 MSDN 中的平台 SDK 中的"什么是消息队列中的新增功能"主题。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class provides a reference to a Message Queuing queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>类提供对消息队列的队列的引用。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>You can specify a path in the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.%23ctor%2A&gt;</ph> constructor to connect to an existing resource, or you can create a new queue on the server.</source>
          <target state="translated">你可以指定在路径<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.%23ctor%2A&gt;</ph>构造函数，以连接到现有资源，或者让你可以在服务器上创建一个新队列。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>Before you can call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>, you must associate the new instance of the <ph id="ph4">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class with an existing queue.</source>
          <target state="translated">在可以调用之前<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph>， <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>，或<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>，必须将关联的新实例<ph id="ph4">&lt;xref:System.Messaging.MessageQueue&gt;</ph>与某个现有队列的类。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>At that point, you can manipulate the queue properties such as <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>.</source>
          <target state="translated">此时，如操作队列属性<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> supports two types of message retrieval: synchronous and asynchronous.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> 支持两种类型的消息检索： 同步和异步。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>The synchronous methods, <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>, cause the process thread to wait a specified time interval for a new message to arrive in the queue.</source>
          <target state="translated">同步方法，<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>，会导致进程线程等待新消息到达队列中指定的时间间隔。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>The asynchronous methods, <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>, allow the main application tasks to continue in a separate thread until a message arrives in the queue.</source>
          <target state="translated">异步方法，<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>，允许以继续在一个单独的线程，直到消息到达队列中的主应用程序任务。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>These methods work by using callback objects and state objects to communicate information between threads.</source>
          <target state="translated">这些方法通过使用回调对象和状态对象将在线程之间的信息进行工作。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>When you create a new instance of the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class, you are not creating a new Message Queuing queue.</source>
          <target state="translated">当你创建的新实例<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>类，不在创建一个新的消息队列队列。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>Instead, you can use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Create%28System.String%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Delete%28System.String%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.Purge%2A&gt;</ph> methods to manage queues on the server.</source>
          <target state="translated">相反，你可以使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Create%28System.String%29&gt;</ph>， <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Delete%28System.String%29&gt;</ph>，和<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.Purge%2A&gt;</ph>方法来管理服务器上的队列。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>Unlike <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Purge%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Create%28System.String%29&gt;</ph> and <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.Delete%28System.String%29&gt;</ph> are <ph id="ph4">`static`</ph> members, so you can call them without creating a new instance of the <ph id="ph5">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class.</source>
          <target state="translated">与不同<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Purge%2A&gt;</ph>，<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Create%28System.String%29&gt;</ph>和<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.Delete%28System.String%29&gt;</ph>是<ph id="ph4">`static`</ph>成员，因此您可以调用它们而无需创建的新实例<ph id="ph5">&lt;xref:System.Messaging.MessageQueue&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>You can set the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> object's <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> property with one of three names: the friendly name, the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph>, or the <ph id="ph4">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>.</source>
          <target state="translated">你可以设置<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>对象的<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>具有三个名称之一属性： 的友好名称， <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph>，或<ph id="ph4">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>The friendly name, which is defined by the queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph> properties, is <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph><ph id="ph4">\\</ph><ph id="ph5">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph> for a public queue, and <ph id="ph6">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph><ph id="ph7">\\</ph><ph id="ph8">`Private$`</ph><ph id="ph9">\\</ph><ph id="ph10">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph> for a private queue.</source>
          <target state="translated">友好名称，由队列的定义<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph>属性，是<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph> <ph id="ph4">\\</ph> <ph id="ph5">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph>公共队列和<ph id="ph6">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph> <ph id="ph7">\\</ph> <ph id="ph8">`Private$`</ph> <ph id="ph9">\\</ph> <ph id="ph10">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph>专用队列的。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph> property allows offline access to message queues.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph>属性允许脱机访问消息队列。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>Lastly, you can use the queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph> property to set the queue's <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>.</source>
          <target state="translated">最后，你可以使用队列的<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>属性来设置队列的<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>For a list of initial property values for an instance of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>, see the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">有关的实例的初始属性值的列表<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>，请参阅<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.%23ctor%2A&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>The following code example creates new <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> objects using various path name syntax types.</source>
          <target state="translated">下面的代码示例创建新<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>对象使用各种路径名称语法类型。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>In each case, it sends a message to the queue whose path is defined in the constructor.</source>
          <target state="translated">在每个情况下，它将消息发送到其路径定义构造函数中的队列。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>The following code example sends a message to a queue, and receives a message from a queue, using an application-specific class called <ph id="ph1">`Order`</ph>.</source>
          <target state="translated">下面的代码示例向队列发送消息和接收来自队列，使用名为的应用程序特定类的消息<ph id="ph1">`Order`</ph>。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>Only the <ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.GetAllMessages" /&gt;</ph> method is thread safe.</source>
          <target state="translated">仅<ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.GetAllMessages" /&gt;</ph>是线程安全的方法。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor">
          <source>After the default constructor initializes the new instance, you must set the instance's <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> property before you can use the instance.</source>
          <target state="translated">默认构造函数初始化新实例后，必须设置该实例的 <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> 属性才能使用该实例。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor">
          <source>Use this overload to create a new instance of the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class that is not immediately tied to a queue on the Message Queuing server.</source>
          <target state="translated">使用此重载来创建的新实例<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>不立即绑定到消息队列服务器上的队列的类。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor">
          <source>Before using this instance, you must connect it to an existing Message Queuing queue by setting the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> property.</source>
          <target state="translated">使用此实例前，你必须将其连接到现有消息队列队列通过设置<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor">
          <source>Alternatively, you can set the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> reference to the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Create%28System.String%29&gt;</ph> method's return value, thereby creating a new Message Queuing queue.</source>
          <target state="translated">或者，您可以设置<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>引用<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Create%28System.String%29&gt;</ph>方法的返回值，从而创建一个新的消息队列队列。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.%23ctor%2A&gt;</ph> constructor instantiates a new instance of the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class; it does not create a new Message Queuing queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.%23ctor%2A&gt;</ph>构造函数实例化的新实例<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>类; 它不会创建一个新的消息队列队列。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor">
          <source>The following table shows initial property values for an instance of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>.</source>
          <target state="translated">下表显示的实例的初始属性值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor">
          <source>Property</source>
          <target state="translated">Property</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor">
          <source>Initial value</source>
          <target state="translated">初始值</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor">
          <source>The values set by the default constructor of the <ph id="ph1">&lt;xref:System.Messaging.DefaultPropertiesToSend&gt;</ph> class.</source>
          <target state="translated">设置的默认构造函数的值<ph id="ph1">&lt;xref:System.Messaging.DefaultPropertiesToSend&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor">
          <source>The values set by the default constructor of the <ph id="ph1">&lt;xref:System.Messaging.MessagePropertyFilter&gt;</ph> class.</source>
          <target state="translated">设置的默认构造函数的值<ph id="ph1">&lt;xref:System.Messaging.MessagePropertyFilter&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor">
          <source>All the filter values are set to <ph id="ph1">`true`</ph>.</source>
          <target state="translated">所有的筛选器值设置为<ph id="ph1">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor">
          <source>The following code example creates a new <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>.</source>
          <target state="translated">下面的代码示例创建一个新<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>The location of the queue referenced by this <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>.</source>
          <target state="translated">此 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 引用的队列的位置。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> class that references the Message Queuing queue at the specified path.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 类的新实例，该实例引用指定路径处的“消息队列”队列。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Use this overload when you want to tie the new <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> instance to a particular Message Queuing queue, for which you know the path, format name, or label.</source>
          <target state="translated">当你想要将新使用此重载<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>到特定消息队列的队列，并为其知道路径、 格式名或标签的实例。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>If you want to grant exclusive access to the first application that references the queue, you must set the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DenySharedReceive%2A&gt;</ph> property to <ph id="ph2">`true`</ph> or use the constructor that passes a read-access restriction parameter.</source>
          <target state="translated">如果你想要授予对第一个应用程序独占访问权引用队列，则必须设置<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DenySharedReceive%2A&gt;</ph>属性<ph id="ph2">`true`</ph>或使用传递的读取访问权限限制参数的构造函数。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.%23ctor%2A&gt;</ph> constructor instantiates a new instance of the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class; it does not create a new Message Queuing queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.%23ctor%2A&gt;</ph>构造函数实例化的新实例<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>类; 它不会创建一个新的消息队列队列。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>To create a new queue in Message Queuing, use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Create%28System.String%29&gt;</ph>.</source>
          <target state="translated">若要在消息队列中创建新队列，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Create%28System.String%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>The syntax of the <ph id="ph1">`path`</ph> parameter depends on the type of queue it references, as shown in the following table.</source>
          <target state="translated">语法<ph id="ph1">`path`</ph>参数取决于队列的类型它的引用下, 表中所示。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Queue type</source>
          <target state="translated">队列类型</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Syntax</source>
          <target state="translated">语法</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Public queue</source>
          <target state="translated">公用队列</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Private queue</source>
          <target state="translated">专用队列</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Journal queue</source>
          <target state="translated">日记队列</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Machine journal queue</source>
          <target state="translated">计算机日记队列</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Machine dead-letter queue</source>
          <target state="translated">机死信队列</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Machine transactional dead-letter queue</source>
          <target state="translated">计算机事务性死信队列</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph> to describe the queue path, as shown in the following table.</source>
          <target state="translated">或者，可以使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>来描述队列路径中下, 表中所示。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Reference</source>
          <target state="translated">参考</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Syntax</source>
          <target state="translated">语法</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Example</source>
          <target state="translated">示例</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Format name</source>
          <target state="translated">格式名称</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source><ph id="ph1">`FormatName:`</ph> [ <bpt id="p1">*</bpt>format name<ept id="p1">*</ept> ]</source>
          <target state="translated"><ph id="ph1">`FormatName:`</ph> [<bpt id="p1">*</bpt>格式名<ept id="p1">*</ept>]</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source><ph id="ph1">`FormatName:Public=`</ph> 5A5F7535-AE9A-41d4-935C-845C2AFF7112</source>
          <target state="translated"><ph id="ph1">`FormatName:Public=`</ph> 5A5F7535-AE9A-41d4-935C-845C2AFF7112</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source><ph id="ph1">`FormatName:DIRECT=SPX:`</ph> <ph id="ph2">`NetworkNumber`</ph>; <ph id="ph3">`HostNumber`</ph><ph id="ph4">\\</ph><ph id="ph5">`QueueName`</ph></source>
          <target state="translated"><ph id="ph1">`FormatName:DIRECT=SPX:`</ph> <ph id="ph2">`NetworkNumber`</ph>; <ph id="ph3">`HostNumber`</ph><ph id="ph4">\\</ph><ph id="ph5">`QueueName`</ph></target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source><ph id="ph1">`FormatName:DIRECT=TCP:`</ph> <ph id="ph2">`IPAddress`</ph><ph id="ph3">\\</ph><ph id="ph4">`QueueName`</ph></source>
          <target state="translated"><ph id="ph1">`FormatName:DIRECT=TCP:`</ph> <ph id="ph2">`IPAddress`</ph><ph id="ph3">\\</ph><ph id="ph4">`QueueName`</ph></target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source><ph id="ph1">`FormatName:DIRECT=OS:`</ph> <ph id="ph2">`MachineName`</ph><ph id="ph3">\\</ph><ph id="ph4">`QueueName`</ph></source>
          <target state="translated"><ph id="ph1">`FormatName:DIRECT=OS:`</ph> <ph id="ph2">`MachineName`</ph><ph id="ph3">\\</ph><ph id="ph4">`QueueName`</ph></target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Label</source>
          <target state="translated">Label</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source><ph id="ph1">`Label:`</ph> [ <bpt id="p1">*</bpt>label<ept id="p1">*</ept> ]</source>
          <target state="translated"><ph id="ph1">`Label:`</ph> [<bpt id="p1">*</bpt>标签<ept id="p1">*</ept>]</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source><ph id="ph1">`Label:`</ph> TheLabel</source>
          <target state="translated"><ph id="ph1">`Label:`</ph> 标签</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>To work offline, you must use the format name syntax, not the path name syntax for the constructor.</source>
          <target state="translated">若要在脱机工作，必须使用的格式名称语法，而不是路径名称语法构造函数。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Otherwise, an exception is thrown because the primary domain controller is not available to resolve the path to the format name.</source>
          <target state="translated">否则，因为该域的主域控制器不可用来为格式名称解析路径，则会引发异常。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>The following table shows initial property values for an instance of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>.</source>
          <target state="translated">下表显示的实例的初始属性值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>These values are based on the properties of the Message Queuing queue with the path specified by the <ph id="ph1">`path`</ph> parameter.</source>
          <target state="translated">这些值基于消息队列队列的属性与指定的路径<ph id="ph1">`path`</ph>参数。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Property</source>
          <target state="translated">Property</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>Initial value</source>
          <target state="translated">初始值</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>The values set by the default constructor of the <ph id="ph1">&lt;xref:System.Messaging.DefaultPropertiesToSend&gt;</ph> class.</source>
          <target state="translated">设置的默认构造函数的值<ph id="ph1">&lt;xref:System.Messaging.DefaultPropertiesToSend&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source><ph id="ph1">`true`</ph>, if the Message Queuing queue's privacy level setting is "Body"; otherwise, <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`true`</ph>如果消息队列队列的隐私级别设置为"正文";否则为<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>The value of the Message Queuing queue's computer name property.</source>
          <target state="translated">消息队列队列的计算机名称属性的值。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>The values set by the default constructor of the <ph id="ph1">&lt;xref:System.Messaging.MessagePropertyFilter&gt;</ph> class.</source>
          <target state="translated">设置的默认构造函数的值<ph id="ph1">&lt;xref:System.Messaging.MessagePropertyFilter&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>, if not set by the constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>如果未设置由构造函数。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>, if not set by the constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>如果未设置由构造函数。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source><ph id="ph1">`true`</ph>, if the Message Queuing object's journal setting is enabled; otherwise, <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`true`</ph>如果启用了消息队列对象的日志设置;否则为<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>The following code example creates new <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> objects using various path name syntax types.</source>
          <target state="translated">下面的代码示例创建新<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>对象使用各种路径名称语法类型。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>In each case, it sends a message to the queue whose path is defined in the constructor.</source>
          <target state="translated">在每个情况下，它将消息发送到其路径定义构造函数中的队列。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> property is not valid, possibly because it has not been set.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> 属性无效，很可能因为尚未设置该属性。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>The location of the queue referenced by this <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>, which can be "." for the local computer.</source>
          <target state="translated">此 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 引用的队列的位置，它对于本地计算机可以是“.”。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to grant exclusive read access to the first application that accesses the queue; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>，授予访问该队列的第一个应用程序独占读访问权；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> class that references the Message Queuing queue at the specified path and with the specified read-access restriction.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 类的新实例，该实例引用位于指定路径处而且具有指定读访问限制的“消息队列”队列。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Use this overload when you want to tie the new <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> to a particular Message Queuing queue, for which you know the path, format name, or label.</source>
          <target state="translated">当你想要将新使用此重载<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>到特定消息队列的队列，并为其知道路径、 格式名或标签。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>If you want to grant exclusive access to the first application that references the queue, set the <ph id="ph1">`sharedModeDenyReceive`</ph> parameter to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">如果你想要授予对第一个应用程序独占访问权引用队列，请将设置<ph id="ph1">`sharedModeDenyReceive`</ph>参数<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Otherwise, set <ph id="ph1">`sharedModeDenyReceive`</ph> to <ph id="ph2">`false`</ph> or use the constructor that has only a <ph id="ph3">`path`</ph> parameter.</source>
          <target state="translated">否则，设置<ph id="ph1">`sharedModeDenyReceive`</ph>到<ph id="ph2">`false`</ph>或使用构造函数仅具有<ph id="ph3">`path`</ph>参数。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Setting <ph id="ph1">`sharedModeDenyReceive`</ph> to <ph id="ph2">`true`</ph> affects all objects that access the Message Queuing queue, including other applications.</source>
          <target state="translated">设置<ph id="ph1">`sharedModeDenyReceive`</ph>到<ph id="ph2">`true`</ph>影响访问消息队列队列，包括其他应用程序的所有对象。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>The effects of the parameter are not restricted to this application.</source>
          <target state="translated">参数的效果并不限于此应用程序。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.%23ctor%2A&gt;</ph> constructor creates a new instance of the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class; it does not create a new Message Queuing queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.%23ctor%2A&gt;</ph>构造函数创建的新实例<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>类; 它不会创建一个新的消息队列队列。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>To create a new queue in Message Queuing, use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Create%28System.String%29&gt;</ph>.</source>
          <target state="translated">若要在消息队列中创建新队列，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Create%28System.String%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>The syntax of the <ph id="ph1">`path`</ph> parameter depends on the type of queue.</source>
          <target state="translated">语法<ph id="ph1">`path`</ph>参数依赖于的队列的类型。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Queue type</source>
          <target state="translated">队列类型</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Syntax</source>
          <target state="translated">语法</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Public queue</source>
          <target state="translated">公用队列</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Private queue</source>
          <target state="translated">专用队列</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Journal queue</source>
          <target state="translated">日记队列</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Machine journal queue</source>
          <target state="translated">计算机日记队列</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Machine dead-letter queue</source>
          <target state="translated">机死信队列</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Machine transactional dead-letter queue</source>
          <target state="translated">计算机事务性死信队列</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Alternatively, you can use the format name or label of a Message Queuing queue to describe the queue path.</source>
          <target state="translated">或者，你可以使用的格式名或标签的消息队列的队列来描述队列路径。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Reference</source>
          <target state="translated">参考</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Syntax</source>
          <target state="translated">语法</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Example</source>
          <target state="translated">示例</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Format name</source>
          <target state="translated">格式名称</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source><ph id="ph1">`FormatName:`</ph> [ <bpt id="p1">*</bpt>format name<ept id="p1">*</ept> ]</source>
          <target state="translated"><ph id="ph1">`FormatName:`</ph> [<bpt id="p1">*</bpt>格式名<ept id="p1">*</ept>]</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source><ph id="ph1">`FormatName:Public=`</ph> 5A5F7535-AE9A-41d4-935C-845C2AFF7112</source>
          <target state="translated"><ph id="ph1">`FormatName:Public=`</ph> 5A5F7535-AE9A-41d4-935C-845C2AFF7112</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source><ph id="ph1">`FormatName:DIRECT=SPX:`</ph> <ph id="ph2">`NetworkNumber`</ph>; <ph id="ph3">`HostNumber`</ph><ph id="ph4">\\</ph><ph id="ph5">`QueueName`</ph></source>
          <target state="translated"><ph id="ph1">`FormatName:DIRECT=SPX:`</ph> <ph id="ph2">`NetworkNumber`</ph>; <ph id="ph3">`HostNumber`</ph><ph id="ph4">\\</ph><ph id="ph5">`QueueName`</ph></target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source><ph id="ph1">`FormatName:DIRECT=TCP:`</ph> <ph id="ph2">`IPAddress`</ph><ph id="ph3">\\</ph><ph id="ph4">`QueueName`</ph></source>
          <target state="translated"><ph id="ph1">`FormatName:DIRECT=TCP:`</ph> <ph id="ph2">`IPAddress`</ph><ph id="ph3">\\</ph><ph id="ph4">`QueueName`</ph></target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source><ph id="ph1">`FormatName:DIRECT=OS:`</ph> <ph id="ph2">`MachineName`</ph><ph id="ph3">\\</ph><ph id="ph4">`QueueName`</ph></source>
          <target state="translated"><ph id="ph1">`FormatName:DIRECT=OS:`</ph> <ph id="ph2">`MachineName`</ph><ph id="ph3">\\</ph><ph id="ph4">`QueueName`</ph></target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Label</source>
          <target state="translated">Label</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source><ph id="ph1">`Label:`</ph> [ <bpt id="p1">*</bpt>label<ept id="p1">*</ept> ]</source>
          <target state="translated"><ph id="ph1">`Label:`</ph> [<bpt id="p1">*</bpt>标签<ept id="p1">*</ept>]</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source><ph id="ph1">`Label:`</ph> TheLabel</source>
          <target state="translated"><ph id="ph1">`Label:`</ph> 标签</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>To work offline, you must use the format name syntax, rather than the friendly name syntax.</source>
          <target state="translated">若要在脱机工作，必须使用格式名语法，而不是友好名称语法。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Otherwise, an exception is thrown because the primary domain controller (on which Active Directory resides) is not available to resolve the path to the format name.</source>
          <target state="translated">否则，因为该域的主域控制器 （在其 Active Directory 处于） 不是可用于为格式名称解析的路径，则会引发异常。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>If a <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> opens a queue with the <ph id="ph2">`sharedModeDenyReceive`</ph> parameter set to <ph id="ph3">`true`</ph>, any <ph id="ph4">&lt;xref:System.Messaging.MessageQueue&gt;</ph> that subsequently tries to read from the queue generates a <ph id="ph5">&lt;xref:System.Messaging.MessageQueueException&gt;</ph> because of a sharing violation.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>打开一个队列<ph id="ph2">`sharedModeDenyReceive`</ph>参数设置为<ph id="ph3">`true`</ph>、 任何<ph id="ph4">&lt;xref:System.Messaging.MessageQueue&gt;</ph>，随后尝试从队列中读取生成<ph id="ph5">&lt;xref:System.Messaging.MessageQueueException&gt;</ph>由于共享冲突。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>A <ph id="ph1">&lt;xref:System.Messaging.MessageQueueException&gt;</ph> is also thrown if a <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> tries to access the queue in exclusive mode while another <ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph> already has non-exclusive access to the queue.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Messaging.MessageQueueException&gt;</ph>也会引发如果<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>尝试访问以独占模式，而此时另一个队列<ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph>已有非独占访问该队列。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>The following table shows initial property values for an instance of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>.</source>
          <target state="translated">下表显示的实例的初始属性值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>These values are based on the properties of the Message Queuing queue, with the path specified by the <ph id="ph1">`path`</ph> parameter.</source>
          <target state="translated">这些值基于属性的消息队列队列中，使用指定的路径<ph id="ph1">`path`</ph>参数。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Property</source>
          <target state="translated">Property</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>Initial value</source>
          <target state="translated">初始值</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source><ph id="ph1">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>0.</source>
          <target state="translated">0.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Guid.Empty&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Guid.Empty&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>The values set by the default constructor of the <ph id="ph1">&lt;xref:System.Messaging.DefaultPropertiesToSend&gt;</ph> class.</source>
          <target state="translated">设置的默认构造函数的值<ph id="ph1">&lt;xref:System.Messaging.DefaultPropertiesToSend&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source><ph id="ph1">`true`</ph>, if the Message Queuing queue's privacy level setting is "Body"; otherwise, <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`true`</ph>如果消息队列队列的隐私级别设置为"正文";否则为<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>The value of the Message Queuing queue's computer name property.</source>
          <target state="translated">消息队列队列的计算机名称属性的值。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteQueueSize&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteQueueSize&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteQueueSize&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteQueueSize&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>The values set by the default constructor of the <ph id="ph1">&lt;xref:System.Messaging.MessagePropertyFilter&gt;</ph> class.</source>
          <target state="translated">设置的默认构造函数的值<ph id="ph1">&lt;xref:System.Messaging.MessagePropertyFilter&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>, if not set by the constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>如果未设置由构造函数。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>, if not set by the constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>如果未设置由构造函数。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>The value of the <ph id="ph1">`sharedModeDenyReceive`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">`sharedModeDenyReceive`</ph> 参数的值。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source><ph id="ph1">`true`</ph>, if the Message Queuing object's journal setting is enabled; otherwise, <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`true`</ph>如果启用了消息队列对象的日志设置;否则为<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>The following code example creates a new <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> with exclusive access, sets its path, and sends a message to the queue.</source>
          <target state="translated">下面的代码示例创建一个新<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>具有独占访问权，将设置其路径中，并向队列发送消息。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> property is not valid, possibly because it has not been set.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> 属性无效，很可能因为尚未设置该属性。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)">
          <source>The location of the queue referenced by this <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>, which can be "." for the local computer.</source>
          <target state="translated">此 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 引用的队列的位置，它对于本地计算机可以是“.”。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.QueueAccessMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.QueueAccessMode" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)">
          <source>The location of the queue referenced by this <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>, which can be "." for the local computer.</source>
          <target state="translated">此 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 引用的队列的位置，它对于本地计算机可以是“.”。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to grant exclusive read access to the first application that accesses the queue; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>，授予访问该队列的第一个应用程序独占读访问权；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to create and use a connection cache; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果创建和使用连接缓存，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)">
          <source>The following code example creates a new <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> with exclusive read access and with connection caching enabled.</source>
          <target state="translated">下面的代码示例创建一个新<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>具有独占读取访问权限和启用了连接缓存。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)">
          <source>The location of the queue referenced by this <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>, which can be "." for the local computer.</source>
          <target state="translated">此 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 引用的队列的位置，它对于本地计算机可以是“.”。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to grant exclusive read access to the first application that accesses the queue; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>，授予访问该队列的第一个应用程序独占读访问权；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to create and use a connection cache; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果创建和使用连接缓存，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.QueueAccessMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.QueueAccessMode" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.AccessMode">
          <source>Gets a value that indicates the access mode for the queue.</source>
          <target state="translated">获取一个值，该值指示队列的访问模式。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.AccessMode">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.QueueAccessMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.QueueAccessMode" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.AccessMode">
          <source>The default access mode for a queue is <ph id="ph1">`QueueAccessMode.SendAndReceive`</ph>, unless you specify otherwise when calling the constructor.</source>
          <target state="translated">队列的默认访问模式是<ph id="ph1">`QueueAccessMode.SendAndReceive`</ph>，除非另行指定，否则时调用的构造函数。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>Gets or sets a value that indicates whether the queue accepts only authenticated messages.</source>
          <target state="translated">获取或设置一个值，该值指示队列是否仅接受经过身份验证的消息。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the queue accepts only authenticated messages; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果队列仅接受已经过身份验证的消息，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>Message authentication provides a way to ensure message integrity and to verify who sent the message.</source>
          <target state="translated">消息身份验证提供的方法来确保消息完整性和验证的发件人消息。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>To request authentication, the sending application sets the message's authentication level.</source>
          <target state="translated">若要请求身份验证，发送应用程序，请设置消息的身份验证级别。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>When you set <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Authenticate%2A&gt;</ph> to <ph id="ph2">`true`</ph>, you are restricting access to the queue on the server, not only to this <ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph> instance.</source>
          <target state="translated">当你将设置<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Authenticate%2A&gt;</ph>到<ph id="ph2">`true`</ph>，可将在服务器上，而不仅与此队列的访问权限<ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph>实例。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>All clients working against the same Message Queuing queue will be affected.</source>
          <target state="translated">将影响所有客户端使用相同的消息队列队列。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>A queue that accepts only authenticated messages will reject a non-authenticated message.</source>
          <target state="translated">只接受经过身份验证的消息队列将拒绝未经身份验证的消息。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>To request notification of message rejection, a sending application can set the <ph id="ph1">&lt;xref:System.Messaging.Message.AcknowledgeType%2A&gt;</ph> property of the message.</source>
          <target state="translated">若要请求消息遭到拒绝的通知，发送应用程序可以设置<ph id="ph1">&lt;xref:System.Messaging.Message.AcknowledgeType%2A&gt;</ph>消息的属性。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>Because no other indication of message rejection exists, the sending application can lose the message unless you request that it be sent to the dead-letter queue.</source>
          <target state="translated">因为消息遭到拒绝的任何其他指示不存在，则发送应用程序可以丢失的消息，除非您请求，它将发送到死信队列。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>The following code example gets and sets the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Authenticate%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例获取和设置的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Authenticate%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.Authenticate">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>Gets or sets the base priority Message Queuing uses to route a public queue's messages over the network.</source>
          <target state="translated">获取或设置基优先级，“消息队列”使用该基优先级在网络上传送公共队列的消息。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>The single base priority for all messages sent to the (public) queue.</source>
          <target state="translated">发送到（公共）队列的所有消息的单个基本优先级。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>The default is zero (0).</source>
          <target state="translated">默认值为零 (0)。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>A message queue's base priority specifies how a message en route to that queue is treated as it travels through the network.</source>
          <target state="translated">消息队列的基本优先级指定如何一条消息路由到的队列被视为通过网络传输。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>You can set the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BasePriority%2A&gt;</ph> property to confer a higher or lower priority to all messages sent to the specified queue than those sent to other queues.</source>
          <target state="translated">你可以设置<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BasePriority%2A&gt;</ph>属性来授予较高或较低的优先级，于发送到指定的队列比发送到其他队列的所有消息。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>Setting this property modifies the Message Queuing queue.</source>
          <target state="translated">将此属性设置修改消息队列队列。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>Therefore, any other <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> instances are affected by the change.</source>
          <target state="translated">因此，任何其他<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>的更改会影响实例。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>A message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BasePriority%2A&gt;</ph> is not related to the <ph id="ph2">&lt;xref:System.Messaging.Message.Priority%2A&gt;</ph> property of a message, which specifies the order in which an incoming message is placed in the queue.</source>
          <target state="translated">消息队列的<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BasePriority%2A&gt;</ph>无关<ph id="ph2">&lt;xref:System.Messaging.Message.Priority%2A&gt;</ph>消息，它指定在其中传入消息放置在队列中的顺序的属性。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BasePriority%2A&gt;</ph> applies only to public queues whose paths are specified using the format name.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BasePriority%2A&gt;</ph> 将应用使用的格式名来指定其路径仅为公共队列。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>The base priority of a private queue is always zero (0).</source>
          <target state="translated">专用队列的基本优先级始终为零 (0)。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>The following code example gets and sets the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BasePriority%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例获取和设置的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BasePriority%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>The base priority was set to an invalid value.</source>
          <target state="translated">基优先级被设置为无效值。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.BasePriority">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Initiates an asynchronous peek operation by telling Message Queuing to begin peeking a message and notify the event handler when finished.</source>
          <target state="translated">通过通知“消息队列”开始查看消息并在完成后通知事件处理程序，启动一个异步查看操作。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>Initiates an asynchronous peek operation that has no time-out. The operation is not complete until a message becomes available in the queue.</source>
          <target state="translated">启动一个没有超时设定的异步查看操作。直到队列中出现消息时，才完成此操作。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>The <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that identifies the posted asynchronous request.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> 标识已发布的异步请求的。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>In asynchronous processing, you use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> to raise the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event when a message becomes available in the queue.</source>
          <target state="translated">在异步处理，你使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>引发<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>事件时的消息变得在队列中可用。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> is also raised if a message already exists in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> 也会引发一条消息在队列中已存在。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>To use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>, create an event handler that processes the results of the asynchronous operation, and associate it with your event delegate.</source>
          <target state="translated">若要使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>、 创建的事件处理程序处理的异步操作的结果，并将其与你的事件委托。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> initiates an asynchronous peek operation; the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> is notified, through the raising of the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event, when a message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> 启动异步扫视操作;<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>则通知，通过引发<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>事件，当消息到达队列中。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> can then access the message by calling <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph> or by retrieving the result using the <ph id="ph3">&lt;xref:System.Messaging.PeekCompletedEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>然后可以通过调用访问消息<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>或通过检索结果使用<ph id="ph3">&lt;xref:System.Messaging.PeekCompletedEventArgs&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>方法立即返回，但直到调用事件处理程序，则不会完成异步操作。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> is asynchronous, you can call it to peek the queue without blocking the current thread of execution.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>是异步的你可以调用它可查看队列，而不必阻止当前线程的执行。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>To synchronously peek the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method.</source>
          <target state="translated">若要以同步方式查看队列，请使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>Once an asynchronous operation completes, you can call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> again in the event handler to keep receiving notifications.</source>
          <target state="translated">异步操作完成后，你可以调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>再次中继续接收通知的事件处理程序。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>The <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> that <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> returns identifies the asynchronous operation that the method started.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> ，<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>返回标识方法启动异步操作。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>You can use this <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> throughout the lifetime of the operation, although you generally do not use it until <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph> is called.</source>
          <target state="translated">你可以使用此<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>的整个生存期内此操作，尽管你通常不使用它之前<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>调用。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>However, if you start several asynchronous operations, you can place their <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> values in an array and specify whether to wait for all operations or any operation to complete.</source>
          <target state="translated">但是，如果启动多个异步操作，你可以将其<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>值在数组中，并指定是否等待所有的操作或任何操作完成。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>In this case, you use the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to identify the completed operation.</source>
          <target state="translated">在这种情况下，使用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph>属性<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>用于标识已完成的操作。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>If <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph> is <ph id="ph2">`false`</ph>, the completion event is raised, but an exception will be thrown when calling <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph>是<ph id="ph2">`false`</ph>，引发完成事件时，但调用时，将引发异常<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>The following code example creates an event handler named <ph id="ph1">`MyPeekCompleted`</ph>, attaches it to the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event handler delegate, and calls <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> to initiate an asynchronous peek operation on the queue that is located at the path ".\myQueue".</source>
          <target state="translated">下面的代码示例创建名为一个事件处理程序<ph id="ph1">`MyPeekCompleted`</ph>，将其附加到<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>事件处理程序委托，然后调用<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>启动位于路径的队列上的异步查看操作"。 \myQueue"。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>When a <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event is raised, the example peeks the message and writes its body to the screen.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>引发事件，该示例扫视消息，并将其正文写入到屏幕。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>The example then calls <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> again to initiate a new asynchronous peek operation.</source>
          <target state="translated">该示例然后调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>以启动新的异步扫视操作。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the interval of time to wait for a message to become available.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示等待消息变为可用所用的时间间隔。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>Initiates an asynchronous peek operation that has a specified time-out. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</source>
          <target state="translated">启动一个具有指定超时设定的异步查看操作。直到队列中出现消息时或发生超时时才完成操作。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that identifies the posted asynchronous request.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> 标识已发布的异步请求的。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>In asynchronous processing, you use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> to raise the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event when a message becomes available in the queue or when the specified interval of time has expired.</source>
          <target state="translated">在异步处理，你使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>引发<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>事件时的消息变得在队列中或在指定的时间间隔已过期时可用。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> is also raised if a message already exists in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> 也会引发一条消息在队列中已存在。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>To use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>, create an event handler that processes the results of the asynchronous operation, and associate it with your event delegate.</source>
          <target state="translated">若要使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>、 创建的事件处理程序处理的异步操作的结果，并将其与你的事件委托。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> initiates an asynchronous peek operation; the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> is notified, through the raising of the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event, when a message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> 启动异步扫视操作;<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>则通知，通过引发<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>事件，当消息到达队列中。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> can then access the message by calling <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph> or by retrieving the result using the <ph id="ph3">&lt;xref:System.Messaging.PeekCompletedEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>然后可以通过调用访问消息<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>或通过检索结果使用<ph id="ph3">&lt;xref:System.Messaging.PeekCompletedEventArgs&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>方法立即返回，但直到调用事件处理程序，则不会完成异步操作。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> is asynchronous, you can call it to peek the queue without blocking the current thread of execution.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>是异步的你可以调用它可查看队列，而不必阻止当前线程的执行。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>To synchronously peek the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method.</source>
          <target state="translated">若要以同步方式查看队列，请使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>Once an asynchronous operation completes, you can call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> again in the event handler to keep receiving notifications.</source>
          <target state="translated">异步操作完成后，你可以调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>再次中继续接收通知的事件处理程序。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> that <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> returns identifies the asynchronous operation that the method started.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> ，<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>返回标识方法启动异步操作。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>You can use this <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> throughout the lifetime of the operation, although you generally do not use it until <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph> is called.</source>
          <target state="translated">你可以使用此<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>的整个生存期内此操作，尽管你通常不使用它之前<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>调用。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>However, if you start several asynchronous operations, you can place their <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> values in an array and specify whether to wait for all operations or any operation to complete.</source>
          <target state="translated">但是，如果启动多个异步操作，你可以将其<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>值在数组中，并指定是否等待所有的操作或任何操作完成。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>In this case, you use the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to identify the completed operation.</source>
          <target state="translated">在这种情况下，使用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph>属性<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>用于标识已完成的操作。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>This overload specifies a time-out. If the interval specified by the <ph id="ph1">`timeout`</ph> parameter expires, this component raises the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event.</source>
          <target state="translated">此重载指定超时。如果指定的间隔<ph id="ph1">`timeout`</ph>参数过期，则此组件引发<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>Because no message exists, a subsequent call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph> will throw an exception.</source>
          <target state="translated">因为不存在的任何消息的后续调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>将引发异常。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>If <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph> is <ph id="ph2">`false`</ph>, the completion event is raised, but an exception will be thrown when calling <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph>是<ph id="ph2">`false`</ph>，引发完成事件时，但调用时，将引发异常<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>The following code example creates an asynchronous peek operation, using the queue path ".\myQueue".</source>
          <target state="translated">下面的代码示例创建一个异步查看操作，使用队列路径"。 \myQueue"。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>It creates an event handler, <ph id="ph1">`MyPeekCompleted`</ph>, and attaches it to the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event handler delegate.</source>
          <target state="translated">它将创建事件处理程序， <ph id="ph1">`MyPeekCompleted`</ph>，并将其附加到<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>事件处理程序委托。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> is called with a time-out of one minute, to initiate the asynchronous peek operation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> 调用的超时值为 1 分钟后，可启动异步扫视操作。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>When a <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event is raised or the time-out expires, the message is retrieved if one exists, and its body is written to the screen.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>引发事件或超时时间已到，如果存在，并且其正文会写入到屏幕检索消息。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>Then <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> is called again to initiate a new asynchronous peek operation with the same time-out.</source>
          <target state="translated">然后<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>会再次调用以启动新的异步扫视操作相同的超时时间。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the interval of time to wait for a message to become available.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示等待消息变为可用所用的时间间隔。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>A state object, specified by the application, that contains information associated with the asynchronous operation.</source>
          <target state="translated">应用程序指定的状态对象，包含与异步操作关联的信息。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>Initiates an asynchronous peek operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime.</source>
          <target state="translated">启动具有指定超时设定和指定状态对象的异步查看操作，此状态对象在操作的整个生存期内提供相关信息。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>The operation is not complete until either a message becomes available in the queue or the time-out occurs.</source>
          <target state="translated">直到队列中出现消息时或发生超时时才完成操作。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that identifies the posted asynchronous request.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> 标识已发布的异步请求的。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>In asynchronous processing, you use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> to raise the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event when a message becomes available in the queue or when the specified interval of time has expired.</source>
          <target state="translated">在异步处理，你使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>引发<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>事件时的消息变得在队列中或在指定的时间间隔已过期时可用。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> is also raised if a message already exists in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> 也会引发一条消息在队列中已存在。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>Use this overload to associate information with the operation that will be preserved throughout the operation's lifetime.</source>
          <target state="translated">使用此重载以将信息关联与将整个操作的整个生存期内保留操作。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>The event handler can access this information by looking at the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> that is associated with the operation.</source>
          <target state="translated">事件处理程序可以访问此信息通过查看<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>属性<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>操作与该键相关联。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>To use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>, create an event handler that processes the results of the asynchronous operation, and associate it with your event delegate.</source>
          <target state="translated">若要使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>、 创建的事件处理程序处理的异步操作的结果，并将其与你的事件委托。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> initiates an asynchronous peek operation; the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> is notified, through the raising of the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event, when a message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> 启动异步扫视操作;<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>则通知，通过引发<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>事件，当消息到达队列中。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> can then access the message by calling <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph> or by retrieving the result using the <ph id="ph3">&lt;xref:System.Messaging.PeekCompletedEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>然后可以通过调用访问消息<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>或通过检索结果使用<ph id="ph3">&lt;xref:System.Messaging.PeekCompletedEventArgs&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>方法立即返回，但直到调用事件处理程序，则不会完成异步操作。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> is asynchronous, you can call it to peek the queue without blocking the current thread of execution.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>是异步的你可以调用它可查看队列，而不必阻止当前线程的执行。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>To synchronously peek the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method.</source>
          <target state="translated">若要以同步方式查看队列，请使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>Once an asynchronous operation completes, you can call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> again in the event handler to keep receiving notifications.</source>
          <target state="translated">异步操作完成后，你可以调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>再次中继续接收通知的事件处理程序。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> returns a <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> that identifies the asynchronous operation that the method started.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> 返回<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>标识方法启动异步操作。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>You can use this <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> throughout the lifetime of the operation, although you generally do not use it until <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph> is called.</source>
          <target state="translated">你可以使用此<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>的整个生存期内此操作，尽管你通常不使用它之前<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>调用。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>However, if you start several asynchronous operations, you can place their <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> values in an array and specify whether to wait for all operations or any operation to complete.</source>
          <target state="translated">但是，如果启动多个异步操作，你可以将其<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>值在数组中，并指定是否等待所有的操作或任何操作完成。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>In this case, you use the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to identify the completed operation.</source>
          <target state="translated">在这种情况下，使用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph>属性<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>用于标识已完成的操作。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>This overload specifies a time-out and a state object.</source>
          <target state="translated">此重载指定超时和状态对象。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>If the interval specified by the <ph id="ph1">`timeout`</ph> parameter expires, this component raises the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event.</source>
          <target state="translated">如果指定的间隔<ph id="ph1">`timeout`</ph>参数过期，则此组件引发<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>Because no message exists, a subsequent call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph> will throw an exception.</source>
          <target state="translated">因为不存在的任何消息的后续调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>将引发异常。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>The state object associates state information with the operation.</source>
          <target state="translated">状态对象将与操作相关联的状态信息。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>For example, if you call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.</source>
          <target state="translated">例如，如果你调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>多次启动多个操作，你可以指定每个操作通过你定义单独的状态对象。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>For an illustration of this scenario, see the Example section.</source>
          <target state="translated">举例说明了这种情况下，请参阅示例部分。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>You can also use the state object to pass information across process threads.</source>
          <target state="translated">状态对象还可用于跨进程线程中传递信息。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>If a thread is started but the callback is on a different thread in an asynchronous scenario, the state object is marshaled and passed back along with information from the event.</source>
          <target state="translated">如果在线程启动，但在另一个线程中的异步方案是回调，状态对象封送，并从该事件传递回以及信息。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph> is <ph id="ph2">`false`</ph>, the completion event is raised, but an exception will be thrown when calling <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph>是<ph id="ph2">`false`</ph>，引发完成事件时，但调用时，将引发异常<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>The following code example creates an asynchronous peek operation, using the queue path ".\myQueue".</source>
          <target state="translated">下面的代码示例创建一个异步查看操作，使用队列路径"。 \myQueue"。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>It creates an event handler, <ph id="ph1">`MyPeekCompleted`</ph>, and attaches it to the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event handler delegate.</source>
          <target state="translated">它将创建事件处理程序， <ph id="ph1">`MyPeekCompleted`</ph>，并将其附加到<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>事件处理程序委托。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> is called, with a time-out of one minute.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> 被调用的超时值为一分钟。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>Each call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> has a unique associated integer that identifies that particular operation.</source>
          <target state="translated">每次调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>具有一个唯一的关联的整数，它标识该特定操作。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>When a <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event is raised or the time-out expired, the message, if one exists, is retrieved and its body and the operation-specific integer identifier are written to the screen.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>引发事件或超时到期时，检索消息，如果存在，并且其正文和特定操作的整数标识符写入到屏幕。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>Then <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> is called again to initiate a new asynchronous peek operation with the same time-out and the associated integer of the just completed operation.</source>
          <target state="translated">然后<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>会再次调用以启动新的异步扫视操作与相同的超时和的只是已完成的操作关联的整数。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the interval of time to wait for a message to become available.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示等待消息变为可用所用的时间间隔。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>A state object, specified by the application, that contains information associated with the asynchronous operation.</source>
          <target state="translated">应用程序指定的状态对象，包含与异步操作关联的信息。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> that will receive the notification of the asynchronous operation completion.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> 将接收异步操作完成通知。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Initiates an asynchronous peek operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime.</source>
          <target state="translated">启动具有指定超时设定和指定状态对象的异步查看操作，此状态对象在操作的整个生存期内提供相关信息。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>This overload receives notification, through a callback, of the identity of the event handler for the operation.</source>
          <target state="translated">此重载通过回调接收操作的事件处理程序标识的通知。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The operation is not complete until either a message becomes available in the queue or the time-out occurs.</source>
          <target state="translated">直到队列中出现消息时或发生超时时才完成操作。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that identifies the posted asynchronous request.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> 标识已发布的异步请求的。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>When you use this overload, the callback specified in the callback parameter is invoked directly when a message becomes available in the queue or when the specified interval of time has expired; the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event is not raised.</source>
          <target state="translated">当你使用此重载时，回调参数中指定时将调用回调直接的消息变得可用队列中或已过期的指定的时间间隔;<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>不会引发事件。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The other overloads of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> rely on this component to raise the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event.</source>
          <target state="translated">其他重载的<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>依赖于此组件以引发<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> is also raised if a message already exists in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> 也会引发一条消息在队列中已存在。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>方法立即返回，但直到调用事件处理程序，则不会完成异步操作。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> is asynchronous, you can call it to peek the queue without blocking the current thread of execution.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>是异步的你可以调用它可查看队列，而不必阻止当前线程的执行。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>To synchronously peek the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method.</source>
          <target state="translated">若要以同步方式查看队列，请使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Once an asynchronous operation completes, you can call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> again in the event handler to keep receiving notifications.</source>
          <target state="translated">异步操作完成后，你可以调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>再次中继续接收通知的事件处理程序。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> returns a <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> that identifies the asynchronous operation that the method started.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> 返回<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>标识方法启动异步操作。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>You can use this <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> throughout the lifetime of the operation, although you generally do not use it until <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph> is called.</source>
          <target state="translated">你可以使用此<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>的整个生存期内此操作，尽管你通常不使用它之前<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>调用。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>However, if you start several asynchronous operations, you can place their <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> values in an array and specify whether to wait for all operations or any operation to complete.</source>
          <target state="translated">但是，如果启动多个异步操作，你可以将其<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>值在数组中，并指定是否等待所有的操作或任何操作完成。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>In this case, you use the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to identify the completed operation.</source>
          <target state="translated">在这种情况下，使用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph>属性<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>用于标识已完成的操作。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The state object associates state information with the operation.</source>
          <target state="translated">状态对象将与操作相关联的状态信息。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>For example, if you call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.</source>
          <target state="translated">例如，如果你调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>多次启动多个操作，你可以指定每个操作通过你定义单独的状态对象。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The following code example creates an asynchronous peek operation.</source>
          <target state="translated">下面的代码示例创建一个异步查看操作。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The code example sends a message to a local message queue, then calls <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29&gt;</ph>, passing in: a time-out value of ten seconds; a unique integer that identifies that particular message; and a new instance of <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> that identifies the event handler, <ph id="ph3">`MyPeekCompleted`</ph>.</source>
          <target state="translated">此代码示例将发送一条消息到本地的消息队列，然后调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29&gt;</ph>，并传入： 超时值为十秒; 标识该特定的消息; 和的新实例的唯一整数<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>标识的事件处理程序中， <ph id="ph3">`MyPeekCompleted`</ph>.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>When a <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event is raised, the event handler peeks at the message and writes the message body and the integer message identifier to the screen.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>引发事件，事件处理程序扫视消息，并将消息正文和整数消息标识符写到屏幕。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the interval of time to wait for a message to become available.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示等待消息变为可用所用的时间间隔。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Cursor" /&gt;</ph> that maintains a specific position in the message queue.</source>
          <target state="translated">维持消息队列中特定位置的 <ph id="ph1">&lt;see cref="T:System.Messaging.Cursor" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.PeekAction" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.PeekAction" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>Indicates whether to peek at the current message in the queue, or the next message.</source>
          <target state="translated">指示是查看队列中的当前消息还是下一条消息。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>A state object, specified by the application, that contains information associated with the asynchronous operation.</source>
          <target state="translated">应用程序指定的状态对象，包含与异步操作关联的信息。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> that receives the notification of the asynchronous operation completion.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> 将接收异步操作完成通知。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>Initiates an asynchronous peek operation that has a specified time-out and that uses a specified cursor, a specified peek action, and a specified state object.</source>
          <target state="translated">启动异步查看操作，此操作具有指定的超时并使用指定的游标、指定的查看操作和指定的状态对象。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>The state object provides associated information throughout the lifetime of the operation.</source>
          <target state="translated">状态对象在操作的整个生存期内提供相关的信息。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>This overload receives notification, through a callback, of the identity of the event handler for the operation.</source>
          <target state="translated">此重载通过回调接收操作的事件处理程序标识的通知。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>The operation is not complete until either a message becomes available in the queue or the time-out occurs.</source>
          <target state="translated">直到队列中出现消息时或发生超时时才完成操作。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that identifies the posted asynchronous request.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> 标识已发布的异步请求的。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>When you use this overload, the callback specified in the callback parameter is invoked directly when a message becomes available in the queue or when the specified interval of time has expired.</source>
          <target state="translated">当你使用此重载时，回调参数中指定时将调用回调直接的消息变得在队列中或在指定的时间间隔已过期时可用。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event is not raised.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>不会引发事件。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>The other overloads of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> rely on this component to raise the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event.</source>
          <target state="translated">其他重载的<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>依赖于此组件以引发<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> is also raised if a message already exists in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> 也会引发一条消息在队列中已存在。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>方法立即返回，但直到调用事件处理程序，则不会完成异步操作。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> is asynchronous, you can call it to peek the queue without blocking the current thread of execution.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>是异步的你可以调用它可查看队列，而不必阻止当前线程的执行。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>To synchronously peek the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method.</source>
          <target state="translated">若要以同步方式查看队列，请使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>Once an asynchronous operation completes, you can call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> again in the event handler to keep receiving notifications.</source>
          <target state="translated">异步操作完成后，你可以调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>再次中继续接收通知的事件处理程序。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> returns a <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> that identifies the asynchronous operation started by the method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> 返回<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>标识通过方法启动的异步操作。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>You can use this <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> throughout the lifetime of the operation, although you generally do not use it until <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph> is called.</source>
          <target state="translated">你可以使用此<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>的整个生存期内此操作，尽管你通常不使用它之前<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>调用。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>However, if you start several asynchronous operations, you can place their <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> values in an array and specify whether to wait for all operations or any operation to complete.</source>
          <target state="translated">但是，如果启动多个异步操作，你可以将其<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>值在数组中，并指定是否等待所有的操作或任何操作完成。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>In this case, use the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to identify the completed operation.</source>
          <target state="translated">在这种情况下，使用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph>属性<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>用于标识已完成的操作。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>The state object associates state information with the operation.</source>
          <target state="translated">状态对象将与操作相关联的状态信息。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>For example, if you call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.</source>
          <target state="translated">例如，如果你调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>多次启动多个操作，你可以指定每个操作通过你定义单独的状态对象。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>A value other than <ph id="ph1">&lt;see langword="PeekAction.Current" /&gt;</ph> or <ph id="ph2">&lt;see langword="PeekAction.Next" /&gt;</ph> was specified for the <ph id="ph3">&lt;paramref name="action" /&gt;</ph> parameter.</source>
          <target state="translated">为 <ph id="ph3">&lt;paramref name="action" /&gt;</ph> 参数指定的值不是 <ph id="ph1">&lt;see langword="PeekAction.Current" /&gt;</ph> 和 <ph id="ph2">&lt;see langword="PeekAction.Next" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;paramref name="cursor" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cursor" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Initiates an asynchronous receive operation by telling Message Queuing to begin receiving a message and notify the event handler when finished.</source>
          <target state="translated">通过通知“消息队列”开始接收消息并在完成后通知事件处理程序，启动一个异步接收操作。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>Initiates an asynchronous receive operation that has no time-out. The operation is not complete until a message becomes available in the queue.</source>
          <target state="translated">启动一个没有超时设定的异步接收操作。直到队列中出现消息时，才完成此操作。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>The <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that identifies the posted asynchronous request.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> 标识已发布的异步请求的。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>In asynchronous processing, you use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> to raise the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event when a message has been removed from the queue.</source>
          <target state="translated">在异步处理，你使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>引发<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>事件时从队列中删除一条消息。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> is also raised if a message already exists in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> 也会引发一条消息在队列中已存在。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>To use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate.</source>
          <target state="translated">若要使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>、 创建的事件处理程序处理异步操作的结果，并将其与你的事件委托。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> initiates an asynchronous receive operation; the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> is notified, through the raising of the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event, when a message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> 启动异步接收操作;<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>则通知，通过引发<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>事件，当消息到达队列中。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> can then access the message by calling <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>然后可以通过调用访问消息<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>方法立即返回，但直到调用事件处理程序，则不会完成异步操作。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>是异步的你可以调用它可接收来自队列的消息，而不会阻止当前线程的执行。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>To synchronously receive a message, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method.</source>
          <target state="translated">若要以同步方式收到一条消息，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>Once an asynchronous operation completes, you can call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> again in the event handler to keep receiving notifications.</source>
          <target state="translated">异步操作完成后，你可以调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>再次中继续接收通知的事件处理程序。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>The <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> that <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> returns identifies the asynchronous operation that the method started.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> ，<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>返回标识方法启动异步操作。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>You can use this <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> throughout the lifetime of the operation, although you generally do not use it until <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph> is called.</source>
          <target state="translated">你可以使用此<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>的整个生存期内此操作，尽管你通常不使用它之前<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>调用。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>However, if you start several asynchronous operations, you can place their <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> values in an array and specify whether to wait for all operations or any operation to complete.</source>
          <target state="translated">但是，如果启动多个异步操作，你可以将其<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>值在数组中，并指定是否等待所有的操作或任何操作完成。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>In this case, you use the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to identify the completed operation.</source>
          <target state="translated">在这种情况下，使用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph>属性<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>用于标识已完成的操作。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>If <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph> is <ph id="ph2">`false`</ph>, the completion event is raised, but an exception will be thrown when calling <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph>是<ph id="ph2">`false`</ph>，引发完成事件时，但调用时，将引发异常<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>Do not use the asynchronous call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> with transactions.</source>
          <target state="translated">不使用异步调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>与事务。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>If you want to perform a transactional asynchronous operation, call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>, and put the transaction and the (synchronous) <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method within the event handler you create for the peek operation.</source>
          <target state="translated">如果你想要执行的事务的异步操作，调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>，并将事务和 （同步）<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>扫视操作在你创建的事件处理程序方法。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>Your event handler might contain functionality as shown in the following C# code.</source>
          <target state="translated">事件处理程序可能包含功能，如下面的 C# 代码中所示。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>The following code example chains asynchronous requests.</source>
          <target state="translated">下面的代码示例链接异步请求。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>It assumes there is a queue on the local computer called "myQueue".</source>
          <target state="translated">它假定名为"myQueue"的本地计算机上没有队列。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>The <ph id="ph1">`Main`</ph> function begins the asynchronous operation that is handled by the <ph id="ph2">`MyReceiveCompleted`</ph> routine.</source>
          <target state="translated"><ph id="ph1">`Main`</ph>函数开始异步操作由处理<ph id="ph2">`MyReceiveCompleted`</ph>例程。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source><ph id="ph1">`MyReceiveCompleted`</ph> processes the current message and begins a new asynchronous receive operation.</source>
          <target state="translated"><ph id="ph1">`MyReceiveCompleted`</ph> 处理当前消息并开始一个新异步接收操作。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>The following code example queues asynchronous requests.</source>
          <target state="translated">下面的代码示例将异步请求排队。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>The call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> uses the <ph id="ph2">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> in its return value.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>使用<ph id="ph2">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph>其返回值中。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>The <ph id="ph1">`Main`</ph> routine waits for all asynchronous operations to be completed before exiting.</source>
          <target state="translated"><ph id="ph1">`Main`</ph>例程等待所有异步操作，可在退出之前完成。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the interval of time to wait for a message to become available.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示等待消息变为可用所用的时间间隔。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>Initiates an asynchronous receive operation that has a specified time-out. The operation is not complete until either a message becomes available in the queue or the time-out occurs.</source>
          <target state="translated">启动具有指定超时设定的异步接收操作。直到队列中出现消息时或发生超时时才完成操作。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that identifies the posted asynchronous request.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> 标识已发布的异步请求的。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>In asynchronous processing, you use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> to raise the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event when a message becomes available in the queue or when the specified interval of time has expired.</source>
          <target state="translated">在异步处理，你使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>引发<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>事件时的消息变得在队列中或在指定的时间间隔已过期时可用。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> is also raised if a message already exists in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> 也会引发一条消息在队列中已存在。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>To use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate.</source>
          <target state="translated">若要使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>、 创建的事件处理程序处理异步操作的结果，并将其与你的事件委托。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> initiates an asynchronous receive operation; the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> is notified, through the raising of the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event, when a message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> 启动异步接收操作;<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>则通知，通过引发<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>事件，当消息到达队列中。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> can then access the message by calling <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph> or retrieving the result using the <ph id="ph3">&lt;xref:System.Messaging.ReceiveCompletedEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>然后可以通过调用访问消息<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>或检索结果使用<ph id="ph3">&lt;xref:System.Messaging.ReceiveCompletedEventArgs&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>方法立即返回，但直到调用事件处理程序，则不会完成异步操作。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>是异步的你可以调用它可接收来自队列的消息，而不会阻止当前线程的执行。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>To synchronously receive a message, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method.</source>
          <target state="translated">若要以同步方式收到一条消息，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>Once an asynchronous operation completes, you can call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> again in the event handler to keep receiving notifications.</source>
          <target state="translated">异步操作完成后，你可以调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>再次中继续接收通知的事件处理程序。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>If <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph> is <ph id="ph2">`false`</ph>, the completion event is raised, but an exception will be thrown when calling <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph>是<ph id="ph2">`false`</ph>，引发完成事件时，但调用时，将引发异常<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> that <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> returns identifies the asynchronous operation that the method started.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> ，<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>返回标识方法启动异步操作。</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>You can use this <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> throughout the lifetime of the operation, although you generally do not use it until <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph> is called.</source>
          <target state="translated">你可以使用此<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>的整个生存期内此操作，尽管你通常不使用它之前<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>调用。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>However, if you start several asynchronous operations, you can place their <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> values in an array and specify whether to wait for all operations or any operation to complete.</source>
          <target state="translated">但是，如果启动多个异步操作，你可以将其<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>值在数组中，并指定是否等待所有的操作或任何操作完成。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>In this case, you use the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to identify the completed operation.</source>
          <target state="translated">在这种情况下，使用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph>属性<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>用于标识已完成的操作。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>This overload specifies a time-out. If the interval specified by the <ph id="ph1">`timeout`</ph> parameter expires, this component raises the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event.</source>
          <target state="translated">此重载指定超时。如果指定的间隔<ph id="ph1">`timeout`</ph>参数过期，则此组件引发<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>Because no message exists, a subsequent call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph> will throw an exception.</source>
          <target state="translated">因为不存在的任何消息的后续调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>将引发异常。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>Do not use the asynchronous call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> with transactions.</source>
          <target state="translated">不使用异步调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>与事务。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>If you want to perform a transactional asynchronous operation, call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>, and put the transaction and the (synchronous) <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method within the event handler you create for the peek operation.</source>
          <target state="translated">如果你想要执行的事务的异步操作，调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>，并将事务和 （同步）<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>扫视操作在你创建的事件处理程序方法。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>Your event handler might contain functionality as shown in the following C# code.</source>
          <target state="translated">事件处理程序可能包含功能，如下面的 C# 代码中所示。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>The following code example creates an asynchronous receive operation.</source>
          <target state="translated">下面的代码示例创建异步接收操作。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>The code example creates an event handler, <ph id="ph1">`MyReceiveCompleted`</ph>, and attaches it to the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event handler delegate.</source>
          <target state="translated">此代码示例创建一个事件处理程序即<ph id="ph1">`MyReceiveCompleted`</ph>，并将其附加到<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>事件处理程序委托。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>The code example sends a message to a local message queue, then calls <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29&gt;</ph>, passing in a time-out value of ten seconds.</source>
          <target state="translated">此代码示例将发送一条消息到本地的消息队列，然后调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29&gt;</ph>，并传入超时值为十秒。</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>When a <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event is raised, the event handler receives the message and writes the message body to the screen.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>引发事件，事件处理程序接收消息，并将消息正文写到屏幕。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid, possibly because it represents a negative number.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效，可能是因为它表示负数。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the interval of time to wait for a message to become available.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示等待消息变为可用所用的时间间隔。</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>A state object, specified by the application, that contains information associated with the asynchronous operation.</source>
          <target state="translated">应用程序指定的状态对象，包含与异步操作关联的信息。</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>Initiates an asynchronous receive operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime.</source>
          <target state="translated">启动具有指定超时设定和指定状态对象的异步接收操作，此状态对象在操作的整个生存期内提供相关信息。</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>The operation is not complete until either a message becomes available in the queue or the time-out occurs.</source>
          <target state="translated">直到队列中出现消息时或发生超时时才完成操作。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that identifies the posted asynchronous request.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> 标识已发布的异步请求的。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>In asynchronous processing, you use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> to raise the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event when a message becomes available in the queue or when the specified interval of time has expired.</source>
          <target state="translated">在异步处理，你使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>引发<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>事件时的消息变得在队列中或在指定的时间间隔已过期时可用。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> is also raised if a message already exists in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> 也会引发一条消息在队列中已存在。</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>Use this overload to associate information with the operation that will be preserved throughout the operation's lifetime.</source>
          <target state="translated">使用此重载以将信息关联与将整个操作的整个生存期内保留操作。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>The event handler can detect this information by looking at the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> that is associated with the operation.</source>
          <target state="translated">事件处理程序可以通过查看检测此信息<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>属性<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>操作与该键相关联。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>To use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate.</source>
          <target state="translated">若要使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>、 创建的事件处理程序处理异步操作的结果，并将其与你的事件委托。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> initiates an asynchronous receive operation; the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> is notified, through the raising of the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event, when a message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> 启动异步接收操作;<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>则通知，通过引发<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>事件，当消息到达队列中。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> can then access the message by calling <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph> or retrieving the result using the <ph id="ph3">&lt;xref:System.Messaging.ReceiveCompletedEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>然后可以通过调用访问消息<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>或检索结果使用<ph id="ph3">&lt;xref:System.Messaging.ReceiveCompletedEventArgs&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>方法立即返回，但直到调用事件处理程序，则不会完成异步操作。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>是异步的你可以调用它可接收来自队列的消息，而不会阻止当前线程的执行。</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>To synchronously receive a message, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method.</source>
          <target state="translated">若要以同步方式收到一条消息，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>Once an asynchronous operation completes, you can call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> again in the event handler to keep receiving notifications.</source>
          <target state="translated">异步操作完成后，你可以调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>再次中继续接收通知的事件处理程序。</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> that <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> returns identifies the asynchronous operation that the method started.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> ，<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>返回标识方法启动异步操作。</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>You can use this <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> throughout the lifetime of the operation, although you generally do not use it until <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph> is called.</source>
          <target state="translated">你可以使用此<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>的整个生存期内此操作，尽管你通常不使用它之前<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>调用。</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>However, if you start several asynchronous operations, you can place their <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> values in an array and specify whether to wait for all operations or any operation to complete.</source>
          <target state="translated">但是，如果启动多个异步操作，你可以将其<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>值在数组中，并指定是否等待所有的操作或任何操作完成。</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>In this case, you use the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to identify the completed operation.</source>
          <target state="translated">在这种情况下，使用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph>属性<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>用于标识已完成的操作。</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>This overload specifies a time-out and a state object.</source>
          <target state="translated">此重载指定超时和状态对象。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>If the interval specified by the <ph id="ph1">`timeout`</ph> parameter expires, this component raises the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event.</source>
          <target state="translated">如果指定的间隔<ph id="ph1">`timeout`</ph>参数过期，则此组件引发<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>Because no message exists, a subsequent call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph> will throw an exception.</source>
          <target state="translated">因为不存在的任何消息的后续调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>将引发异常。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>The state object associates state information with the operation.</source>
          <target state="translated">状态对象将与操作相关联的状态信息。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>For example, if you call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.</source>
          <target state="translated">例如，如果你调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>多次启动多个操作，你可以指定每个操作通过你定义单独的状态对象。</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>You can also use the state object to pass information across process threads.</source>
          <target state="translated">状态对象还可用于跨进程线程中传递信息。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>If a thread is started but the callback is on a different thread in an asynchronous scenario, the state object is marshaled and passed back along with information from the event.</source>
          <target state="translated">如果在线程启动，但在另一个线程中的异步方案是回调，状态对象封送，并从该事件传递回以及信息。</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>Do not use the asynchronous call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> with transactions.</source>
          <target state="translated">不使用异步调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>与事务。</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>If you want to perform a transactional asynchronous operation, call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>, and put the transaction and the (synchronous) <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method within the event handler you create for the peek operation.</source>
          <target state="translated">如果你想要执行的事务的异步操作，调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>，并将事务和 （同步）<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>扫视操作在你创建的事件处理程序方法。</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>Your event handler might contain functionality as shown in the following C# code.</source>
          <target state="translated">事件处理程序可能包含功能，如下面的 C# 代码中所示。</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>The following code example creates an asynchronous receive operation.</source>
          <target state="translated">下面的代码示例创建异步接收操作。</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>The code example creates an event handler, <ph id="ph1">`MyReceiveCompleted`</ph>, and attaches it to the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event handler delegate.</source>
          <target state="translated">此代码示例创建一个事件处理程序即<ph id="ph1">`MyReceiveCompleted`</ph>，并将其附加到<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>事件处理程序委托。</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>The code example sends a message to a local message queue, then calls <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29&gt;</ph>, passing in a time-out value of ten seconds and a unique integer that identifies that particular message.</source>
          <target state="translated">此代码示例将发送一条消息到本地的消息队列，然后调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29&gt;</ph>，并传入超时值为十秒和一个唯一的整数，它标识该特定消息。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>When a <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event is raised, the event handler receives the message and writes the message body and the integer message identifier to the screen.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>引发事件，事件处理程序接收消息，并将消息正文和整数消息标识符写入屏幕。</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the interval of time to wait for a message to become available.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示等待消息变为可用所用的时间间隔。</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>A state object, specified by the application, that contains information associated with the asynchronous operation.</source>
          <target state="translated">应用程序指定的状态对象，包含与异步操作关联的信息。</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> that will receive the notification of the asynchronous operation completion.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> 将接收异步操作完成通知。</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Initiates an asynchronous receive operation that has a specified time-out and a specified state object, which provides associated information throughout the operation's lifetime.</source>
          <target state="translated">启动具有指定超时设定和指定状态对象的异步接收操作，此状态对象在操作的整个生存期内提供相关信息。</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>This overload receives notification, through a callback, of the identity of the event handler for the operation.</source>
          <target state="translated">此重载通过回调接收操作的事件处理程序标识的通知。</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The operation is not complete until either a message becomes available in the queue or the time-out occurs.</source>
          <target state="translated">直到队列中出现消息时或发生超时时才完成操作。</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that identifies the posted asynchronous request.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> 标识已发布的异步请求的。</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>When you use this overload, the callback specified in the callback parameter is invoked directly when a message becomes available in the queue or when the specified interval of time has expired; the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event is not raised.</source>
          <target state="translated">当你使用此重载时，回调参数中指定时将调用回调直接的消息变得可用队列中或已过期的指定的时间间隔;<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>不会引发事件。</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The other overloads of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> rely on this component to raise the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event.</source>
          <target state="translated">其他重载的<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>依赖于此组件以引发<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> is also raised if a message already exists in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> 也会引发一条消息在队列中已存在。</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>To use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate.</source>
          <target state="translated">若要使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>、 创建的事件处理程序处理异步操作的结果，并将其与你的事件委托。</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> initiates an asynchronous receive operation; the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> is notified, through the raising of the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event, when a message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> 启动异步接收操作;<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>则通知，通过引发<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>事件，当消息到达队列中。</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> can then access the message by calling <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph> or retrieving the result using the <ph id="ph3">&lt;xref:System.Messaging.ReceiveCompletedEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>然后可以通过调用访问消息<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>或检索结果使用<ph id="ph3">&lt;xref:System.Messaging.ReceiveCompletedEventArgs&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>方法立即返回，但直到调用事件处理程序，则不会完成异步操作。</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>是异步的你可以调用它可接收来自队列的消息，而不会阻止当前线程的执行。</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>To synchronously receive a message, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method.</source>
          <target state="translated">若要以同步方式收到一条消息，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Once an asynchronous operation completes, you can call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> again in the event handler to keep receiving notifications.</source>
          <target state="translated">异步操作完成后，你可以调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>再次中继续接收通知的事件处理程序。</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> that <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> returns identifies the asynchronous operation that the method started.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> ，<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>返回标识方法启动异步操作。</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>You can use this <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> throughout the lifetime of the operation, although you generally do not use it until <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph> is called.</source>
          <target state="translated">你可以使用此<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>的整个生存期内此操作，尽管你通常不使用它之前<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>调用。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>However, if you start several asynchronous operations, you can place their <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> values in an array and specify whether to wait for all operations or any operation to complete.</source>
          <target state="translated">但是，如果启动多个异步操作，你可以将其<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>值在数组中，并指定是否等待所有的操作或任何操作完成。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>In this case, you use the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to identify the completed operation.</source>
          <target state="translated">在这种情况下，使用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph>属性<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>用于标识已完成的操作。</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The state object associates state information with the operation.</source>
          <target state="translated">状态对象将与操作相关联的状态信息。</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>For example, if you call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.</source>
          <target state="translated">例如，如果你调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>多次启动多个操作，你可以指定每个操作通过你定义单独的状态对象。</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>You can also use the state object to pass information across process threads.</source>
          <target state="translated">状态对象还可用于跨进程线程中传递信息。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>If a thread is started but the callback is on a different thread in an asynchronous scenario, the state object is marshaled and passed back along with information from the event.</source>
          <target state="translated">如果在线程启动，但在另一个线程中的异步方案是回调，状态对象封送，并从该事件传递回以及信息。</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Do not use the asynchronous call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> with transactions.</source>
          <target state="translated">不使用异步调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>与事务。</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>If you want to perform a transactional asynchronous operation, call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>, and put the transaction and the (synchronous) <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method within the event handler you create for the peek operation.</source>
          <target state="translated">如果你想要执行的事务的异步操作，调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>，并将事务和 （同步）<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>扫视操作在你创建的事件处理程序方法。</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Your event handler might contain functionality as shown in the following C# code.</source>
          <target state="translated">事件处理程序可能包含功能，如下面的 C# 代码中所示。</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The following code example creates an asynchronous receive operation.</source>
          <target state="translated">下面的代码示例创建异步接收操作。</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The code example sends a message to a local message queue, then calls <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29&gt;</ph>, passing in: a time-out value of ten seconds; a unique integer that identifies that particular message; and a new instance of <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> that identifies the event handler, <ph id="ph3">`MyReceiveCompleted`</ph>.</source>
          <target state="translated">此代码示例将发送一条消息到本地的消息队列，然后调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29&gt;</ph>，并传入： 超时值为十秒; 标识该特定的消息; 和的新实例的唯一整数<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>标识的事件处理程序中， <ph id="ph3">`MyReceiveCompleted`</ph>.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>When a <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event is raised, the event handler receives the message and writes the message body and the integer message identifier to the screen.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>引发事件，事件处理程序接收消息，并将消息正文和整数消息标识符写入屏幕。</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效。</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the interval of time to wait for a message to become available.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示等待消息变为可用所用的时间间隔。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Cursor" /&gt;</ph> that maintains a specific position in the message queue.</source>
          <target state="translated">维持消息队列中特定位置的 <ph id="ph1">&lt;see cref="T:System.Messaging.Cursor" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>A state object, specified by the application, that contains information associated with the asynchronous operation.</source>
          <target state="translated">应用程序指定的状态对象，包含与异步操作关联的信息。</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> that receives the notification of the asynchronous operation completion.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> 将接收异步操作完成通知。</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>Initiates an asynchronous receive operation that has a specified time-out and uses a specified cursor and a specified state object.</source>
          <target state="translated">启动异步接收操作，此操作具有指定的超时并使用指定的游标和指定的状态对象。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>The state object provides associated information throughout the lifetime of the operation.</source>
          <target state="translated">状态对象在操作的整个生存期内提供相关的信息。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>This overload receives notification, through a callback, of the identity of the event handler for the operation.</source>
          <target state="translated">此重载通过回调接收操作的事件处理程序标识的通知。</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>The operation is not complete until either a message becomes available in the queue or the time-out occurs.</source>
          <target state="translated">直到队列中出现消息时或发生超时时才完成操作。</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that identifies the posted asynchronous request.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> 标识已发布的异步请求的。</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>When you use this overload, the callback specified in the callback parameter is invoked directly when a message becomes available in the queue or when the specified interval of time has expired; the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event is not raised.</source>
          <target state="translated">当你使用此重载时，回调参数中指定时将调用回调直接的消息变得可用队列中或已过期的指定的时间间隔;<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>不会引发事件。</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>The other overloads of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> rely on this component to raise the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event.</source>
          <target state="translated">其他重载的<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>依赖于此组件以引发<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> is also raised if a message already exists in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> 也会引发一条消息在队列中已存在。</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>To use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>, create an event handler that processes the results of the asynchronous operation and associate it with your event delegate.</source>
          <target state="translated">若要使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>、 创建的事件处理程序处理异步操作的结果，并将其与你的事件委托。</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> initiates an asynchronous receive operation; the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> is notified, through the raising of the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event, when a message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> 启动异步接收操作;<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>则通知，通过引发<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>事件，当消息到达队列中。</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> can then access the message by calling <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph> or retrieving the result using the <ph id="ph3">&lt;xref:System.Messaging.ReceiveCompletedEventArgs&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>然后可以通过调用访问消息<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>或检索结果使用<ph id="ph3">&lt;xref:System.Messaging.ReceiveCompletedEventArgs&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> method returns immediately, but the asynchronous operation is not completed until the event handler is called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>方法立即返回，但直到调用事件处理程序，则不会完成异步操作。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> is asynchronous, you can call it to receive a message from the queue without blocking the current thread of execution.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>是异步的你可以调用它可接收来自队列的消息，而不会阻止当前线程的执行。</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>To synchronously receive a message, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method.</source>
          <target state="translated">若要以同步方式收到一条消息，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>Once an asynchronous operation completes, you can call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> again in the event handler to keep receiving notifications.</source>
          <target state="translated">异步操作完成后，你可以调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>再次中继续接收通知的事件处理程序。</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> that <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> returns identifies the asynchronous operation that the method started.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> ，<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>返回标识方法启动异步操作。</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>You can use this <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> throughout the lifetime of the operation, although you generally do not use it until <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph> is called.</source>
          <target state="translated">你可以使用此<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>的整个生存期内此操作，尽管你通常不使用它之前<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>调用。</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>However, if you start several asynchronous operations, you can place their <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> values in an array and specify whether to wait for all operations or any operation to complete.</source>
          <target state="translated">但是，如果启动多个异步操作，你可以将其<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>值在数组中，并指定是否等待所有的操作或任何操作完成。</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>In this case, use the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> property of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to identify the completed operation.</source>
          <target state="translated">在这种情况下，使用<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph>属性<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>用于标识已完成的操作。</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>The state object associates state information with the operation.</source>
          <target state="translated">状态对象将与操作相关联的状态信息。</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>For example, if you call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> multiple times to initiate multiple operations, you can identify each operation through a separate state object that you define.</source>
          <target state="translated">例如，如果你调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>多次启动多个操作，你可以指定每个操作通过你定义单独的状态对象。</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>You can also use the state object to pass information across process threads.</source>
          <target state="translated">状态对象还可用于跨进程线程中传递信息。</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>If a thread is started but the callback is on a different thread in an asynchronous scenario, the state object is marshaled and passed back along with information from the event.</source>
          <target state="translated">如果在线程启动，但在另一个线程中的异步方案是回调，状态对象封送，并从该事件传递回以及信息。</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>Do not use the asynchronous call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> with transactions.</source>
          <target state="translated">不使用异步调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>与事务。</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>If you want to perform a transactional asynchronous operation, call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>, and put the transaction and the (synchronous) <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method within the event handler you create for the peek operation.</source>
          <target state="translated">如果你想要执行的事务的异步操作，调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>，并将事务和 （同步）<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>扫视操作在你创建的事件处理程序方法。</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>Your event handler might contain functionality as shown in the following C# code.</source>
          <target state="translated">事件处理程序可能包含功能，如下面的 C# 代码中所示。</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>The <ph id="ph1">&lt;paramref name="cursor" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cursor" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效。</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.CanRead">
          <source>Gets a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> can be read.</source>
          <target state="translated">获取一个值，该值指示 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 是否可读。</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanRead">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> exists and the application can read from it; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果存在 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 而且应用程序可从其中读取，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanRead">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph> indicates whether the application is able to peek or receive messages from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph> 指示应用程序是否能够查看或从队列接收消息。</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanRead">
          <source>If <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph> is <ph id="ph2">`true`</ph>, the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph> can receive or peek messages from the queue.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph>是<ph id="ph2">`true`</ph>、<ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph>可以接收或查看从队列的消息。</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanRead">
          <source>Otherwise, it cannot.</source>
          <target state="translated">否则，不能。</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanRead">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph> is <ph id="ph2">`false`</ph> if a queue is already open with exclusive read access (or if it's open with non-exclusive access and this <ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph> requests exclusive access), or if the application does not have sufficient rights to access it.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph> 是<ph id="ph2">`false`</ph>如果队列已打开使用独占读取访问权 (或如果它是使用非独占访问权限和这打开<ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph>请求独占访问权)，或如果应用程序没有足够的权限访问它。</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanRead">
          <source>If your application tries to read from a queue when <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph> is <ph id="ph2">`false`</ph>, access is denied.</source>
          <target state="translated">如果你的应用程序尝试从队列中读取时<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph>是<ph id="ph2">`false`</ph>，访问被拒绝。</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanRead">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanRead">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanRead">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanRead">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanRead">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanRead">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanRead">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanRead">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanRead">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanRead">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanRead">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanRead">
          <source>The following code example displays the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例显示的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanRead%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source>Gets a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> can be written to.</source>
          <target state="translated">获取一个值，该值指示 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 是否可写。</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> exists and the application can write to it; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果存在 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 而且应用程序可向其中写入，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanWrite%2A&gt;</ph> indicates whether the application is able to send messages to the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanWrite%2A&gt;</ph> 指示应用程序是否能够将消息发送到队列。</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source>If <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanWrite%2A&gt;</ph> is <ph id="ph2">`true`</ph>, the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph> can send messages to the queue.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanWrite%2A&gt;</ph>是<ph id="ph2">`true`</ph>、<ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph>可以向队列发送消息。</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source>Otherwise, it cannot.</source>
          <target state="translated">否则，不能。</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanWrite%2A&gt;</ph> is <ph id="ph2">`false`</ph> if a queue is already open with exclusive write access (or if it's open with non-exclusive access and this <ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph> requests exclusive access), or if the application does not have sufficient rights to access it.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanWrite%2A&gt;</ph> 是<ph id="ph2">`false`</ph>如果队列已用独占写入访问权限打开 (或如果它是使用非独占访问权限和这打开<ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph>请求独占访问权)，或如果应用程序没有足够的权限访问它。</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source>If your application tries to write to a queue when <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanWrite%2A&gt;</ph> is <ph id="ph2">`false`</ph>, access is denied.</source>
          <target state="translated">如果你的应用程序尝试写入队列时<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanWrite%2A&gt;</ph>是<ph id="ph2">`false`</ph>，访问被拒绝。</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CanWrite">
          <source>The following code example displays the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanWrite%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例显示的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CanWrite%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.Category">
          <source>Gets or sets the queue category.</source>
          <target state="translated">获取或设置队列类别。</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>A <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> that represents the queue category (Message Queuing type identifier), which allows an application to categorize its queues.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph>，表示队列类别（“消息队列”类型标识符），它允许应用程序将其队列分类。</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>The default is <ph id="ph1">&lt;see langword="Guid.empty" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="Guid.empty" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>The queue category allows an application to categorize its queues.</source>
          <target state="translated">队列类别允许应用程序对它的队列进行分类。</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>For example, you can place all Billing queues in one category and all Order queues in another.</source>
          <target state="translated">例如，你可以将所有计费队列都放在一个类别和在另一个中的所有订单队列中。</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph> property provides access to the Message Queuing Type ID property (which is read/write), accessible through the <bpt id="p1">**</bpt>Queue Properties<ept id="p1">**</ept> dialog box in the Computer Management Console.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph>属性提供访问权限 （这是读/写） 的消息队列类型 ID 属性，可通过访问<bpt id="p1">**</bpt>队列属性<ept id="p1">**</ept>计算机管理控制台中的对话框。</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>You can define a new category.</source>
          <target state="translated">你可以定义新类别。</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>Although you can use <ph id="ph1">&lt;xref:System.Guid.NewGuid%2A&gt;</ph> to create a category value that is unique across all <ph id="ph2">&lt;xref:System.Guid&gt;</ph> values, such an action is unnecessary.</source>
          <target state="translated">尽管可以使用<ph id="ph1">&lt;xref:System.Guid.NewGuid%2A&gt;</ph>来创建跨所有都是唯一的类别值<ph id="ph2">&lt;xref:System.Guid&gt;</ph>值，执行此操作是不必要的。</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>The category value needs to be distinct only from other categories, not from all other <ph id="ph1">&lt;xref:System.Guid&gt;</ph> values.</source>
          <target state="translated">类别值必须是不同于其他类别，不是从所有其他仅<ph id="ph1">&lt;xref:System.Guid&gt;</ph>值。</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>For example, you can assign <ph id="ph1">{00000000-0000-0000-0000-000000000001}</ph> as the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph> for one set of queues and <ph id="ph3">{00000000-0000-0000-0000-000000000002}</ph> as the <ph id="ph4">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph> for another set.</source>
          <target state="translated">例如，你可以分配<ph id="ph1">{00000000-0000-0000-0000-000000000001}</ph>作为<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph>为一组队列和<ph id="ph3">{00000000-0000-0000-0000-000000000002}</ph>作为<ph id="ph4">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph>为另一组。</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>It is not necessary to set the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph>.</source>
          <target state="translated">不需要设置<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>The value can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">该值可以为 <ph id="ph1">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>Setting this property modifies the Message Queuing queue.</source>
          <target state="translated">将此属性设置修改消息队列队列。</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>Therefore, any other <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> instances are affected by the change.</source>
          <target state="translated">因此，任何其他<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>的更改会影响实例。</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Category">
          <source>The following code example gets and sets the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例获取和设置的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.Category">
          <source>The queue category was set to an invalid value.</source>
          <target state="translated">队列类别被设置为无效值。</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.Category">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ClearConnectionCache">
          <source>Clears the connection cache.</source>
          <target state="translated">清除连接缓存。</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ClearConnectionCache">
          <source>When you call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ClearConnectionCache%2A&gt;</ph>, the format names stored in the cache are removed and handles opened and stored in the cache are closed.</source>
          <target state="translated">当调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ClearConnectionCache%2A&gt;</ph>，将删除缓存中存储的格式名，并且关闭句柄打开并存储在缓存中。</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ClearConnectionCache">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ClearConnectionCache">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ClearConnectionCache">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ClearConnectionCache">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ClearConnectionCache">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ClearConnectionCache">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ClearConnectionCache">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ClearConnectionCache">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ClearConnectionCache">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ClearConnectionCache">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ClearConnectionCache">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ClearConnectionCache">
          <source>The following code example calls <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ClearConnectionCache%2A&gt;</ph>.</source>
          <target state="translated">下面的代码示例调用 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ClearConnectionCache%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Close">
          <source>Frees all resources allocated by the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>.</source>
          <target state="translated">释放 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 分配的所有资源。</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Close%2A&gt;</ph> frees all resources associated with a <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>, including shared resources if appropriate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Close%2A&gt;</ph> 释放与关联的所有资源<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>，包括根据共享资源。</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>The system re-acquires these resources automatically if they are still available, for example when you call the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph> method, as in the following C# code.</source>
          <target state="translated">系统自动重新获取这些资源它们是否仍然可用，例如当调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph>方法，如下面的 C# 代码所示。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>When you call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Close%2A&gt;</ph>, all <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> properties that directly access the Message Queuing queue are cleared out. The <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph>, and <ph id="ph6">&lt;xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A&gt;</ph> all remain as they were.</source>
          <target state="translated">当调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Close%2A&gt;</ph>，所有<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>直接访问消息队列队列的属性会清除。<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>， <ph id="ph4">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>， <ph id="ph5">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph>，和<ph id="ph6">&lt;xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A&gt;</ph>所有保持不变。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Close%2A&gt;</ph> does not always free the read and write handles to a queue, because they might be shared.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Close%2A&gt;</ph> 不会不能始终释放读取和写入队列的句柄，因为它们可能被共享。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>You can take any of the following steps to ensure that <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Close%2A&gt;</ph> frees the read and write handles to a queue:</source>
          <target state="translated">你可以采取以下步骤以确保任一<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Close%2A&gt;</ph>释放到队列的读取和写入句柄：</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>Create the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> with exclusive access.</source>
          <target state="translated">创建<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>具有独占访问权。</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>To do so, call the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> constructor, and set the <ph id="ph3">`sharedModeDenyReceive`</ph> parameter to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">为此，请调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>构造函数，并且组<ph id="ph3">`sharedModeDenyReceive`</ph>参数<ph id="ph4">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>Create the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> with connection caching disabled.</source>
          <target state="translated">创建<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>禁用了连接缓存。</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>To do so, call the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> constructor and set the <ph id="ph2">`enableConnectionCache`</ph> parameter to <ph id="ph3">`false`</ph>.</source>
          <target state="translated">为此，请调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph>构造函数和组<ph id="ph2">`enableConnectionCache`</ph>参数<ph id="ph3">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>Disable connection caching.</source>
          <target state="translated">禁用连接缓存。</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>To do so, set the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EnableConnectionCache%2A&gt;</ph> property to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">为此，请设置<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EnableConnectionCache%2A&gt;</ph>属性<ph id="ph2">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>You should call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Close%2A&gt;</ph> for a queue before you delete the queue on the Message Queuing server.</source>
          <target state="translated">应调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Close%2A&gt;</ph>队列之前删除消息队列服务器上的队列。</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>Otherwise, messages sent to the queue could throw exceptions or appear in the dead-letter queue.</source>
          <target state="translated">否则为，请发送到队列的消息无法引发异常，或出现在死信队列中。</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Close">
          <source>The following code example closes a Message Queuing queue.</source>
          <target state="translated">下面的代码示例将关闭消息队列的队列。</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Creates a new queue at the specified path on a Message Queuing server.</source>
          <target state="translated">在“消息队列”服务器上的指定路径中创建新队列。</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>The path of the queue to create.</source>
          <target state="translated">要创建的队列的路径。</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>Creates a non-transactional Message Queuing queue at the specified path.</source>
          <target state="translated">在指定的路径中创建非事务性“消息队列”队列。</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> that represents the new queue.</source>
          <target state="translated">表示新队列的 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>Use this overload to create a non-transactional Message Queuing queue.</source>
          <target state="translated">使用此重载以创建消息队列的非事务性队列。</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>To create a new instance of the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class in your application and bind it to an existing queue, use the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">若要创建的新实例<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>类在你的应用程序并将其绑定到现有队列，而使用<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.%23ctor%2A&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>To create a new queue in Message Queuing, call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Create%28System.String%29&gt;</ph>.</source>
          <target state="translated">若要在消息队列中创建新队列，调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Create%28System.String%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>The syntax for the <ph id="ph1">`path`</ph> parameter depends on the type of queue it references, as shown in the following table.</source>
          <target state="translated">语法<ph id="ph1">`path`</ph>参数取决于队列的类型它的引用下, 表中所示。</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>Queue type</source>
          <target state="translated">队列类型</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>Syntax</source>
          <target state="translated">语法</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>Public queue</source>
          <target state="translated">公用队列</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>Private queue</source>
          <target state="translated">专用队列</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>Use "." for the local computer.</source>
          <target state="translated">使用"。"本地计算机。</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>For more syntax, see the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> property.</source>
          <target state="translated">有关更多的语法，请参阅<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>The following code example creates public and private queues.</source>
          <target state="translated">下面的代码示例创建了公用和专用队列。</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>It sends a message to selected queues.</source>
          <target state="translated">它将消息发送到所选队列。</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 或者是空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>A queue already exists at the specified path.</source>
          <target state="translated">队列已存在于指定的路径中。</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Create(System.String)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>The path of the queue to create.</source>
          <target state="translated">要创建的队列的路径。</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to create a transactional queue; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to create a non-transactional queue.</source>
          <target state="translated">如果创建事务性队列，为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；如果创建非事务性队列，则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>Creates a transactional or non-transactional Message Queuing queue at the specified path.</source>
          <target state="translated">在指定的路径中创建事务性或非事务性“消息队列”队列。</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> that represents the new queue.</source>
          <target state="translated">表示新队列的 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>You can use this overload to create a transactional queue in Message Queuing.</source>
          <target state="translated">此重载可用于在消息队列中创建事务性队列。</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>You can create a non-transactional queue, by setting the <ph id="ph1">`transactional`</ph> parameter to <ph id="ph2">`false`</ph> or by calling the other overload of <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.Create%28System.String%29&gt;</ph>.</source>
          <target state="translated">可以创建非事务性队列时，通过设置<ph id="ph1">`transactional`</ph>参数<ph id="ph2">`false`</ph>或通过调用的其他重载<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.Create%28System.String%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>To create a new instance of the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class in your application and bind it to an existing queue, use the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">若要创建的新实例<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>类在你的应用程序并将其绑定到现有队列，而使用<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.%23ctor%2A&gt;</ph>构造函数。</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>To create a new queue in Message Queuing, call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Create%28System.String%29&gt;</ph>.</source>
          <target state="translated">若要在消息队列中创建新队列，调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Create%28System.String%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>The syntax for the <ph id="ph1">`path`</ph> parameter depends on the type of queue it references, as shown in the following table.</source>
          <target state="translated">语法<ph id="ph1">`path`</ph>参数取决于队列的类型它的引用下, 表中所示。</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>Queue type</source>
          <target state="translated">队列类型</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>Syntax</source>
          <target state="translated">语法</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>Public queue</source>
          <target state="translated">公用队列</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>Private queue</source>
          <target state="translated">专用队列</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>Use "." for the local computer.</source>
          <target state="translated">使用"。"本地计算机。</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>For more syntax, see the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> property.</source>
          <target state="translated">有关更多的语法，请参阅<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>The following code example creates public and private transactional queues.</source>
          <target state="translated">下面的代码示例创建公钥和私钥的事务性队列。</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>It sends a message to selected queues.</source>
          <target state="translated">它将消息发送到所选队列。</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 或者是空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>A queue already exists at the specified path.</source>
          <target state="translated">队列已存在于指定的路径中。</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.CreateCursor">
          <source>Creates a new <ph id="ph1">&lt;see cref="T:System.Messaging.Cursor" /&gt;</ph> for the current message queue.</source>
          <target state="translated">为当前消息队列创建新的 <ph id="ph1">&lt;see cref="T:System.Messaging.Cursor" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.CreateCursor">
          <source>A new <ph id="ph1">&lt;see cref="T:System.Messaging.Cursor" /&gt;</ph> for the current message queue.</source>
          <target state="translated">当前消息队列的新 <ph id="ph1">&lt;see cref="T:System.Messaging.Cursor" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.CreateCursor">
          <source>This cursor is used to maintain a specific location in the queue when reading the queue's messages.</source>
          <target state="translated">此游标用于在读取队列的消息时保持队列中的特定位置。</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.CreateTime">
          <source>Gets the time and date that the queue was created in Message Queuing.</source>
          <target state="translated">获取在“消息队列”中创建队列的时间和日期。</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CreateTime">
          <source>A <ph id="ph1">&lt;see cref="T:System.DateTime" /&gt;</ph> that represents the date and time at which the queue was created.</source>
          <target state="translated">表示队列创建日期和时间的 <ph id="ph1">&lt;see cref="T:System.DateTime" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CreateTime">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CreateTime%2A&gt;</ph> refers to the queue on the Message Queuing server, not the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CreateTime%2A&gt;</ph> 不是指在消息队列服务器上，队列<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>实例。</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CreateTime">
          <source>If the queue exists, this property represents the time the queue was created, adjusted to the local time of the server on which the queue exists.</source>
          <target state="translated">如果该队列存在，则此属性表示创建队列，队列所在的服务器的本地时间调整的时间。</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CreateTime">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CreateTime">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CreateTime">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CreateTime">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CreateTime">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CreateTime">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CreateTime">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CreateTime">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CreateTime">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CreateTime">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CreateTime">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.CreateTime">
          <source>The following code example displays the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CreateTime%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例显示的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.CreateTime%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.CreateTime">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>Gets or sets the message property values to be used by default when the application sends messages to the queue.</source>
          <target state="translated">获取或设置(当应用程序向队列发送消息时)默认情况下使用的消息属性值。</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.DefaultPropertiesToSend" /&gt;</ph> that contains the default Message Queuing message property values used when the application sends objects other than <ph id="ph2">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> instances to the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.DefaultPropertiesToSend" /&gt;</ph>，它包含当应用程序向队列发送 <ph id="ph2">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> 实例以外的对象时使用的默认“消息队列”消息属性值。</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>When you send any object that is not of type <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph> to the queue, the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> inserts the object into a Message Queuing message.</source>
          <target state="translated">如果要将发送的类型不是任何对象<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>到队列，<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>将对象插入到消息队列消息。</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>At that time, the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> applies to the message the property values you specify in the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> property.</source>
          <target state="translated">在那时，<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>适用于消息中指定的属性值<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>Conversely, if you send a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph> to the queue, these properties are already specified for the instance itself, so <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> is ignored for the <ph id="ph3">&lt;xref:System.Messaging.Message&gt;</ph>.</source>
          <target state="translated">相反，如果你发送<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>到队列，这些属性已指定为该实例本身，因此<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>对于，将忽略<ph id="ph3">&lt;xref:System.Messaging.Message&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>Although you set the properties through the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> object, the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> refers to the properties of the messages that are sent to the queue, not the queue itself.</source>
          <target state="translated">尽管您设置的属性通过<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>对象，<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>引用的是发送到队列，队列本身的消息属性。</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>The default values for the properties are shown in the following table.</source>
          <target state="translated">下表中显示属性的默认值。</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>Property</source>
          <target state="translated">Property</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>Default value</source>
          <target state="translated">默认值</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>Zero (0)</source>
          <target state="translated">零 (0)</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>A zero-length array of bytes</source>
          <target state="translated">一个零长度的字节数组</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>Empty string ("")</source>
          <target state="translated">空字符串 ("")</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>The following code example uses the priority of a message to determine default properties to send for the message.</source>
          <target state="translated">下面的代码示例使用一条消息的优先级来确定要发送的消息的默认属性。</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.DefaultPropertiesToSend">
          <source>The default properties could not be set for the queue, possibly because one of the properties is not valid.</source>
          <target state="translated">未能设置队列的默认属性，可能因为这些属性之一无效。</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>The location of the queue to be deleted.</source>
          <target state="translated">要删除的队列的位置。</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Deletes a queue on a Message Queuing server.</source>
          <target state="translated">删除“消息队列”服务器上的队列。</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>The syntax for the <ph id="ph1">`path`</ph> parameter depends on the type of queue.</source>
          <target state="translated">语法<ph id="ph1">`path`</ph>参数依赖于的队列的类型。</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Queue type</source>
          <target state="translated">队列类型</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Syntax</source>
          <target state="translated">语法</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Public queue</source>
          <target state="translated">公用队列</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Private queue</source>
          <target state="translated">专用队列</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>For more syntax, see the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> property.</source>
          <target state="translated">有关更多的语法，请参阅<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph> to describe the queue path.</source>
          <target state="translated">或者，可以使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>来描述队列路径。</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Reference</source>
          <target state="translated">参考</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Syntax</source>
          <target state="translated">语法</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Format name</source>
          <target state="translated">格式名称</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>FormatName:[ <bpt id="p1">*</bpt>format name<ept id="p1">*</ept> ]</source>
          <target state="translated">通过 FormatName: [<bpt id="p1">*</bpt>格式名<ept id="p1">*</ept>]</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Label</source>
          <target state="translated">Label</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Label:[ <bpt id="p1">*</bpt>label<ept id="p1">*</ept> ]</source>
          <target state="translated">标签: [<bpt id="p1">*</bpt>标签<ept id="p1">*</ept>]</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>The following code example deletes a Message Queuing queue, if it exists.</source>
          <target state="translated">下面的代码示例删除消息队列队列中，如果它存在。</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or is an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 或者是空字符串 ("")。</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>The syntax for the <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is not valid.</source>
          <target state="translated">该 <ph id="ph1">&lt;paramref name="path" /&gt;</ph> 参数的语法无效。</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Delete(System.String)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source>Gets or sets a value that indicates whether this <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> has exclusive access to receive messages from the Message Queuing queue.</source>
          <target state="translated">获取或设置一个值，该值指示此 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 对来自“消息队列”队列的消息是否有独占接收访问权。</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> has exclusive rights to receive messages from the queue; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果此 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 对来自队列的消息有独占接收权，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DenySharedReceive%2A&gt;</ph> specifies the shared mode of the queue referenced by this <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DenySharedReceive%2A&gt;</ph> 指定引用此队列的共享的模式<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source>Set <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DenySharedReceive%2A&gt;</ph> to <ph id="ph2">`true`</ph> to indicate that only this <ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph> should have access to peek or receive messages from the queue with the specified <ph id="ph4">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>.</source>
          <target state="translated">设置<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DenySharedReceive%2A&gt;</ph>到<ph id="ph2">`true`</ph>以指示只有这<ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph>应具有访问权限以查看或从指定的队列接收消息<ph id="ph4">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source>If another <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> or another application is associated with the same queue resource, that instance or application will not be able to peek or receive messages, but it can still send them.</source>
          <target state="translated">如果另一个<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>或者通过同一队列资源，该实例关联的另一个应用程序或应用程序将不能查看或接收消息，但它仍可发送它们。</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source>If <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DenySharedReceive%2A&gt;</ph> is <ph id="ph2">`false`</ph>, the queue is available to multiple applications for sending, peeking, or receiving messages.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DenySharedReceive%2A&gt;</ph>是<ph id="ph2">`false`</ph>，队列可供多个应用程序来发送、 扫视、 或接收消息。</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.DenySharedReceive">
          <source>The following code example gets and sets the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DenySharedReceive%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例获取和设置的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DenySharedReceive%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated">若要释放托管资源和非托管资源，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；若仅释放非托管资源，则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Dispose(System.Boolean)">
          <source>Disposes of the resources (other than memory) used by the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>.</source>
          <target state="translated">处置由 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 占用的资源（内存除外）。</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Dispose(System.Boolean)">
          <source>Call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29&gt;</ph> when you are finished using the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>.</source>
          <target state="translated">在完成使用 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29&gt;</ph> 后，应调用 <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Dispose(System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> in an unusable state.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29&gt;</ph> 方法使 <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> 处于不可用状态。</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Dispose(System.Boolean)">
          <source>After calling <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29&gt;</ph>, you must release all references to the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> so the memory it was occupying can be reclaimed by garbage collection.</source>
          <target state="translated">在调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29&gt;</ph>，必须释放对所有引用<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>以便可以通过垃圾回收回收其占用的内存。</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Dispose(System.Boolean)">
          <source>You should call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29&gt;</ph> before you release your last reference to the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>.</source>
          <target state="translated">应调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29&gt;</ph>在发布到最后一个引用之前<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Dispose(System.Boolean)">
          <source>Otherwise, the resources the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> is using will not be freed until garbage collection calls the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> object's destructor.</source>
          <target state="translated">否则为资源<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>是使用不会被释放之前垃圾集合调用<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>对象的析构函数。</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>Gets or sets a value that indicates whether a cache of connections will be maintained by the application.</source>
          <target state="translated">获取或设置一个值，该值指示应用程序是否维护连接缓存。</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to create and use a connection cache; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果创建和使用连接缓存，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>A connection cache is a list of references to structures that contain read or write handles to queues.</source>
          <target state="translated">连接缓存是对结构包含读取或写入队列的句柄的引用列表。</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>When <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EnableConnectionCache%2A&gt;</ph> is <ph id="ph2">`true`</ph>, the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph> borrows handles from the cache each time you call <ph id="ph4">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph>, <ph id="ph5">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>, or <ph id="ph6">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>, rather than open new handles.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EnableConnectionCache%2A&gt;</ph>是<ph id="ph2">`true`</ph>、<ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph>借用从缓存的句柄您每次调用<ph id="ph4">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph>， <ph id="ph5">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>，或<ph id="ph6">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>，而不是打开新的句柄。</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>This can improve performance.</source>
          <target state="translated">这可以提高性能。</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>Using a connection cache also insulates the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> from changes in the network topology.</source>
          <target state="translated">使用连接缓存还使<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>网络拓扑中的更改。</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>If you create a new connection to a queue when the connection cache is full, the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> overwrites the least recently accessed structure with the new connection.</source>
          <target state="translated">如果你创建新的连接到队列，当连接缓存已满，<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>覆盖最近访问最少的结构与新的连接。</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>You can clear the cache entirely by calling <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ClearConnectionCache%2A&gt;</ph>, for example, if the format names of the queues you are working with have changed so that the previous read and write handles are no longer valid.</source>
          <target state="translated">你可以完全由调用清除缓存<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ClearConnectionCache%2A&gt;</ph>，例如，如果你正在使用的队列的格式名已更改，以便以前的读取和写入句柄不再有效。</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EnableConnectionCache">
          <source>The following code example gets and sets the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EnableConnectionCache%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例获取和设置的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EnableConnectionCache%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>Gets or sets a value that indicates whether the queue accepts only non-private (non-encrypted) messages.</source>
          <target state="translated">获取或设置一个指示队列是否只接受非私有（非加密）消息的值。</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.EncryptionRequired" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.EncryptionRequired" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>The default is <ph id="ph1">&lt;see langword="None" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="None" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>When you specify that encryption is required for the messages sent to a queue, only the message bodies are encrypted.</source>
          <target state="translated">指定该加密是必需的消息发送到队列时，只有消息正文进行加密。</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>The other members (for example, the <ph id="ph1">&lt;xref:System.Messaging.Message.Label%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.Message.SenderId%2A&gt;</ph> properties) cannot be encrypted.</source>
          <target state="translated">其他成员 (例如，<ph id="ph1">&lt;xref:System.Messaging.Message.Label%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Messaging.Message.SenderId%2A&gt;</ph>属性) 不能被加密。</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>Setting this property modifies the Message Queuing queue.</source>
          <target state="translated">将此属性设置修改消息队列队列。</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>Therefore, any other <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> instances are affected by the change.</source>
          <target state="translated">因此，任何其他<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>的更改会影响实例。</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>Encrypting a message makes the message private.</source>
          <target state="translated">加密的邮件将使私有消息。</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>You can specify the queue's encryption requirement to be <ph id="ph1">`None`</ph>, <ph id="ph2">`Body`</ph>, or <ph id="ph3">`Optional`</ph> by setting the <ph id="ph4">&lt;xref:System.Messaging.MessageQueue.EncryptionRequired%2A&gt;</ph> property appropriately.</source>
          <target state="translated">你可以指定队列的加密需要<ph id="ph1">`None`</ph>， <ph id="ph2">`Body`</ph>，或<ph id="ph3">`Optional`</ph>通过设置<ph id="ph4">&lt;xref:System.Messaging.MessageQueue.EncryptionRequired%2A&gt;</ph>属性正确。</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.UseEncryption%2A&gt;</ph> setting of the message must correspond to the encryption requirement of the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.UseEncryption%2A&gt;</ph>消息的设置必须与对应的队列的加密要求。</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>If the message is not encrypted but the queue specifies <ph id="ph1">`Body`</ph>, or if the message is encrypted but the queue specifies <ph id="ph2">`None`</ph>, the message is rejected by the queue.</source>
          <target state="translated">如果未加密消息，而队列指定<ph id="ph1">`Body`</ph>，或者如果消息已加密，而队列指定<ph id="ph2">`None`</ph>，消息被拒绝由队列。</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>If the sending application requests a negative acknowledgment message in this event, Message Queuing indicates the message's rejection to the sending application.</source>
          <target state="translated">如果发送应用程序请求在这种情况的否定确认消息，消息队列指示发送应用程序的消息遭到拒绝。</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>If the <ph id="ph1">&lt;xref:System.Messaging.Message.UseDeadLetterQueue%2A&gt;</ph> property is <ph id="ph2">`true`</ph>, a message that fails encryption is sent to the dead-letter queue.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Messaging.Message.UseDeadLetterQueue%2A&gt;</ph>属性是<ph id="ph2">`true`</ph>，加密失败消息发送到死信队列。</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>Otherwise, the message is lost.</source>
          <target state="translated">否则，消息将丢失。</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>The following code example gets and sets the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EncryptionRequired%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例获取和设置的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EncryptionRequired%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.EncryptionRequired">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that identifies the asynchronous peek operation to finish and from which to retrieve an end result.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> 标识要完成的异步查看操作，并且从它检索最终结果。</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>Completes the specified asynchronous peek operation.</source>
          <target state="translated">完成指定的异步查看操作。</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> associated with the completed asynchronous operation.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> 与已完成的异步操作关联。</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>When the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event is raised, <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph> completes the operation that was initiated by the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> call.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>引发事件时，<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>完成由启动的操作<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>调用。</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>To do so, <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph> peeks the message.</source>
          <target state="translated">为此，请<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>查看的消息。</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> can specify a time-out, which causes the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event to be raised if the time-out occurs before a message appears in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> 可以指定超时，这会导致<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>如果队列中出现一条消息之前发生超时的时候引发的事件。</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>When a time-out occurs without a message arriving in the queue, a subsequent call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph> throws an exception.</source>
          <target state="translated">当发生超时则没有消息到达队列的后续调用中<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>引发异常。</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph> is used to read the message that caused the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event to be raised.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph> 用于读取导致的消息<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>引发事件。</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>If you want to continue to asynchronously peek messages, you can again call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> after calling <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>.</source>
          <target state="translated">如果你想要继续以异步方式扫视消息，则可以再次调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>之后调用<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>The following code example creates an event handler named <ph id="ph1">`MyPeekCompleted`</ph>, attaches it to the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event handler delegate, and calls <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> to initiate an asynchronous peek operation on the queue that is located at the path ".\myQueue".</source>
          <target state="translated">下面的代码示例创建名为一个事件处理程序<ph id="ph1">`MyPeekCompleted`</ph>，将其附加到<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>事件处理程序委托，然后调用<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>启动位于路径的队列上的异步查看操作"。 \myQueue"。</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>When a <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event is raised, the example peeks the message and writes its body to the screen.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>引发事件，该示例扫视消息，并将其正文写入到屏幕。</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>The example then calls <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> again to initiate a new asynchronous peek operation.</source>
          <target state="translated">该示例然后调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>以启动新的异步扫视操作。</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>The syntax of the <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> parameter is not valid.</source>
          <target state="translated">该 <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> 参数的语法无效。</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that identifies the asynchronous receive operation to finish and from which to retrieve an end result.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> 标识要完成的异步接收操作，并且从它检索最终结果。</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>Completes the specified asynchronous receive operation.</source>
          <target state="translated">完成指定的异步接收操作。</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> associated with the completed asynchronous operation.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> 与已完成的异步操作关联。</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>When the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event is raised, <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph> completes the operation that was initiated by the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> call.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>引发事件时，<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>完成由启动的操作<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>调用。</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>To do so, <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph> receives the message.</source>
          <target state="translated">为此，请<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>接收消息。</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> can specify a time-out, which causes the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event to be raised if the time-out occurs before a message appears in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> 可以指定超时，这会导致<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>如果队列中出现一条消息之前发生超时的时候引发的事件。</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>When a time-out occurs without a message arriving in the queue, a subsequent call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph> throws an exception.</source>
          <target state="translated">当发生超时则没有消息到达队列的后续调用中<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>引发异常。</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph> is used to read (removing from the queue) the message that caused the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event to be raised.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph> 用于读取 （从队列中删除） 导致的消息<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>引发事件。</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>If you want to continue to asynchronously receive messages, you can again call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> after calling <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>.</source>
          <target state="translated">如果你想要继续以异步方式接收消息，则可以再次调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>之后调用<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>The following code example chains asynchronous requests.</source>
          <target state="translated">下面的代码示例链接异步请求。</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>It assumes there is a queue on the local computer called "myQueue".</source>
          <target state="translated">它假定名为"myQueue"的本地计算机上没有队列。</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">`Main`</ph> function begins the asynchronous operation that is handled by the <ph id="ph2">`MyReceiveCompleted`</ph> routine.</source>
          <target state="translated"><ph id="ph1">`Main`</ph>函数开始异步操作由处理<ph id="ph2">`MyReceiveCompleted`</ph>例程。</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source><ph id="ph1">`MyReceiveCompleted`</ph> processes the current message and begins a new asynchronous receive operation.</source>
          <target state="translated"><ph id="ph1">`MyReceiveCompleted`</ph> 处理当前消息并开始一个新异步接收操作。</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>The syntax of the <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> parameter is not valid.</source>
          <target state="translated">该 <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> 参数的语法无效。</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>The location of the queue to find.</source>
          <target state="translated">要查找的队列的位置。</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>Determines whether a Message Queuing queue exists at the specified path.</source>
          <target state="translated">确定指定的路径中是否存在“消息队列”队列。</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if a queue with the specified path exists; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果指定的路径中存在队列，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Exists%28System.String%29&gt;</ph> method determines whether a Message Queuing queue exists at a specified path.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Exists%28System.String%29&gt;</ph>方法确定消息队列的队列是否存在在指定路径。</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>No method exists to determine whether a queue with a specified format name exists.</source>
          <target state="translated">不存在的方法来确定是否存在具有指定的格式名称的队列。</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>For more information about the format name syntax and other path syntax forms, see the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> property.)</source>
          <target state="translated">有关格式名语法和其他路径语法窗体的详细信息，请参阅<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>属性。)</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Exists%28System.String%29&gt;</ph> is an expensive operation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Exists%28System.String%29&gt;</ph> 是代价高昂的操作。</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>Use it only when it is necessary within the application.</source>
          <target state="translated">应用程序中的必要时，请使用它。</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Exists%28System.String%29&gt;</ph> method does not support the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph> prefix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Exists%28System.String%29&gt;</ph>方法不支持<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph>前缀。</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>The syntax for the <ph id="ph1">`path`</ph> parameter depends on the type of queue, as shown in the following table.</source>
          <target state="translated">语法<ph id="ph1">`path`</ph>参数取决于队列的类型下表中所示。</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>Queue type</source>
          <target state="translated">队列类型</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>Syntax</source>
          <target state="translated">语法</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>Public queue</source>
          <target state="translated">公用队列</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Exists%28System.String%29&gt;</ph> cannot be called to verify the existence of a remote private queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Exists%28System.String%29&gt;</ph> 无法调用它以验证远程专用队列存在。</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>For more syntax, see the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> property.</source>
          <target state="translated">有关更多的语法，请参阅<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph> to describe the queue path.</source>
          <target state="translated">或者，可以使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>来描述队列路径。</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>Reference</source>
          <target state="translated">参考</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>Syntax</source>
          <target state="translated">语法</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>Label</source>
          <target state="translated">Label</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>Label:[ <ph id="ph1">`label`</ph> ]</source>
          <target state="translated">标签: [ <ph id="ph1">`label`</ph> ]</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>The following code example verifies whether a Message Queuing queue exists, and then deletes it.</source>
          <target state="translated">下面的代码示例验证消息队列的队列是否存在，，然后将其删除。</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> syntax is not valid.</source>
          <target state="translated">该 <ph id="ph1">&lt;paramref name="path" /&gt;</ph> 语法无效。</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>The <ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /&gt;</ph> method is being called on a remote private queue</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /&gt;</ph> 方法正被远程专用队列调用。</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Exists(System.String)">
          <source>The application used format name syntax when verifying queue existence.</source>
          <target state="translated">应用程序在验证队列是否存在时使用的格式名语法。</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>Gets the unique queue name that Message Queuing generated at the time of the queue's creation.</source>
          <target state="translated">获取“消息队列”在创建队列时生成的唯一队列名。</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>The name for the queue, which is unique on the network.</source>
          <target state="translated">队列的名称，该名称在网络上是唯一的。</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph> property contains the format name of the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph>属性包含队列的格式名。</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>Message Queuing uses the format name to identify which queue to open and how to access it.</source>
          <target state="translated">消息队列使用的格式名来标识要打开的队列以及如何访问它。</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>Unlike most of a queue's characteristics, the format name is not a Message Queuing application queue property, so you cannot access it through the Message Queuing management tool.</source>
          <target state="translated">与大部分队列的特征，不同的格式名不是消息队列应用程序队列属性，因此不能通过消息队列管理工具访问它。</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>The format name is simply a unique name for the queue, which Message Queuing generates when it creates the queue or which the application generates later.</source>
          <target state="translated">格式名只是的唯一名称的队列，当它创建队列或更高版本生成应用程序的消息队列生成的。</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>If you specify a path using the path name syntax (such as <ph id="ph1">`myComputer\myQueue`</ph>) rather than using the format name syntax when you read or write to the queue, the primary domain controller (which uses Active Directory) translates the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> into the associated <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph> before accessing the queue.</source>
          <target state="translated">如果指定路径中使用的路径名称语法 (如<ph id="ph1">`myComputer\myQueue`</ph>) 而不是在读取或写入到队列时，请使用格式名称语法，主域控制器 （它使用 Active Directory） 将转换<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>到关联的<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph>之前访问该队列。</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>If your application is working offline, you must use the format name syntax; otherwise, the primary domain controller will not be available to perform the path translation.</source>
          <target state="translated">如果你的应用程序正在脱机工作，则必须使用格式名称语法;否则，该域的主域控制器将不可以执行路径翻译。</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>The following code example displays the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例显示的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> is not set.</source>
          <target state="translated">未设置 <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.FormatName">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>Gets or sets the formatter used to serialize an object into or deserialize an object from the body of a message read from or written to the queue.</source>
          <target state="translated">获取或设置格式化程序，该格式化程序用于将对象序列化为从队列读取或写入队列的消息体，或者用于将从队列读取或写入队列的消息体反序列化为对象。</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.IMessageFormatter" /&gt;</ph> that produces a stream to be written to or read from the message body.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.Messaging.IMessageFormatter" /&gt;</ph> 产生要写入消息体或要从消息体中读取的流。</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>The default is <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see cref="T:System.Messaging.XmlMessageFormatter" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph> property contains an instance of a formatter object, which transforms messages when your application reads or writes to the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph>属性包含一个格式化程序对象，该转换时你的应用程序读取或写入到队列的消息对象的实例。</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>When the application sends message to the queue, the formatter serializes the object into a stream and inserts it into the message body.</source>
          <target state="translated">当应用程序将消息发送到队列时，格式化程序对象序列化为流，并将它插入到消息正文。</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>When reading from a queue, the formatter deserializes the message data into the <ph id="ph1">&lt;xref:System.Messaging.Message.Body%2A&gt;</ph> property of a <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>.</source>
          <target state="translated">当从队列中读取，格式化程序反序列化到消息数据<ph id="ph1">&lt;xref:System.Messaging.Message.Body%2A&gt;</ph>属性<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph> is loosely coupled, so it is not necessary to have the same object type on the sender and receiver when using this format.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>松散耦合的因此不需要时使用此格式键入发送方和接收方将相同对象。</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.ActiveXMessageFormatter&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.BinaryMessageFormatter&gt;</ph> serialize the data into binary representation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.ActiveXMessageFormatter&gt;</ph>和<ph id="ph2">&lt;xref:System.Messaging.BinaryMessageFormatter&gt;</ph>数据序列化为二进制表示形式。</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.ActiveXMessageFormatter&gt;</ph> is used when sending or receiving COM components.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.ActiveXMessageFormatter&gt;</ph>发送或接收 COM 组件时使用。</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source><ph id="ph1">&lt;xref:System.Messaging.BinaryMessageFormatter&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.ActiveXMessageFormatter&gt;</ph> provide faster throughput than the <ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.BinaryMessageFormatter&gt;</ph> 和<ph id="ph2">&lt;xref:System.Messaging.ActiveXMessageFormatter&gt;</ph>提供更快吞吐量要高于<ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.ActiveXMessageFormatter&gt;</ph> allows interoperability with Visual Basic 6.0 Message Queuing applications.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.ActiveXMessageFormatter&gt;</ph>允许与 Visual Basic 6.0 消息队列应用程序的互操作性。</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>When your application sends messages to the queue, the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType&gt;</ph> applies only to those messages that use the default message properties, <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>.</source>
          <target state="translated">当你的应用程序将消息发送到队列，<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType&gt;</ph>仅适用于使用默认消息属性，这些消息<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>If you send a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph> to the queue, Message Queuing uses the formatter defined in the <ph id="ph2">&lt;xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType&gt;</ph> property to serialize the body instead.</source>
          <target state="translated">如果你发送<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>到队列，消息队列使用格式化程序中定义<ph id="ph2">&lt;xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType&gt;</ph>要改为序列化正文的属性。</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class will always use a <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph> to receive or peek a message from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>类将始终使用<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>接收或查看从队列的消息。</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>The message is deserialized using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">消息使用反序列化<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>The following code example demonstrates formatting a message body using <ph id="ph1">&lt;xref:System.Messaging.BinaryMessageFormatter&gt;</ph>.</source>
          <target state="translated">下面的代码示例演示了格式设置消息正文使用<ph id="ph1">&lt;xref:System.Messaging.BinaryMessageFormatter&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Formatter">
          <source>The following code example demonstrates formatting a message body using <ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>.</source>
          <target state="translated">下面的代码示例演示了格式设置消息正文使用<ph id="ph1">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source>Returns all the messages that are in the queue.</source>
          <target state="translated">返回位于队列中的所有消息。</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that represents all the messages in the queue, in the same order as they appear in the Message Queuing queue.</source>
          <target state="translated">类型 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> 的数组，表示队列中所有消息，其顺序与这些消息在“消息队列”队列中的出现顺序相同。</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetAllMessages%2A&gt;</ph> returns a static snapshot of the messages in the queue, not dynamic links to those messages.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetAllMessages%2A&gt;</ph> 返回这些消息的队列中的消息，不是动态链接的静态快照。</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source>Therefore, you cannot use the array to modify the messages in the queue.</source>
          <target state="translated">因此，数组不能用于修改在队列中的消息。</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source>If you want real-time, dynamic interaction with the queue (such as the ability to delete messages), call the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A&gt;</ph> method, which returns a dynamic list of the messages in the queue.</source>
          <target state="translated">如果您需要与队列 （如删除消息的能力） 的实时、 动态交互，调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A&gt;</ph>方法，返回队列中的动态列表的消息。</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetAllMessages%2A&gt;</ph> returns a copy of the messages in the queue at the time the method was called, the array does not reflect new messages that arrive in the queue or messages that are removed from the queue.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetAllMessages%2A&gt;</ph>调用该方法返回的队列中的消息副本时，该数组不会反映新消息到达队列中或从队列中删除的消息。</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetAllMessages%2A&gt;</ph> retrieves only those properties not filtered out by the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetAllMessages%2A&gt;</ph> 检索不通过筛选出这些属性<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetAllMessages%2A&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetAllMessages%2A&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetAllMessages">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetEnumerator">
          <source>Enumerates the messages in a queue.</source>
          <target state="translated">枚举队列中的消息。</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetEnumerator">
          <source><ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.GetEnumerator" /&gt;</ph> is deprecated.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.GetEnumerator" /&gt;</ph> 已弃用。</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetEnumerator">
          <source><ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /&gt;</ph> should be used instead.</source>
          <target state="translated">应改用 <ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetEnumerator">
          <source>A <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> that provides a dynamic connection to the messages in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph>，它提供与队列消息的动态连接。</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetEnumerator">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetEnumerator">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetEnumerator">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetEnumerator">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetEnumerator">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetEnumerator">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetEnumerator">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetEnumerator">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetEnumerator">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetEnumerator">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetEnumerator">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetEnumerator">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetEnumerator%2A&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetEnumerator%2A&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>The name of the computer that contains the queue, without the two preceding backslashes (<ph id="ph1">\\</ph><ph id="ph2">\\</ph>).</source>
          <target state="translated">包含队列的计算机的名称，名称前不含两个反斜杠 (<ph id="ph1">\\</ph><ph id="ph2">\\</ph>)。</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>Gets the identifier of the computer on which the queue referenced by this <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> is located.</source>
          <target state="translated">获取计算机的标识符，此 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 引用的队列位于该计算机上。</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> that represents a unique identifier for the computer on which the queue is located.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph>，表示队列所在的计算机的唯一标识符。</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>You can use a computer's identifier for two purposes, among others: to read the computer journal and to set security certificates.</source>
          <target state="translated">你可以有两个用途，以及其他使用计算机的标识符： 读取计算机日志和设置的安全证书。</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>However, you cannot call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29&gt;</ph> for a remote computer when you are working offline because the application must have access to the directory service on the domain controller.</source>
          <target state="translated">但是，不能调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29&gt;</ph>以远程计算机时脱机工作因为的应用程序必须对目录服务的访问，域控制器上。</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>The computer identifier (or machine identifier) is a <ph id="ph1">&lt;xref:System.Guid&gt;</ph> that Message Queuing creates when a computer is added to the enterprise.</source>
          <target state="translated">计算机标识符 （或的计算机标识符） 是<ph id="ph1">&lt;xref:System.Guid&gt;</ph>消息队列时，创建一台计算机添加到企业。</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>Message Queuing combines the computer identifier with the <ph id="ph1">`Machine`</ph> and <ph id="ph2">`Journal`</ph> keywords to create the machine journal's format name, which has the syntax <ph id="ph3">`Machine=&lt;computeridentifier&gt;;Journal`</ph>.</source>
          <target state="translated">消息队列结合使用计算机标识符<ph id="ph1">`Machine`</ph>和<ph id="ph2">`Journal`</ph>关键字创建具有语法的计算机日记格式名<ph id="ph3">`Machine=&lt;computeridentifier&gt;;Journal`</ph>。</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>The machine journal, which is also known as the journal queue, is a system queue that stores copies of application-generated messages when the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.UseJournalQueue%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">计算机日记，也称为作为日记队列中，是用于存储的副本的系统队列应用程序生成消息时<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.UseJournalQueue%2A&gt;</ph>属性是<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>This syntax for the journal is only valid when constructing the format name for the queue.</source>
          <target state="translated">构造队列格式名时，此语法为日志才有效。</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>The path name syntax is <ph id="ph1">`MachineName`</ph><ph id="ph2">\\</ph><ph id="ph3">`Journal$`</ph>.</source>
          <target state="translated">路径名称语法不<ph id="ph1">`MachineName`</ph> <ph id="ph2">\\</ph> <ph id="ph3">`Journal$`</ph>。</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>The following code example calls <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29&gt;</ph>.</source>
          <target state="translated">下面的代码示例调用 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>The computer identifier could not be retrieved, possibly because the directory service is not available; for example, if you are working offline.</source>
          <target state="translated">未能检索到计算机标识符，可能是因为目录服务不可用，例如当正在脱机工作时。</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetMachineId(System.String)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>Creates an enumerator object for all the messages in the queue.</source>
          <target state="translated">为队列中的所有消息创建枚举数对象。</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source><ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /&gt;</ph> is deprecated.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /&gt;</ph> 已弃用。</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source><ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /&gt;</ph> should be used instead.</source>
          <target state="translated">应改用 <ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.MessageEnumerator" /&gt;</ph> holding the messages that are contained in the queue.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageEnumerator" /&gt;</ph> 包括队列中所包含的消息。</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A&gt;</ph> creates a dynamic list of all the messages in a queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A&gt;</ph> 在队列中创建的所有消息的动态列表。</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>You can remove from the queue the message at the enumerator's current position by calling <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> for the <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> that <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A&gt;</ph> returns.</source>
          <target state="translated">你可以从队列中删除位于枚举器的当前位置的消息通过调用<ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph>为<ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph>，<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A&gt;</ph>返回。</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>Because the cursor is associated with the dynamic list of messages in the queue, the enumeration reflects any modification you make to the messages in the queue, if the message is beyond the current cursor position.</source>
          <target state="translated">因为光标位于与队列中消息的动态列表相关联，则枚举将反映对消息在队列中，进行任何修改，如果消息已超出了当前光标位置。</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>For example, the enumerator can automatically access a lower-priority message placed beyond the cursor's current position, but not a higher-priority message inserted before that position.</source>
          <target state="translated">例如，枚举数可以自动访问放置光标的当前位置，之外优先级较低的消息，但不是在该位置之前插入优先级较高的消息。</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>However, you can reset the enumeration, thereby moving the cursor back to the beginning of the list, by calling <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Reset%2A&gt;</ph> for the <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph>.</source>
          <target state="translated">但是，你可以重置枚举，从而移动光标返回到的列表中，通过调用<ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Reset%2A&gt;</ph>为<ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>The order of the messages in the enumeration reflects their order in the queue, so higher-priority messages will appear before lower-priority ones.</source>
          <target state="translated">枚举中消息的顺序反映在队列中，其顺序，因此优先级高的消息将出现在优先级较低之前。</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>If you want a static snapshot of the messages in the queue rather than a dynamic connection to them, call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetAllMessages%2A&gt;</ph>.</source>
          <target state="translated">如果您需要在队列，而不是动态连接到它们的消息的静态快照，调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetAllMessages%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>This method returns an array of <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph> objects, which represent the messages at the time the method was called.</source>
          <target state="translated">此方法返回的数组<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>对象，表示该方法调用时的消息。</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator">
          <source>The following code example gets a dynamic list of messages in a queue and counts all messages with the <ph id="ph1">&lt;xref:System.Messaging.Message.Priority%2A&gt;</ph> property set to <ph id="ph2">&lt;xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">下面的代码示例获取队列中消息的动态列表和使用的所有消息进行都计数<ph id="ph1">&lt;xref:System.Messaging.Message.Priority%2A&gt;</ph>属性设置为<ph id="ph2">&lt;xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>Creates an enumerator object for all the messages in the queue.</source>
          <target state="translated">为队列中的所有消息创建枚举数对象。</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.MessageEnumerator" /&gt;</ph> holding the messages that are contained in the queue.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageEnumerator" /&gt;</ph> 包括队列中所包含的消息。</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A&gt;</ph> creates a dynamic list of all the messages in a queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A&gt;</ph> 在队列中创建的所有消息的动态列表。</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>You can remove from the queue the message at the enumerator's current position by calling <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph> for the <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph> that <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A&gt;</ph> returns.</source>
          <target state="translated">你可以从队列中删除位于枚举器的当前位置的消息通过调用<ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A&gt;</ph>为<ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph>，<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A&gt;</ph>返回。</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>Because the cursor is associated with the dynamic list of messages in the queue, the enumeration reflects any modification you make to the messages in the queue, if the message is beyond the current cursor position.</source>
          <target state="translated">因为光标位于与队列中消息的动态列表相关联，则枚举将反映对消息在队列中，进行任何修改，如果消息已超出了当前光标位置。</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>For example, the enumerator can automatically access a lower-priority message placed beyond the cursor's current position, but not a higher-priority message inserted before that position.</source>
          <target state="translated">例如，枚举数可以自动访问放置光标的当前位置，之外优先级较低的消息，但不是在该位置之前插入优先级较高的消息。</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>However, you can reset the enumeration, thereby moving the cursor back to the beginning of the list, by calling <ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Reset%2A&gt;</ph> for the <ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph>.</source>
          <target state="translated">但是，你可以重置枚举，从而移动光标返回到的列表中，通过调用<ph id="ph1">&lt;xref:System.Messaging.MessageEnumerator.Reset%2A&gt;</ph>为<ph id="ph2">&lt;xref:System.Messaging.MessageEnumerator&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>The order of the messages in the enumeration reflects their order in the queue, so higher-priority messages will appear before lower-priority ones.</source>
          <target state="translated">枚举中消息的顺序反映在队列中，其顺序，因此优先级高的消息将出现在优先级较低之前。</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>If you want a static snapshot of the messages in the queue rather than a dynamic connection to them, call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetAllMessages%2A&gt;</ph>.</source>
          <target state="translated">如果您需要在队列，而不是动态连接到它们的消息的静态快照，调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetAllMessages%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>This method returns an array of <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph> objects, which represent the messages at the time the method was called.</source>
          <target state="translated">此方法返回的数组<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>对象，表示该方法调用时的消息。</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageEnumerator2">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Creates an enumerator object for a dynamic listing of the public queues on the network.</source>
          <target state="translated">为网络上公共队列的动态列表创建枚举数对象。</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>Provides forward-only cursor semantics to enumerate through all public queues on the network.</source>
          <target state="translated">提供只进游标语义，以枚举网络上的所有公共队列。</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueEnumerator" /&gt;</ph> that provides a dynamic listing of all the public message queues on the network.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueEnumerator" /&gt;</ph>，提供网络上所有公共消息队列的动态列表。</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>This overload of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A&gt;</ph> returns an enumeration of all the public queues that are on the network.</source>
          <target state="translated">此重载<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A&gt;</ph>返回位于网络上的所有公用队列的枚举。</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>Because the cursor is associated with a dynamic listing, the enumeration reflects any modification you make to a queue list for queues deleted or added beyond the cursor's current position.</source>
          <target state="translated">因为光标位于与动态列表相关联，则枚举反映对删除或添加光标的当前位置之后的队列的队列列表进行任何修改。</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>Additions or deletion of queues located before the cursor's current position are not reflected.</source>
          <target state="translated">添加或删除队列位于光标的当前位置之前不会反映。</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>For example, the enumerator can automatically access a queue appended beyond the cursor position but not one inserted before that position.</source>
          <target state="translated">例如，枚举数可以自动访问追加之外光标位置的队列，但不是一插入该位置之前。</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>However, you can reset the enumeration, thereby moving the cursor back to the beginning of the list, by calling <ph id="ph1">&lt;xref:System.Messaging.MessageQueueEnumerator.Reset%2A&gt;</ph> for the <ph id="ph2">&lt;xref:System.Messaging.MessageQueueEnumerator&gt;</ph>.</source>
          <target state="translated">但是，你可以重置枚举，从而移动光标返回到的列表中，通过调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueueEnumerator.Reset%2A&gt;</ph>为<ph id="ph2">&lt;xref:System.Messaging.MessageQueueEnumerator&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>There is no defined ordering of queues in a network.</source>
          <target state="translated">没有任何已定义的排序的网络中的队列。</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>An enumerator does not order them, for example, by computer, label, public or private status, or any other accessible criteria.</source>
          <target state="translated">一个枚举器不会不通过进行排序，例如，计算机、 标签、 公共或私有状态或任何其他可访问的条件。</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>If you want a static snapshot of the queues on the network rather than a dynamic connection to them, call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPublicQueues%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29&gt;</ph>.</source>
          <target state="translated">如果您需要静态快照的网络，而不是与它们的动态连接上的队列，调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPublicQueues%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>Each of these two methods returns an array of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> objects, which represent the queues at the time the method was called.</source>
          <target state="translated">这两种方法的每个返回的数组<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>对象，表示该方法调用时的队列。</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>The following code example iterates through all the message queues in the network, and examines the path for each queue.</source>
          <target state="translated">下面的代码示例循环访问网络中的所有消息队列，并检查每个队列的路径。</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator">
          <source>Finally, it displays the number of public queues on the network.</source>
          <target state="translated">最后，它显示网络上的公用队列的数量。</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueCriteria" /&gt;</ph> that contains the criteria used to filter the available message queues.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueCriteria" /&gt;</ph>，包含用于筛选可用消息队列的判据。</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>Provides forward-only cursor semantics to enumerate through all public queues on the network that meet the specified criteria.</source>
          <target state="translated">提供只进游标语义，以枚举网络上满足指定判据的所有公共队列。</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueEnumerator" /&gt;</ph> that provides a dynamic listing of the public message queues on the network that satisfy the restrictions specified by the <ph id="ph2">&lt;paramref name="criteria" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueEnumerator" /&gt;</ph>，提供网络上公共消息队列的动态列表，这些消息队列满足 <ph id="ph2">&lt;paramref name="criteria" /&gt;</ph> 参数指定的限制。</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>This overload of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A&gt;</ph> returns a listing of all the public queues on the network that satisfy criteria defined in the application criteria.</source>
          <target state="translated">此重载<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A&gt;</ph>返回满足条件的应用程序条件中定义的网络上的所有公用队列的列表。</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>You can specify the criteria to include, for example, queue creation or modification time, computer name, label, category, or any combination of these.</source>
          <target state="translated">你可以指定条件后，若要包括，例如，队列创建或修改时间、 计算机名、 标签、 类别或这些项的组合。</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>Because the cursor is associated with a dynamic listing, the enumeration reflects any modification you make to a queue that occurs beyond the cursor's current position.</source>
          <target state="translated">因为光标位于与动态列表相关联，则枚举反映对队列发生游标的当前位置之后进行任何修改。</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>Changes to queues located before the cursor's current position are not reflected.</source>
          <target state="translated">不反映对队列位于光标的当前位置之前的更改。</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>For example, the enumerator can automatically access a queue appended beyond the cursor position but not one inserted before that position.</source>
          <target state="translated">例如，枚举数可以自动访问追加之外光标位置的队列，但不是一插入该位置之前。</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>However, you can reset the enumeration, thereby moving the cursor back to the beginning of the list, by calling <ph id="ph1">&lt;xref:System.Messaging.MessageQueueEnumerator.Reset%2A&gt;</ph> for the <ph id="ph2">&lt;xref:System.Messaging.MessageQueueEnumerator&gt;</ph>.</source>
          <target state="translated">但是，你可以重置枚举，从而移动光标返回到的列表中，通过调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueueEnumerator.Reset%2A&gt;</ph>为<ph id="ph2">&lt;xref:System.Messaging.MessageQueueEnumerator&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>There is no defined ordering of queues in a network.</source>
          <target state="translated">没有任何已定义的排序的网络中的队列。</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>An enumerator does not order them, for example, by computer, label, public or private status, or any other accessible criteria.</source>
          <target state="translated">一个枚举器不会不通过进行排序，例如，计算机、 标签、 公共或私有状态或任何其他可访问的条件。</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>If you want a static snapshot of the queues on the network rather than a dynamic connection to them, specify criteria for <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPublicQueues%2A&gt;</ph> or call <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29&gt;</ph>.</source>
          <target state="translated">如果你希望网络而不是与它们的动态连接上的队列的静态快照，指定用于条件<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPublicQueues%2A&gt;</ph>或调用<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>Each of these two methods returns an array of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> objects, which represent the queues at the time the method was called.</source>
          <target state="translated">这两种方法的每个返回的数组<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>对象，表示该方法调用时的队列。</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>Calling <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29&gt;</ph>, or <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29&gt;</ph> provides the same results as calling <ph id="ph4">&lt;xref:System.Messaging.MessageQueue.GetPublicQueues%2A&gt;</ph> with the filtering criteria of <ph id="ph5">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>, and <ph id="ph7">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>, respectively.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29&gt;</ph>， <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29&gt;</ph>，或<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29&gt;</ph>提供相同的结果与调用<ph id="ph4">&lt;xref:System.Messaging.MessageQueue.GetPublicQueues%2A&gt;</ph>使用的筛选条件<ph id="ph5">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph>， <ph id="ph6">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>，和<ph id="ph7">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>分别。</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)">
          <source>The following code example iterates through message queues and displays the path of each queue that was created in the last day and that exists on the computer "MyComputer".</source>
          <target state="translated">下面的代码示例循环访问消息队列，并显示"MyComputer"的计算机上的每个队列中的最后一天的已创建并存在的路径。</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)">
          <source>The computer from which to retrieve the private queues.</source>
          <target state="translated">计算机，从其中检索专用队列。</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)">
          <source>Retrieves all the private queues on the specified computer.</source>
          <target state="translated">检索指定计算机上的所有专用队列。</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> objects that reference the retrieved private queues.</source>
          <target state="translated">引用检索的专用队列的 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 对象数组。</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29&gt;</ph> retrieves a static snapshot of the queues on a specified computer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29&gt;</ph> 检索指定计算机上的队列的静态快照。</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)">
          <source>The following code example retrieves lists of queues.</source>
          <target state="translated">下面的代码示例检索队列的列表。</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="machineName" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="machineName" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph> 或是空字符串（“”）。</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Retrieves all the public queues on the network.</source>
          <target state="translated">检索网络上的所有公共队列。</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>Retrieves all the public queues on the network.</source>
          <target state="translated">检索网络上的所有公共队列。</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> objects that reference the retrieved public queues.</source>
          <target state="translated">引用检索的公共队列的 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 对象数组。</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>Use this overload if you want a complete list of all the public queues on the network.</source>
          <target state="translated">如果你想在网络上的所有公用队列的完整列表，请使用此重载。</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>If you want to restrict the list by certain criteria, such as <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph>, or last modified time use another overload of this method.</source>
          <target state="translated">如果你想要按某些条件，如限制列表<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph>，或上次修改的时间使用此方法的另一个重载。</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>(Alternatively, you can use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29&gt;</ph>, or <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29&gt;</ph>.)</source>
          <target state="translated">(或者，可以使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29&gt;</ph>， <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29&gt;</ph>，或<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29&gt;</ph>。)</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPublicQueues%2A&gt;</ph> retrieves a static snapshot of the queues.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPublicQueues%2A&gt;</ph> 检索队列的静态快照。</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>To interact with a dynamic list of the queues, use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A&gt;</ph>.</source>
          <target state="translated">若要与队列的动态列表进行交互，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>The following code example retrieves lists of queues.</source>
          <target state="translated">下面的代码示例检索队列的列表。</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueues">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueCriteria" /&gt;</ph> that contains the criteria used to filter the queues.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueCriteria" /&gt;</ph>，包含用于筛选队列的判据。</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>Retrieves all the public queues on the network that meet the specified criteria.</source>
          <target state="translated">检索网络上满足指定判据的所有公共队列。</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> objects that reference the retrieved public queues.</source>
          <target state="translated">引用检索的公共队列的 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 对象数组。</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>If you want to filter all the public queues on the network by label, category, or computer name, the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> class contains specific methods that provide that functionality (<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29&gt;</ph>, <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29&gt;</ph>, and <ph id="ph4">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29&gt;</ph>, respectively).</source>
          <target state="translated">如果你想要按标签、 类别或计算机名称，筛选在网络上的所有公用队列<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>类包含提供该功能的特定方法 (<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29&gt;</ph>， <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29&gt;</ph>，和<ph id="ph4">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29&gt;</ph>分别)。</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>Use this overload to get a list of all the public queues on the network that meet more than one of these criteria (for example, if you want to specify both a label and a category).</source>
          <target state="translated">使用此重载以获取网络上 （例如，如果你想要指定一个标签和类别） 满足多个这些条件之一的所有公用队列的列表。</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>You can also filter by message criteria other than <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>.</source>
          <target state="translated">你还可以筛选按消息条件以外<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>For example, you use this overload to filter by a queue's last-modified time.</source>
          <target state="translated">例如，你可以使用此重载按队列的上次修改时间进行筛选。</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>Simply create a new instance of the <ph id="ph1">&lt;xref:System.Messaging.MessageQueueCriteria&gt;</ph> class, set the appropriate properties in the instance, and pass the instance as the <ph id="ph2">`criteria`</ph> parameter.</source>
          <target state="translated">只需创建的新实例<ph id="ph1">&lt;xref:System.Messaging.MessageQueueCriteria&gt;</ph>类，请在实例中，设置适当的属性并将实例作为传递<ph id="ph2">`criteria`</ph>参数。</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPublicQueues%2A&gt;</ph> retrieves a static snapshot of the queues.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPublicQueues%2A&gt;</ph> 检索队列的静态快照。</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>To interact with a dynamic list of the queues, use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A&gt;</ph>.</source>
          <target state="translated">若要与队列的动态列表进行交互，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>The following code example retrieves lists of queues.</source>
          <target state="translated">下面的代码示例检索队列的列表。</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph> that groups the set of queues to be retrieved.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Guid" /&gt;</ph>，它将要检索的队列集分组。</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>Retrieves all the public queues on the network that belong to the specified category.</source>
          <target state="translated">检索网络上所有属于指定类别的公共队列。</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> objects that reference the retrieved public queues.</source>
          <target state="translated">引用检索的公共队列的 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 对象数组。</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>Use this method to filter the public queues by category.</source>
          <target state="translated">使用此方法以按类别筛选公用队列。</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph> property provides access to the Message Queuing type ID property (which is read/write) of a particular queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph>属性提供访问权限的消息队列类型 ID 属性 （这是读/写） 的特定队列。</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>Although you can use <ph id="ph1">&lt;xref:System.Guid.NewGuid%2A&gt;</ph> to create a category value that is unique across all <ph id="ph2">&lt;xref:System.Guid&gt;</ph> values, it is not necessary.</source>
          <target state="translated">尽管可以使用<ph id="ph1">&lt;xref:System.Guid.NewGuid%2A&gt;</ph>来创建跨所有都是唯一的类别值<ph id="ph2">&lt;xref:System.Guid&gt;</ph>值，则没有必要。</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>The category value needs to be distinct only from other categories, not from all other <ph id="ph1">&lt;xref:System.Guid&gt;</ph> values.</source>
          <target state="translated">类别值必须是不同于其他类别，不是从所有其他仅<ph id="ph1">&lt;xref:System.Guid&gt;</ph>值。</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>For example, you can assign <ph id="ph1">{00000000-0000-0000-0000-000000000001}</ph> as the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph> for one set of queues and <ph id="ph3">{00000000-0000-0000-0000-000000000002}</ph> as the <ph id="ph4">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph> for another set.</source>
          <target state="translated">例如，你可以分配<ph id="ph1">{00000000-0000-0000-0000-000000000001}</ph>作为<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph>为一组队列和<ph id="ph3">{00000000-0000-0000-0000-000000000002}</ph>作为<ph id="ph4">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph>为另一组。</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29&gt;</ph> retrieves a static snapshot of the queues.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29&gt;</ph> 检索队列的静态快照。</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>To interact with a dynamic list of the queues, use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A&gt;</ph>.</source>
          <target state="translated">若要与队列的动态列表进行交互，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>You can specify the category as part of the <ph id="ph1">&lt;xref:System.Messaging.MessageQueueCriteria&gt;</ph> you pass into the method.</source>
          <target state="translated">你可以作为的一部分指定类别<ph id="ph1">&lt;xref:System.Messaging.MessageQueueCriteria&gt;</ph>传递到方法。</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>The following code example retrieves lists of queues.</source>
          <target state="translated">下面的代码示例检索队列的列表。</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>A label that groups the set of queues to be retrieved.</source>
          <target state="translated">一个标签，它将要检索的队列集分组。</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>Retrieves all the public queues on the network that carry the specified label.</source>
          <target state="translated">检索网络上带有指定标签的所有公共队列。</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> objects that reference the retrieved public queues.</source>
          <target state="translated">引用检索的公共队列的 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 对象数组。</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>Use this method to filter the public queues by label.</source>
          <target state="translated">使用此方法以按标签筛选公用队列。</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29&gt;</ph> retrieves a static snapshot of the queues.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29&gt;</ph> 检索队列的静态快照。</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>To interact with a dynamic list of the queues, use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A&gt;</ph>.</source>
          <target state="translated">若要与队列的动态列表进行交互，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>You can specify the label as part of the <ph id="ph1">&lt;xref:System.Messaging.MessageQueueCriteria&gt;</ph> you pass into the method.</source>
          <target state="translated">你可以作为的一部分指定的标签<ph id="ph1">&lt;xref:System.Messaging.MessageQueueCriteria&gt;</ph>传递到方法。</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>The following code example retrieves lists of queues.</source>
          <target state="translated">下面的代码示例检索队列的列表。</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="label" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="label" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>The name of the computer that contains the set of public queues to be retrieved.</source>
          <target state="translated">计算机的名称，该计算机包含要检索的公共队列集。</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>Retrieves all the public queues that reside on the specified computer.</source>
          <target state="translated">检索驻留在指定计算机上的所有公共队列。</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> objects that reference the public queues on the computer.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 对象数组，这些对象引用该计算机上的公共队列。</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>Use this method to filter the public queues by computer.</source>
          <target state="translated">使用此方法以按计算机筛选公用队列。</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29&gt;</ph> retrieves a static snapshot of the queues.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29&gt;</ph> 检索队列的静态快照。</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>To interact with a dynamic list of the queues, use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A&gt;</ph>.</source>
          <target state="translated">若要与队列的动态列表进行交互，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>You can specify the computer name as part of the <ph id="ph1">&lt;xref:System.Messaging.MessageQueueCriteria&gt;</ph> you pass into the method.</source>
          <target state="translated">你可以指定计算机名称作为的一部分<ph id="ph1">&lt;xref:System.Messaging.MessageQueueCriteria&gt;</ph>传递到方法。</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>The following code example retrieves lists of queues.</source>
          <target state="translated">下面的代码示例检索队列的列表。</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="machineName" /&gt;</ph> parameter has incorrect syntax.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="machineName" /&gt;</ph> 参数的语法不正确。</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetSecurityContext">
          <source>Retrieves the security context that MSMQ associates with the current user (thread identity) at the time of this call.</source>
          <target state="translated">检索进行此调用时 MSMQ 将当前用户（线程标识）关联到的安全上下文。</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.GetSecurityContext">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.SecurityContext" /&gt;</ph> object that contains the security context.</source>
          <target state="translated">包含安全上下文的 <ph id="ph1">&lt;see cref="T:System.Messaging.SecurityContext" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.Id">
          <source>Gets the unique Message Queuing identifier of the queue.</source>
          <target state="translated">获取队列的唯一“消息队列”标识符。</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Id">
          <source>A <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Id" /&gt;</ph> that represents the message identifier generated by the Message Queuing application.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Id" /&gt;</ph>，表示由“消息队列”应用程序生成的消息标识符。</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Id">
          <source>Message Queuing sets the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Id%2A&gt;</ph> property when it creates the queue.</source>
          <target state="translated">消息队列集<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Id%2A&gt;</ph>属性在创建队列时。</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Id">
          <source>This property is only available for public queues.</source>
          <target state="translated">此属性才可用于公用队列。</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Id">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Id">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Id">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Id">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Id">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Id">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Id">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Id">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Id">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Id">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Id">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Id">
          <source>The following code example displays the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Id%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例显示的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Id%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.Id">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="F:System.Messaging.MessageQueue.InfiniteQueueSize">
          <source>Specifies that no size restriction exists for a queue.</source>
          <target state="translated">指定对某队列不存在大小限制。</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Messaging.MessageQueue.InfiniteQueueSize">
          <source>This member is frequently used when setting <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MaximumJournalSize%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.MaximumQueueSize%2A&gt;</ph>.</source>
          <target state="translated">此成员常用设置时<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MaximumJournalSize%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.MaximumQueueSize%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Messaging.MessageQueue.InfiniteQueueSize">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteQueueSize&gt;</ph> member.</source>
          <target state="translated">下面的代码示例演示如何将<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteQueueSize&gt;</ph>成员。</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" uid="F:System.Messaging.MessageQueue.InfiniteTimeout">
          <source>Specifies that no time-out exists for methods that peek or receive messages.</source>
          <target state="translated">指定对查看或接收消息的方法不存在超时设定。</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Messaging.MessageQueue.InfiniteTimeout">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> supports two types of message retrieval: synchronous and asynchronous.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> 支持两种类型的消息检索： 同步和异步。</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Messaging.MessageQueue.InfiniteTimeout">
          <source>The synchronous methods, <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>, cause the process thread to wait a specified time interval for a new message to arrive in the queue.</source>
          <target state="translated">同步方法，<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>，会导致进程线程等待新消息到达队列中指定的时间间隔。</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Messaging.MessageQueue.InfiniteTimeout">
          <source>If the specified time interval is <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph>, the process thread remains blocked until a new message is available.</source>
          <target state="translated">如果指定的时间间隔是<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph>，进程线程保持被阻止，直到有可用的新消息。</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Messaging.MessageQueue.InfiniteTimeout">
          <source>On the other hand, <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> (the asynchronous methods), allow the main application tasks to continue in a separate thread until a message arrives in the queue.</source>
          <target state="translated">另一方面，<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>（异步方法），允许以继续在一个单独的线程，直到消息到达队列中的主应用程序任务。</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Messaging.MessageQueue.InfiniteTimeout">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph> member.</source>
          <target state="translated">下面的代码示例演示如何将<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph>成员。</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.Label">
          <source>Gets or sets the queue description.</source>
          <target state="translated">获取或设置队列说明。</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Label">
          <source>The label for the message queue.</source>
          <target state="translated">消息队列的标签。</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Label">
          <source>The default is an empty string ("").</source>
          <target state="translated">默认值为空字符串("")。</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Label">
          <source>The maximum length of a message queue label is 124 characters.</source>
          <target state="translated">消息队列标签的最大长度为 124 个字符。</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Label">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph> property does not need to be unique across all queues.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>属性不需要是唯一的跨所有队列。</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Label">
          <source>However, if multiple queues share the same <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>, you cannot use the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph> method to broadcast a message to all of them.</source>
          <target state="translated">但是，如果多个队列共用同一个<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>，不能使用<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph>方法来广播到所有这些消息。</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Label">
          <source>If you use the label syntax for the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> property when you send the message, an exception will be thrown if the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph> is not unique.</source>
          <target state="translated">如果你使用的标签语法<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>属性在发送消息时，将引发异常，如果<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>不是唯一的。</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Label">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Label">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Label">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Label">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Label">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Label">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Label">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Label">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Label">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Label">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Label">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Label">
          <source>The following code example gets and sets the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例获取和设置的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.Label">
          <source>The label was set to an invalid value.</source>
          <target state="translated">标签被设置为无效值。</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.Label">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.LastModifyTime">
          <source>Gets the last time the properties of a queue were modified.</source>
          <target state="translated">获取队列属性的最近修改时间。</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.LastModifyTime">
          <source>A <ph id="ph1">&lt;see cref="T:System.DateTime" /&gt;</ph> that indicates when the queue properties were last modified.</source>
          <target state="translated">指示队列属性最近修改时间的 <ph id="ph1">&lt;see cref="T:System.DateTime" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.LastModifyTime">
          <source>The last modification time includes when the queue was created and any <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> property that modifies the Message Queuing queue, such as <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BasePriority%2A&gt;</ph>.</source>
          <target state="translated">上次修改时间包括创建队列和任何<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>属性，修改消息队列队列中，如<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BasePriority%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.LastModifyTime">
          <source>The value of the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.LastModifyTime%2A&gt;</ph> property represents the system time of the local computer.</source>
          <target state="translated">值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.LastModifyTime%2A&gt;</ph>属性表示本地计算机的系统时间。</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.LastModifyTime">
          <source>You must call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Refresh%2A&gt;</ph> before getting the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.LastModifyTime%2A&gt;</ph> property; otherwise, the modification time associated with this <ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph> might not be current.</source>
          <target state="translated">必须调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Refresh%2A&gt;</ph>之前获取<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.LastModifyTime%2A&gt;</ph>属性; 否则，修改时间关联与此<ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph>可能不是最新。</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.LastModifyTime">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.LastModifyTime">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.LastModifyTime">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.LastModifyTime">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.LastModifyTime">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.LastModifyTime">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.LastModifyTime">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.LastModifyTime">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.LastModifyTime">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.LastModifyTime">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.LastModifyTime">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.LastModifyTime">
          <source>The following code example displays the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.LastModifyTime%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例显示的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.LastModifyTime%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.LastModifyTime">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Gets or sets the name of the computer where the Message Queuing queue is located.</source>
          <target state="translated">获取或设置“消息队列”队列所在的计算机的名称。</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>The name of the computer where the queue is located.</source>
          <target state="translated">队列所在的计算机的名称。</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>The Message Queuing default is ".", the local computer.</source>
          <target state="translated">“消息队列”默认值为“.”，即本地计算机。</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph> is an integral component of the friendly name syntax of the queue <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>是必不可少的组成部分的队列的友好名称语法<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>The following table shows the syntax you should use for a queue of a specified type when you want to identify the queue path using its friendly name.</source>
          <target state="translated">下表显示当你想要确定使用其友好名称的队列路径时应使用具有指定类型的队列的语法。</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Queue type</source>
          <target state="translated">队列类型</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Syntax</source>
          <target state="translated">语法</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Public queue</source>
          <target state="translated">公用队列</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Private queue</source>
          <target state="translated">专用队列</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Journal queue</source>
          <target state="translated">日记队列</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Machine journal queue</source>
          <target state="translated">计算机日记队列</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Machine dead-letter queue</source>
          <target state="translated">机死信队列</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Machine transactional dead-letter queue</source>
          <target state="translated">计算机事务性死信队列</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Use "." for the local computer when specifying the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>.</source>
          <target state="translated">使用"。"本地计算机时指定<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Only the computer name is recognized for this property, for example, <ph id="ph1">`Server0`</ph>.</source>
          <target state="translated">例如，对于此属性，识别仅的计算机名称<ph id="ph1">`Server0`</ph>。</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph> property does not support the IP address format.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>属性不支持 IP 地址格式。</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>If you define the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> in terms of the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>, the application throws an exception when working offline because the domain controller is required for path translation.</source>
          <target state="translated">如果你定义<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>方面<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>，应用程序会引发异常，因为域控制器是路径翻译需要脱机工作时。</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Therefore, you must use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph> for the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> syntax when working offline.</source>
          <target state="translated">因此，你必须使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph>为<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>脱机工作时的语法。</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph> properties are related.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph>相关属性。</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Changing the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph> property causes the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> property to change.</source>
          <target state="translated">更改<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>属性会导致<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>属性可以更改。</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>It is built from the new <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph> and the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph>.</source>
          <target state="translated">从新生成<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Changing the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> (for example, to use the format name syntax) resets the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph> properties to refer to the new queue.</source>
          <target state="translated">更改<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>（例如，若要使用的格式名称语法） 将重置<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>和<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph>属性来引用新队列。</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>If the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph> property is empty, the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> is set to the Journal queue of the computer you specify.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph>属性为空，<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>设置为指定的计算机日记队列。</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>The following code example gets and sets the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例获取和设置的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>The name of the computer is not valid, possibly because the syntax is incorrect.</source>
          <target state="translated">计算机名称无效，可能是因为语法不正确。</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.MachineName">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>Gets or sets the maximum size of the journal queue.</source>
          <target state="translated">获取或设置日记队列的最大大小。</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>The maximum size, in kilobytes, of the journal queue.</source>
          <target state="translated">日记队列的最大大小，以千字节为单位。</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>The Message Queuing default specifies that no limit exists.</source>
          <target state="translated">“消息队列”默认设置指定：不存在任何限制。</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MaximumJournalSize%2A&gt;</ph> provides access to the Message Queuing journal storage limit.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MaximumJournalSize%2A&gt;</ph> 提供对消息队列的日志存储限制访问。</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>It is relevant only when <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.UseJournalQueue%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">它是唯一时才可用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.UseJournalQueue%2A&gt;</ph>是<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>Setting this property modifies the Message Queuing queue.</source>
          <target state="translated">将此属性设置修改消息队列队列。</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>Therefore, any other <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> instances are affected by the change</source>
          <target state="translated">因此，任何其他<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>的更改会影响实例</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>If you store messages in a journal or dead-letter queue, you should periodically clear the queue to remove messages that are no longer needed.</source>
          <target state="translated">如果在日志或死信队列中存储消息，则应该定期清除要删除不再需要的消息的队列。</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>Messages in such a queue count toward the message quota for the computer where the queue resides.</source>
          <target state="translated">此类队列中的消息计入队列所驻留的计算机的消息配额。</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>(The administrator sets the computer quota.)</source>
          <target state="translated">（管理员设置的计算机配额。）</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>The following code example gets and sets the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MaximumJournalSize%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例获取和设置的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MaximumJournalSize%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>The maximum journal queue size was set to an invalid value.</source>
          <target state="translated">日记队列的最大大小被设置为无效值。</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.MaximumJournalSize">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>Gets or sets the maximum size of the queue.</source>
          <target state="translated">获取或设置队列的最大大小。</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>The maximum size, in kilobytes, of the queue.</source>
          <target state="translated">队列的最大大小，以千字节为单位。</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>The Message Queuing default specifies that no limit exists.</source>
          <target state="translated">“消息队列”默认设置指定：不存在任何限制。</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MaximumQueueSize%2A&gt;</ph> provides access to the Message Queuing message storage limit, which is separate from the computer's message quota that the administrator defines.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MaximumQueueSize%2A&gt;</ph>提供对消息队列消息的存储限制，这不同于管理员定义的计算机的消息配额的访问。</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>For more information about the message quota, see <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MaximumJournalSize%2A&gt;</ph>.</source>
          <target state="translated">有关消息配额的详细信息，请参阅<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MaximumJournalSize%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>Setting this property modifies the Message Queuing queue.</source>
          <target state="translated">将此属性设置修改消息队列队列。</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>Therefore, any other <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> instances are affected by the change</source>
          <target state="translated">因此，任何其他<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>的更改会影响实例</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>If an attempt is made to exceed either the maximum queue size or the computer message quota, messages might be lost.</source>
          <target state="translated">如果尝试超过最大队列大小或计算机消息配额，消息可能会丢失。</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>When the queue quota is reached, Message Queuing notifies the administration queue of the sending application to indicate that the queue is full, by returning a negative acknowledgment message.</source>
          <target state="translated">当达到队列配额时，消息队列通知发送的应用程序，以指示，队列已满，通过返回否定确认消息的管理队列。</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>Message Queuing continues to send negative acknowledgments until the total size of the messages in the queue drops below the limit.</source>
          <target state="translated">消息队列将继续发送否定确认，直到在队列中消息的总大小低于该限制。</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>The following code example gets and sets the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MaximumQueueSize%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例获取和设置的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MaximumQueueSize%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>The maximum queue size contains a negative value.</source>
          <target state="translated">队列最大大小包含负值。</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.MaximumQueueSize">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>Gets or sets the property filter for receiving or peeking messages.</source>
          <target state="translated">获取或设置接收或查看消息的属性筛选器。</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.MessagePropertyFilter" /&gt;</ph> used by the queue to filter the set of properties it receives or peeks for each message.</source>
          <target state="translated">由队列使用的 <ph id="ph1">&lt;see cref="T:System.Messaging.MessagePropertyFilter" /&gt;</ph>，用来筛选队列所接收或查看的每个消息的属性集。</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>This filter is a set of Boolean values restricting the message properties that the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> receives or peeks.</source>
          <target state="translated">此筛选器是一套限制的消息属性的布尔值，<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>接收或查看。</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>When the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> receives or peeks a message from the server queue, it retrieves only those properties for which the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A&gt;</ph> value is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>接收或查看消息从服务器队列中，它仅检索那些为其<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A&gt;</ph>值是<ph id="ph3">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>The following shows initial property values for the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A&gt;</ph> property.</source>
          <target state="translated">下面显示的初始属性值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>These settings are identical to calling <ph id="ph1">&lt;xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A&gt;</ph> on a <ph id="ph2">&lt;xref:System.Messaging.MessagePropertyFilter&gt;</ph>.</source>
          <target state="translated">这些设置是相当于调用<ph id="ph1">&lt;xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A&gt;</ph>上<ph id="ph2">&lt;xref:System.Messaging.MessagePropertyFilter&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>Property</source>
          <target state="translated">Property</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>Default value</source>
          <target state="translated">默认值</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>1024 bytes</source>
          <target state="translated">1024 个字节</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>255 bytes</source>
          <target state="translated">255 个字节</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>255 bytes</source>
          <target state="translated">255 个字节</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A&gt;</ph> to restrict the message properties received.</source>
          <target state="translated">下面的代码示例使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A&gt;</ph>限制收到的消息属性。</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.MessageReadPropertyFilter">
          <source>The filter is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">筛选器为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>Introduced in MSMQ 3.0.</source>
          <target state="translated">在 MSMQ 3.0 中引入。</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>Gets or sets the multicast address associated with the queue.</source>
          <target state="translated">获取或设置与队列关联的多路广播地址。</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains a valid multicast address (in the form shown below) or <ph id="ph2">&lt;see langword="null" /&gt;</ph>, which indicates that the queue is not associated with a multicast address.</source>
          <target state="translated">包含有效的多路广播地址（格式如下）的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>，或者为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>，这表示队列与多路广播地址不关联。</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MulticastAddress%2A&gt;</ph> property is used to associate a non-transactional queue with a multicast address that can be used when sending messages.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MulticastAddress%2A&gt;</ph>属性用于将非事务性队列发送消息时可以使用的多播地址与相关联。</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>You cannot associate a transactional queue with a multicast address.</source>
          <target state="translated">无法将事务性队列与多播地址相关联。</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>When the sending application sends messages to a multicast address, Message Queuing sends a copy of the message to every queue associated with that address.</source>
          <target state="translated">当发送应用程序将消息发送到多播地址时，则消息队列都会向与该地址关联的每个队列发送消息的副本。</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>IP multicast addresses must be in the class D range from 224.0.0.0 to 239.255.255.255, which corresponds to setting the first four high-order bits equal to 1110.</source>
          <target state="translated">IP 多播地址必须是从 224.0.0.0 到 239.255.255.255，与设置前四个高序位等于 1110年相对应的类 D 范围内。</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>However, only certain ranges of addresses in this range are unreserved and available for sending multicast messages.</source>
          <target state="translated">但是，只有某些范围的在此范围内的地址是保留的可用于发送多播的消息。</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>For the latest list of reserved multicast addresses, see the <bpt id="p1">[</bpt>Internet Assigned Number Authority (IANA) Internet Multicast Addresses<ept id="p1">](http://go.microsoft.com/fwlink/?linkid=3859)</ept> Web page.</source>
          <target state="translated">保留的多播地址的最新列表，请参阅<bpt id="p1">[</bpt>Internet 分配号机构 (IANA) Internet 多播地址<ept id="p1">](http://go.microsoft.com/fwlink/?linkid=3859)</ept>网页。</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>There are no restrictions on the port number.</source>
          <target state="translated">没有任何限制上的端口号。</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>If several source computers are sending multicast messages and you want a specific queue to receive messages from only one source computer, each source computer must send messages to a different combination of IP address and port number.</source>
          <target state="translated">如果多个源计算机发送多播的消息，并且你想要从只有一个源计算机接收消息的特定队列，则每台源计算机必须向不同的 IP 地址和端口号组合发送消息。</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>To dissociate a queue from a multicast address, set the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MulticastAddress%2A&gt;</ph> property to a zero-length string.</source>
          <target state="translated">若要取消关联的多播地址从队列，将设置<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MulticastAddress%2A&gt;</ph>属性设置为零长度字符串。</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>Do not set it to <ph id="ph1">`null`</ph>, as this will result in a <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph>.</source>
          <target state="translated">不将其设置为<ph id="ph1">`null`</ph>，因为这将导致<ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.MulticastAddress">
          <source>MSMQ 3.0 is not installed.</source>
          <target state="translated">未安装 MSMQ 3.0。</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.Path">
          <source>Gets or sets the queue's path.</source>
          <target state="translated">获取或设置队列的路径。</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.Path">
          <source>Setting the <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> causes the <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> to point to a new queue.</source>
          <target state="translated">设置 <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> 会导致 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 指向新队列。</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>The queue that is referenced by the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>.</source>
          <target state="translated">由 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 引用的队列。</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>The default depends on which <ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.#ctor" /&gt;</ph> constructor you use; it is either <ph id="ph2">&lt;see langword="null" /&gt;</ph> or is specified by the constructor's <ph id="ph3">&lt;paramref name="path" /&gt;</ph> parameter.</source>
          <target state="translated">默认值取决于所使用的 <ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.#ctor" /&gt;</ph> 构造函数；它或者是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>，或者是由构造函数的 <ph id="ph3">&lt;paramref name="path" /&gt;</ph> 参数指定的。</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>The syntax for the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> property depends on the type of queue it points to, as shown in the following table.</source>
          <target state="translated">语法<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>属性取决于队列的类型它点为下表中所示。</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Queue type</source>
          <target state="translated">队列类型</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Syntax</source>
          <target state="translated">语法</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Public queue</source>
          <target state="translated">公用队列</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Private queue</source>
          <target state="translated">专用队列</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Journal queue</source>
          <target state="translated">日记队列</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Machine journal queue</source>
          <target state="translated">计算机日记队列</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Machine dead-letter queue</source>
          <target state="translated">机死信队列</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Machine transactional dead-letter queue</source>
          <target state="translated">计算机事务性死信队列</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Use "." to represent the local computer.</source>
          <target state="translated">使用"。"来表示本地计算机。</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph> properties are related.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph>相关属性。</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Changing the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph> property causes the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> property to change.</source>
          <target state="translated">更改<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>属性会导致<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>属性可以更改。</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>It is built from the new <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph> and the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph>.</source>
          <target state="translated">从新生成<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Changing the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> (for example, to use the format name syntax) resets the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph> properties to refer to the new queue.</source>
          <target state="translated">更改<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>（例如，若要使用的格式名称语法） 将重置<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>和<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph>属性来引用新队列。</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph> to describe the queue path, as shown in the following table.</source>
          <target state="translated">或者，可以使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.FormatName%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>来描述队列路径中下, 表中所示。</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Reference</source>
          <target state="translated">参考</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Syntax</source>
          <target state="translated">语法</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Example</source>
          <target state="translated">示例</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Format name</source>
          <target state="translated">格式名称</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source><ph id="ph1">`FormatName:`</ph> [ <bpt id="p1">*</bpt>format name<ept id="p1">*</ept> ]</source>
          <target state="translated"><ph id="ph1">`FormatName:`</ph> [<bpt id="p1">*</bpt>格式名<ept id="p1">*</ept>]</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source><ph id="ph1">`FormatName:Public=`</ph> 5A5F7535-AE9A-41d4-935C-845C2AFF7112</source>
          <target state="translated"><ph id="ph1">`FormatName:Public=`</ph> 5A5F7535-AE9A-41d4-935C-845C2AFF7112</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Label</source>
          <target state="translated">Label</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source><ph id="ph1">`Label:`</ph> [ <bpt id="p1">*</bpt>label<ept id="p1">*</ept> ]</source>
          <target state="translated"><ph id="ph1">`Label:`</ph> [<bpt id="p1">*</bpt>标签<ept id="p1">*</ept>]</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source><ph id="ph1">`Label:`</ph> TheLabel</source>
          <target state="translated"><ph id="ph1">`Label:`</ph> 标签</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>If you use the label syntax for the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> property when you send the message, an exception will be thrown if the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph> is not unique.</source>
          <target state="translated">如果你使用的标签语法<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>属性在发送消息时，将引发异常，如果<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>不是唯一的。</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>To work offline, you must use the format name syntax, rather than the friendly name syntax in the first table.</source>
          <target state="translated">若要脱机工作，必须在第一个表中使用格式名语法，而不是友好名称语法。</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Otherwise, an exception is thrown because the primary domain controller (on which Active Directory resides) is not available to resolve the path to the format name.</source>
          <target state="translated">否则，因为该域的主域控制器 （在其 Active Directory 处于） 不是可用于为格式名称解析的路径，则会引发异常。</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Setting a new path closes the message queue and releases all handles.</source>
          <target state="translated">设置新路径关闭的消息队列，并释放所有句柄。</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>In workgroup mode you can only use private queues.</source>
          <target state="translated">在工作组模式下只能使用专用队列。</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>You specify the path using the private queue syntax <ph id="ph1">`MachineName`</ph><ph id="ph2">\\</ph><ph id="ph3">`Private$`</ph><ph id="ph4">\\</ph><ph id="ph5">`QueueName`</ph>.</source>
          <target state="translated">指定路径中使用的专用队列语法<ph id="ph1">`MachineName`</ph> <ph id="ph2">\\</ph> <ph id="ph3">`Private$`</ph> <ph id="ph4">\\</ph> <ph id="ph5">`QueueName`</ph>。</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>The following code example creates new <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> objects using various path name syntax types.</source>
          <target state="translated">下面的代码示例创建新<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>对象使用各种路径名称语法类型。</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Path">
          <source>In each case, it sends a message to the queue whose path is defined in the constructor.</source>
          <target state="translated">在每个情况下，它将消息发送到其路径定义构造函数中的队列。</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.Path">
          <source>The path is not valid, possibly because the syntax is not valid.</source>
          <target state="translated">路径无效，可能是因为语法无效。</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Returns a copy of the first message in the queue without removing the message from the queue.</source>
          <target state="translated">返回队列中第一条消息的副本，而不从队列中移除该消息。</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek">
          <source>Returns without removing (peeks) the first message in the queue referenced by this <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>.</source>
          <target state="translated">返回但不移除（查看）此 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 所引用的队列中的第一条消息。</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek">
          <source>The <ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.Peek" /&gt;</ph> method is synchronous, so it blocks the current thread until a message becomes available.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.Peek" /&gt;</ph> 方法是同步的，所以在有可用消息前，该方法阻塞当前线程。</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that represents the first message in the queue.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> 表示队列中第一条消息。</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>Use this overload to peek a queue, or to wait until a message exists in the queue.</source>
          <target state="translated">若要查看队列，或等待，直到在队列中存在一条消息，请使用此重载。</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method reads, but does not remove, the first message from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法读取，但不会删除从队列第一条消息。</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>Therefore, repeated calls to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> return the same message, unless a higher priority message arrives in the queue.</source>
          <target state="translated">因此，重复调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>返回同一条消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method, on the other hand, both reads and removes the first message from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法，另一方面，同时读取和从队列中移除第一条消息。</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>Repeated calls to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>, therefore, return different messages.</source>
          <target state="translated">重复调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>，因此，返回不同的消息。</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>Message Queuing orders messages in the queue according to priority and arrival time.</source>
          <target state="translated">消息队列消息优先级和到达时间根据队列中进行排序。</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>A newer message is placed before an older one only if it is of a higher priority.</source>
          <target state="translated">仅当它为较高优先级的较新的消息放置在旧版本之前。</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>Use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</source>
          <target state="translated">如果当前线程在等待消息到达队列时可以被阻塞，则使用 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>Because this overload does not specify a time-out, the application might wait indefinitely.</source>
          <target state="translated">由于此重载不指定超时，则应用程序可能会无限期地等待。</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>If you need the application processing to continue without waiting, use the asynchronous <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> method.</source>
          <target state="translated">如果需要应用程序处理继续进行而不等待，则使用异步 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>Alternatively, you can specify a time-out for a message to arrive in the queue by using the overload of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> that specifies a time-out.</source>
          <target state="translated">或者，您可以指定对消息到达队列中使用的重载使用超时<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>，指定超时。</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>The following examples use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method on a queue.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>队列上的方法。</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>In the first example, the application waits until a message becomes available in the queue.</source>
          <target state="translated">在第一个示例中，应用程序等待，直到的消息变得在队列中可用。</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>Note that the first example does not access the message that arrives; it merely pauses processing until a message arrives.</source>
          <target state="translated">请注意第一个示例不会访问消息到达;它只是将暂停处理，直到到达的消息。</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>If a message already exists in the queue, it will return immediately.</source>
          <target state="translated">如果队列中已存在一条消息，它将立即返回。</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>In the second example, a message that contains an application-defined <ph id="ph1">`Order`</ph> class is sent to the queue, and then peeked from the queue.</source>
          <target state="translated">在第二个示例中，包含应用程序定义的消息<ph id="ph1">`Order`</ph>类是发送到队列，，然后从队列中查看它。</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the maximum time to wait for the queue to contain a message.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示等待队列包含消息所用的最长时间。</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>Returns without removing (peeks) the first message in the queue referenced by this <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>.</source>
          <target state="translated">返回但不移除（查看）此 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 所引用的队列中的第一条消息。</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.Peek" /&gt;</ph> method is synchronous, so it blocks the current thread until a message becomes available or the specified time-out occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.Peek" /&gt;</ph> 方法是同步的，因此在有可用消息或发生指定的超时之前，它一直阻止当前线程。</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that represents the first message in the queue.</source>
          <target state="translated">该 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> 表示队列中第一条消息。</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>Use this overload to peek a queue, or to wait a specified period of time until a message exists in the queue.</source>
          <target state="translated">若要查看队列，或等待一段指定时间，直到在队列中存在一条消息，请使用此重载。</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>The method returns immediately if a message already exists in the queue.</source>
          <target state="translated">如果消息在队列中已存在，方法将立即返回。</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method reads, but does not remove, the first message from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法读取，但不会删除从队列第一条消息。</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>Therefore, repeated calls to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> return the same message, unless a higher priority message arrives in the queue.</source>
          <target state="translated">因此，重复调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>返回同一条消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method, on the other hand, both reads and removes the first message from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法，另一方面，同时读取和从队列中移除第一条消息。</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>Repeated calls to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>, therefore, return different messages.</source>
          <target state="translated">重复调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>，因此，返回不同的消息。</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>Message Queuing orders messages in the queue according to priority and arrival time.</source>
          <target state="translated">消息队列消息优先级和到达时间根据队列中进行排序。</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>A newer message is placed before an older one only if it is of a higher priority.</source>
          <target state="translated">仅当它为较高优先级的较新的消息放置在旧版本之前。</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>Use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</source>
          <target state="translated">如果当前线程在等待消息到达队列时可以被阻塞，则使用 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>The thread will be blocked up to the specified period of time, or indefinitely if you indicated <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph>.</source>
          <target state="translated">线程将被阻塞段指定的时间，或者如果你表明<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>If you need the application processing to continue without waiting, use the asynchronous <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> method.</source>
          <target state="translated">如果需要应用程序处理继续进行而不等待，则使用异步 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method with a time-out of zero to check whether the queue is empty.</source>
          <target state="translated">下面的代码示例使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法的超时值为零，以检查队列是否为空。</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid, possibly <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> is less than <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> or greater than <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效，可能是 <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> 小于 <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> 或大于 <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the maximum time to wait for the queue to contain a message.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示等待队列包含消息所用的最长时间。</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Cursor" /&gt;</ph> that maintains a specific position in the message queue.</source>
          <target state="translated">维持消息队列中特定位置的 <ph id="ph1">&lt;see cref="T:System.Messaging.Cursor" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.PeekAction" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.PeekAction" /&gt;</ph> 值之一。</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>Indicates whether to peek at the current message in the queue, or the next message.</source>
          <target state="translated">指示是查看队列中的当前消息还是下一条消息。</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>Returns without removing (peeks) the current or next message in the queue, using the specified cursor.</source>
          <target state="translated">使用指定的游标返回但不移除（查看）队列中的当前消息或下一条消息。</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>The <ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.Peek" /&gt;</ph> method is synchronous, so it blocks the current thread until a message becomes available or the specified time-out occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.Peek" /&gt;</ph> 方法是同步的，因此在有可用消息或发生指定的超时之前，它一直阻止当前线程。</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that represents a message in the queue.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，表示队列中的消息。</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>Use this overload to peek a queue, or to wait a specified period of time until a message exists in the queue.</source>
          <target state="translated">若要查看队列，或等待一段指定时间，直到在队列中存在一条消息，请使用此重载。</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>The method returns immediately if a message already exists in the queue.</source>
          <target state="translated">如果消息在队列中已存在，方法将立即返回。</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method reads, but does not remove, a message from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法读取，但不会删除队列的消息。</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method, on the other hand, both reads and removes a message from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法，另一方面，同时读取和从队列中移除消息。</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>Use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</source>
          <target state="translated">如果当前线程在等待消息到达队列时可以被阻塞，则使用 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>The thread is blocked up to the specified period of time, or indefinitely if you indicated <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph>.</source>
          <target state="translated">线程阻塞段指定的时间，或者如果你表明<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>If you need the application processing to continue without waiting, use the asynchronous <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> method.</source>
          <target state="translated">如果需要应用程序处理继续进行而不等待，则使用异步 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>A value other than <ph id="ph1">&lt;see langword="PeekAction.Current" /&gt;</ph> or <ph id="ph2">&lt;see langword="PeekAction.Next" /&gt;</ph> was specified for the <ph id="ph3">&lt;paramref name="action" /&gt;</ph> parameter.</source>
          <target state="translated">为 <ph id="ph3">&lt;paramref name="action" /&gt;</ph> 参数指定的值不是 <ph id="ph1">&lt;see langword="PeekAction.Current" /&gt;</ph> 和 <ph id="ph2">&lt;see langword="PeekAction.Next" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>The <ph id="ph1">&lt;paramref name="cursor" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cursor" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效。</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>Possibly <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is less than <ph id="ph2">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> or greater than <ph id="ph3">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 可能小于 <ph id="ph2">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> 或大于 <ph id="ph3">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Peeks a message that matches a given correlation identifier.</source>
          <target state="translated">查看匹配给定相关标识符的消息。</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph> of the message to peek.</source>
          <target state="translated">要查看的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>Peeks the message that matches the given correlation identifier and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</source>
          <target state="translated">查看匹配给定相关标识符的消息，而且在队列中当前不存在具有指定相关标识符的消息时，立即引发异常。</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph> matches the <ph id="ph3">&lt;paramref name="correlationId" /&gt;</ph> parameter passed in.</source>
          <target state="translated">其 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> 匹配传入的 <ph id="ph3">&lt;paramref name="correlationId" /&gt;</ph> 参数的 <ph id="ph2">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>This method looks in the queue referenced by the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> for a message whose <ph id="ph2">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> matches the specified <ph id="ph3">`correlationId`</ph> parameter.</source>
          <target state="translated">此方法引用的队列中查找<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>的消息其<ph id="ph2">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>匹配所指定<ph id="ph3">`correlationId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>If no message is found that matches the <ph id="ph1">`correlationID`</ph> parameter, an exception is thrown.</source>
          <target state="translated">如果不找到任何消息匹配<ph id="ph1">`correlationID`</ph>参数，将引发异常。</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>属性用于将发送到队列相关联的响应、 报表或确认消息发送到的消息。</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>Two other methods allow you to peek messages in a queue.</source>
          <target state="translated">其他两种方法，可以查看队列中的消息。</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method returns the first message in the queue, and the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> method is used to retrieve a message by specifying its unique identifier.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法返回第一条消息在队列中，与<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>方法用于检索一条消息，通过指定其唯一标识符。</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>The following code example sends and receives a message that contains an order to and from a queue.</source>
          <target state="translated">下面的代码示例发送和接收包含订单与队列的消息。</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.</source>
          <target state="translated">它特别请求肯定确认当原始消息到达或已从队列中检索。</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>The message with the specified <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> could not be found.</source>
          <target state="translated">未能找到具有指定 <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> 的消息。</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph> of the message to peek.</source>
          <target state="translated">要查看的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the time to wait until a new message is available for inspection.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示有新消息可用于检查之前等待的时间。</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>Peeks the message that matches the given correlation identifier and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</source>
          <target state="translated">查看匹配给定相关标识符的消息，并且一直等到队列中出现具有指定相关标识符的消息或超时过期时。</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph> matches the <ph id="ph3">&lt;paramref name="correlationId" /&gt;</ph> parameter passed in.</source>
          <target state="translated">其 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> 匹配传入的 <ph id="ph3">&lt;paramref name="correlationId" /&gt;</ph> 参数的 <ph id="ph2">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>This method looks in the queue referenced by the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> for a message whose <ph id="ph2">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> matches the specified <ph id="ph3">`correlationId`</ph> parameter.</source>
          <target state="translated">此方法引用的队列中查找<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>的消息其<ph id="ph2">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>匹配所指定<ph id="ph3">`correlationId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>If no message is found that matches the <ph id="ph1">`correlationID`</ph> parameter, and no new message arrives in the queue within the period specified by the <ph id="ph2">`timeout`</ph> parameter, an exception is thrown.</source>
          <target state="translated">如果不找到任何消息匹配<ph id="ph1">`correlationID`</ph>参数，并且没有新消息到达队列中通过指定的时间内<ph id="ph2">`timeout`</ph>参数，将引发异常。</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">`timeout`</ph> parameter does not specify the total running time for this method.</source>
          <target state="translated"><ph id="ph1">`timeout`</ph>参数未指定的总运行时间为此方法。</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>Rather, it specifies the time to wait for a new message to arrive in the queue.</source>
          <target state="translated">相反，它指定为新消息到达队列中等待的时间。</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>Each time a new message arrives, this method examines the <ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> of the new message to see if it matches the <ph id="ph2">`correlationId`</ph> parameter.</source>
          <target state="translated">每次有新消息到达时，此方法检查<ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>的新消息，以查看其是否符合<ph id="ph2">`correlationId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>If not, this method starts the time-out period over and waits for another new message to arrive.</source>
          <target state="translated">如果没有，此方法通过启动超时期限，等待另一个新消息到达。</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> matches the <ph id="ph2">`correlationId`</ph> parameter.</source>
          <target state="translated">因此，如果新消息继续到达超时时间内，则可能为此方法继续运行; 如果无限期，直到在超时期限过期并且没有任何新的消息到达，或者直到消息到达其<ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>匹配<ph id="ph2">`correlationId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>属性用于将发送到队列相关联的响应、 报表或确认消息发送到的消息。</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>Two other methods allow you to peek messages in a queue.</source>
          <target state="translated">其他两种方法，可以查看队列中的消息。</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method returns the first message in the queue, and the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> method is used to retrieve a message by specifying its unique identifier.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法返回第一条消息在队列中，与<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>方法用于检索一条消息，通过指定其唯一标识符。</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid, possibly <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> is less than <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> or greater than <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效，可能是 <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> 小于 <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> 或大于 <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>The message with the specified <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> does not exist in the queue and did not arrive before the time-out expired.</source>
          <target state="translated">具有指定 <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> 的消息不在队列中，而且在超时过期之前没有到达。</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>A message did not arrive before the time-out expired.</source>
          <target state="translated">消息在超时过期前没有到达。</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Returns a copy of the message that has the specified message identifier without removing the message from the queue.</source>
          <target state="translated">返回具有指定消息标识符的消息的副本，但不从队列中移除消息。</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> of the message to peek.</source>
          <target state="translated">要查看的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>Peeks the message whose message identifier matches the <ph id="ph1">&lt;paramref name="id" /&gt;</ph> parameter.</source>
          <target state="translated">查看其消息标识符匹配 <ph id="ph1">&lt;paramref name="id" /&gt;</ph> 参数的消息。</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> property matches the <ph id="ph3">&lt;paramref name="id" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，其 <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> 属性匹配 <ph id="ph3">&lt;paramref name="id" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>Use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> to read, without removing from the queue, a message that has a known message identifier.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>若要读取，而不必从队列中，删除一条消息，都有一个已知的消息标识符。</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>The identifier of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given <ph id="ph1">`id`</ph> parameter.</source>
          <target state="translated">一条消息的标识符是消息队列企业中，唯一的因此将最多一条消息匹配的队列中给定<ph id="ph1">`id`</ph>参数。</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>This overload throws an exception if the queue does not currently contain the message.</source>
          <target state="translated">如果队列中当前不包含消息，此重载将引发异常。</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>Two additional methods allow you to peek messages in a queue: <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>.</source>
          <target state="translated">两个其他方法使您得以队列中扫视消息：<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method returns the first message in the queue; <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph> returns an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法返回的第一个消息队列; 中<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>返回确认、 报表或创建第一条消息发送到队列的应用程序生成的响应消息。</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="id" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="id" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>No message with the specified <ph id="ph1">&lt;paramref name="id" /&gt;</ph> exists.</source>
          <target state="translated">不存在具有指定 <ph id="ph1">&lt;paramref name="id" /&gt;</ph> 的消息。</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekById(System.String)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> of the message to peek.</source>
          <target state="translated">要查看的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the time to wait until a new message is available for inspection.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示有新消息可用于检查之前等待的时间。</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>Peeks the message whose message identifier matches the <ph id="ph1">&lt;paramref name="id" /&gt;</ph> parameter.</source>
          <target state="translated">查看其消息标识符匹配 <ph id="ph1">&lt;paramref name="id" /&gt;</ph> 参数的消息。</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>Waits until the message appears in the queue or a time-out occurs.</source>
          <target state="translated">一直等到队列中出现该消息或发生超时。</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> property matches the <ph id="ph3">&lt;paramref name="id" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，其 <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> 属性匹配 <ph id="ph3">&lt;paramref name="id" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>Use <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> to read, without removing from the queue, a message that has a known message identifier.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>若要读取，而不必从队列中，删除一条消息，都有一个已知的消息标识符。</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>The identifier of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given <ph id="ph1">`id`</ph> parameter.</source>
          <target state="translated">一条消息的标识符是消息队列企业中，唯一的因此将最多一条消息匹配的队列中给定<ph id="ph1">`id`</ph>参数。</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>This overload throws an exception if the queue does not currently contain the message and a new message does not arrive before the time-out occurs.</source>
          <target state="translated">如果队列中当前不包含消息和一条新消息没有到达之前发生超时的时候，此重载将引发异常。</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">`timeout`</ph> parameter does not specify the total running time for this method.</source>
          <target state="translated"><ph id="ph1">`timeout`</ph>参数未指定的总运行时间为此方法。</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>Rather, it specifies the time to wait for a new message to arrive in the queue.</source>
          <target state="translated">相反，它指定为新消息到达队列中等待的时间。</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>Each time a new message arrives, this method examines the <ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph> of the new message to see if it matches the <ph id="ph2">`id`</ph> parameter.</source>
          <target state="translated">每次有新消息到达时，此方法检查<ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph>的新消息，以查看其是否符合<ph id="ph2">`id`</ph>参数。</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>If not, this method starts the time-out period over and waits for another new message to arrive.</source>
          <target state="translated">如果没有，此方法通过启动超时期限，等待另一个新消息到达。</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph> matches the <ph id="ph2">`id`</ph> parameter.</source>
          <target state="translated">因此，如果新消息继续到达超时时间内，则可能为此方法继续运行; 如果无限期，直到在超时期限过期并且没有任何新的消息到达，或者直到消息到达其<ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph>匹配<ph id="ph2">`id`</ph>参数。</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>Two additional methods allow you to peek messages in a queue: <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>.</source>
          <target state="translated">两个其他方法使您得以队列中扫视消息：<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method returns the first message in the queue; <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph> returns an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法返回的第一个消息队列; 中<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>返回确认、 报表或创建第一条消息发送到队列的应用程序生成的响应消息。</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="id" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="id" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid, possibly <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> is less than <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> or greater than <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效，可能是 <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> 小于 <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> 或大于 <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>The message with the specified <ph id="ph1">&lt;paramref name="id" /&gt;</ph> does not exist in the queue and did not arrive before the period specified by the <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> parameter expired.</source>
          <target state="translated">队列中不存在具有指定 <ph id="ph1">&lt;paramref name="id" /&gt;</ph> 的消息，并且在 <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> 参数指定的时间段过期之前该消息仍未到达。</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Introduced in MSMQ 3.0.</source>
          <target state="translated">在 MSMQ 3.0 中引入。</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Peeks at a specific message from the queue.</source>
          <target state="translated">查看队列中特定的消息。</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>The message can be specified by a lookup identifier or by its position at the front or end of the queue.</source>
          <target state="translated">消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.LookupId" /&gt;</ph> of the message to peek at.</source>
          <target state="translated">要查看的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.LookupId" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>Introduced in MSMQ 3.0.</source>
          <target state="translated">在 MSMQ 3.0 中引入。</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>Peeks at the message that matches the given lookup identifier from a non-transactional queue.</source>
          <target state="translated">从非事务性队列中查看与给定查找标识符匹配的消息。</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.LookupId" /&gt;</ph> property matches the <ph id="ph3">&lt;paramref name="lookupId" /&gt;</ph> parameter passed in.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，其 <ph id="ph2">&lt;see cref="P:System.Messaging.Message.LookupId" /&gt;</ph> 属性匹配传入的 <ph id="ph3">&lt;paramref name="lookupId" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>Use this method to read a message with a known lookup identifier without removing it from the queue.</source>
          <target state="translated">使用此方法读取具有已知的查找标识符的消息，而不必从队列中将其删除。</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>This method throws an exception immediately if the message is not in the queue.</source>
          <target state="translated">如果消息也不会在队列中，此方法将立即引发异常。</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.LookupId%2A&gt;</ph> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given <ph id="ph2">`lookupId`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.LookupId%2A&gt;</ph>属性的消息是唯一的队列消息所在的位置，因此将最多一条消息匹配的队列中给定<ph id="ph2">`lookupId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>To read a message with a specified lookup identifier and remove it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A&gt;</ph> method.</source>
          <target state="translated">读取具有指定的查找标识符的消息并将其从队列删除，请使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>MSMQ 3.0 is not installed.</source>
          <target state="translated">未安装 MSMQ 3.0。</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>The message with the specified <ph id="ph1">&lt;paramref name="lookupId" /&gt;</ph> could not be found.</source>
          <target state="translated">未能找到具有指定 <ph id="ph1">&lt;paramref name="lookupId" /&gt;</ph> 的消息。</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageLookupAction" /&gt;</ph> values, specifying how the message is read in the queue.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageLookupAction" /&gt;</ph> 值，指定读取队列中消息的方式。</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>Specify one of the following:</source>
          <target state="translated">指定以下值之一：</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source><ph id="ph1">&lt;see langword="MessageLookupAction.Current" /&gt;</ph>: Peeks at the message specified by <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MessageLookupAction.Current" /&gt;</ph>：查看由 <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> 指定的消息。</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source><ph id="ph1">&lt;see langword="MessageLookupAction.Next" /&gt;</ph>: Peeks at the message following the message specified by <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MessageLookupAction.Next" /&gt;</ph>：查看由 <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> 指定消息的下一条消息。</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source><ph id="ph1">&lt;see langword="MessageLookupAction.Previous" /&gt;</ph>: Peeks at the message preceding the message specified by <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MessageLookupAction.Previous" /&gt;</ph>：查看由 <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> 指定消息的上一条消息。</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source><ph id="ph1">&lt;see langword="MessageLookupAction.First" /&gt;</ph>: Peeks at the first message in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MessageLookupAction.First" /&gt;</ph>：查看队列中的第一条消息。</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> parameter must be set to 0.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> 参数必须设置为 0。</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source><ph id="ph1">&lt;see langword="MessageLookupAction.Last" /&gt;</ph>: Peeks at the last message in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MessageLookupAction.Last" /&gt;</ph>：查看队列中的最后一条消息。</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> parameter must be set to 0.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> 参数必须设置为 0。</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.LookupId" /&gt;</ph> of the message to peek at, or 0.</source>
          <target state="translated">要查看的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.LookupId" /&gt;</ph> 或者为 0。</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>0 is used when accessing the first or last message in the queue.</source>
          <target state="translated">访问队列中的第一条和最后一条消息时使用 0。</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>Introduced in MSMQ 3.0.</source>
          <target state="translated">在 MSMQ 3.0 中引入。</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>Peeks at a specific message from the queue.</source>
          <target state="translated">查看队列中特定的消息。</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>The message can be specified by a lookup identifier or by its position at the front or end of the queue.</source>
          <target state="translated">消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> specified by the <ph id="ph2">&lt;paramref name="action" /&gt;</ph> and <ph id="ph3">&lt;paramref name="lookupId" /&gt;</ph> parameters passed in.</source>
          <target state="translated">由传入的 <ph id="ph2">&lt;paramref name="action" /&gt;</ph> 和 <ph id="ph3">&lt;paramref name="lookupId" /&gt;</ph> 参数指定的 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>Use this method to read a message with a known lookup identifier without removing it from the queue.</source>
          <target state="translated">使用此方法读取具有已知的查找标识符的消息，而不必从队列中将其删除。</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>This method throws an exception immediately if the message is not in the queue.</source>
          <target state="translated">如果消息也不会在队列中，此方法将立即引发异常。</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.LookupId%2A&gt;</ph> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given <ph id="ph2">`lookupId`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.LookupId%2A&gt;</ph>属性的消息是唯一的队列消息所在的位置，因此将最多一条消息匹配的队列中给定<ph id="ph2">`lookupId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>To read a message with a specified identifier and remove it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A&gt;</ph> method.</source>
          <target state="translated">读取具有指定标识符的消息并将其从队列删除，请使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>MSMQ 3.0 is not installed.</source>
          <target state="translated">未安装 MSMQ 3.0。</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>The message with the specified <ph id="ph1">&lt;paramref name="lookupId" /&gt;</ph> could not be found.</source>
          <target state="translated">未能找到具有指定 <ph id="ph1">&lt;paramref name="lookupId" /&gt;</ph> 的消息。</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Messaging.MessageLookupAction" /&gt;</ph> members.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> 参数不是 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageLookupAction" /&gt;</ph> 成员之一。</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" uid="E:System.Messaging.MessageQueue.PeekCompleted">
          <source>Occurs when a message is read without being removed from the queue.</source>
          <target state="translated">在消息未从队列移除的情况下读取该消息时发生。</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" uid="E:System.Messaging.MessageQueue.PeekCompleted">
          <source>This is a result of the asynchronous operation, <ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.BeginPeek" /&gt;</ph>.</source>
          <target state="translated">这是异步操作 <ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.BeginPeek" /&gt;</ph> 的结果。</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Messaging.MessageQueue.PeekCompleted">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> is used in asynchronous processing to raise the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event when a message is available in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> 在异步处理中用于引发<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>事件队列中出现一条消息时。</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Messaging.MessageQueue.PeekCompleted">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph> is used to complete the operation initiated by a call to <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> and peek the message when the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event is raised.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29&gt;</ph> 用于完成通过调用启动的操作<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>和扫视消息时<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>引发事件。</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Messaging.MessageQueue.PeekCompleted">
          <source>When you create a <ph id="ph1">&lt;xref:System.Messaging.PeekCompletedEventHandler&gt;</ph> delegate, you identify the method that will handle the event.</source>
          <target state="translated">创建 <ph id="ph1">&lt;xref:System.Messaging.PeekCompletedEventHandler&gt;</ph> 委托时，需要标识将处理该事件的方法。</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Messaging.MessageQueue.PeekCompleted">
          <source>To associate the event with your event handler, add an instance of the delegate to the event.</source>
          <target state="translated">若要将事件与事件处理程序关联，请将该委托的一个实例添加到事件中。</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Messaging.MessageQueue.PeekCompleted">
          <source>The event handler is called whenever the event occurs, unless you remove the delegate.</source>
          <target state="translated">除非移除了该委托，否则每当发生该事件时就会调用事件处理程序。</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Messaging.MessageQueue.PeekCompleted">
          <source>For more information about event handler delegates, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">有关事件处理程序委托的详细信息，请参阅<bpt id="p1">[</bpt>处理和引发事件<ept id="p1">](~/docs/standard/events/index.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Messaging.MessageQueue.PeekCompleted">
          <source>The following code example creates an event handler named <ph id="ph1">`MyPeekCompleted`</ph>, attaches it to the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event handler delegate, and calls <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> to initiate an asynchronous peek operation on the queue that is located at the path ".\myQueue".</source>
          <target state="translated">下面的代码示例创建名为一个事件处理程序<ph id="ph1">`MyPeekCompleted`</ph>，将其附加到<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>事件处理程序委托，然后调用<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>启动位于路径的队列上的异步查看操作"。 \myQueue"。</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Messaging.MessageQueue.PeekCompleted">
          <source>When a <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event is raised, the example peeks the message and writes its body to the screen.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>引发事件，该示例扫视消息，并将其正文写入到屏幕。</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Messaging.MessageQueue.PeekCompleted">
          <source>The example then calls <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> again to initiate a new asynchronous peek operation</source>
          <target state="translated">该示例然后调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>以启动新的异步扫视操作</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Purge">
          <source>Deletes all the messages contained in the queue.</source>
          <target state="translated">删除队列中包含的所有消息。</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Purge">
          <source>Purging the queue causes Message Queuing to set the queue modification flag, which affects the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.LastModifyTime%2A&gt;</ph> property.</source>
          <target state="translated">清除队列导致消息队列设置队列修改标志，这会影响<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.LastModifyTime%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Purge">
          <source>Messages that are purged from the queue are lost; they are not sent to the dead-letter queue or the journal queue.</source>
          <target state="translated">从队列中清除的消息都将丢失;它们不发送到死信队列或日志队列。</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Purge">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Purge">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Purge">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Purge">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Purge">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Purge">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Purge">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Purge">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Purge">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Purge">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Purge">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Purge">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Purge%2A&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Purge%2A&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Purge">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>Gets or sets the friendly name that identifies the queue.</source>
          <target state="translated">获取或设置标识队列的友好名称。</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>The name that identifies the queue referenced by this <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>.</source>
          <target state="translated">名称，该名称标识由此 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 引用的队列。</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>The value cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">该值不能为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>You can combine the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph> with the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph> to create a friendly <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> name for the queue.</source>
          <target state="translated">你可以组合<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph>与<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>创建一个友好<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>队列的名称。</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>The syntax for the friendly name variation of the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> property depends on the type of queue, as shown in the following table.</source>
          <target state="translated">友好名称变体的语法<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>属性取决于队列的类型下表中所示。</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>Queue type</source>
          <target state="translated">队列类型</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>Syntax</source>
          <target state="translated">语法</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>Public queue</source>
          <target state="translated">公用队列</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>Private queue</source>
          <target state="translated">专用队列</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>Journal queue</source>
          <target state="translated">日记队列</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>Use "." to represent the local computer.</source>
          <target state="translated">使用"。"来表示本地计算机。</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>Changing the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph> property affects the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> property.</source>
          <target state="translated">更改<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph>属性将影响<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>If you set the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph> without setting the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph> property, the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> property becomes .<ph id="ph4">\\</ph><ph id="ph5">`QueueName`</ph>.</source>
          <target state="translated">如果你设置<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph>但不包括设置<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.MachineName%2A&gt;</ph>属性，<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>属性变为。<ph id="ph4">\\</ph><ph id="ph5">`QueueName`</ph>.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>Otherwise, the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> becomes <ph id="ph2">`MachineName`</ph><ph id="ph3">\\</ph><ph id="ph4">`QueueName`</ph>.</source>
          <target state="translated">否则为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>变得<ph id="ph2">`MachineName`</ph> <ph id="ph3">\\</ph> <ph id="ph4">`QueueName`</ph>。</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>The following code example gets and sets the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例获取和设置的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.QueueName%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.QueueName">
          <source>The queue name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">队列名称为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.ReadHandle">
          <source>Gets the native handle used to read messages from the message queue.</source>
          <target state="translated">获取用于从消息队列读取消息的本机句柄。</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.ReadHandle">
          <source>A handle to the native queue object that you use for peeking and receiving messages from the queue.</source>
          <target state="translated">用于查看和接收来自队列的消息的本机队列对象的句柄。</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.ReadHandle">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReadHandle%2A&gt;</ph> provides a native Windows handle to the message queue object that is used for peeking and receiving messages from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReadHandle%2A&gt;</ph>提供用于查看和从队列接收消息的消息队列对象的本机 Windows 句柄。</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.ReadHandle">
          <source>If you change the path of the queue, the handle is closed and reopened with a new value.</source>
          <target state="translated">如果你更改队列的路径，该句柄关闭，并使用新值重新打开。</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.ReadHandle">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.ReadHandle">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.ReadHandle">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.ReadHandle">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.ReadHandle">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.ReadHandle">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.ReadHandle">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.ReadHandle">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.ReadHandle">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.ReadHandle">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.ReadHandle">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.ReadHandle">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Messaging.MessageQueue">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Receives the first message in the queue, removing it from the queue.</source>
          <target state="translated">接收队列中的第一条消息，但不将它从队列中移除。</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive">
          <source>Receives the first message available in the queue referenced by the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>.</source>
          <target state="translated">接收 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 引用的队列中可用的第一条消息。</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive">
          <source>This call is synchronous, and blocks the current thread of execution until a message is available.</source>
          <target state="translated">此调用是同步的，在有可用消息前，它将一直阻止当前线程的执行。</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that references the first message available in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，它引用队列中可用的第一条消息。</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>Use this overload to receive a message from a queue, or wait until there are messages in the queue.</source>
          <target state="translated">此重载用于接收来自队列的消息或等待，直到在队列中消息。</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method allows for the synchronous reading of a message, thereby removing it from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法允许同步读取一条消息，从而它从队列中删除。</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>Subsequent calls to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> will return the messages that follow in the queue, or new, higher priority messages.</source>
          <target state="translated">后续调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>将返回后面在队列中，或新，优先级高的消息的消息。</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>To read the first message in a queue without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method.</source>
          <target state="translated">若要读取队列中的第一个消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法始终返回第一条消息在队列中，因此对方法的后续调用将返回相同的消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>Use a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</source>
          <target state="translated">使用调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>它是当前线程在等待消息到达队列时可以被阻塞。</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>Because this overload of the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method specifies an infinite time-out, the application might wait indefinitely.</source>
          <target state="translated">因为此重载<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法指定无限期超时，则应用程序可能会无限期地等待。</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>If the application processing should continue without waiting for the message, consider using the asynchronous method, <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>.</source>
          <target state="translated">如果应用程序处理应继续而不等待消息，请考虑使用异步方法， <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive">
          <source>The following code example receives a message from a queue and outputs information about that message to the screen.</source>
          <target state="translated">下面的代码示例从队列接收消息，并输出到屏幕该消息有关的信息。</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>Receives the first message available in the transactional queue referenced by the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>.</source>
          <target state="translated">接收 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 引用的事务性队列中可用的第一条消息。</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>This call is synchronous, and blocks the current thread of execution until a message is available.</source>
          <target state="translated">此调用是同步的，在有可用消息前，它将一直阻止当前线程的执行。</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that references the first message available in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，它引用队列中可用的第一条消息。</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>Use this overload to receive a message from a transactional queue using the internal transaction context defined by the <ph id="ph1">`transaction`</ph> parameter, or wait until there are messages in the queue.</source>
          <target state="translated">使用此重载用于从使用由定义的内部事务上下文的事务性队列接收消息<ph id="ph1">`transaction`</ph>参数或等待队列中没有消息。</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method allows for the synchronous reading of a message, thereby removing it from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法允许同步读取一条消息，从而它从队列中删除。</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>Subsequent calls to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> will return the messages that follow in the queue.</source>
          <target state="translated">后续调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>将返回后面的消息队列中。</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</source>
          <target state="translated">因为此方法调用事务性队列，接收的消息将返回到队列如果则中止此事务。</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>The message is not permanently removed from the queue until the transaction is committed.</source>
          <target state="translated">消息永久性不删除从队列直到提交事务。</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>To read the first message in a queue without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method.</source>
          <target state="translated">若要读取队列中的第一个消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法始终返回第一条消息在队列中，因此对方法的后续调用将返回相同的消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>There is no transaction context associated with a message returned by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>.</source>
          <target state="translated">没有与通过调用返回的消息关联事务上下文<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> does not remove any messages in the queue, there would be nothing to roll back by a call to <ph id="ph2">&lt;xref:System.Messaging.MessageQueueTransaction.Abort%2A&gt;</ph>.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>不会的删除队列中的任何消息，将通过调用回滚任何内容<ph id="ph2">&lt;xref:System.Messaging.MessageQueueTransaction.Abort%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>Use a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</source>
          <target state="translated">使用调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>它是当前线程在等待消息到达队列时可以被阻塞。</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>Because this overload of the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method specifies an infinite time-out, the application might wait indefinitely.</source>
          <target state="translated">因为此重载<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法指定无限期超时，则应用程序可能会无限期地等待。</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>If the application processing should continue without waiting for the message, consider using the asynchronous method, <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>.</source>
          <target state="translated">如果应用程序处理应继续而不等待消息，请考虑使用异步方法， <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>The following code example connects to a transactional queue on the local computer and sends a message to the queue.</source>
          <target state="translated">下面的代码示例连接到本地计算机上的事务性队列并向队列发送消息。</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>It then receives the message that contains an order.</source>
          <target state="translated">然后，它接收包含订单的消息。</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>If it encounters a non-transactional queue, it will throw and exception and rollback the transaction.</source>
          <target state="translated">如果遇到非事务性队列，则会引发异常并回滚事务。</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>The queue is non-transactional.</source>
          <target state="translated">该队列为非事务性队列。</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> values, describing the type of transaction context to associate with the message.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 值之一，它描述与消息关联的事务上下文的类型。</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>Receives the first message available in the queue referenced by the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>.</source>
          <target state="translated">接收 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 引用的队列中可用的第一条消息。</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>This call is synchronous, and blocks the current thread of execution until a message is available.</source>
          <target state="translated">此调用是同步的，在有可用消息前，它将一直阻止当前线程的执行。</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that references the first message available in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，它引用队列中可用的第一条消息。</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>Use this overload to receive a message from a queue using a transaction context defined by the <ph id="ph1">`transactionType`</ph> parameter, or wait until there are messages in the queue.</source>
          <target state="translated">使用此重载用于使用定义的事务上下文从队列接收消息<ph id="ph1">`transactionType`</ph>参数或等待队列中没有消息。</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Automatic`</ph> for the <ph id="ph2">`transactionType`</ph> parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</source>
          <target state="translated">指定<ph id="ph1">`Automatic`</ph>为<ph id="ph2">`transactionType`</ph>参数，如果已存在外部事务上下文附加到你想要用于接收消息的线程。</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Single`</ph> if you want to receive the message as a single internal transaction.</source>
          <target state="translated">指定<ph id="ph1">`Single`</ph>如果你想要接收的消息作为单个内部事务。</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>You can specify <ph id="ph1">`None`</ph> if you want to receive a message from a transactional queue outside of a transaction context.</source>
          <target state="translated">你可以指定<ph id="ph1">`None`</ph>如果你想要接收来自外部事务上下文事务性队列的消息。</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method allows for the synchronous reading of a message, thereby removing it from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法允许同步读取一条消息，从而它从队列中删除。</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>Subsequent calls to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> will return the messages that follow in the queue.</source>
          <target state="translated">后续调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>将返回后面的消息队列中。</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</source>
          <target state="translated">如果调用此方法用于从事务性队列接收消息，接收的消息将返回到队列如果则中止此事务。</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>The message is not permanently removed from the queue until the transaction is committed.</source>
          <target state="translated">消息永久性不删除从队列直到提交事务。</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>To read the first message in a queue without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method.</source>
          <target state="translated">若要读取队列中的第一个消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法始终返回第一条消息在队列中，因此对方法的后续调用将返回相同的消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>There is no transaction context associated with a message returned by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>.</source>
          <target state="translated">没有与通过调用返回的消息关联事务上下文<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> does not remove any messages in the queue, there would be nothing to roll back by a call to <ph id="ph2">&lt;xref:System.Messaging.MessageQueueTransaction.Abort%2A&gt;</ph>.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>不会的删除队列中的任何消息，将通过调用回滚任何内容<ph id="ph2">&lt;xref:System.Messaging.MessageQueueTransaction.Abort%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>Use a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</source>
          <target state="translated">使用调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>它是当前线程在等待消息到达队列时可以被阻塞。</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>Because this overload of the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method specifies an infinite time-out, the application might wait indefinitely.</source>
          <target state="translated">因为此重载<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法指定无限期超时，则应用程序可能会无限期地等待。</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>If the application processing should continue without waiting for the message, consider using the asynchronous method, <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>.</source>
          <target state="translated">如果应用程序处理应继续而不等待消息，请考虑使用异步方法， <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> members.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> 参数不是 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 成员之一。</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the time to wait until a new message is available for inspection.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示有新消息可用于检查之前等待的时间。</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>Receives the first message available in the queue referenced by the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> and waits until either a message is available in the queue, or the time-out expires.</source>
          <target state="translated">接收由 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 引用的队列中的第一条可用消息，并且一直等到队列中有可用消息或超时过期。</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that references the first message available in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，它引用队列中可用的第一条消息。</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>Use this overload to receive a message and return in a specified period of time if there are no messages in the queue.</source>
          <target state="translated">使用此重载接收消息并在队列中没有消息时在指定的时间段内返回。</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method allows for the synchronous reading of a message, removing it from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法允许一条消息，同步读取从队列中删除它。</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>Subsequent calls to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> will return the messages that follow in the queue, or new, higher priority messages.</source>
          <target state="translated">后续调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>将返回后面在队列中，或新，优先级高的消息的消息。</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>To read the first message in a queue without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method.</source>
          <target state="translated">若要读取队列中的第一个消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法始终返回第一条消息在队列中，因此对方法的后续调用将返回相同的消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>Use a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</source>
          <target state="translated">使用调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>它是当前线程在等待消息到达队列时可以被阻塞。</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>The thread will be blocked for the given period of time, or indefinitely if you specified the value <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph> for the <ph id="ph2">`timeout`</ph> parameter.</source>
          <target state="translated">线程将被阻止给定的时间段的时间，或者如果你指定的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph>为<ph id="ph2">`timeout`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>If the application processing should continue without waiting for a message, consider using the asynchronous method, <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>.</source>
          <target state="translated">如果应用程序处理应继续而不等待一条消息，请考虑使用异步方法， <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>The following code example receives a message from a queue and outputs information about that message to the screen.</source>
          <target state="translated">下面的代码示例从队列接收消息，并输出到屏幕该消息有关的信息。</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>The example pauses execution for up to five seconds while waiting for a message to arrive in the queue.</source>
          <target state="translated">示例暂停执行时等待消息到达队列中最多为 5 秒。</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid, possibly <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> is less than <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> or greater than <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效，可能是 <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> 小于 <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> 或大于 <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>A message did not arrive in the queue before the time-out expired.</source>
          <target state="translated">在超时过期之前消息没有到达队列。</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>An error occurred when accessing a Message Queuing method</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the time to wait until a new message is available for inspection.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示有新消息可用于检查之前等待的时间。</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Cursor" /&gt;</ph> that maintains a specific position in the message queue.</source>
          <target state="translated">维持消息队列中特定位置的 <ph id="ph1">&lt;see cref="T:System.Messaging.Cursor" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)">
          <source>Receives the current message in the queue, using a specified cursor.</source>
          <target state="translated">使用指定的游标接收队列中的当前消息。</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)">
          <source>If no message is available, this method waits until either a message is available, or the time-out expires.</source>
          <target state="translated">如果没有可用的消息，此方法将等待，直到有可用的消息或超时到期为止。</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that references the first message available in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，它引用队列中可用的第一条消息。</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid, possibly <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> is less than <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> or greater than <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效，可能是 <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> 小于 <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> 或大于 <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)">
          <source>A message did not arrive in the queue before the time-out expired.</source>
          <target state="translated">在超时过期之前消息没有到达队列。</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)">
          <source>An error occurred when accessing a Message Queuing method</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)">
          <source>Use this overload to receive a message and return in a specified period of time if there are no messages in the queue.</source>
          <target state="translated">使用此重载接收消息并在队列中没有消息时在指定的时间段内返回。</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the time to wait until a new message is available for inspection.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示有新消息可用于检查之前等待的时间。</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Receives the first message available in the transactional queue referenced by the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> and waits until either a message is available in the queue, or the time-out expires.</source>
          <target state="translated">接收由 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 引用的事务性队列中的第一条可用消息，并且一直等到队列中有可用消息或超时过期。</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that references the first message available in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，它引用队列中可用的第一条消息。</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Use this overload to receive a message from a transactional queue using the internal transaction context defined by the <ph id="ph1">`transaction`</ph> parameter, and return within a specified period of time if there are no messages in the queue.</source>
          <target state="translated">使用此重载用于从使用由定义的内部事务上下文的事务性队列接收消息<ph id="ph1">`transaction`</ph>参数，并返回在指定时间段内是否存在任何消息队列中。</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method allows for the synchronous reading of a message, thereby removing it from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法允许同步读取一条消息，从而它从队列中删除。</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Subsequent calls to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> will return the messages that follow in the queue.</source>
          <target state="translated">后续调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>将返回后面的消息队列中。</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</source>
          <target state="translated">因为此方法调用事务性队列，接收的消息将返回到队列如果则中止此事务。</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The message is not permanently removed from the queue until the transaction is committed.</source>
          <target state="translated">消息永久性不删除从队列直到提交事务。</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>To read the first message in a queue without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method.</source>
          <target state="translated">若要读取队列中的第一个消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法始终返回第一条消息在队列中，因此对方法的后续调用将返回相同的消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>There is no transaction context associated with a message returned by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>.</source>
          <target state="translated">没有与通过调用返回的消息关联事务上下文<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> does not remove any messages in the queue, there would be nothing to roll back by a call to <ph id="ph2">&lt;xref:System.Messaging.MessageQueueTransaction.Abort%2A&gt;</ph>.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>不会的删除队列中的任何消息，将通过调用回滚任何内容<ph id="ph2">&lt;xref:System.Messaging.MessageQueueTransaction.Abort%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Use a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</source>
          <target state="translated">使用调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>它是当前线程在等待消息到达队列时可以被阻塞。</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The thread will be blocked for the given period of time, or indefinitely if you specified the value <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph> for the <ph id="ph2">`timeout`</ph> parameter.</source>
          <target state="translated">线程将被阻止给定的时间段的时间，或者如果你指定的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph>为<ph id="ph2">`timeout`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>If the application processing should continue without waiting for a message, consider using the asynchronous method, <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>.</source>
          <target state="translated">如果应用程序处理应继续而不等待一条消息，请考虑使用异步方法， <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The following code example demonstrates the use of this method.</source>
          <target state="translated">下面的代码示例演示如何使用此方法。</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid, possibly <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> is less than <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> or greater than <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效，可能是 <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> 小于 <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> 或大于 <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>A message did not arrive in the queue before the time-out expired.</source>
          <target state="translated">在超时过期之前消息没有到达队列。</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The queue is non-transactional.</source>
          <target state="translated">该队列为非事务性队列。</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the time to wait until a new message is available for inspection.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示有新消息可用于检查之前等待的时间。</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> values, describing the type of transaction context to associate with the message.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 值之一，它描述与消息关联的事务上下文的类型。</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Receives the first message available in the queue referenced by the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>.</source>
          <target state="translated">接收 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 引用的队列中可用的第一条消息。</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>This call is synchronous, and waits until either a message is available in the queue, or the time-out expires.</source>
          <target state="translated">此调用是同步的，并且一直等到队列中有可用的消息或超时到期。</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that references the first message available in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，它引用队列中可用的第一条消息。</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Use this overload to receive a message from a queue using a transaction context defined by the <ph id="ph1">`transactionType`</ph> parameter, and return in a specified period of time if there are no messages in the queue.</source>
          <target state="translated">使用此重载用于使用定义的事务上下文从队列接收消息<ph id="ph1">`transactionType`</ph>参数，并返回在指定时间段内是否存在任何消息队列中。</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Automatic`</ph> for the <ph id="ph2">`transactionType`</ph> parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</source>
          <target state="translated">指定<ph id="ph1">`Automatic`</ph>为<ph id="ph2">`transactionType`</ph>参数，如果已存在外部事务上下文附加到你想要用于接收消息的线程。</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Single`</ph> if you want to receive the message as a single internal transaction.</source>
          <target state="translated">指定<ph id="ph1">`Single`</ph>如果你想要接收的消息作为单个内部事务。</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>You can specify <ph id="ph1">`None`</ph> if you want to receive a message from a transactional queue outside of a transaction context.</source>
          <target state="translated">你可以指定<ph id="ph1">`None`</ph>如果你想要接收来自外部事务上下文事务性队列的消息。</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method allows for the synchronous reading of a message, thereby removing it from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法允许同步读取一条消息，从而它从队列中删除。</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Subsequent calls to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> will return the messages that follow in the queue.</source>
          <target state="translated">后续调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>将返回后面的消息队列中。</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</source>
          <target state="translated">如果调用此方法用于从事务性队列接收消息，接收的消息将返回到队列如果则中止此事务。</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The message is not permanently removed from the queue until the transaction is committed.</source>
          <target state="translated">消息永久性不删除从队列直到提交事务。</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>To read the first message in a queue without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method.</source>
          <target state="translated">若要读取队列中的第一个消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法始终返回第一条消息在队列中，因此对方法的后续调用将返回相同的消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>There is no transaction context associated with a message returned by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>.</source>
          <target state="translated">没有与通过调用返回的消息关联事务上下文<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> does not remove any messages in the queue, there would be nothing to roll back by a call to <ph id="ph2">&lt;xref:System.Messaging.MessageQueueTransaction.Abort%2A&gt;</ph>.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>不会的删除队列中的任何消息，将通过调用回滚任何内容<ph id="ph2">&lt;xref:System.Messaging.MessageQueueTransaction.Abort%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Use a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</source>
          <target state="translated">使用调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>它是当前线程在等待消息到达队列时可以被阻塞。</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The thread will be blocked for the given period of time, or indefinitely if you specified the value <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph> for the <ph id="ph2">`timeout`</ph> parameter.</source>
          <target state="translated">线程将被阻止给定的时间段的时间，或者如果你指定的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph>为<ph id="ph2">`timeout`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>If the application processing should continue without waiting for a message, consider using the asynchronous method, <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>.</source>
          <target state="translated">如果应用程序处理应继续而不等待一条消息，请考虑使用异步方法， <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The following code example demonstrates the use of this method.</source>
          <target state="translated">下面的代码示例演示如何使用此方法。</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid, possibly <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> is less than <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> or greater than <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效，可能是 <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> 小于 <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> 或大于 <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> members.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> 参数不是 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 成员之一。</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>A message did not arrive in the queue before the time-out expired.</source>
          <target state="translated">在超时过期之前消息没有到达队列。</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the time to wait until a new message is available for inspection.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示有新消息可用于检查之前等待的时间。</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Cursor" /&gt;</ph> that maintains a specific position in the message queue.</source>
          <target state="translated">维持消息队列中特定位置的 <ph id="ph1">&lt;see cref="T:System.Messaging.Cursor" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>Receives the current message in the queue, using a specified cursor.</source>
          <target state="translated">使用指定的游标接收队列中的当前消息。</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>If no message is available, this method waits until either a message is available, or the time-out expires.</source>
          <target state="translated">如果没有可用的消息，此方法将等待，直到有可用的消息或超时到期为止。</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that references a message in the queue.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，它引用队列中的一条消息。</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>Use this overload to receive a message from a transactional queue using the internal transaction context defined by the <ph id="ph1">`transaction`</ph> parameter, and return within a specified period of time if there are no messages in the queue.</source>
          <target state="translated">使用此重载用于从使用由定义的内部事务上下文的事务性队列接收消息<ph id="ph1">`transaction`</ph>参数，并返回在指定时间段内是否存在任何消息队列中。</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method allows for the synchronous reading of a message, thereby removing it from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法允许同步读取一条消息，从而它从队列中删除。</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>Subsequent calls to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> return the messages that follow in the queue.</source>
          <target state="translated">后续调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>返回后面的消息队列中。</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>Because this method is called on a transactional queue, the message that is received is returned to the queue if the transaction is aborted.</source>
          <target state="translated">因为事务性队列上调用此方法，则中止此事务如果收到的消息则返回到队列中。</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>The message is not permanently removed from the queue until the transaction is committed.</source>
          <target state="translated">消息永久性不删除从队列直到提交事务。</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>To read a message in a queue without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method.</source>
          <target state="translated">若要读取队列中的邮件，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>There is no transaction context associated with a message returned by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>.</source>
          <target state="translated">没有与通过调用返回的消息关联事务上下文<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> does not remove any messages in the queue, there is nothing to roll back by a call to <ph id="ph2">&lt;xref:System.Messaging.MessageQueueTransaction.Abort%2A&gt;</ph>.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>不会的删除队列中的任何消息，不需要通过调用回滚<ph id="ph2">&lt;xref:System.Messaging.MessageQueueTransaction.Abort%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>Use a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</source>
          <target state="translated">使用调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>它是当前线程在等待消息到达队列时可以被阻塞。</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>The thread is blocked for the given period of time, or indefinitely if you specified the value <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph> for the <ph id="ph2">`timeout`</ph> parameter.</source>
          <target state="translated">线程被阻止给定期间的时间，或者如果你指定的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph>为<ph id="ph2">`timeout`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>If the application processing should continue without waiting for a message, consider using the asynchronous method, <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>.</source>
          <target state="translated">如果应用程序处理应继续而不等待一条消息，请考虑使用异步方法， <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;paramref name="cursor" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cursor" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;paramref name="transaction" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transaction" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效。</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>Possibly <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is less than <ph id="ph2">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> or greater than <ph id="ph3">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 可能小于 <ph id="ph2">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> 或大于 <ph id="ph3">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>A message did not arrive in the queue before the time-out expired.</source>
          <target state="translated">在超时过期之前消息没有到达队列。</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>The queue is non-transactional.</source>
          <target state="translated">该队列为非事务性队列。</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the time to wait until a new message is available for inspection.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示有新消息可用于检查之前等待的时间。</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Cursor" /&gt;</ph> that maintains a specific position in the message queue.</source>
          <target state="translated">维持消息队列中特定位置的 <ph id="ph1">&lt;see cref="T:System.Messaging.Cursor" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> values that describes the type of transaction context to associate with the message.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 值之一，它描述与消息关联的事务上下文类型。</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>Receives the current message in the queue, using a specified cursor.</source>
          <target state="translated">使用指定的游标接收队列中的当前消息。</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>If no message is available, this method waits until either a message is available, or the time-out expires.</source>
          <target state="translated">如果没有可用的消息，此方法将等待，直到有可用的消息或超时到期为止。</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> that references a message in the queue.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，它引用队列中的一条消息。</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>Use this overload to receive a message from a queue using a transaction context defined by the <ph id="ph1">`transactionType`</ph> parameter, and return in a specified period of time if there are no messages in the queue.</source>
          <target state="translated">使用此重载用于使用定义的事务上下文从队列接收消息<ph id="ph1">`transactionType`</ph>参数，并返回在指定时间段内是否存在任何消息队列中。</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Automatic`</ph> for the <ph id="ph2">`transactionType`</ph> parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</source>
          <target state="translated">指定<ph id="ph1">`Automatic`</ph>为<ph id="ph2">`transactionType`</ph>参数，如果已存在外部事务上下文附加到你想要用于接收消息的线程。</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Single`</ph> if you want to receive the message as a single internal transaction.</source>
          <target state="translated">指定<ph id="ph1">`Single`</ph>如果你想要接收的消息作为单个内部事务。</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>You can specify <ph id="ph1">`None`</ph> if you want to receive a message from a transactional queue outside of a transaction context.</source>
          <target state="translated">你可以指定<ph id="ph1">`None`</ph>如果你想要接收来自外部事务上下文事务性队列的消息。</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method allows for the synchronous reading of a message, thereby removing it from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法允许同步读取一条消息，从而它从队列中删除。</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>Subsequent calls to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> return the messages that follow in the queue.</source>
          <target state="translated">后续调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>返回后面的消息队列中。</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>If this method is called to receive a message from a transactional queue, the message that is received is returned to the queue if the transaction is aborted.</source>
          <target state="translated">如果调用此方法用于从事务性队列接收消息，则中止此事务如果收到的消息则返回到队列中。</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>The message is not permanently removed from the queue until the transaction is committed.</source>
          <target state="translated">消息永久性不删除从队列直到提交事务。</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>To read a message in a queue without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> method.</source>
          <target state="translated">若要读取队列中的邮件，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>There is no transaction context associated with a message returned by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>.</source>
          <target state="translated">没有与通过调用返回的消息关联事务上下文<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph> does not remove any messages in the queue, there is nothing to roll back by a call to <ph id="ph2">&lt;xref:System.Messaging.MessageQueueTransaction.Abort%2A&gt;</ph>.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Peek%2A&gt;</ph>不会的删除队列中的任何消息，不需要通过调用回滚<ph id="ph2">&lt;xref:System.Messaging.MessageQueueTransaction.Abort%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>Use a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.</source>
          <target state="translated">使用调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>它是当前线程在等待消息到达队列时可以被阻塞。</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>The thread is blocked for the given period of time, or indefinitely if you specified the value <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph> for the <ph id="ph2">`timeout`</ph> parameter.</source>
          <target state="translated">线程被阻止给定期间的时间，或者如果你指定的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph>为<ph id="ph2">`timeout`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>If the application processing should continue without waiting for a message, consider using the asynchronous method, <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>.</source>
          <target state="translated">如果应用程序处理应继续而不等待一条消息，请考虑使用异步方法， <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="cursor" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cursor" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效。</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>Possibly <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is less than <ph id="ph2">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> or greater than <ph id="ph3">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 可能小于 <ph id="ph2">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> 或大于 <ph id="ph3">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> members.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> 参数不是 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 成员之一。</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>A message did not arrive in the queue before the time-out expired.</source>
          <target state="translated">在超时过期之前消息没有到达队列。</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)">
          <source>The method is not thread safe.</source>
          <target state="translated">该方法不是线程安全。</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Receives a message that matches a given correlation identifier.</source>
          <target state="translated">接收匹配给定相关标识符的消息。</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph> of the message to receive.</source>
          <target state="translated">要接收的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>Receives the message that matches the given correlation identifier (from a non-transactional queue) and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</source>
          <target state="translated">从非事务性队列中接收与给定的相关标识符匹配的消息，而且在队列中当前不存在具有指定相关标识符的消息时立即引发异常。</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph> matches the <ph id="ph3">&lt;paramref name="correlationId" /&gt;</ph> parameter passed in.</source>
          <target state="translated">其 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> 匹配传入的 <ph id="ph3">&lt;paramref name="correlationId" /&gt;</ph> 参数的 <ph id="ph2">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>This method looks in the non-transactional queue referenced by the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> for a message whose <ph id="ph2">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> matches the specified <ph id="ph3">`correlationId`</ph> parameter.</source>
          <target state="translated">此方法引用的非事务性队列中查找<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>的消息其<ph id="ph2">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>匹配所指定<ph id="ph3">`correlationId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>If no message is found that matches the <ph id="ph1">`correlationID`</ph> parameter, an exception is thrown.</source>
          <target state="translated">如果不找到任何消息匹配<ph id="ph1">`correlationID`</ph>参数，将引发异常。</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>Otherwise, the message is removed from the queue and returned to the application.</source>
          <target state="translated">否则为消息是从队列中移除并返回到应用程序。</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>属性用于将发送到队列相关联的响应、 报表或确认消息发送到的消息。</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>Two other methods allow you to receive messages from a queue.</source>
          <target state="translated">其他两种方法可用于从队列接收消息。</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method returns the first message in the queue, and the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph> method retrieves a message by specifying its unique identifier.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法返回第一条消息在队列中，与<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph>方法通过指定其唯一标识符来检索一条消息。</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>To read a message with a specified correlation identifier without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph> method.</source>
          <target state="translated">若要读取具有指定的相关标识符的消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>方法始终返回第一条消息在队列中，因此对方法的后续调用将返回相同的消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>The following code example sends and receives a message that contains an order to and from a queue.</source>
          <target state="translated">下面的代码示例发送和接收包含订单与队列的消息。</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.</source>
          <target state="translated">它特别请求肯定确认当原始消息到达或已从队列中检索。</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>The message with the specified <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> could not be found.</source>
          <target state="translated">未能找到具有指定 <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> 的消息。</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph> of the message to receive.</source>
          <target state="translated">要接收的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Receives the message that matches the given correlation identifier (from a transactional queue) and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</source>
          <target state="translated">从事务性队列中接收与给定的相关标识符匹配的消息，而且在队列中当前不存在具有指定相关标识符的消息时立即引发异常。</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph> matches the <ph id="ph3">&lt;paramref name="correlationId" /&gt;</ph> parameter passed in.</source>
          <target state="translated">其 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> 匹配传入的 <ph id="ph3">&lt;paramref name="correlationId" /&gt;</ph> 参数的 <ph id="ph2">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>This method looks in the transactional queue referenced by the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> for a message whose <ph id="ph2">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> matches the specified <ph id="ph3">`correlationId`</ph> parameter.</source>
          <target state="translated">此方法引用的事务性队列中查找<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>的消息其<ph id="ph2">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>匹配所指定<ph id="ph3">`correlationId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>If no message is found that matches the <ph id="ph1">`correlationID`</ph> parameter, an exception is thrown.</source>
          <target state="translated">如果不找到任何消息匹配<ph id="ph1">`correlationID`</ph>参数，将引发异常。</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Otherwise, the message is removed from the queue and returned to the application using the internal transaction context defined by the <ph id="ph1">`transaction`</ph> parameter.</source>
          <target state="translated">否则为消息从队列中删除，并且返回到应用程序使用由定义的内部事务上下文<ph id="ph1">`transaction`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</source>
          <target state="translated">因为此方法调用事务性队列，接收的消息将返回到队列如果则中止此事务。</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The message is not permanently removed from the queue until the transaction is committed.</source>
          <target state="translated">消息永久性不删除从队列直到提交事务。</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>属性用于将发送到队列相关联的响应、 报表或确认消息发送到的消息。</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Two other methods allow you to receive messages from a queue.</source>
          <target state="translated">其他两种方法可用于从队列接收消息。</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method returns the first message in the queue, and the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph> method is used to retrieve a message by specifying its unique identifier.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法返回第一条消息在队列中，与<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph>方法用于检索一条消息，通过指定其唯一标识符。</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>To read a message with a specified correlation identifier without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph> method.</source>
          <target state="translated">若要读取具有指定的相关标识符的消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>方法始终返回第一条消息在队列中，因此对方法的后续调用将返回相同的消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>There is no transaction context associated with a message returned by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>.</source>
          <target state="translated">没有与通过调用返回的消息关联事务上下文<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>不会的删除队列中的任何消息，将无法回滚事务被中止。</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;paramref name="transaction" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transaction" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The message with the specified <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> could not be found.</source>
          <target state="translated">未能找到具有指定 <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> 的消息。</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The queue is non-transactional.</source>
          <target state="translated">该队列为非事务性队列。</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph> of the message to receive.</source>
          <target state="translated">要接收的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> values, describing the type of transaction context to associate with the message.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 值之一，它描述与消息关联的事务上下文的类型。</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Receives the message that matches the given correlation identifier and immediately raises an exception if no message with the specified correlation identifier currently exists in the queue.</source>
          <target state="translated">接收匹配给定相关标识符的消息，而且在队列中当前不存在具有指定相关标识符的消息时立即引发异常。</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph> matches the <ph id="ph3">&lt;paramref name="correlationId" /&gt;</ph> parameter passed in.</source>
          <target state="translated">其 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> 匹配传入的 <ph id="ph3">&lt;paramref name="correlationId" /&gt;</ph> 参数的 <ph id="ph2">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>This method looks in the queue referenced by the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> for a message whose <ph id="ph2">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> matches the specified <ph id="ph3">`correlationId`</ph> parameter.</source>
          <target state="translated">此方法引用的队列中查找<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>的消息其<ph id="ph2">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>匹配所指定<ph id="ph3">`correlationId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>If no message is found that matches the <ph id="ph1">`correlationID`</ph> parameter, an exception is thrown.</source>
          <target state="translated">如果不找到任何消息匹配<ph id="ph1">`correlationID`</ph>参数，将引发异常。</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Otherwise, the message is removed from the queue and returned to the application using a transaction context defined by the <ph id="ph1">`transactionType`</ph> parameter.</source>
          <target state="translated">否则为消息从队列中删除，并且返回到应用程序使用定义的事务上下文<ph id="ph1">`transactionType`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Automatic`</ph> for the <ph id="ph2">`transactionType`</ph> parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</source>
          <target state="translated">指定<ph id="ph1">`Automatic`</ph>为<ph id="ph2">`transactionType`</ph>参数，如果已存在外部事务上下文附加到你想要用于接收消息的线程。</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Single`</ph> if you want to receive the message as a single internal transaction.</source>
          <target state="translated">指定<ph id="ph1">`Single`</ph>如果你想要接收的消息作为单个内部事务。</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>You can specify <ph id="ph1">`None`</ph> if you want to receive a message from a transactional queue outside of a transaction context.</source>
          <target state="translated">你可以指定<ph id="ph1">`None`</ph>如果你想要接收来自外部事务上下文事务性队列的消息。</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</source>
          <target state="translated">如果调用此方法用于从事务性队列接收消息，接收的消息将返回到队列如果则中止此事务。</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The message is not permanently removed from the queue until the transaction is committed.</source>
          <target state="translated">消息永久性不删除从队列直到提交事务。</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>属性用于将发送到队列相关联的响应、 报表或确认消息发送到的消息。</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Two other methods allow you to receive messages from a queue.</source>
          <target state="translated">其他两种方法可用于从队列接收消息。</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method returns the first message in the queue, and the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph> method is used to retrieve a message by specifying its unique identifier.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法返回第一条消息在队列中，与<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph>方法用于检索一条消息，通过指定其唯一标识符。</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>To read a message with a specified correlation identifier without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph> method.</source>
          <target state="translated">若要读取具有指定的相关标识符的消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>方法始终返回第一条消息在队列中，因此对方法的后续调用将返回相同的消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>There is no transaction context associated with a message returned by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>.</source>
          <target state="translated">没有与通过调用返回的消息关联事务上下文<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>不会的删除队列中的任何消息，将无法回滚事务被中止。</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The message with the specified <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> could not be found.</source>
          <target state="translated">未能找到具有指定 <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> 的消息。</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> members.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> 参数不是 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 成员之一。</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph> of the message to receive.</source>
          <target state="translated">要接收的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the time to wait until a new message is available for inspection.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示有新消息可用于检查之前等待的时间。</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>Receives the message that matches the given correlation identifier (from a non-transactional queue) and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</source>
          <target state="translated">从非事务性队列中接收与给定的相关标识符匹配的消息，并且一直等到队列中出现具有指定相关标识符的消息或者超时过期。</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph> matches the <ph id="ph3">&lt;paramref name="correlationId" /&gt;</ph> parameter passed in.</source>
          <target state="translated">其 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> 匹配传入的 <ph id="ph3">&lt;paramref name="correlationId" /&gt;</ph> 参数的 <ph id="ph2">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>This method looks in the non-transactional queue referenced by the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> for a message whose <ph id="ph2">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> matches the specified <ph id="ph3">`correlationId`</ph> parameter.</source>
          <target state="translated">此方法引用的非事务性队列中查找<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>的消息其<ph id="ph2">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>匹配所指定<ph id="ph3">`correlationId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>This method returns immediately if the message with the correlation identifier specified by the <ph id="ph1">`correlationId`</ph> parameter is in the queue.</source>
          <target state="translated">此方法将立即返回指定的相关标识符的消息如果<ph id="ph1">`correlationId`</ph>参数是在队列中。</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>Otherwise, the method waits the given period of time for a new message to arrive.</source>
          <target state="translated">否则，该方法将等待给定的时间段内的新消息到达。</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>If a new message does not arrive before the time-out expires, an exception is thrown.</source>
          <target state="translated">如果超时过期之前，不会到达一条新消息，将引发异常。</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">`timeout`</ph> parameter does not specify the total running time for this method.</source>
          <target state="translated"><ph id="ph1">`timeout`</ph>参数未指定的总运行时间为此方法。</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>Rather, it specifies the time to wait for a new message to arrive in the queue.</source>
          <target state="translated">相反，它指定为新消息到达队列中等待的时间。</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>Each time a new message arrives, this method examines the <ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> of the new message to see if it matches the <ph id="ph2">`correlationId`</ph> parameter.</source>
          <target state="translated">每次有新消息到达时，此方法检查<ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>的新消息，以查看其是否符合<ph id="ph2">`correlationId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>If not, this method starts the time-out period over and waits for another new message to arrive.</source>
          <target state="translated">如果没有，此方法通过启动超时期限，等待另一个新消息到达。</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> matches the <ph id="ph2">`correlationId`</ph> parameter.</source>
          <target state="translated">因此，如果新消息继续到达超时时间内，则可能为此方法继续运行; 如果无限期，直到在超时期限过期并且没有任何新的消息到达，或者直到消息到达其<ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>匹配<ph id="ph2">`correlationId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>属性用于将发送到队列相关联的响应、 报表或确认消息发送到的消息。</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>Two other methods allow you to receive messages from a queue.</source>
          <target state="translated">其他两种方法可用于从队列接收消息。</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method returns the first message in the queue, and the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph> method is used to retrieve a message by specifying its unique identifier.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法返回第一条消息在队列中，与<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph>方法用于检索一条消息，通过指定其唯一标识符。</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>To read a message with a specified correlation identifier without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph> method.</source>
          <target state="translated">若要读取具有指定的相关标识符的消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>方法始终返回第一条消息在队列中，因此对方法的后续调用将返回相同的消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid, possibly <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> is less than <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> or greater than <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效，可能是 <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> 小于 <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> 或大于 <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>The message with the specified <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> does not exist in the queue and did not arrive before the time-out expired.</source>
          <target state="translated">具有指定 <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> 的消息不在队列中，而且在超时过期之前没有到达。</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph> of the message to receive.</source>
          <target state="translated">要接收的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the time to wait until a new message is available for inspection.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示有新消息可用于检查之前等待的时间。</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Receives the message that matches the given correlation identifier (from a transactional queue) and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</source>
          <target state="translated">从事务性队列中接收与给定的相关标识符匹配的消息，并且一直等到队列中出现具有指定相关标识符的消息或者超时过期。</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph> matches the <ph id="ph3">&lt;paramref name="correlationId" /&gt;</ph> parameter passed in.</source>
          <target state="translated">其 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> 匹配传入的 <ph id="ph3">&lt;paramref name="correlationId" /&gt;</ph> 参数的 <ph id="ph2">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>This method looks in the transactional queue referenced by the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> for a message whose <ph id="ph2">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> matches the specified <ph id="ph3">`correlationId`</ph> parameter.</source>
          <target state="translated">此方法引用的事务性队列中查找<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>的消息其<ph id="ph2">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>匹配所指定<ph id="ph3">`correlationId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>This method returns immediately if the message with the correlation identifier specified by the <ph id="ph1">`correlationId`</ph> parameter is in the queue, using the internal transaction context defined by the <ph id="ph2">`transaction`</ph> parameter.</source>
          <target state="translated">此方法将立即返回指定的相关标识符的消息如果<ph id="ph1">`correlationId`</ph>参数是在队列中，使用由定义的内部事务上下文<ph id="ph2">`transaction`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Otherwise, the method waits the given period of time for a new message to arrive.</source>
          <target state="translated">否则，该方法将等待给定的时间段内的新消息到达。</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>If a new message does not arrive before the time-out expires, an exception is thrown.</source>
          <target state="translated">如果超时过期之前，不会到达一条新消息，将引发异常。</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">`timeout`</ph> parameter does not specify the total running time for this method.</source>
          <target state="translated"><ph id="ph1">`timeout`</ph>参数未指定的总运行时间为此方法。</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Rather, it specifies the time to wait for a new message to arrive in the queue.</source>
          <target state="translated">相反，它指定为新消息到达队列中等待的时间。</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Each time a new message arrives, this method examines the <ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> of the new message to see if it matches the <ph id="ph2">`correlationId`</ph> parameter.</source>
          <target state="translated">每次有新消息到达时，此方法检查<ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>的新消息，以查看其是否符合<ph id="ph2">`correlationId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>If not, this method starts the time-out period over and waits for another new message to arrive.</source>
          <target state="translated">如果没有，此方法通过启动超时期限，等待另一个新消息到达。</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> matches the <ph id="ph2">`correlationId`</ph> parameter.</source>
          <target state="translated">因此，如果新消息继续到达超时时间内，则可能为此方法继续运行; 如果无限期，直到在超时期限过期并且没有任何新的消息到达，或者直到消息到达其<ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>匹配<ph id="ph2">`correlationId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</source>
          <target state="translated">因为此方法调用事务性队列，接收的消息将返回到队列如果则中止此事务。</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The message is not permanently removed from the queue until the transaction is committed.</source>
          <target state="translated">消息永久性不删除从队列直到提交事务。</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>属性用于将发送到队列相关联的响应、 报表或确认消息发送到的消息。</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Two other methods allow you to receive messages from a queue.</source>
          <target state="translated">其他两种方法可用于从队列接收消息。</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method returns the first message in the queue, and the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph> method is used to retrieve a message by specifying its unique identifier.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法返回第一条消息在队列中，与<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph>方法用于检索一条消息，通过指定其唯一标识符。</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>To read a message with a specified correlation identifier without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph> method.</source>
          <target state="translated">若要读取具有指定的相关标识符的消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>方法始终返回第一条消息在队列中，因此对方法的后续调用将返回相同的消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>There is no transaction context associated with a message returned by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>.</source>
          <target state="translated">没有与通过调用返回的消息关联事务上下文<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>不会的删除队列中的任何消息，将无法回滚事务被中止。</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;paramref name="transaction" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transaction" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid, possibly <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> is less than <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> or greater than <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效，可能是 <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> 小于 <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> 或大于 <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The message with the specified <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> does not exist in the queue and did not arrive before the time-out expired.</source>
          <target state="translated">具有指定 <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> 的消息不在队列中，而且在超时过期之前没有到达。</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The queue is non-transactional.</source>
          <target state="translated">该队列为非事务性队列。</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph> of the message to receive.</source>
          <target state="translated">要接收的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the time to wait until a new message is available for inspection.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示有新消息可用于检查之前等待的时间。</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> values, describing the type of transaction context to associate with the message.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 值之一，它描述与消息关联的事务上下文的类型。</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Receives the message that matches the given correlation identifier and waits until either a message with the specified correlation identifier is available in the queue, or the time-out expires.</source>
          <target state="translated">接收与给定的相关标识符匹配的消息，并且一直等到队列中出现具有指定相关标识符的消息或超时过期。</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph> matches the <ph id="ph3">&lt;paramref name="correlationId" /&gt;</ph> parameter passed in.</source>
          <target state="translated">其 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> 匹配传入的 <ph id="ph3">&lt;paramref name="correlationId" /&gt;</ph> 参数的 <ph id="ph2">&lt;see cref="P:System.Messaging.Message.CorrelationId" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>This method looks in the queue referenced by the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> for a message whose <ph id="ph2">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> matches the specified <ph id="ph3">`correlationId`</ph> parameter.</source>
          <target state="translated">此方法引用的队列中查找<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>的消息其<ph id="ph2">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>匹配所指定<ph id="ph3">`correlationId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>This method returns immediately if the message with the correlation identifier specified by the <ph id="ph1">`correlationId`</ph> parameter is in the queue, using a transaction context defined by the <ph id="ph2">`transactionType`</ph> parameter.</source>
          <target state="translated">此方法将立即返回指定的相关标识符的消息如果<ph id="ph1">`correlationId`</ph>参数是在队列中，使用定义的事务上下文<ph id="ph2">`transactionType`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Otherwise, the method waits the given period of time for a new message to arrive.</source>
          <target state="translated">否则，该方法将等待给定的时间段内的新消息到达。</target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>If a new message does not arrive before the time-out expires, an exception is thrown.</source>
          <target state="translated">如果超时过期之前，不会到达一条新消息，将引发异常。</target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">`timeout`</ph> parameter does not specify the total running time for this method.</source>
          <target state="translated"><ph id="ph1">`timeout`</ph>参数未指定的总运行时间为此方法。</target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Rather, it specifies the time to wait for a new message to arrive in the queue.</source>
          <target state="translated">相反，它指定为新消息到达队列中等待的时间。</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Each time a new message arrives, this method examines the <ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> of the new message to see if it matches the <ph id="ph2">`correlationId`</ph> parameter.</source>
          <target state="translated">每次有新消息到达时，此方法检查<ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>的新消息，以查看其是否符合<ph id="ph2">`correlationId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>If not, this method starts the time-out period over and waits for another new message to arrive.</source>
          <target state="translated">如果没有，此方法通过启动超时期限，等待另一个新消息到达。</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> matches the <ph id="ph2">`correlationId`</ph> parameter.</source>
          <target state="translated">因此，如果新消息继续到达超时时间内，则可能为此方法继续运行; 如果无限期，直到在超时期限过期并且没有任何新的消息到达，或者直到消息到达其<ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>匹配<ph id="ph2">`correlationId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Automatic`</ph> for the <ph id="ph2">`transactionType`</ph> parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</source>
          <target state="translated">指定<ph id="ph1">`Automatic`</ph>为<ph id="ph2">`transactionType`</ph>参数，如果已存在外部事务上下文附加到你想要用于接收消息的线程。</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Single`</ph> if you want to receive the message as a single internal transaction.</source>
          <target state="translated">指定<ph id="ph1">`Single`</ph>如果你想要接收的消息作为单个内部事务。</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>You can specify <ph id="ph1">`None`</ph> if you want to receive a message from a transactional queue outside of a transaction context.</source>
          <target state="translated">你可以指定<ph id="ph1">`None`</ph>如果你想要接收来自外部事务上下文事务性队列的消息。</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</source>
          <target state="translated">如果调用此方法用于从事务性队列接收消息，接收的消息将返回到队列如果则中止此事务。</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The message is not permanently removed from the queue until the transaction is committed.</source>
          <target state="translated">消息永久性不删除从队列直到提交事务。</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph> property is used to tie a message sent to the queue to associated response, report, or acknowledgment messages.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.CorrelationId%2A&gt;</ph>属性用于将发送到队列相关联的响应、 报表或确认消息发送到的消息。</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Two other methods allow you to receive messages from a queue.</source>
          <target state="translated">其他两种方法可用于从队列接收消息。</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method returns the first message in the queue, and the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph> method is used to retrieve a message by specifying its unique identifier.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法返回第一条消息在队列中，与<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph>方法用于检索一条消息，通过指定其唯一标识符。</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>To read a message with a specified correlation identifier without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph> method.</source>
          <target state="translated">若要读取具有指定的相关标识符的消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>方法始终返回第一条消息在队列中，因此对方法的后续调用将返回相同的消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>There is no transaction context associated with a message returned by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>.</source>
          <target state="translated">没有与通过调用返回的消息关联事务上下文<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29&gt;</ph>不会的删除队列中的任何消息，将无法回滚事务被中止。</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The message with the specified <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> could not be found.</source>
          <target state="translated">未能找到具有指定 <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> 的消息。</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid, possibly <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> is less than <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> or greater than <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效，可能是 <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> 小于 <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> 或大于 <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> members.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> 参数不是 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 成员之一。</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The message with the specified <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> does not exist in the queue and did not arrive before the time-out expired.</source>
          <target state="translated">具有指定 <ph id="ph1">&lt;paramref name="correlationId" /&gt;</ph> 的消息不在队列中，而且在超时过期之前没有到达。</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Receives the message that matches the given identifier, removing it from the queue.</source>
          <target state="translated">接收匹配给定标识符的消息，并将其从队列中移除。</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> of the message to receive.</source>
          <target state="translated">要接收的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>Receives the message that matches the given identifier from a non-transactional queue and immediately raises an exception if no message with the specified identifier currently exists in the queue.</source>
          <target state="translated">从非事务性队列中接收与给定的标识符匹配的消息，而且在队列中当前不存在具有指定标识符的消息时立即引发异常。</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> property matches the <ph id="ph3">&lt;paramref name="id" /&gt;</ph> parameter passed in.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，其 <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> 属性匹配传入的 <ph id="ph3">&lt;paramref name="id" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>Use this method to read a message with a known identifier and remove it from the queue.</source>
          <target state="translated">使用此方法读取具有已知标识符的消息和从队列中删除它。</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>This method throws an exception immediately if the message is not in the queue.</source>
          <target state="translated">如果消息也不会在队列中，此方法将立即引发异常。</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given <ph id="ph2">`id`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph>消息的属性是消息队列企业中，唯一的因此将最多一条消息匹配的队列中给定<ph id="ph2">`id`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>Two other methods allow you to receive messages from a queue.</source>
          <target state="translated">其他两种方法可用于从队列接收消息。</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method returns the first message in the queue, and the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29&gt;</ph> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法返回第一条消息在队列中，与<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29&gt;</ph>方法用于检索确认、 报表或创建第一条消息发送到队列的应用程序生成的响应消息。</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>To read a message with a specified identifier without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> method.</source>
          <target state="translated">若要读取具有指定标识符的消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>方法始终返回第一条消息在队列中，因此对方法的后续调用将返回相同的消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="id" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="id" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>The message with the specified <ph id="ph1">&lt;paramref name="id" /&gt;</ph> could not be found.</source>
          <target state="translated">未能找到具有指定 <ph id="ph1">&lt;paramref name="id" /&gt;</ph> 的消息。</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> of the message to receive.</source>
          <target state="translated">要接收的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Receives the message that matches the given identifier (from a transactional queue) and immediately raises an exception if no message with the specified identifier currently exists in the queue.</source>
          <target state="translated">从事务性队列中接收与给定的标识符匹配的消息，而且在队列中当前不存在具有指定标识符的消息时立即引发异常。</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> property matches the <ph id="ph3">&lt;paramref name="id" /&gt;</ph> parameter passed in.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，其 <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> 属性匹配传入的 <ph id="ph3">&lt;paramref name="id" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Use this method to read a message with a known identifier and remove it from the queue, using the internal transaction context defined by the <ph id="ph1">`transaction`</ph> parameter.</source>
          <target state="translated">使用此方法读取具有已知标识符的消息并从队列中，使用由定义的内部事务上下文中移除<ph id="ph1">`transaction`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>This method throws an exception immediately if the message is not in the queue</source>
          <target state="translated">此方法时引发异常立即消息也不会在队列中</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given <ph id="ph2">`id`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph>消息的属性是消息队列企业中，唯一的因此将最多一条消息匹配的队列中给定<ph id="ph2">`id`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</source>
          <target state="translated">因为此方法调用事务性队列，接收的消息将返回到队列如果则中止此事务。</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The message is not permanently removed from the queue until the transaction is committed.</source>
          <target state="translated">消息永久性不删除从队列直到提交事务。</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Two other methods allow you to receive messages from a queue.</source>
          <target state="translated">其他两种方法可用于从队列接收消息。</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method returns the first message in the queue, and the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29&gt;</ph> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法返回第一条消息在队列中，与<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29&gt;</ph>方法用于检索确认、 报表或创建第一条消息发送到队列的应用程序生成的响应消息。</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>To read a message with a specified identifier without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> method.</source>
          <target state="translated">若要读取具有指定标识符的消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>方法始终返回第一条消息在队列中，因此对方法的后续调用将返回相同的消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>There is no transaction context associated with a message returned by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>.</source>
          <target state="translated">没有与通过调用返回的消息关联事务上下文<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>不会的删除队列中的任何消息，将无法回滚事务被中止。</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;paramref name="id" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="id" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;paramref name="transaction" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transaction" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The message with the specified <ph id="ph1">&lt;paramref name="id" /&gt;</ph> could not be found.</source>
          <target state="translated">未能找到具有指定 <ph id="ph1">&lt;paramref name="id" /&gt;</ph> 的消息。</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>The queue is non-transactional.</source>
          <target state="translated">该队列为非事务性队列。</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> of the message to receive.</source>
          <target state="translated">要接收的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> values, describing the type of transaction context to associate with the message.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 值之一，它描述与消息关联的事务上下文的类型。</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Receives the message that matches the given identifier and immediately raises an exception if no message with the specified identifier currently exists in the queue.</source>
          <target state="translated">接收与给定的标识符匹配的消息，而且在队列中当前不存在具有指定标识符的消息时立即引发异常。</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> property matches the <ph id="ph3">&lt;paramref name="id" /&gt;</ph> parameter passed in.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，其 <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> 属性匹配传入的 <ph id="ph3">&lt;paramref name="id" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Use this method to read a message with a known identifier and remove it from the queue.</source>
          <target state="translated">使用此方法读取具有已知标识符的消息和从队列中删除它。</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>This method throws an exception immediately if the message is not in the queue.</source>
          <target state="translated">如果消息也不会在队列中，此方法将立即引发异常。</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Otherwise, the message is removed from the queue and returned to the application using a transaction context defined by the <ph id="ph1">`transactionType`</ph> parameter.</source>
          <target state="translated">否则为消息从队列中删除，并且返回到应用程序使用定义的事务上下文<ph id="ph1">`transactionType`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Automatic`</ph> for the <ph id="ph2">`transactionType`</ph> parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</source>
          <target state="translated">指定<ph id="ph1">`Automatic`</ph>为<ph id="ph2">`transactionType`</ph>参数，如果已存在外部事务上下文附加到你想要用于接收消息的线程。</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Single`</ph> if you want to receive the message as a single internal transaction.</source>
          <target state="translated">指定<ph id="ph1">`Single`</ph>如果你想要接收的消息作为单个内部事务。</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>You can specify <ph id="ph1">`None`</ph> if you want to receive a message from a transactional queue outside of a transaction context.</source>
          <target state="translated">你可以指定<ph id="ph1">`None`</ph>如果你想要接收来自外部事务上下文事务性队列的消息。</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given <ph id="ph2">`id`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph>消息的属性是消息队列企业中，唯一的因此将最多一条消息匹配的队列中给定<ph id="ph2">`id`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>If the message with the specified identifier is in a queue other than the one associated with this <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> instance, the message will not be found.</source>
          <target state="translated">如果具有指定标识符消息在队列中与此关联以外<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>实例，该消息将不会找到。</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</source>
          <target state="translated">如果调用此方法用于从事务性队列接收消息，接收的消息将返回到队列如果则中止此事务。</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The message is not permanently removed from the queue until the transaction is committed.</source>
          <target state="translated">消息永久性不删除从队列直到提交事务。</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Two other methods allow you to receive messages from a queue.</source>
          <target state="translated">其他两种方法可用于从队列接收消息。</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method returns the first message in the queue, and the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29&gt;</ph> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法返回第一条消息在队列中，与<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29&gt;</ph>方法用于检索确认、 报表或创建第一条消息发送到队列的应用程序生成的响应消息。</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>To read a message with a specified identifier without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> method.</source>
          <target state="translated">若要读取具有指定标识符的消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>方法始终返回第一条消息在队列中，因此对方法的后续调用将返回相同的消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>There is no transaction context associated with a message returned by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>.</source>
          <target state="translated">没有与通过调用返回的消息关联事务上下文<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>不会的删除队列中的任何消息，将无法回滚事务被中止。</target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="id" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="id" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The message with the specified <ph id="ph1">&lt;paramref name="id" /&gt;</ph> could not be found.</source>
          <target state="translated">未能找到具有指定 <ph id="ph1">&lt;paramref name="id" /&gt;</ph> 的消息。</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> members.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> 参数不是 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 成员之一。</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> of the message to receive.</source>
          <target state="translated">要接收的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the time to wait until a new message is available for inspection.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示有新消息可用于检查之前等待的时间。</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>Receives the message that matches the given identifier (from a non-transactional queue) and waits until either a message with the specified identifier is available in the queue or the time-out expires.</source>
          <target state="translated">从非事务性队列接收与给定的标识符匹配的消息，并且一直等到队列中出现具有指定标识符的消息或超时过期。</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> property matches the <ph id="ph3">&lt;paramref name="id" /&gt;</ph> parameter passed in.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，其 <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> 属性匹配传入的 <ph id="ph3">&lt;paramref name="id" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>Use this method to read a message with a known identifier and remove it from the queue.</source>
          <target state="translated">使用此方法读取具有已知标识符的消息和从队列中删除它。</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>This method returns immediately if the message with the identifier specified by the <ph id="ph1">`id`</ph> parameter is in the queue.</source>
          <target state="translated">此方法将立即返回指定标识符的消息如果<ph id="ph1">`id`</ph>参数是在队列中。</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>Otherwise, the method waits the given period of time for a new message to arrive.</source>
          <target state="translated">否则，该方法将等待给定的时间段内的新消息到达。</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>If a new message does not arrive before the time-out expires, an exception is thrown.</source>
          <target state="translated">如果超时过期之前，不会到达一条新消息，将引发异常。</target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">`timeout`</ph> parameter does not specify the total running time for this method.</source>
          <target state="translated"><ph id="ph1">`timeout`</ph>参数未指定的总运行时间为此方法。</target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>Rather, it specifies the time to wait for a new message to arrive in the queue.</source>
          <target state="translated">相反，它指定为新消息到达队列中等待的时间。</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>Each time a new message arrives, this method examines the <ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph> of the new message to see if it matches the <ph id="ph2">`id`</ph> parameter.</source>
          <target state="translated">每次有新消息到达时，此方法检查<ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph>的新消息，以查看其是否符合<ph id="ph2">`id`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>If not, this method starts the time-out period over and waits for another new message to arrive.</source>
          <target state="translated">如果没有，此方法通过启动超时期限，等待另一个新消息到达。</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph> matches the <ph id="ph2">`id`</ph> parameter.</source>
          <target state="translated">因此，如果新消息继续到达超时时间内，则可能为此方法继续运行; 如果无限期，直到在超时期限过期并且没有任何新的消息到达，或者直到消息到达其<ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph>匹配<ph id="ph2">`id`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given <ph id="ph2">`id`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph>消息的属性是消息队列企业中，唯一的因此将最多一条消息匹配的队列中给定<ph id="ph2">`id`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>Use this overload of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph> when it is acceptable for the current thread to be blocked as long as new messages continue to arrive in the queue within the time-out period specified by the <ph id="ph2">`timeout`</ph> parameter.</source>
          <target state="translated">请使用此重载<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph>时可接受的当前线程，可以被阻塞，只要新消息继续到达队列所指定的超时时间内<ph id="ph2">`timeout`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>The thread will be blocked for at least the given period of time, or indefinitely if you specified the value <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph> for the <ph id="ph2">`timeout`</ph> parameter, or if new messages continue to arrive in the queue within the time-out period specified by the <ph id="ph3">`timeout`</ph> parameter.</source>
          <target state="translated">该线程将被阻止至少给定期间的时间，或者如果你指定的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph>为<ph id="ph2">`timeout`</ph>参数，或如果新消息继续到达队列所指定的超时时间内<ph id="ph3">`timeout`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>Two other methods allow you to receive messages from a queue.</source>
          <target state="translated">其他两种方法可用于从队列接收消息。</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method returns the first message in the queue, and the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29&gt;</ph> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法返回第一条消息在队列中，与<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29&gt;</ph>方法用于检索确认、 报表或创建第一条消息发送到队列的应用程序生成的响应消息。</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>To read a message with a specified identifier without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> method.</source>
          <target state="translated">若要读取具有指定标识符的消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>方法始终返回第一条消息在队列中，因此对方法的后续调用将返回相同的消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="id" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="id" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid, possibly <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> is less than <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> or greater than <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效，可能是 <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> 小于 <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> 或大于 <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>A message with the specified <ph id="ph1">&lt;paramref name="id" /&gt;</ph> did not arrive in the queue before the time-out expired.</source>
          <target state="translated">在时间超时之前，带有指定 <ph id="ph1">&lt;paramref name="id" /&gt;</ph> 的消息没有到达队列。</target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> of the message to receive.</source>
          <target state="translated">要接收的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the time to wait until a new message is available for inspection.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示有新消息可用于检查之前等待的时间。</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Receives the message that matches the given identifier (from a transactional queue) and waits until either a message with the specified identifier is available in the queue or the time-out expires.</source>
          <target state="translated">从事务性队列接收与给定的标识符匹配的消息，并且一直等到队列中出现具有指定标识符的消息或超时过期。</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> property matches the <ph id="ph3">&lt;paramref name="id" /&gt;</ph> parameter passed in.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，其 <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> 属性匹配传入的 <ph id="ph3">&lt;paramref name="id" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Use this method to read a message with a known identifier and remove it from the queue, using the internal transaction context defined by the <ph id="ph1">`transaction`</ph> parameter.</source>
          <target state="translated">使用此方法读取具有已知标识符的消息并从队列中，使用由定义的内部事务上下文中移除<ph id="ph1">`transaction`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>This method returns immediately if the message with the identifier specified by the <ph id="ph1">`id`</ph> parameter is in the queue.</source>
          <target state="translated">此方法将立即返回指定标识符的消息如果<ph id="ph1">`id`</ph>参数是在队列中。</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Otherwise, the method waits the given period of time for a new message to arrive.</source>
          <target state="translated">否则，该方法将等待给定的时间段内的新消息到达。</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>If a new message does not arrive before the time-out expires, an exception is thrown.</source>
          <target state="translated">如果超时过期之前，不会到达一条新消息，将引发异常。</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">`timeout`</ph> parameter does not specify the total running time for this method.</source>
          <target state="translated"><ph id="ph1">`timeout`</ph>参数未指定的总运行时间为此方法。</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Rather, it specifies the time to wait for a new message to arrive in the queue.</source>
          <target state="translated">相反，它指定为新消息到达队列中等待的时间。</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Each time a new message arrives, this method examines the <ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph> of the new message to see if it matches the <ph id="ph2">`id`</ph> parameter.</source>
          <target state="translated">每次有新消息到达时，此方法检查<ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph>的新消息，以查看其是否符合<ph id="ph2">`id`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>If not, this method starts the time-out period over and waits for another new message to arrive.</source>
          <target state="translated">如果没有，此方法通过启动超时期限，等待另一个新消息到达。</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph> matches the <ph id="ph2">`id`</ph> parameter.</source>
          <target state="translated">因此，如果新消息继续到达超时时间内，则可能为此方法继续运行; 如果无限期，直到在超时期限过期并且没有任何新的消息到达，或者直到消息到达其<ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph>匹配<ph id="ph2">`id`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given <ph id="ph2">`id`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph>消息的属性是消息队列企业中，唯一的因此将最多一条消息匹配的队列中给定<ph id="ph2">`id`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Use this overload of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph> when it is acceptable for the current thread to be blocked as long as new messages continue to arrive in the queue within the time-out period specified by the <ph id="ph2">`timeout`</ph> parameter.</source>
          <target state="translated">请使用此重载<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph>时可接受的当前线程，可以被阻塞，只要新消息继续到达队列所指定的超时时间内<ph id="ph2">`timeout`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The thread will be blocked for at least the given period of time, or indefinitely if you specified the value <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph> for the <ph id="ph2">`timeout`</ph> parameter, or if new messages continue to arrive in the queue within the timeout period specified by the <ph id="ph3">`timeout`</ph> parameter.</source>
          <target state="translated">该线程将被阻止至少给定期间的时间，或者如果你指定的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph>为<ph id="ph2">`timeout`</ph>参数，或如果新消息继续到达队列所指定的超时期限内<ph id="ph3">`timeout`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</source>
          <target state="translated">因为此方法调用事务性队列，接收的消息将返回到队列如果则中止此事务。</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The message is not permanently removed from the queue until the transaction is committed.</source>
          <target state="translated">消息永久性不删除从队列直到提交事务。</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Two other methods allow you to receive messages from a queue.</source>
          <target state="translated">其他两种方法可用于从队列接收消息。</target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method returns the first message in the queue, and the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29&gt;</ph> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法返回第一条消息在队列中，与<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29&gt;</ph>方法用于检索确认、 报表或创建第一条消息发送到队列的应用程序生成的响应消息。</target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>To read a message with a specified identifier without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> method.</source>
          <target state="translated">若要读取具有指定标识符的消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> method always returns the first message in the queue, so subsequent calls to the method return the same message, unless a higher priority message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>方法始终返回第一条消息在队列中，因此对方法的后续调用返回相同的消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>There is no transaction context associated with a message returned by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>.</source>
          <target state="translated">没有与通过调用返回的消息关联事务上下文<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>不会的删除队列中的任何消息，将无法回滚事务被中止。</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;paramref name="id" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="id" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;paramref name="transaction" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transaction" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid, possibly <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> is less than <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> or greater than <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效，可能是 <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> 小于 <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> 或大于 <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>A message with the specified <ph id="ph1">&lt;paramref name="id" /&gt;</ph> did not arrive in the queue before the time-out expired.</source>
          <target state="translated">在时间超时之前，带有指定 <ph id="ph1">&lt;paramref name="id" /&gt;</ph> 的消息没有到达队列。</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>The queue is non-transactional.</source>
          <target state="translated">该队列为非事务性队列。</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> of the message to receive.</source>
          <target state="translated">要接收的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that indicates the time to wait until a new message is available for inspection.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> 指示有新消息可用于检查之前等待的时间。</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> values, describing the type of transaction context to associate with the message.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 值之一，它描述与消息关联的事务上下文的类型。</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Receives the message that matches the given identifier and waits until either a message with the specified identifier is available in the queue or the time-out expires.</source>
          <target state="translated">接收与给定的标识符匹配的消息，并且一直等到队列中出现具有指定标识符的消息或超时过期。</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> property matches the <ph id="ph3">&lt;paramref name="id" /&gt;</ph> parameter passed in.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，其 <ph id="ph2">&lt;see cref="P:System.Messaging.Message.Id" /&gt;</ph> 属性匹配传入的 <ph id="ph3">&lt;paramref name="id" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Use this method to read a message with a known identifier and remove it from the queue.</source>
          <target state="translated">使用此方法读取具有已知标识符的消息和从队列中删除它。</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>This method returns immediately if the message with the identifier specified by the <ph id="ph1">`id`</ph> parameter is in the queue, using a transaction context defined by the <ph id="ph2">`transactionType`</ph> parameter.</source>
          <target state="translated">此方法将立即返回指定标识符的消息如果<ph id="ph1">`id`</ph>参数是在队列中，使用定义的事务上下文<ph id="ph2">`transactionType`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Otherwise, the method waits the given period of time for a new message to arrive.</source>
          <target state="translated">否则，该方法将等待给定的时间段内的新消息到达。</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>If a new message does not arrive before the time-out expires, an exception is thrown.</source>
          <target state="translated">如果超时过期之前，不会到达一条新消息，将引发异常。</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">`timeout`</ph> parameter does not specify the total running time for this method.</source>
          <target state="translated"><ph id="ph1">`timeout`</ph>参数未指定的总运行时间为此方法。</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Rather, it specifies the time to wait for a new message to arrive in the queue.</source>
          <target state="translated">相反，它指定为新消息到达队列中等待的时间。</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Each time a new message arrives, this method examines the <ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph> of the new message to see if it matches the <ph id="ph2">`id`</ph> parameter.</source>
          <target state="translated">每次有新消息到达时，此方法检查<ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph>的新消息，以查看其是否符合<ph id="ph2">`id`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>If not, this method starts the time-out period over and waits for another new message to arrive.</source>
          <target state="translated">如果没有，此方法通过启动超时期限，等待另一个新消息到达。</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Therefore, if new messages continue to arrive within the time-out period, it is possible for this method to continue running indefinitely, either until the time-out period expires without any new messages arriving, or until a message arrives whose <ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph> matches the <ph id="ph2">`id`</ph> parameter.</source>
          <target state="translated">因此，如果新消息继续到达超时时间内，则可能为此方法继续运行; 如果无限期，直到在超时期限过期并且没有任何新的消息到达，或者直到消息到达其<ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph>匹配<ph id="ph2">`id`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Automatic`</ph> for the <ph id="ph2">`transactionType`</ph> parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</source>
          <target state="translated">指定<ph id="ph1">`Automatic`</ph>为<ph id="ph2">`transactionType`</ph>参数，如果已存在外部事务上下文附加到你想要用于接收消息的线程。</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Single`</ph> if you want to receive the message as a single internal transaction.</source>
          <target state="translated">指定<ph id="ph1">`Single`</ph>如果你想要接收的消息作为单个内部事务。</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>You can specify <ph id="ph1">`None`</ph> if you want to receive a message from a transactional queue outside of a transaction context.</source>
          <target state="translated">你可以指定<ph id="ph1">`None`</ph>如果你想要接收来自外部事务上下文事务性队列的消息。</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph> property of a message is unique across the Message Queuing enterprise, so there will be at most one message in the queue that matches the given <ph id="ph2">`id`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.Id%2A&gt;</ph>消息的属性是消息队列企业中，唯一的因此将最多一条消息匹配的队列中给定<ph id="ph2">`id`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>If the message with the specified identifier is in a queue other than the one associated with this <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> instance, the message will not be found.</source>
          <target state="translated">如果具有指定标识符消息在队列中与此关联以外<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>实例，该消息将不会找到。</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Use this overload of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph> when it is acceptable for the current thread to be blocked as long as new messages continue to arrive in the queue within the time-out period specified by the <ph id="ph2">`timeout`</ph> parameter.</source>
          <target state="translated">请使用此重载<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29&gt;</ph>时可接受的当前线程，可以被阻塞，只要新消息继续到达队列所指定的超时时间内<ph id="ph2">`timeout`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The thread will be blocked for at least the given period of time, or indefinitely if you specified the value <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph> for the <ph id="ph2">`timeout`</ph> parameter, or if new messages continue to arrive in the queue within the time-out period specified by the <ph id="ph3">`timeout`</ph> parameter.</source>
          <target state="translated">该线程将被阻止至少给定期间的时间，或者如果你指定的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.InfiniteTimeout&gt;</ph>为<ph id="ph2">`timeout`</ph>参数，或如果新消息继续到达队列所指定的超时时间内<ph id="ph3">`timeout`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</source>
          <target state="translated">如果调用此方法用于从事务性队列接收消息，接收的消息将返回到队列如果则中止此事务。</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The message is not permanently removed from the queue until the transaction is committed.</source>
          <target state="translated">消息永久性不删除从队列直到提交事务。</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Two other methods allow you to receive messages from a queue.</source>
          <target state="translated">其他两种方法可用于从队列接收消息。</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph> method returns the first message in the queue, and the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29&gt;</ph> method is used to retrieve an acknowledgment, report, or application-generated response message that was created as a result of a message sent to the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Receive%2A&gt;</ph>方法返回第一条消息在队列中，与<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29&gt;</ph>方法用于检索确认、 报表或创建第一条消息发送到队列的应用程序生成的响应消息。</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>To read a message with a specified identifier without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> method.</source>
          <target state="translated">若要读取具有指定标识符的消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> method always returns the first message in the queue, so subsequent calls to the method return the same message unless a higher priority message arrives in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>方法始终返回第一条消息在队列中，因此对方法的后续调用将返回相同的消息，除非较高优先级的消息到达队列中。</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>There is no transaction context associated with a message returned by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>.</source>
          <target state="translated">没有与通过调用返回的消息关联事务上下文<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph> does not remove any messages in the queue, there would be nothing to roll back if the transaction were aborted.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekById%28System.String%29&gt;</ph>不会的删除队列中的任何消息，将无法回滚事务被中止。</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="id" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="id" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The value specified for the <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> parameter is not valid, possibly <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> is less than <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> or greater than <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>.</source>
          <target state="translated">为 <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> 参数指定的值无效，可能是 <ph id="ph2">&lt;paramref name="timeout" /&gt;</ph> 小于 <ph id="ph3">&lt;see cref="F:System.TimeSpan.Zero" /&gt;</ph> 或大于 <ph id="ph4">&lt;see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>A message with the specified <ph id="ph1">&lt;paramref name="id" /&gt;</ph> did not arrive in the queue before the time-out expired.</source>
          <target state="translated">在时间超时之前，带有指定 <ph id="ph1">&lt;paramref name="id" /&gt;</ph> 的消息没有到达队列。</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> members.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> 参数不是 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 成员之一。</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Introduced in MSMQ 3.0.</source>
          <target state="translated">在 MSMQ 3.0 中引入。</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Receives a specific message from the queue.</source>
          <target state="translated">接收队列中特定的消息。</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>The message can be specified by a lookup identifier or by its position at the front or end of the queue.</source>
          <target state="translated">消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.LookupId" /&gt;</ph> of the message to receive.</source>
          <target state="translated">要接收的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.LookupId" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>Introduced in MSMQ 3.0.</source>
          <target state="translated">在 MSMQ 3.0 中引入。</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>Receives the message that matches the given lookup identifier from a non-transactional queue.</source>
          <target state="translated">从非事务性队列中接收与给定的查找标识符匹配的消息。</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> whose <ph id="ph2">&lt;see cref="P:System.Messaging.Message.LookupId" /&gt;</ph> property matches the <ph id="ph3">&lt;paramref name="lookupId" /&gt;</ph> parameter passed in.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>，其 <ph id="ph2">&lt;see cref="P:System.Messaging.Message.LookupId" /&gt;</ph> 属性匹配传入的 <ph id="ph3">&lt;paramref name="lookupId" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>Use this method to read a message with a known lookup identifier and remove it from the queue.</source>
          <target state="translated">使用此方法读取具有已知的查找标识符的消息并从队列中删除它。</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>This method throws an exception immediately if the message is not in the queue.</source>
          <target state="translated">如果消息也不会在队列中，此方法将立即引发异常。</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.LookupId%2A&gt;</ph> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given <ph id="ph2">`lookupId`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.LookupId%2A&gt;</ph>属性的消息是唯一的队列消息所在的位置，因此将最多一条消息匹配的队列中给定<ph id="ph2">`lookupId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>To read a message with a specified lookup identifier without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByLookupId%2A&gt;</ph> method.</source>
          <target state="translated">若要读取具有指定的查找标识符的消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByLookupId%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>MSMQ 3.0 is not installed.</source>
          <target state="translated">未安装 MSMQ 3.0。</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>The message with the specified <ph id="ph1">&lt;paramref name="lookupId" /&gt;</ph> could not be found.</source>
          <target state="translated">未能找到具有指定 <ph id="ph1">&lt;paramref name="lookupId" /&gt;</ph> 的消息。</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageLookupAction" /&gt;</ph> values, specifying how the message is read in the queue.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageLookupAction" /&gt;</ph> 值，指定读取队列中消息的方式。</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>Specify one of the following:</source>
          <target state="translated">指定以下值之一：</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source><ph id="ph1">&lt;see langword="MessageLookupAction.Current" /&gt;</ph>: Receives the message specified by <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> and removes it from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MessageLookupAction.Current" /&gt;</ph>：接收由 <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> 指定的消息，然后将其从队列中移除。</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source><ph id="ph1">&lt;see langword="MessageLookupAction.Next" /&gt;</ph>: Receives the message following the message specified by <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> and removes it from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MessageLookupAction.Next" /&gt;</ph>：接收由 <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> 指定消息的下一条消息，然后将其从队列中移除。</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source><ph id="ph1">&lt;see langword="MessageLookupAction.Previous" /&gt;</ph>: Receives the message preceding the message specified by <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> and removes it from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MessageLookupAction.Previous" /&gt;</ph>：接收由 <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> 指定消息的上一条消息，然后将其从队列中移除。</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source><ph id="ph1">&lt;see langword="MessageLookupAction.First" /&gt;</ph>: Receives the first message in the queue and removes it from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MessageLookupAction.First" /&gt;</ph>：接收队列中的第一条消息并将它从队列中移除。</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> parameter must be set to 0.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> 参数必须设置为 0。</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source><ph id="ph1">&lt;see langword="MessageLookupAction.Last" /&gt;</ph>: Receives the last message in the queue and removes it from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MessageLookupAction.Last" /&gt;</ph>：接收队列中的最后一条消息并将它从队列中移除。</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> parameter must be set to 0.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> 参数必须设置为 0。</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.LookupId" /&gt;</ph> of the message to receive, or 0.</source>
          <target state="translated">要接收的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.LookupId" /&gt;</ph>，或者为 0。</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>0 is used when accessing the first or last message in the queue.</source>
          <target state="translated">访问队列中的第一条和最后一条消息时使用 0。</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>Introduced in MSMQ 3.0.</source>
          <target state="translated">在 MSMQ 3.0 中引入。</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>Receives a specific message from a transactional queue.</source>
          <target state="translated">从事务性队列中接收特定的消息。</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>The message can be specified by a lookup identifier or by its position at the front or end of the queue.</source>
          <target state="translated">消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> specified by the <ph id="ph2">&lt;paramref name="lookupId" /&gt;</ph> and <ph id="ph3">&lt;paramref name="action" /&gt;</ph> parameters passed in.</source>
          <target state="translated">由传入的 <ph id="ph2">&lt;paramref name="lookupId" /&gt;</ph> 和 <ph id="ph3">&lt;paramref name="action" /&gt;</ph> 参数指定的 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>Use this method to read a message with a known lookup identifier and remove it from the queue, using a transaction context defined by the <ph id="ph1">`transaction`</ph> parameter.</source>
          <target state="translated">使用此方法读取具有已知的查找标识符的消息并从队列中，使用定义的事务上下文中移除<ph id="ph1">`transaction`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>This method throws an exception immediately if the message is not in the queue.</source>
          <target state="translated">如果消息也不会在队列中，此方法将立即引发异常。</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.LookupId%2A&gt;</ph> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given <ph id="ph2">`lookupId`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.LookupId%2A&gt;</ph>属性的消息是唯一的队列消息所在的位置，因此将最多一条消息匹配的队列中给定<ph id="ph2">`lookupId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>Because this method is called on a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</source>
          <target state="translated">因为此方法调用事务性队列，接收的消息将返回到队列如果则中止此事务。</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>The message is not permanently removed from the queue until the transaction is committed.</source>
          <target state="translated">消息永久性不删除从队列直到提交事务。</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>To read a message with a specified identifier without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByLookupId%2A&gt;</ph> method.</source>
          <target state="translated">若要读取具有指定标识符的消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByLookupId%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>There is no transaction context associated with a message returned by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByLookupId%2A&gt;</ph>.</source>
          <target state="translated">没有与通过调用返回的消息关联事务上下文<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByLookupId%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByLookupId%2A&gt;</ph> does not remove any messages from the queue, there would be nothing to roll back if the transaction were aborted.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByLookupId%2A&gt;</ph>不会的删除队列中的任何消息，将无法回滚事务被中止。</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>MSMQ 3.0 is not installed.</source>
          <target state="translated">未安装 MSMQ 3.0。</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>The message with the specified <ph id="ph1">&lt;paramref name="lookupId" /&gt;</ph> could not be found.</source>
          <target state="translated">未能找到具有指定 <ph id="ph1">&lt;paramref name="lookupId" /&gt;</ph> 的消息。</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>The queue is non-transactional.</source>
          <target state="translated">该队列为非事务性队列。</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Messaging.MessageLookupAction" /&gt;</ph> members.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> 参数不是 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageLookupAction" /&gt;</ph> 成员之一。</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageLookupAction" /&gt;</ph> values, specifying how the message is read in the queue.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageLookupAction" /&gt;</ph> 值，指定读取队列中消息的方式。</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>Specify one of the following:</source>
          <target state="translated">指定以下值之一：</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source><ph id="ph1">&lt;see langword="MessageLookupAction.Current" /&gt;</ph>: Receives the message specified by <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> and removes it from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MessageLookupAction.Current" /&gt;</ph>：接收由 <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> 指定的消息，然后将其从队列中移除。</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source><ph id="ph1">&lt;see langword="MessageLookupAction.Next" /&gt;</ph>: Receives the message following the message specified by <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> and removes it from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MessageLookupAction.Next" /&gt;</ph>：接收由 <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> 指定消息的下一条消息，然后将其从队列中移除。</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source><ph id="ph1">&lt;see langword="MessageLookupAction.Previous" /&gt;</ph>: Receives the message preceding the message specified by <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> and removes it from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MessageLookupAction.Previous" /&gt;</ph>：接收由 <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> 指定消息的上一条消息，然后将其从队列中移除。</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source><ph id="ph1">&lt;see langword="MessageLookupAction.First" /&gt;</ph>: Receives the first message in the queue and removes it from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MessageLookupAction.First" /&gt;</ph>：接收队列中的第一条消息并将它从队列中移除。</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> parameter must be set to 0.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> 参数必须设置为 0。</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source><ph id="ph1">&lt;see langword="MessageLookupAction.Last" /&gt;</ph>: Receives the last message in the queue and removes it from the queue.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="MessageLookupAction.Last" /&gt;</ph>：接收队列中的最后一条消息并将它从队列中移除。</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> parameter must be set to 0.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>lookupId<ept id="p1">&lt;/c&gt;</ept> 参数必须设置为 0。</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.Message.LookupId" /&gt;</ph> of the message to receive, or 0.</source>
          <target state="translated">要接收的消息的 <ph id="ph1">&lt;see cref="P:System.Messaging.Message.LookupId" /&gt;</ph>，或者为 0。</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>0 is used when accessing the first or last message in the queue.</source>
          <target state="translated">访问队列中的第一条和最后一条消息时使用 0。</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> values, describing the type of transaction context to associate with the message.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 值之一，它描述与消息关联的事务上下文的类型。</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>Introduced in MSMQ 3.0.</source>
          <target state="translated">在 MSMQ 3.0 中引入。</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>Receives a specific message from the queue, using the specified transaction context.</source>
          <target state="translated">使用指定的事务上下文从队列中接收特定的消息。</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>The message can be specified by a lookup identifier or by its position at the front or end of the queue.</source>
          <target state="translated">消息可通过查询标识符来指定，也可以通过其相对于队首或队尾的位置来指定。</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph> specified by the <ph id="ph2">&lt;paramref name="action" /&gt;</ph> and <ph id="ph3">&lt;paramref name="lookupId" /&gt;</ph> parameters passed in.</source>
          <target state="translated">由传入的 <ph id="ph2">&lt;paramref name="action" /&gt;</ph> 和 <ph id="ph3">&lt;paramref name="lookupId" /&gt;</ph> 参数指定的 <ph id="ph1">&lt;see cref="T:System.Messaging.Message" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>Use this method to read a message with a known lookup identifier and remove it from the queue, using a transaction context defined by the <ph id="ph1">`transactionType`</ph> parameter.</source>
          <target state="translated">使用此方法读取具有已知的查找标识符的消息并从队列中，使用定义的事务上下文中移除<ph id="ph1">`transactionType`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>This method throws an exception immediately if the message is not in the queue.</source>
          <target state="translated">如果消息也不会在队列中，此方法将立即引发异常。</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.Message.LookupId%2A&gt;</ph> property of a message is unique to the queue where the message resides, so there will be at most one message in the queue that matches the given <ph id="ph2">`lookupId`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.Message.LookupId%2A&gt;</ph>属性的消息是唯一的队列消息所在的位置，因此将最多一条消息匹配的队列中给定<ph id="ph2">`lookupId`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>To read a message with a specified identifier without removing it from the queue, use the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByLookupId%2A&gt;</ph> method.</source>
          <target state="translated">若要读取具有指定标识符的消息，而不必从队列中删除它，使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByLookupId%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>There is no transaction context associated with a message returned by a call to <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByLookupId%2A&gt;</ph>.</source>
          <target state="translated">没有与通过调用返回的消息关联事务上下文<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByLookupId%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>Because <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByLookupId%2A&gt;</ph> does not remove any messages from the queue, there would be nothing to roll back if the transaction were aborted.</source>
          <target state="translated">因为<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.PeekByLookupId%2A&gt;</ph>不会的删除队列中的任何消息，将无法回滚事务被中止。</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Automatic`</ph> for the <ph id="ph2">`transactionType`</ph> parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</source>
          <target state="translated">指定<ph id="ph1">`Automatic`</ph>为<ph id="ph2">`transactionType`</ph>参数，如果已存在外部事务上下文附加到你想要用于接收消息的线程。</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Single`</ph> if you want to receive the message as a single internal transaction.</source>
          <target state="translated">指定<ph id="ph1">`Single`</ph>如果你想要接收的消息作为单个内部事务。</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>You can specify <ph id="ph1">`None`</ph> if you want to receive a message from a transactional queue outside of a transaction context.</source>
          <target state="translated">你可以指定<ph id="ph1">`None`</ph>如果你想要接收来自外部事务上下文事务性队列的消息。</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>If this method is called to receive a message from a transactional queue, the message that is received would be returned to the queue if the transaction is aborted.</source>
          <target state="translated">如果调用此方法用于从事务性队列接收消息，接收的消息将返回到队列如果则中止此事务。</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>The message is not permanently removed from the queue until the transaction is committed.</source>
          <target state="translated">消息永久性不删除从队列直到提交事务。</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>MSMQ 3.0 is not installed.</source>
          <target state="translated">未安装 MSMQ 3.0。</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>The message with the specified <ph id="ph1">&lt;paramref name="lookupId" /&gt;</ph> could not be found.</source>
          <target state="translated">未能找到具有指定 <ph id="ph1">&lt;paramref name="lookupId" /&gt;</ph> 的消息。</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Messaging.MessageLookupAction" /&gt;</ph> members.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> 参数不是 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageLookupAction" /&gt;</ph> 成员之一。</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> members.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> 参数不是 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 成员之一。</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" uid="E:System.Messaging.MessageQueue.ReceiveCompleted">
          <source>Occurs when a message has been removed from the queue.</source>
          <target state="translated">在从队列移除某条消息后发生。</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" uid="E:System.Messaging.MessageQueue.ReceiveCompleted">
          <source>This event is raised by the asynchronous operation, <ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.BeginReceive" /&gt;</ph>.</source>
          <target state="translated">此事件由异步操作 <ph id="ph1">&lt;see cref="M:System.Messaging.MessageQueue.BeginReceive" /&gt;</ph> 引发。</target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Messaging.MessageQueue.ReceiveCompleted">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> is used in asynchronous processing to raise the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event when a message is available in the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> 在异步处理中用于引发<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>事件队列中出现一条消息时。</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Messaging.MessageQueue.ReceiveCompleted">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph> is used to complete the operation initiated by a call to <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> and peek the message when the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event is raised.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29&gt;</ph> 用于完成通过调用启动的操作<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>和扫视消息时<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>引发事件。</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Messaging.MessageQueue.ReceiveCompleted">
          <source>When you create a <ph id="ph1">&lt;xref:System.Messaging.ReceiveCompletedEventHandler&gt;</ph> delegate, you identify the method that will handle the event.</source>
          <target state="translated">创建 <ph id="ph1">&lt;xref:System.Messaging.ReceiveCompletedEventHandler&gt;</ph> 委托时，需要标识将处理该事件的方法。</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Messaging.MessageQueue.ReceiveCompleted">
          <source>To associate the event with your event handler, add an instance of the delegate to the event.</source>
          <target state="translated">若要将事件与事件处理程序关联，请将该委托的一个实例添加到事件中。</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Messaging.MessageQueue.ReceiveCompleted">
          <source>The event handler is called whenever the event occurs, unless you remove the delegate.</source>
          <target state="translated">除非移除了该委托，否则每当发生该事件时就会调用事件处理程序。</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Messaging.MessageQueue.ReceiveCompleted">
          <source>For more information about event handler delegates, see <bpt id="p1">[</bpt>Handling and Raising Events<ept id="p1">](~/docs/standard/events/index.md)</ept>.</source>
          <target state="translated">有关事件处理程序委托的详细信息，请参阅<bpt id="p1">[</bpt>处理和引发事件<ept id="p1">](~/docs/standard/events/index.md)</ept>。</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Messaging.MessageQueue.ReceiveCompleted">
          <source>The following code example creates an event handler named <ph id="ph1">`MyReceiveCompleted`</ph>, attaches it to the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event handler delegate, and calls <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> to initiate an asynchronous receive operation on the queue that is located at the path ".\myQueue".</source>
          <target state="translated">下面的代码示例创建名为一个事件处理程序<ph id="ph1">`MyReceiveCompleted`</ph>，将其附加到<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>事件处理程序委托，然后调用<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>启动异步接收操作位于路径的队列上"。 \myQueue"。</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Messaging.MessageQueue.ReceiveCompleted">
          <source>When a <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> event is raised, the example receives the message and writes its body to the screen.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>引发事件，该示例中接收的消息，并将其正文写入到屏幕。</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Messaging.MessageQueue.ReceiveCompleted">
          <source>The example then calls <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> again to initiate a new asynchronous receive operation.</source>
          <target state="translated">该示例然后调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>再次以启动一个新异步接收操作。</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Refresh">
          <source>Refreshes the properties presented by the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> to reflect the current state of the resource.</source>
          <target state="translated">刷新 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 所显示的属性以反映资源的当前状态。</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Refresh">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Refresh%2A&gt;</ph> synchronizes the properties of a <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> with its associated Message Queuing server resource.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Refresh%2A&gt;</ph> 同步的属性<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>与其关联的消息队列服务器资源。</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Refresh">
          <source>If any property, such as <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph>, has changed on the server since the time the <ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph> was created, <ph id="ph4">&lt;xref:System.Messaging.MessageQueue.Refresh%2A&gt;</ph> updates the <ph id="ph5">&lt;xref:System.Messaging.MessageQueue&gt;</ph> with the new information.</source>
          <target state="translated">如果任何属性，如<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Label%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Category%2A&gt;</ph>，以来已更改服务器上<ph id="ph3">&lt;xref:System.Messaging.MessageQueue&gt;</ph>已创建，<ph id="ph4">&lt;xref:System.Messaging.MessageQueue.Refresh%2A&gt;</ph>更新<ph id="ph5">&lt;xref:System.Messaging.MessageQueue&gt;</ph>使用新信息。</target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Refresh">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Refresh">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Refresh">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Refresh">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Refresh">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Refresh">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Refresh">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Refresh">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Refresh">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Refresh">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Refresh">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Refresh">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Refresh%2A&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Refresh%2A&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>Resets the permission list to the operating system's default values.</source>
          <target state="translated">将权限列表重置为操作系统的默认值。</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>Removes any queue permissions you have appended to the default list.</source>
          <target state="translated">移除已追加到默认列表中的所有队列权限。</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>When you call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ResetPermissions%2A&gt;</ph>, you return the permission list to its default values.</source>
          <target state="translated">当调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ResetPermissions%2A&gt;</ph>，为其默认值返回权限列表。</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>Generally, this grants the queue creator all permissions, and gives the group Everyone the following rights:</source>
          <target state="translated">通常，这授予队列创建者的所有权限，并给予每个人对组的以下权限：</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>Get the properties of the queue.</source>
          <target state="translated">获取队列的属性。</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>Get queue permissions.</source>
          <target state="translated">获取队列的权限。</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>Write to the queue.</source>
          <target state="translated">写入队列。</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ResetPermissions%2A&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ResetPermissions%2A&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.ResetPermissions">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Sends an object to a queue.</source>
          <target state="translated">向队列发送对象。</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>The object to send to the queue.</source>
          <target state="translated">要发送到队列的对象。</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>Sends an object to non-transactional queue referenced by this <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>.</source>
          <target state="translated">将对象发送到此 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 引用的非事务性队列。</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>Use this overload to send a message that contains the <ph id="ph1">`obj`</ph> parameter to the queue referenced by the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>.</source>
          <target state="translated">使用此重载将发送一条消息，包含<ph id="ph1">`obj`</ph>参数所引用的队列<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>The object you send to the queue can be a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph> or any managed object.</source>
          <target state="translated">向队列发送该对象可以为<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>或任何托管的对象。</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>If you send any object other than a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>, the object is serialized and inserted into the body of the message.</source>
          <target state="translated">如果不发送任何对象<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>，序列化对象并将其插入到消息的正文。</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>If you use this overload to send a message to a transactional queue, the message will be sent to the dead-letter queue.</source>
          <target state="translated">如果使用此重载以将消息发送到事务性队列，消息将发送到死信队列中。</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>If you want the message to be part of a transaction that contains other messages, use an overload that takes a <ph id="ph1">&lt;xref:System.Messaging.MessageQueueTransaction&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueueTransactionType&gt;</ph> as a parameter.</source>
          <target state="translated">如果你想要是包含其他消息的事务的一部分的消息，请使用采用重载<ph id="ph1">&lt;xref:System.Messaging.MessageQueueTransaction&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueueTransactionType&gt;</ph>作为参数。</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>If you do not set the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph> property before calling <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph>, the formatter defaults to the <ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>.</source>
          <target state="translated">如果你未设置<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph>属性之前调用<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph>，格式化程序将默认为<ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> property applies to any object other than a <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>属性而不应用于任何对象<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>If you specify, for example, a label or a priority using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> member, these values apply to any message that contains an object that is not of type <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph> when your application sends it to the queue.</source>
          <target state="translated">如果指定，例如，标签或优先级使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>成员，这些值将应用于包含的类型不是对象的任何消息<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>时你的应用程序将其发送到队列。</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>When sending a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>, the property values set for the <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph> take precedence over <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> and the message's <ph id="ph4">&lt;xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType&gt;</ph> property takes precedence over the queue's <ph id="ph5">&lt;xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">发送时<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>，属性值设置为<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>优先于<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>和消息的<ph id="ph4">&lt;xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType&gt;</ph>属性优先于队列的<ph id="ph5">&lt;xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>The following code example connects to a message queue and sends a message to the queue.</source>
          <target state="translated">下面的代码示例连接到消息队列，并向队列发送消息。</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>The following code example sends an application-defined <ph id="ph1">`Order`</ph> class to a queue and then receives a message from that queue.</source>
          <target state="translated">下面的代码示例将发送应用程序定义<ph id="ph1">`Order`</ph>类到队列，然后从该队列接收消息。</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> property has not been set.</source>
          <target state="translated">尚未设置 <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>The object to send to the queue.</source>
          <target state="translated">要发送到队列的对象。</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>Sends an object to the transactional queue referenced by this <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>.</source>
          <target state="translated">将对象发送到此 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 所引用的事务性队列。</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>Use this overload to send a message that contains the <ph id="ph1">`obj`</ph> parameter to the transactional queue referenced by the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>, using an internal transaction context defined by the <ph id="ph3">`transaction`</ph> parameter.</source>
          <target state="translated">使用此重载将发送一条消息，包含<ph id="ph1">`obj`</ph>为事务性队列的引用参数<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>，使用所定义的内部事务上下文<ph id="ph3">`transaction`</ph>参数。</target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>The object you send to the queue can be a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph> or any managed object.</source>
          <target state="translated">向队列发送该对象可以为<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>或任何托管的对象。</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>If you send any object other than a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>, the object is serialized and inserted into the body of the message.</source>
          <target state="translated">如果不发送任何对象<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>，序列化对象并将其插入到消息的正文。</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>If you use this overload to send a message to a non-transactional queue, the message might be sent to the dead-letter queue without throwing an exception.</source>
          <target state="translated">如果使用此重载以将消息发送到非事务性队列，则消息可能会发送到死信队列中而不引发异常。</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>If you do not set the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph> property before calling <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph>, the formatter defaults to the <ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>.</source>
          <target state="translated">如果你未设置<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph>属性之前调用<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph>，格式化程序将默认为<ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> property applies to any object other than a <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>属性而不应用于任何对象<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>If you specify, for example, a label or a priority using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> member, these values apply to any message that contains an object that is not of type <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph> when your application sends it to the queue.</source>
          <target state="translated">如果指定，例如，标签或优先级使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>成员，这些值将应用于包含的类型不是对象的任何消息<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>时你的应用程序将其发送到队列。</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>When sending a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>, the property values set for the <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph> take precedence over <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> and the message's <ph id="ph4">&lt;xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType&gt;</ph> property takes precedence over the queue's <ph id="ph5">&lt;xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">发送时<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>，属性值设置为<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>优先于<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>和消息的<ph id="ph4">&lt;xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType&gt;</ph>属性优先于队列的<ph id="ph5">&lt;xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueueTransaction&gt;</ph> is threading apartment aware, so if your apartment state is <ph id="ph2">`STA`</ph>, you cannot use the transaction in multiple threads.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueueTransaction&gt;</ph> 线程处理单元感知，因此，如果你的单元状态<ph id="ph2">`STA`</ph>，不能在多个线程中使用的事务。</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>Visual Basic sets the state of the main thread to <ph id="ph1">`STA`</ph>, so you must apply the <ph id="ph2">&lt;xref:System.MTAThreadAttribute&gt;</ph> in the <ph id="ph3">`Main`</ph> subroutine.</source>
          <target state="translated">Visual Basic 将设置到的主线程的状态<ph id="ph1">`STA`</ph>，因此您必须首先应用<ph id="ph2">&lt;xref:System.MTAThreadAttribute&gt;</ph>中<ph id="ph3">`Main`</ph>子例程。</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>Otherwise, sending a transactional message using another thread throws a <ph id="ph1">&lt;xref:System.Messaging.MessageQueueException&gt;</ph> exception.</source>
          <target state="translated">否则，利用另一个线程发送事务性消息将引发 <ph id="ph1">&lt;xref:System.Messaging.MessageQueueException&gt;</ph> 异常。</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>You apply the <ph id="ph1">&lt;xref:System.MTAThreadAttribute&gt;</ph> by using the following fragment.</source>
          <target state="translated">你将应用<ph id="ph1">&lt;xref:System.MTAThreadAttribute&gt;</ph>通过使用下面的片段。</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>The following code example sends a string to a transactional queue and then receives a message from that queue.</source>
          <target state="translated">下面的代码示例将字符串发送到事务性队列，，然后从该队列接收消息。</target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;paramref name="transaction" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transaction" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> property has not been set.</source>
          <target state="translated">尚未设置 <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>The Message Queuing application indicated an incorrect transaction use.</source>
          <target state="translated">“消息队列”应用程序指示事务用法不正确。</target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>The object to send to the queue.</source>
          <target state="translated">要发送到队列的对象。</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> values, describing the type of transaction context to associate with the message.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 值之一，它描述与消息关联的事务上下文的类型。</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>Sends an object to the queue referenced by this <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph>.</source>
          <target state="translated">将对象发送到此 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 所引用的队列。</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>Use this overload to send a message that contains the <ph id="ph1">`obj`</ph> parameter to the queue referenced by the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>, using a transaction context defined by the <ph id="ph3">`transactionType`</ph> parameter.</source>
          <target state="translated">使用此重载将发送一条消息，包含<ph id="ph1">`obj`</ph>参数所引用的队列<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>，使用定义的事务上下文<ph id="ph3">`transactionType`</ph>参数。</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Automatic`</ph> for the <ph id="ph2">`transactionType`</ph> parameter if there is already an external transaction context attached to the thread that you want to use to send the message.</source>
          <target state="translated">指定<ph id="ph1">`Automatic`</ph>为<ph id="ph2">`transactionType`</ph>参数，如果已存在外部事务上下文附加到你想要用于发送消息的线程。</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Single`</ph> if you want to send the message as a single internal transaction.</source>
          <target state="translated">指定<ph id="ph1">`Single`</ph>如果你想要将消息发送作为单个内部事务。</target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>You can specify <ph id="ph1">`None`</ph> if you want to send a transactional message to a non-transactional thread.</source>
          <target state="translated">你可以指定<ph id="ph1">`None`</ph>如果你想要将事务性消息发送到非事务性的线程。</target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>The object you send to the queue can be a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph> or any managed object.</source>
          <target state="translated">向队列发送该对象可以为<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>或任何托管的对象。</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>If you send any object other than a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>, the object is serialized and inserted into the body of the message.</source>
          <target state="translated">如果不发送任何对象<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>，序列化对象并将其插入到消息的正文。</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>If you do not set the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph> property before calling <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph>, the formatter defaults to the <ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>.</source>
          <target state="translated">如果你未设置<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph>属性之前调用<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph>，格式化程序将默认为<ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> property applies to any object other than a <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>属性而不应用于任何对象<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>If you specify, for example, a label or a priority using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> member, these values apply to any message that contains an object that is not of type <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph> when your application sends it to the queue.</source>
          <target state="translated">如果指定，例如，标签或优先级使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>成员，这些值将应用于包含的类型不是对象的任何消息<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>时你的应用程序将其发送到队列。</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>When sending a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>, the property values set for the <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph> take precedence over <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> and the message's <ph id="ph4">&lt;xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType&gt;</ph> property takes precedence over the queue's <ph id="ph5">&lt;xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">发送时<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>，属性值设置为<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>优先于<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>和消息的<ph id="ph4">&lt;xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType&gt;</ph>属性优先于队列的<ph id="ph5">&lt;xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> members.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> 参数不是 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 成员之一。</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> property has not been set.</source>
          <target state="translated">尚未设置 <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>The object to send to the queue.</source>
          <target state="translated">要发送到队列的对象。</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>The label of the message.</source>
          <target state="translated">消息的标签。</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>Sends an object to the non-transactional queue referenced by this <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> and specifies a label for the message.</source>
          <target state="translated">将对象发送到此 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 引用的非事务性队列，并指定消息的标签。</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>Use this overload to send a message that contains the <ph id="ph1">`obj`</ph> parameter to the queue referenced by the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>.</source>
          <target state="translated">使用此重载将发送一条消息，包含<ph id="ph1">`obj`</ph>参数所引用的队列<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>With this overload, you can specify the string label that identifies the message.</source>
          <target state="translated">使用此重载，你可以指定用于标识消息的字符串为标签。</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>The object you send to the queue can be a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>, a structure, a data object, or any managed object.</source>
          <target state="translated">向队列发送该对象可以为<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>，结构、 数据对象或任何托管的对象。</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>If you send any object other than a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>, the object is serialized and inserted into the body of the message.</source>
          <target state="translated">如果不发送任何对象<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>，序列化对象并将其插入到消息的正文。</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>The message label is distinct from the message queue label, but both are application-dependent and have no inherit meaning to Message Queuing.</source>
          <target state="translated">消息标签是不同于消息队列标签，但又彼此是与应用程序相关的和没有继承到消息队列的含义。</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>If you use this overload to send a message to a transactional queue, the message will be sent to the dead-letter queue.</source>
          <target state="translated">如果使用此重载以将消息发送到事务性队列，消息将发送到死信队列中。</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>If you want the message to be part of a transaction that contains other messages, use an overload that takes a <ph id="ph1">&lt;xref:System.Messaging.MessageQueueTransaction&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueueTransactionType&gt;</ph> as a parameter.</source>
          <target state="translated">如果你想要是包含其他消息的事务的一部分的消息，请使用采用重载<ph id="ph1">&lt;xref:System.Messaging.MessageQueueTransaction&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueueTransactionType&gt;</ph>作为参数。</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph> property for this <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph> instance must be specified before you send the message.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Path%2A&gt;</ph>此属性<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>发送消息之前，必须指定实例。</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>If you do not set the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph> property before calling <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph>, the formatter defaults to the <ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>.</source>
          <target state="translated">如果你未设置<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph>属性之前调用<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph>，格式化程序将默认为<ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> property applies to any object other than a <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>属性而不应用于任何对象<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>If you specify, for example, a label or a priority using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> member, these values apply to any message that contains an object that is not of type <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph> when your application sends it to the queue.</source>
          <target state="translated">如果指定，例如，标签或优先级使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>成员，这些值将应用于包含的类型不是对象的任何消息<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>时你的应用程序将其发送到队列。</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>When sending a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>, the property values set for the <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph> take precedence over <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> and the message's <ph id="ph4">&lt;xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType&gt;</ph> property takes precedence over the queue's <ph id="ph5">&lt;xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">发送时<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>，属性值设置为<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>优先于<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>和消息的<ph id="ph4">&lt;xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType&gt;</ph>属性优先于队列的<ph id="ph5">&lt;xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>The <ph id="ph1">&lt;paramref name="label" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="label" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> property has not been set.</source>
          <target state="translated">尚未设置 <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>The object to send to the queue.</source>
          <target state="translated">要发送到队列的对象。</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>The label of the message.</source>
          <target state="translated">消息的标签。</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransaction" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>Sends an object to the transactional queue referenced by this <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> and specifies a label for the message.</source>
          <target state="translated">将对象发送到此 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 引用的事务性队列中，并指定该消息的标签。</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>Use this overload to send a message that contains the <ph id="ph1">`obj`</ph> parameter to the transactional queue referenced by the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>, using an internal transaction context defined by the <ph id="ph3">`transaction`</ph> parameter.</source>
          <target state="translated">使用此重载将发送一条消息，包含<ph id="ph1">`obj`</ph>为事务性队列的引用参数<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>，使用所定义的内部事务上下文<ph id="ph3">`transaction`</ph>参数。</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>With this overload, you can specify the string label that identifies the message.</source>
          <target state="translated">使用此重载，你可以指定用于标识消息的字符串为标签。</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>The object you send to the queue can be a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>, a structure, a data object, or any managed object.</source>
          <target state="translated">向队列发送该对象可以为<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>，结构、 数据对象或任何托管的对象。</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>If you send any object other than a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>, the object is serialized and inserted into the body of the message.</source>
          <target state="translated">如果不发送任何对象<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>，序列化对象并将其插入到消息的正文。</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>The message label is distinct from the message queue label, but both are application-dependent and have no inherit meaning to Message Queuing.</source>
          <target state="translated">消息标签是不同于消息队列标签，但又彼此是与应用程序相关的和没有继承到消息队列的含义。</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>If you use this overload to send a message to a non-transactional queue, the message might be sent to the dead-letter queue without throwing an exception.</source>
          <target state="translated">如果使用此重载以将消息发送到非事务性队列，则消息可能会发送到死信队列中而不引发异常。</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>If you do not set the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph> property before calling <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph>, the formatter defaults to the <ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>.</source>
          <target state="translated">如果你未设置<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph>属性之前调用<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph>，格式化程序将默认为<ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> property applies to any object other than a <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>属性而不应用于任何对象<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>If you specify, for example, a label or a priority using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> member, these values apply to any message that contains an object that is not of type <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph> when your application sends it to the queue.</source>
          <target state="translated">如果指定，例如，标签或优先级使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>成员，这些值将应用于包含的类型不是对象的任何消息<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>时你的应用程序将其发送到队列。</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>When sending a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>, the property values set for the <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph> take precedence over <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> and the message's <ph id="ph4">&lt;xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType&gt;</ph> property takes precedence over the queue's <ph id="ph5">&lt;xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType&gt;</ph> property</source>
          <target state="translated">发送时<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>，属性值设置为<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>优先于<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>和消息的<ph id="ph4">&lt;xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType&gt;</ph>属性优先于队列的<ph id="ph5">&lt;xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType&gt;</ph>属性</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueueTransaction&gt;</ph> is threading apartment aware, so if your apartment state is <ph id="ph2">`STA`</ph>, you cannot use the transaction in multiple threads.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueueTransaction&gt;</ph> 线程处理单元感知，因此，如果你的单元状态<ph id="ph2">`STA`</ph>，不能在多个线程中使用的事务。</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>Visual Basic sets the state of the main thread to <ph id="ph1">`STA`</ph>, so you must apply the <ph id="ph2">&lt;xref:System.MTAThreadAttribute&gt;</ph> in the <ph id="ph3">`Main`</ph> subroutine.</source>
          <target state="translated">Visual Basic 将设置到的主线程的状态<ph id="ph1">`STA`</ph>，因此您必须首先应用<ph id="ph2">&lt;xref:System.MTAThreadAttribute&gt;</ph>中<ph id="ph3">`Main`</ph>子例程。</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>Otherwise, sending a transactional message using another thread throws a <ph id="ph1">&lt;xref:System.Messaging.MessageQueueException&gt;</ph> exception.</source>
          <target state="translated">否则，利用另一个线程发送事务性消息将引发 <ph id="ph1">&lt;xref:System.Messaging.MessageQueueException&gt;</ph> 异常。</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>You apply the <ph id="ph1">&lt;xref:System.MTAThreadAttribute&gt;</ph> by using the following fragment.</source>
          <target state="translated">你将应用<ph id="ph1">&lt;xref:System.MTAThreadAttribute&gt;</ph>通过使用下面的片段。</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;paramref name="label" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="label" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;paramref name="transaction" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transaction" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> property has not been set.</source>
          <target state="translated">尚未设置 <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>The Message Queuing application indicated an incorrect transaction usage.</source>
          <target state="translated">“消息队列”应用程序指示了不正确的事务用法。</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The object to send to the queue.</source>
          <target state="translated">要发送到队列的对象。</target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The label of the message.</source>
          <target state="translated">消息的标签。</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> values, describing the type of transaction context to associate with the message.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 值之一，它描述与消息关联的事务上下文的类型。</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Sends an object to the queue referenced by this <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> and specifies a label for the message.</source>
          <target state="translated">将对象发送到此 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueue" /&gt;</ph> 引用的队列中，并指定该消息的标签。</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Use this overload to send a message that contains the <ph id="ph1">`obj`</ph> parameter to the queue referenced by the <ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>, using a transaction context defined by the <ph id="ph3">`transactionType`</ph> parameter.</source>
          <target state="translated">使用此重载将发送一条消息，包含<ph id="ph1">`obj`</ph>参数所引用的队列<ph id="ph2">&lt;xref:System.Messaging.MessageQueue&gt;</ph>，使用定义的事务上下文<ph id="ph3">`transactionType`</ph>参数。</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Automatic`</ph> for the <ph id="ph2">`transactionType`</ph> parameter if there is already an external transaction context attached to the thread that you want to use to send the message.</source>
          <target state="translated">指定<ph id="ph1">`Automatic`</ph>为<ph id="ph2">`transactionType`</ph>参数，如果已存在外部事务上下文附加到你想要用于发送消息的线程。</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Specify <ph id="ph1">`Single`</ph> if you want to send the message as a single internal transaction.</source>
          <target state="translated">指定<ph id="ph1">`Single`</ph>如果你想要将消息发送作为单个内部事务。</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>You can specify <ph id="ph1">`None`</ph> if you want to send a transactional message to a non-transactional thread.</source>
          <target state="translated">你可以指定<ph id="ph1">`None`</ph>如果你想要将事务性消息发送到非事务性的线程。</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The object you send to the queue can be a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph> or any managed object.</source>
          <target state="translated">向队列发送该对象可以为<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>或任何托管的对象。</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>If you send any object other than a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>, the object is serialized and inserted into the body of the message.</source>
          <target state="translated">如果不发送任何对象<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>，序列化对象并将其插入到消息的正文。</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>With this overload, you can specify the string label that identifies the message.</source>
          <target state="translated">使用此重载，你可以指定用于标识消息的字符串为标签。</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The message label is distinct from the message queue label, but both are application-dependent and have no inherit meaning to Message Queuing.</source>
          <target state="translated">消息标签是不同于消息队列标签，但又彼此是与应用程序相关的和没有继承到消息队列的含义。</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>If you do not set the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph> property before calling <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph>, the formatter defaults to the <ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>.</source>
          <target state="translated">如果你未设置<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Formatter%2A&gt;</ph>属性之前调用<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%29&gt;</ph>，格式化程序将默认为<ph id="ph3">&lt;xref:System.Messaging.XmlMessageFormatter&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> property applies to any object other than a <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>属性而不应用于任何对象<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>If you specify, for example, a label or a priority using the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph> member, these values apply to any message that contains an object that is not of type <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph> when your application sends it to the queue.</source>
          <target state="translated">如果指定，例如，标签或优先级使用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>成员，这些值将应用于包含的类型不是对象的任何消息<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>时你的应用程序将其发送到队列。</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>When sending a <ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>, the property values set for the <ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph> take precedence over <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>, and the message's <ph id="ph4">&lt;xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType&gt;</ph> property takes precedence over the queue's <ph id="ph5">&lt;xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">发送时<ph id="ph1">&lt;xref:System.Messaging.Message&gt;</ph>，属性值设置为<ph id="ph2">&lt;xref:System.Messaging.Message&gt;</ph>优先于<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A&gt;</ph>，和消息的<ph id="ph4">&lt;xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType&gt;</ph>属性优先于队列的<ph id="ph5">&lt;xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="label" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="label" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The Message Queuing application indicated an incorrect transaction usage.</source>
          <target state="translated">“消息队列”应用程序指示了不正确的事务用法。</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> members.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="transactionType" /&gt;</ph> 参数不是 <ph id="ph2">&lt;see cref="T:System.Messaging.MessageQueueTransactionType" /&gt;</ph> 成员之一。</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> property has not been set.</source>
          <target state="translated">尚未设置 <ph id="ph1">&lt;see cref="P:System.Messaging.MessageQueue.Path" /&gt;</ph> 属性。</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>Adds permissions to the current set.</source>
          <target state="translated">将权限添加到当前集合中。</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" uid="T:System.Messaging.MessageQueue">
          <source>This controls who has access rights to queue properties and messages in the queue.</source>
          <target state="translated">这样可控制谁对队列中的队列属性和消息具有访问权限。</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.AccessControlList" /&gt;</ph> that contains one or more access control entries that specify the trustees and the permissions to grant.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.AccessControlList" /&gt;</ph>，包含一个或多个指定受信者和要授予的权限的访问控制项。</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Assigns access rights to the queue based on the contents of an access control list.</source>
          <target state="translated">基于访问控制列表的内容将访问权限分配给队列。</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Use this overload to grant, deny, or revoke rights by using a collection of access control entries to specify trustee and permissions information.</source>
          <target state="translated">使用此重载以授予、 拒绝或撤消权限，通过使用访问控制项的集合来指定受信者和权限的信息。</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>This is used, for example, to grant permissions to multiple users at the same time.</source>
          <target state="translated">这用于，例如，同时向多个用户授予权限。</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>The trustee you specify when you construct the <ph id="ph1">`ace`</ph> parameter can be an individual user, a group of users, or a computer.</source>
          <target state="translated">构造时指定的受信者<ph id="ph1">`ace`</ph>参数可以为单个用户、 一组用户或计算机。</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>If the trustee is an individual, use the format <ph id="ph1">`DOMAIN`</ph><ph id="ph2">\\</ph><ph id="ph3">`user`</ph>.</source>
          <target state="translated">如果受信者个人，请使用格式<ph id="ph1">`DOMAIN`</ph> <ph id="ph2">\\</ph> <ph id="ph3">`user`</ph>。</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>You can specify "." for the trustee to indicate the local computer.</source>
          <target state="translated">你可以指定"。"受信者以指示本地计算机。</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>The permissions you assign through <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%2A&gt;</ph> add rights to the existing list.</source>
          <target state="translated">通过分配的权限<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%2A&gt;</ph>将权限添加到现有列表。</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>By default, the creator of a public or private queue has full control, and the domain group Everyone has permission to get queue properties, get permissions, and write to the queue.</source>
          <target state="translated">默认情况下，公用或专用队列的创建者具有完全控制和域组的每个人都获取队列属性，获取权限，并向队列中写入的权限。</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>When you call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%2A&gt;</ph>, the user and permissions information is appended to the bottom of the existing list.</source>
          <target state="translated">当调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%2A&gt;</ph>，用户和权限的信息都会追加到现有列表的底部。</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>The system examines each <ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph> in sequence until one of the following events occurs:</source>
          <target state="translated">系统将检查每个<ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph>顺序，直到发生以下事件之一：</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>An access-denied <ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph> explicitly denies any of the requested access rights to one of the trustees listed in the thread's access token.</source>
          <target state="translated">访问拒绝<ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph>显式拒绝任何对一个线程的访问令牌中列出的受信者的请求的访问权限。</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>One or more access-allowed <ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph> items for trustees listed in the thread's access token explicitly grant all the requested access rights.</source>
          <target state="translated">一个或多个访问允许<ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph>项的线程的访问令牌中显式列出的受信者授予所有请求的访问权限。</target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>All <ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph> items have been checked and there is still at least one requested access right that has not been explicitly allowed, in which case, access is implicitly denied.</source>
          <target state="translated">所有<ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph>已检查项，并且没有仍在至少一个请求的访问权限，没有已明确允许，在这种情况下，访问被隐式拒绝。</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>When you construct the <ph id="ph1">`dacl`</ph> parameter, you add <ph id="ph2">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph> instances to your <ph id="ph3">&lt;xref:System.Messaging.AccessControlList&gt;</ph> collection.</source>
          <target state="translated">构造时<ph id="ph1">`dacl`</ph>参数，你将添加<ph id="ph2">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph>实例到你<ph id="ph3">&lt;xref:System.Messaging.AccessControlList&gt;</ph>集合。</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>When you construct each access control entry, you can specify generic or standard access rights.</source>
          <target state="translated">在构造每个访问控制项时，你可以指定泛型或标准访问权限。</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>The rights to a queue can be any combination of the following:</source>
          <target state="translated">对队列的权限可以是以下任意组合：</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Delete</source>
          <target state="translated">删除</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Read Security</source>
          <target state="translated">读取安全设置</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Write Security</source>
          <target state="translated">编写安全</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Synchronize</source>
          <target state="translated">同步</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Modify Owner</source>
          <target state="translated">修改所有者</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Read</source>
          <target state="translated">读取</target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Write</source>
          <target state="translated">Write</target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Execute</source>
          <target state="translated">执行</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Required</source>
          <target state="translated">必需</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>All</source>
          <target state="translated">全部</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>None</source>
          <target state="translated">无</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>These rights are a set of bit flags that you can combine using the OR bitwise operator.</source>
          <target state="translated">这些权限是一组可使用或按位运算符进行组合的位标志。</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Full Control</source>
          <target state="translated">完全控制</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Delete Message</source>
          <target state="translated">删除消息</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Receive Message</source>
          <target state="translated">接收消息</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Peek Message</source>
          <target state="translated">扫视消息</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Receive Journal Message</source>
          <target state="translated">接收日志消息</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Get Queue Properties</source>
          <target state="translated">获取队列属性</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Set Queue Properties</source>
          <target state="translated">设置队列属性</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Get Permissions</source>
          <target state="translated">获取权限</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Set Permissions</source>
          <target state="translated">设置权限</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Take Queue Ownership</source>
          <target state="translated">获取队列所属权</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Write Message</source>
          <target state="translated">写入消息</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueAccessControlEntry" /&gt;</ph> that specifies a user, an access type, and a permission type.</source>
          <target state="translated">指定用户、访问类型和权限类型的 <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueAccessControlEntry" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Assigns access rights to the queue based on the contents of an access control entry.</source>
          <target state="translated">基于访问控制项的内容将访问权限分配给队列。</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Use this overload to grant, deny, or revoke rights by using an access control entry to specify trustee and rights information.</source>
          <target state="translated">使用此重载以授予、 拒绝或撤消权限，通过使用访问控制项指定受信者和权限信息。</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>The trustee you specify when you construct the <ph id="ph1">`ace`</ph> parameter can be an individual user, a group of users, or a computer.</source>
          <target state="translated">构造时指定的受信者<ph id="ph1">`ace`</ph>参数可以为单个用户、 一组用户或计算机。</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>If the trustee is an individual, use the format <ph id="ph1">`DOMAIN`</ph><ph id="ph2">\\</ph><ph id="ph3">`user`</ph>.</source>
          <target state="translated">如果受信者个人，请使用格式<ph id="ph1">`DOMAIN`</ph> <ph id="ph2">\\</ph> <ph id="ph3">`user`</ph>。</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>You can specify "." for the trustee to indicate the local computer.</source>
          <target state="translated">你可以指定"。"受信者以指示本地计算机。</target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>The permissions you assign through <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%2A&gt;</ph> add rights to the existing list.</source>
          <target state="translated">通过分配的权限<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%2A&gt;</ph>将权限添加到现有列表。</target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>By default, the creator of a public or private queue has full control, and the domain group Everyone has permission to get queue properties, get permissions, and write to the queue.</source>
          <target state="translated">默认情况下，公用或专用队列的创建者具有完全控制和域组的每个人都获取队列属性，获取权限，并向队列中写入的权限。</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>When you call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%2A&gt;</ph>, the user and permissions information is appended to the bottom of the existing list.</source>
          <target state="translated">当调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%2A&gt;</ph>，用户和权限的信息都会追加到现有列表的底部。</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>The system examines each <ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph> in sequence until one of the following events occurs:</source>
          <target state="translated">系统将检查每个<ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph>顺序，直到发生以下事件之一：</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>An access-denied <ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph> explicitly denies any of the requested access rights to one of the trustees listed in the thread's access token.</source>
          <target state="translated">访问拒绝<ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph>显式拒绝任何对一个线程的访问令牌中列出的受信者的请求的访问权限。</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>One or more access-allowed <ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph> items for trustees listed in the thread's access token explicitly grant all the requested access rights.</source>
          <target state="translated">一个或多个访问允许<ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph>项的线程的访问令牌中显式列出的受信者授予所有请求的访问权限。</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>All <ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph> items have been checked and there is still at least one requested access right that has not been explicitly allowed, in which case, access is implicitly denied.</source>
          <target state="translated">所有<ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph>已检查项，并且没有仍在至少一个请求的访问权限，没有已明确允许，在这种情况下，访问被隐式拒绝。</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>The rights to a queue, which you specify in the <ph id="ph1">`rights`</ph> parameter when you construct your <ph id="ph2">&lt;xref:System.Messaging.MessageQueueAccessControlEntry&gt;</ph>, can be any combination of the following:</source>
          <target state="translated">对在指定的队列的权限<ph id="ph1">`rights`</ph>参数在构造时你<ph id="ph2">&lt;xref:System.Messaging.MessageQueueAccessControlEntry&gt;</ph>，可以是以下任意组合：</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Full Control</source>
          <target state="translated">完全控制</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Delete Message</source>
          <target state="translated">删除消息</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Receive Message</source>
          <target state="translated">接收消息</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Peek Message</source>
          <target state="translated">扫视消息</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Receive Journal Message</source>
          <target state="translated">接收日志消息</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Get Queue Properties</source>
          <target state="translated">获取队列属性</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Set Queue Properties</source>
          <target state="translated">设置队列属性</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Get Permissions</source>
          <target state="translated">获取权限</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Set Permissions</source>
          <target state="translated">设置权限</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Take Queue Ownership</source>
          <target state="translated">获取队列所属权</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Write Message</source>
          <target state="translated">写入消息</target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>The <ph id="ph1">`rights`</ph> parameter you specify in the constructor for the <ph id="ph2">`ace`</ph> parameter is a flag of the <ph id="ph3">&lt;xref:System.Messaging.MessageQueueAccessRights&gt;</ph> enumeration.</source>
          <target state="translated"><ph id="ph1">`rights`</ph>参数的构造函数中指定<ph id="ph2">`ace`</ph>参数是一个标志的<ph id="ph3">&lt;xref:System.Messaging.MessageQueueAccessRights&gt;</ph>枚举。</target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>It represents a set of bit flags that you can combine using the bitwise operator OR when you build the <ph id="ph1">`rights`</ph> parameter.</source>
          <target state="translated">它表示一组位标志，你可以组合使用按位运算符或生成时<ph id="ph1">`rights`</ph>参数。</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>The individual, group, or computer that gets additional rights to the queue.</source>
          <target state="translated">获取对队列的附加权限的个人、组或计算机。</target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueAccessRights" /&gt;</ph> that indicates the set of rights to the queue that Message Queuing assigns to the <bpt id="p1">&lt;c&gt;</bpt>user<ept id="p1">&lt;/c&gt;</ept> passed in.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueAccessRights" /&gt;</ph>，指示对消息队列分配给传入的 <bpt id="p1">&lt;c&gt;</bpt>user<ept id="p1">&lt;/c&gt;</ept> 的队列权限集。</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Gives a computer, group, or user the specified access rights.</source>
          <target state="translated">给予计算机、组或用户指定的访问权限。</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Use this overload to grant specified rights to an individual user.</source>
          <target state="translated">此重载用于授予对单个用户的指定的权限。</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>The user can be any valid trustee, which includes individual users, groups of users, or a computer.</source>
          <target state="translated">用户可以是任何有效受信者，包括各个用户、 用户、 组或计算机。</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>If the user is an individual, use the format <ph id="ph1">`DOMAIN`</ph><ph id="ph2">\\</ph><ph id="ph3">`user`</ph> for the <ph id="ph4">`user`</ph> parameter.</source>
          <target state="translated">如果用户是个人，使用格式<ph id="ph1">`DOMAIN`</ph> <ph id="ph2">\\</ph> <ph id="ph3">`user`</ph>为<ph id="ph4">`user`</ph>参数。</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>You can specify "." for the <ph id="ph1">`user`</ph> parameter to indicate the local computer.</source>
          <target state="translated">你可以指定"。"有关<ph id="ph1">`user`</ph>参数以指示本地计算机。</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>The permissions you assign through <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%2A&gt;</ph> add rights to the existing list.</source>
          <target state="translated">通过分配的权限<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%2A&gt;</ph>将权限添加到现有列表。</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>By default, the creator of a public or private queue has full control, and the domain group Everyone has permission to get queue properties, get permissions, and write to the queue.</source>
          <target state="translated">默认情况下，公用或专用队列的创建者具有完全控制和域组的每个人都获取队列属性，获取权限，并向队列中写入的权限。</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>When you call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%2A&gt;</ph>, the user and permissions information is appended to the bottom of the existing list.</source>
          <target state="translated">当调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%2A&gt;</ph>，用户和权限的信息都会追加到现有列表的底部。</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>The system examines each <ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph> in sequence until one of the following events occurs:</source>
          <target state="translated">系统将检查每个<ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph>顺序，直到发生以下事件之一：</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>An access-denied <ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph> explicitly denies any of the requested access rights to one of the trustees listed in the thread's access token.</source>
          <target state="translated">访问拒绝<ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph>显式拒绝任何对一个线程的访问令牌中列出的受信者的请求的访问权限。</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>One or more access-allowed <ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph> items for trustees listed in the thread's access token explicitly grant all the requested access rights.</source>
          <target state="translated">一个或多个访问允许<ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph>项的线程的访问令牌中显式列出的受信者授予所有请求的访问权限。</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>All <ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph> items have been checked and there is still at least one requested access right that has not been explicitly allowed, in which case, access is implicitly denied.</source>
          <target state="translated">所有<ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph>已检查项，并且没有仍在至少一个请求的访问权限，没有已明确允许，在这种情况下，访问被隐式拒绝。</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>The rights to a queue, specified in the <ph id="ph1">`rights`</ph> parameter, can be any combination of the following:</source>
          <target state="translated">对队列中指定的权限<ph id="ph1">`rights`</ph>参数，可以是以下任意组合：</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Full Control</source>
          <target state="translated">完全控制</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Delete Message</source>
          <target state="translated">删除消息</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Receive Message</source>
          <target state="translated">接收消息</target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Peek Message</source>
          <target state="translated">扫视消息</target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Receive Journal Message</source>
          <target state="translated">接收日志消息</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Get Queue Properties</source>
          <target state="translated">获取队列属性</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Set Queue Properties</source>
          <target state="translated">设置队列属性</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Get Permissions</source>
          <target state="translated">获取权限</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Set Permissions</source>
          <target state="translated">设置权限</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Take Queue Ownership</source>
          <target state="translated">获取队列所属权</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Write Message</source>
          <target state="translated">写入消息</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueueAccessRights&gt;</ph> enumeration represents a set of bit flags that you can combine using the bitwise operator OR to build the <ph id="ph2">`rights`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueueAccessRights&gt;</ph>枚举表示一组位标志，你可以组合使用按位运算符，或要生成<ph id="ph2">`rights`</ph>参数。</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>With this overload, you can only grant permissions; you cannot revoke or deny them.</source>
          <target state="translated">使用此重载，您可以仅授予权限;不能撤消或拒绝它们。</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>You must use a different overload to explicitly grant any <ph id="ph1">&lt;xref:System.Messaging.AccessControlEntryType&gt;</ph> other than <ph id="ph2">`Allow`</ph>.</source>
          <target state="translated">必须使用不同的重载来显式授予任何<ph id="ph1">&lt;xref:System.Messaging.AccessControlEntryType&gt;</ph>以外<ph id="ph2">`Allow`</ph>。</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>The <ph id="ph1">&lt;paramref name="user" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="user" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>The individual, group, or computer that gets additional rights to the queue.</source>
          <target state="translated">获取对队列的附加权限的个人、组或计算机。</target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueAccessRights" /&gt;</ph> that indicates the set of rights to the queue that Message Queuing assigns to the <bpt id="p1">&lt;c&gt;</bpt>user<ept id="p1">&lt;/c&gt;</ept> passed in.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.MessageQueueAccessRights" /&gt;</ph>，指示对消息队列分配给传入的 <bpt id="p1">&lt;c&gt;</bpt>user<ept id="p1">&lt;/c&gt;</ept> 的队列权限集。</target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Messaging.AccessControlEntryType" /&gt;</ph> that specifies whether to grant, deny, or revoke the permissions specified by the <bpt id="p1">&lt;c&gt;</bpt>rights<ept id="p1">&lt;/c&gt;</ept> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Messaging.AccessControlEntryType" /&gt;</ph>，指定授予、拒绝还是撤销 <bpt id="p1">&lt;c&gt;</bpt>rights<ept id="p1">&lt;/c&gt;</ept> 参数指定的权限。</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Gives a computer, group, or user the specified access rights, with the specified access control type (allow, deny, revoke, or set).</source>
          <target state="translated">利用指定的访问控制类型（允许、拒绝、撤消或设置），给予计算机、组或用户指定的访问权限。</target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Use this overload to grant, deny, or revoke specified rights for an individual user.</source>
          <target state="translated">使用此重载以授予、 拒绝或撤消为单独用户指定的权限。</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>The user can be any valid trustee, which includes individual users, groups of users, or a computer.</source>
          <target state="translated">用户可以是任何有效受信者，包括各个用户、 用户、 组或计算机。</target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>If the user is an individual, use the format <ph id="ph1">`DOMAIN`</ph><ph id="ph2">\\</ph><ph id="ph3">`user`</ph> for the <ph id="ph4">`user`</ph> parameter.</source>
          <target state="translated">如果用户是个人，使用格式<ph id="ph1">`DOMAIN`</ph> <ph id="ph2">\\</ph> <ph id="ph3">`user`</ph>为<ph id="ph4">`user`</ph>参数。</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>You can specify "." for the <ph id="ph1">`user`</ph> parameter to indicate the local computer.</source>
          <target state="translated">你可以指定"。"有关<ph id="ph1">`user`</ph>参数以指示本地计算机。</target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>The permissions you assign through <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%2A&gt;</ph> add rights to the existing list.</source>
          <target state="translated">通过分配的权限<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%2A&gt;</ph>将权限添加到现有列表。</target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>By default, the creator of a public or private queue has full control, and the domain group Everyone has permission to get queue properties, get permissions, and write to the queue.</source>
          <target state="translated">默认情况下，公用或专用队列的创建者具有完全控制和域组的每个人都获取队列属性，获取权限，并向队列中写入的权限。</target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>When you call <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%2A&gt;</ph>, the user and permissions information is appended to the bottom of the existing list.</source>
          <target state="translated">当调用<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%2A&gt;</ph>，用户和权限的信息都会追加到现有列表的底部。</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>The system examines each <ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph> in sequence until one of the following events occurs:</source>
          <target state="translated">系统将检查每个<ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph>顺序，直到发生以下事件之一：</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>An access-denied <ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph> explicitly denies any of the requested access rights to one of the trustees listed in the thread's access token.</source>
          <target state="translated">访问拒绝<ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph>显式拒绝任何对一个线程的访问令牌中列出的受信者的请求的访问权限。</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>One or more access-allowed <ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph> items for trustees listed in the thread's access token explicitly grant all the requested access rights.</source>
          <target state="translated">一个或多个访问允许<ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph>项的线程的访问令牌中显式列出的受信者授予所有请求的访问权限。</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>All <ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph> items have been checked and there is still at least one requested access right that has not been explicitly allowed, in which case, access is implicitly denied.</source>
          <target state="translated">所有<ph id="ph1">&lt;xref:System.Messaging.AccessControlEntry&gt;</ph>已检查项，并且没有仍在至少一个请求的访问权限，没有已明确允许，在这种情况下，访问被隐式拒绝。</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>The rights to a queue, specified in the <ph id="ph1">`rights`</ph> parameter, can be any combination of the following:</source>
          <target state="translated">对队列中指定的权限<ph id="ph1">`rights`</ph>参数，可以是以下任意组合：</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Full Control</source>
          <target state="translated">完全控制</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Delete Message</source>
          <target state="translated">删除消息</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Receive Message</source>
          <target state="translated">接收消息</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Peek Message</source>
          <target state="translated">扫视消息</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Receive Journal Message</source>
          <target state="translated">接收日志消息</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Get Queue Properties</source>
          <target state="translated">获取队列属性</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Set Queue Properties</source>
          <target state="translated">设置队列属性</target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Get Permissions</source>
          <target state="translated">获取权限</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Set Permissions</source>
          <target state="translated">设置权限</target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Take Queue Ownership</source>
          <target state="translated">获取队列所属权</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Write Message</source>
          <target state="translated">写入消息</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueueAccessRights&gt;</ph> enumeration represents a set of bit flags that you can combine using the bitwise operator OR to build the <ph id="ph2">`rights`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueueAccessRights&gt;</ph>枚举表示一组位标志，你可以组合使用按位运算符，或要生成<ph id="ph2">`rights`</ph>参数。</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>The following table shows whether this method is available in various Workgroup modes.</source>
          <target state="translated">下表显示了此方法是否在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>The following code example demonstrates the use of <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29&gt;</ph>.</source>
          <target state="translated">以下代码示例演示了 <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29&gt;</ph> 的用法。</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" uid="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.SynchronizingObject">
          <source>Gets or sets the object that marshals the event-handler call resulting from a <ph id="ph1">&lt;see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /&gt;</ph> or <ph id="ph2">&lt;see cref="E:System.Messaging.MessageQueue.PeekCompleted" /&gt;</ph> event.</source>
          <target state="translated">获取或设置由 <ph id="ph1">&lt;see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /&gt;</ph> 或 <ph id="ph2">&lt;see cref="E:System.Messaging.MessageQueue.PeekCompleted" /&gt;</ph> 事件产生封送事件处理程序调用的对象。</target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.SynchronizingObject">
          <source>A <ph id="ph1">&lt;see cref="T:System.ComponentModel.ISynchronizeInvoke" /&gt;</ph>, which represents the object that marshals the event-handler call resulting from a <ph id="ph2">&lt;see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /&gt;</ph> or <ph id="ph3">&lt;see cref="E:System.Messaging.MessageQueue.PeekCompleted" /&gt;</ph> event.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.ComponentModel.ISynchronizeInvoke" /&gt;</ph>，表示封送由 <ph id="ph2">&lt;see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /&gt;</ph> 或 <ph id="ph3">&lt;see cref="E:System.Messaging.MessageQueue.PeekCompleted" /&gt;</ph> 事件产生的事件处理程序调用的对象。</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.SynchronizingObject">
          <source>The default is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.SynchronizingObject">
          <source>A <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph> or <ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph> event results from a <ph id="ph3">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph> request, respectively, to a specific thread.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.ReceiveCompleted&gt;</ph>或<ph id="ph2">&lt;xref:System.Messaging.MessageQueue.PeekCompleted&gt;</ph>事件源于<ph id="ph3">&lt;xref:System.Messaging.MessageQueue.BeginReceive%2A&gt;</ph>或<ph id="ph4">&lt;xref:System.Messaging.MessageQueue.BeginPeek%2A&gt;</ph>请求，分别为特定线程。</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.SynchronizingObject">
          <source>Typically, the <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SynchronizingObject%2A&gt;</ph> is set when its related component is placed inside a control or a form, because those components are bound to a specific thread.</source>
          <target state="translated">通常情况下，<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.SynchronizingObject%2A&gt;</ph>时设置其相关的组件放在控件或窗体，因为这些组件绑定到特定线程。</target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.SynchronizingObject">
          <source>Typically, the synchronizing object marshals a method call into a single thread.</source>
          <target state="translated">通常情况下，同步的对象封送到单个线程的方法调用。</target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>Gets a value that indicates whether the queue accepts only transactions.</source>
          <target state="translated">获取一个值，该值指示队列是否只接受事务。</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the queue accepts only messages sent as part of a transaction; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果队列只接受作为事务的一部分发送的消息，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>Transactional messaging refers to the coupling of several related messages into a single transaction.</source>
          <target state="translated">事务性消息处理是指成单个事务的多个相关邮件耦合。</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>Sending messages as part of a transaction ensures that the messages are delivered in order, delivered only once, and successfully retrieved from their destination queue.</source>
          <target state="translated">发送消息，因为事务的一部分可确保消息都会传递顺序情况下，只传递一次，以及从其目标队列中成功检索。</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>If a queue is transactional, it accepts only messages that are sent as part of a transaction.</source>
          <target state="translated">如果队列是事务性的它接受作为事务一部分发送的消息。</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>However, a non-transactional message can be sent or received from a local transaction queue without explicitly using transactional <ph id="ph1">&lt;xref:System.Messaging.MessageQueueTransaction.Begin%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Messaging.MessageQueueTransaction.Commit%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Messaging.MessageQueueTransaction.Abort%2A&gt;</ph> syntax.</source>
          <target state="translated">但是，非事务性消息将要发送或接收从本地事务队列，而无需使用显式事务<ph id="ph1">&lt;xref:System.Messaging.MessageQueueTransaction.Begin%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Messaging.MessageQueueTransaction.Commit%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Messaging.MessageQueueTransaction.Abort%2A&gt;</ph>语法。</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>If a non-transactional message is sent to a transactional queue, this component creates a single-message transaction for it, except in the case of referencing a queue on a remote computer using a direct format name.</source>
          <target state="translated">如果非事务性消息发送到事务性队列，此组件创建一个单个消息事务，除非在引用使用直接格式名的远程计算机上的队列的情况下。</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>In this situation, if you do not specify a transaction context when sending a message, one is not created for you and the message will be sent to the dead-letter queue.</source>
          <target state="translated">在此情况下，如果发送消息时未指定事务上下文，其中一个不会为你创建，并且消息将发送到死信队列。</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>If you send a non-transactional message to a transactional queue, you will not be able to roll back the message in the event of an exception.</source>
          <target state="translated">如果将非事务性消息发送到事务性队列中时，你将不能回滚发生异常时消息。</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source><ph id="ph1">&lt;xref:System.Messaging.MessageQueueTransaction&gt;</ph> is threading apartment aware, so if your apartment state is <ph id="ph2">`STA`</ph>, you cannot use the transaction in multiple threads.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueueTransaction&gt;</ph> 线程处理单元感知，因此，如果你的单元状态<ph id="ph2">`STA`</ph>，不能在多个线程中使用的事务。</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>Visual Basic sets the state of the main thread to <ph id="ph1">`STA`</ph>, so you must apply the <ph id="ph2">&lt;xref:System.MTAThreadAttribute&gt;</ph> in the <ph id="ph3">`Main`</ph> subroutine.</source>
          <target state="translated">Visual Basic 将设置到的主线程的状态<ph id="ph1">`STA`</ph>，因此您必须首先应用<ph id="ph2">&lt;xref:System.MTAThreadAttribute&gt;</ph>中<ph id="ph3">`Main`</ph>子例程。</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>Otherwise, sending a transactional message using another thread throws a <ph id="ph1">&lt;xref:System.Messaging.MessageQueueException&gt;</ph> exception.</source>
          <target state="translated">否则，利用另一个线程发送事务性消息将引发 <ph id="ph1">&lt;xref:System.Messaging.MessageQueueException&gt;</ph> 异常。</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>You apply the <ph id="ph1">&lt;xref:System.MTAThreadAttribute&gt;</ph> by using the following fragment.</source>
          <target state="translated">你将应用<ph id="ph1">&lt;xref:System.MTAThreadAttribute&gt;</ph>通过使用下面的片段。</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>The following code example displays the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Transactional%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例显示的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.Transactional%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.Transactional">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>Gets or sets a value that indicates whether received messages are copied to the journal queue.</source>
          <target state="translated">获取或设置一个值，该值指示接收的消息是否复制到日记队列。</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if messages received from the queue are copied to its journal queue; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果从队列接收到的消息复制到其日记队列，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>When the Message Queuing application creates a new application queue, it automatically creates an associated journal queue in the same location.</source>
          <target state="translated">当消息队列应用程序创建一个新的应用程序队列时，它将自动在同一位置创建关联的日记队列。</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>The journal queue is used to track the messages removed from a queue.</source>
          <target state="translated">日记队列用于跟踪从队列中移除的消息。</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>Setting this property modifies the Message Queuing queue.</source>
          <target state="translated">将此属性设置修改消息队列队列。</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>Therefore, any other <ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph> instances are affected by the change.</source>
          <target state="translated">因此，任何其他<ph id="ph1">&lt;xref:System.Messaging.MessageQueue&gt;</ph>的更改会影响实例。</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>The journal queue does not track messages removed from the queue because their time-to-be-received timer expired, nor does it track messages purged from the queue by using a Message Queuing directory service (Information Store or Active Directory).</source>
          <target state="translated">日记队列不跟踪消息从队列删除，因为其接收时间计时器已过期，也不会跟踪消息从队列中清除通过使用消息队列目录服务 （信息存储或 Active Directory）。</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>Applications cannot send messages to journal queues; they are limited to read-only access of these queues.</source>
          <target state="translated">应用程序不能将消息发送到日志队列;它们仅限于只读访问权限的这些队列。</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>Furthermore, Message Queuing never removes messages from journal queues.</source>
          <target state="translated">此外，消息队列永远不会消息从队列中删除日志。</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>The application using the queue must clear these messages either by receiving them or by purging the queue.</source>
          <target state="translated">通过接收它们或清除队列，使用队列的应用程序必须清除这些消息。</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>The following code example gets and sets the value of a message queue's <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.UseJournalQueue%2A&gt;</ph> property.</source>
          <target state="translated">下面的代码示例获取和设置的消息队列的值<ph id="ph1">&lt;xref:System.Messaging.MessageQueue.UseJournalQueue%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.UseJournalQueue">
          <source>An error occurred when accessing a Message Queuing method.</source>
          <target state="translated">访问“消息队列”方法时出错。</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.WriteHandle">
          <source>Gets the native handle used to send messages to the message queue.</source>
          <target state="translated">获取用于将消息发送到消息队列的本机句柄。</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.WriteHandle">
          <source>A handle to the native queue object that you use for sending messages to the queue.</source>
          <target state="translated">用于将消息发送到队列的本机队列对象的句柄。</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.WriteHandle">
          <source>The <ph id="ph1">&lt;xref:System.Messaging.MessageQueue.WriteHandle%2A&gt;</ph> provides a native Windows handle to the message queue object that is used for sending messages to the queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Messaging.MessageQueue.WriteHandle%2A&gt;</ph>提供用于将消息发送到队列的消息队列对象的本机 Windows 句柄。</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.WriteHandle">
          <source>If you change the path of the queue, the handle is closed and reopened with a new value.</source>
          <target state="translated">如果你更改队列的路径，该句柄关闭，并使用新值重新打开。</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.WriteHandle">
          <source>The following table shows whether this property is available in various Workgroup modes.</source>
          <target state="translated">下表显示此属性是在各种工作组模式下可用。</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.WriteHandle">
          <source>Workgroup mode</source>
          <target state="translated">工作组模式下</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.WriteHandle">
          <source>Available</source>
          <target state="translated">可用</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.WriteHandle">
          <source>Local computer</source>
          <target state="translated">本地计算机</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.WriteHandle">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.WriteHandle">
          <source>Local computer and direct format name</source>
          <target state="translated">本地计算机和直接格式名</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.WriteHandle">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.WriteHandle">
          <source>Remote computer</source>
          <target state="translated">远程计算机</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.WriteHandle">
          <source>No</source>
          <target state="translated">否</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.WriteHandle">
          <source>Remote computer and direct format name</source>
          <target state="translated">远程计算机并直接格式名</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Messaging.MessageQueue.WriteHandle">
          <source>Yes</source>
          <target state="translated">是</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" uid="P:System.Messaging.MessageQueue.WriteHandle">
          <source>The message queue is not available for writing.</source>
          <target state="translated">消息队列无法用于写入。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>