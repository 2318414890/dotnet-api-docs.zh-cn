<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="INormalizeForIsolatedStorage.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5318f83d32bcaea61fe7f94f0d9bc4ac10d11bc4f.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">318f83d32bcaea61fe7f94f0d9bc4ac10d11bc4f</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage">
          <source>Enables comparisons between an isolated store and an application domain and assembly's evidence.</source>
          <target state="translated">启用独立存储和应用程序域与程序集的证据之间的比较。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage">
          <source>Isolated storage uses evidence about an assembly in order to identify it and provide it with a unique file storage location.</source>
          <target state="translated">独立的存储使用有关以便标识它，并为其提供唯一的文件存储位置的程序集的证据。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage">
          <source>When an assembly requests a store, its evidence (as presented by the host that loaded it) is processed and compared with the evidence used to create the existing stores.</source>
          <target state="translated">当程序集请求的应用商店时的证据 （按所提供的加载它的主机） 是处理，与用于创建现有的存储区的证据进行比较。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage">
          <source>This determines if you need to create a new store or if one already exists for the assembly in question.</source>
          <target state="translated">这将确定如果你需要创建新存储，或如果已存在的问题的程序集。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage">
          <source>Due to the comparison technique used, pieces of evidence that are functionally equivalent might not result in a true comparison if the serialized forms are not identical.</source>
          <target state="translated">由于使用的比较方法，在功能上等效的证据片段可能不导致真正的比较如果序列化的窗体不相同。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage">
          <source>When implementing custom evidence, consider whether this is the case for your evidence class and, if so, implement <ph id="ph1">&lt;xref:System.IO.IsolatedStorage.INormalizeForIsolatedStorage&gt;</ph>.</source>
          <target state="translated">当实现自定义的证据，请考虑这是否是您的证据类用例，然后，如果是这样，实现<ph id="ph1">&lt;xref:System.IO.IsolatedStorage.INormalizeForIsolatedStorage&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage">
          <source>For evidence that implements this interface, the <ph id="ph1">&lt;xref:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize%2A&gt;</ph> method is called and comparisons are based on the normalized copy of the object returned by that method.</source>
          <target state="translated">有关实现此接口的证据<ph id="ph1">&lt;xref:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize%2A&gt;</ph>方法称为，比较将基于该方法返回的对象的规范化副本。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage">
          <source>Implement this interface when you are implementing custom evidence and need to determine if a store already exists.</source>
          <target state="translated">要实现自定义的证据和需要确定是否已存在一个存储区时，请实现此接口。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage">
          <source>Serialized objects should not be used for comparisons in some instances, such as that of case sensitive strings.</source>
          <target state="translated">序列化的对象不应该用于在某些情况下，如区分大小写的字符串比较。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage">
          <source>For example, www.MSN.com is equal to WWW.msn.com and will return a <ph id="ph1">&lt;see langword="true" /&gt;</ph> when compared.</source>
          <target state="translated">例如，www.MSN.com 等于 WWW.msn.com 和将返回<ph id="ph1">&lt;see langword="true" /&gt;</ph>进行比较时。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage">
          <source>To create an <ph id="ph1">&lt;see cref="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage" /&gt;</ph> object, you need to implement the <ph id="ph2">&lt;see cref="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize" /&gt;</ph> method.</source>
          <target state="translated">若要创建<ph id="ph1">&lt;see cref="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage" /&gt;</ph>对象，你需要实现<ph id="ph2">&lt;see cref="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.IsolatedStorage.INormalizeForIsolatedStorage">
          <source>Call the methods of this interface to normalize the instance before making comparisons between an assembly's evidence and currently existing isolated stores.</source>
          <target state="translated">调用此接口可规范化实例之前进行程序集的证据和当前现有之间的比较独立存储区的方法。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize">
          <source>When overridden in a derived class, returns a normalized copy of the object on which it is called.</source>
          <target state="translated">当在派生类中重写时，返回在其上调用它的对象的正常化副本。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize">
          <source>A normalized object that represents the instance on which this method was called.</source>
          <target state="translated">一个正常化的对象，它表示在其上调用该方法的实例。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize">
          <source>This instance can be a string, stream, or any serializable object.</source>
          <target state="translated">该实例可以是字符串、流或任何可序列化的对象。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize">
          <source>When you override this method and the object returned is a stream, it is assumed to be serialized and is compared directly to the serialized form of the evidence used to create existing stores.</source>
          <target state="translated">后，重写此方法返回的对象是一个流，它假定要序列化，并直接与用于创建现有的存储区的证据的序列化格式进行比较。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize">
          <source>If the object returned is a string, it is considered the name of an isolated store and compared to the names of the existing stores.</source>
          <target state="translated">如果返回的对象是一个字符串，它则被视为独立存储区的名称，相比的现有存储的名称。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize">
          <source>You typically call this method if you are writing a class derived from isolated storage and you need to check to see if isolated storage already exists for the current assembly.</source>
          <target state="translated">通常，如果你在编写从独立存储派生的类，并且需要检查以查看当前程序集是否已存在独立的存储，可调用此方法。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>