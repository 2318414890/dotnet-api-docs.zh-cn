<Type Name="ApplicationDeployment" FullName="System.Deployment.Application.ApplicationDeployment">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cc0a2f81304b418f78fdfbda4bc0eb4102f24a62" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30400211" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ApplicationDeployment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ApplicationDeployment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Deployment.Application.ApplicationDeployment" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ApplicationDeployment" />
  <TypeSignature Language="C++ CLI" Value="public ref class ApplicationDeployment sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Deployment</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>支持以编程方式更新当前部署，以及处理文件的按需下载。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以配置你[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序检查更新并将其安装自动通过`subscription`部署清单的元素。 某些应用程序，但是，需要更好地控制其更新。 你可能想要以编程方式，安装所需的更新，并提示用户安装在方便的可选更新。 通过关闭部署清单中的订阅更新，你可能需要应用程序的更新策略的完全的控制。 或者，可以结合使用自动订阅<xref:System.Deployment.Application.ApplicationDeployment>，它使[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]定期更新应用程序，但使用<xref:System.Deployment.Application.ApplicationDeployment>不久之后发布它们时才下载关键更新。  
  
 你可以测试你的部署是否有可用的更新通过使用<xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A>或<xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A>方法; 后一种方法引发<xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted>上成功完成事件。 <xref:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate%2A> 返回有关此更新，例如其版本号，以及是否有当前用户所需的更新的重要信息。 如果有可用的更新，你可以通过安装它<xref:System.Deployment.Application.ApplicationDeployment.Update%2A>或<xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A>; 后一种方法将引发<xref:System.Deployment.Application.ApplicationDeployment.UpdateCompleted>事件之后的更新安装已完成。 对于大型更新，你可以接收进度通知通过<xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateProgressChanged>和<xref:System.Deployment.Application.ApplicationDeployment.UpdateProgressChanged>事件，并使用中的信息<xref:System.ComponentModel.ProgressChangedEventArgs>通知下载状态的用户。  
  
 你还可以使用<xref:System.Deployment.Application.ApplicationDeployment>下载较大的文件和按需程序集。 这些文件必须标记为"可选"内部署的应用程序清单，以便在安装期间不下载。 可以通过在应用程序的持续时间下载的文件的任何时刻<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A>或<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A>方法。 通过提供的事件处理程序被加载到内存之前，你可以下载程序集<xref:System.AppDomain.AssemblyResolve>上的事件<xref:System.AppDomain>类。 有关详细信息，请参阅[演练：在设计器中使用 ClickOnce 部署 API 按需下载程序集](http://msdn.microsoft.com/library/59a0dd5f-1cab-4f2f-b780-0ab7399905d5)。  
  
> [!NOTE]
>  如果你更新[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序运行应用程序时，用户将无法查看更新，直到你调用<xref:System.Windows.Forms.Application.Restart%2A>方法<xref:System.Windows.Forms.Application>，这将关闭应用程序的当前运行的实例并立即重新启动它。  
  
 <xref:System.Deployment.Application.ApplicationDeployment> 没有公共构造函数;获取在类的实例[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]通过应用程序<xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A>属性。 你使用<xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A>属性以验证当前应用程序是否[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序。  
  
 <xref:System.Deployment.Application.ApplicationDeployment> 支持检查更新和下载更新文件以异步方式使用新的[基于事件的异步模式概述](~/docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)，从而将公开为类事件完成回调。 <xref:System.Deployment.Application.ApplicationDeployment> 开头和为你管理线程，并且在正确的 UI 线程上回调应用程序。 通过此类中，你可以更新而不锁定应用程序，以便用户可以继续工作时安装的更新。 如果更新发生时，用户必须停止所有工作，请考虑改为使用同步方法。  
  
> [!NOTE]
>  执行异步更新需要，你的应用程序同时导入<xref:System.Deployment.Application>和<xref:System.ComponentModel>命名空间。  
  
   
  
## Examples  
 下面的代码示例确定在应用程序加载时，是否有可用; 新的更新如果所需的更新可用时，代码示例将以异步方式安装此更新。 应将此代码添加到一个包含窗体<xref:System.Windows.Forms.TextBox>名为`downloadStatus`。  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActivationUri">
      <MemberSignature Language="C#" Value="public Uri ActivationUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri ActivationUri" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.ActivationUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ ActivationUri { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于启动应用程序的部署清单的 URL。</summary>
        <value>如果字符串的长度为零<c>TrustUrlParameters</c>部署清单中的属性是<see langword="false" />，或者如果用户提供了一个以打开部署的 UNC 或本地打开它。 否则，返回值为用于启动应用程序的完整 URL（包含所有参数）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性将在完全受信任和部分受信任应用程序工作。  
  
   
  
## Examples  
 下面的代码演示如何通过使用来检索 URL 参数<xref:System.Deployment.Application.ApplicationDeployment.ActivationUri%2A>，以及如何使用<xref:System.Web.HttpUtility>类，以安全地分析查询字符串。 返回一个项中合并多个出现的相同的查询字符串变量<xref:System.Collections.Specialized.NameValueCollection>。  
  
 [!code-csharp[ClickOnceQueryString#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceQueryString/CS/Form1.cs#1)]
 [!code-vb[ClickOnceQueryString#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceQueryString/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CheckForDetailedUpdate">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>执行与 <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" /> 相同的操作，但返回有关可用更新的扩展信息。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CheckForDetailedUpdate">
      <MemberSignature Language="C#" Value="public System.Deployment.Application.UpdateCheckInfo CheckForDetailedUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Deployment.Application.UpdateCheckInfo CheckForDetailedUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckForDetailedUpdate () As UpdateCheckInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Deployment::Application::UpdateCheckInfo ^ CheckForDetailedUpdate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.UpdateCheckInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>执行与 <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" /> 相同的操作，但返回有关可用更新的扩展信息。</summary>
        <returns>可用更新的 <see cref="T:System.Deployment.Application.UpdateCheckInfo" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate%2A>同步调用方获取相同的方法可使扩展异步调用方使用的信息<xref:System.Deployment.Application.CheckForUpdateCompletedEventArgs>类。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate%2A>以检索最新的更新有关的信息。 如果存在更新，它才会自动安装此更新是必需的更新; 如果仅否则，它会提示用户。  
  
 [!code-cpp[ClickOnceAPI#7](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#7)]
 [!code-csharp[ClickOnceAPI#7](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#7)]
 [!code-vb[ClickOnceAPI#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前应用程序未被配置为支持更新，或是已存在另一个已在进行中的更新检查操作。</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">无法下载部署清单。 此异常将显示在 <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> 事件的 <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" /> 属性中。</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">部署清单已损坏。 在尝试为用户部署此应用程序前，请重新生成应用程序的清单。 此异常将显示在 <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> 事件的 <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" /> 属性中。</exception>
        <permission cref="T:System.Security.PermissionSet">到本地计算机的完全访问权限。 关联枚举：<see cref="T:System.Security.Permissions.PermissionState" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CheckForDetailedUpdate">
      <MemberSignature Language="C#" Value="public System.Deployment.Application.UpdateCheckInfo CheckForDetailedUpdate (bool persistUpdateCheckResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Deployment.Application.UpdateCheckInfo CheckForDetailedUpdate(bool persistUpdateCheckResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckForDetailedUpdate (persistUpdateCheckResult As Boolean) As UpdateCheckInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Deployment::Application::UpdateCheckInfo ^ CheckForDetailedUpdate(bool persistUpdateCheckResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.UpdateCheckInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="persistUpdateCheckResult" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="persistUpdateCheckResult">如果为 <see langword="false" />，将以静默方式应用该更新，且不会显示任何对话框。</param>
        <summary>执行与 <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" /> 相同的操作，但返回有关可用更新的扩展信息。</summary>
        <returns>可用更新的 <see cref="T:System.Deployment.Application.UpdateCheckInfo" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CheckForUpdate">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检查 <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> 以确定是否有新的更新可用。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CheckForUpdate">
      <MemberSignature Language="C#" Value="public bool CheckForUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckForUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckForUpdate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CheckForUpdate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检查 <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> 以确定是否有新的更新可用。</summary>
        <returns>
          如果有新的更新可用，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A>方法比较当前安装的部署使用位于部署清单中指定的版本的版本<xref:System.Deployment.Application.ApplicationDeployment.UpdateLocation%2A>。 如果服务器上的版本是已安装的版本不同，它将返回`true`。  
  
 此方法将受阻，直到完成该检查。 若要以异步方式检查更新，请使用<xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A>方法相反。  
  
> [!NOTE]
>  如果<xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A>发现更新可用，并且用户选择不安装它，[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]会提示有可用的更新在下次运行应用程序的用户。 没有方法来禁用此提示。 (如果应用程序所需的更新，[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]无提示安装。)  
  
   
  
## Examples  
 下面的代码示例检查应用程序更新中;如果找到一个对象，它会安装它以同步方式。  
  
 [!code-cpp[ClickOnceAPI#5](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#5)]
 [!code-csharp[ClickOnceAPI#5](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#5)]
 [!code-vb[ClickOnceAPI#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">如果更新已在进行中，而这时又调用 <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" /> 方法，那么 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 会立即引发此异常。</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">无法下载部署清单。</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">部署清单已损坏。 您可能需要重新部署应用程序才能修复此问题。</exception>
        <permission cref="T:System.Security.PermissionSet">到本地计算机的完全访问权限。 关联枚举：<see cref="T:System.Security.Permissions.PermissionState" />。</permission>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate" />
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdate">
      <MemberSignature Language="C#" Value="public bool CheckForUpdate (bool persistUpdateCheckResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckForUpdate(bool persistUpdateCheckResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckForUpdate (persistUpdateCheckResult As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CheckForUpdate(bool persistUpdateCheckResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="persistUpdateCheckResult" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="persistUpdateCheckResult">如果为 <see langword="false" />，将以静默方式应用该更新，且不会显示任何对话框。</param>
        <summary>检查 <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> 以确定是否有新的更新可用。</summary>
        <returns>
          如果有新的更新可用，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdateAsync">
      <MemberSignature Language="C#" Value="public void CheckForUpdateAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CheckForUpdateAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CheckForUpdateAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CheckForUpdateAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步检查 <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> 以确定是否有新的更新可用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A> 将立即返回，启动单独的线程来下载更新的应用程序。 当方法完成或被取消时，将引发<xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted>事件。 你可以使用<xref:System.ComponentModel.AsyncCompletedEventArgs>中来确定是否已取消该操作，或如果更新过程中引发了异常，此事件处理程序。  
  
 你可以通过调用取消异步更新<xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsyncCancel%2A>。  
  
> [!NOTE]
>  如果<xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A>发现更新可用，并且用户选择不安装它，[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]会提示有可用的更新在下次运行应用程序的用户。 没有方法来禁用此提示。 (如果应用程序所需的更新，[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]无提示安装。)  
  
   
  
## Examples  
 下面的示例以异步方式，检查更新并安装更新，如果存在。  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">如果更新已在进行中，而这时又调用 <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" /> 方法，那么 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 会立即引发此异常。</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">无法下载部署清单。 此异常出现在 <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> 事件的 <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" /> 属性中。</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">部署清单已损坏。 您可能需要重新部署应用程序才能修复此问题。 此异常出现在 <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> 事件的 <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" /> 属性中。</exception>
        <permission cref="T:System.Security.PermissionSet">到本地计算机的完全访问权限。 关联枚举：<see cref="T:System.Security.Permissions.PermissionState" />。</permission>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsyncCancel" />
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdateAsyncCancel">
      <MemberSignature Language="C#" Value="public void CheckForUpdateAsyncCancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CheckForUpdateAsyncCancel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsyncCancel" />
      <MemberSignature Language="VB.NET" Value="Public Sub CheckForUpdateAsyncCancel ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CheckForUpdateAsyncCancel();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取消异步更新检查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法来取消使用启动更新检查<xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A>方法。  
  
 此方法不会取消正在进行，可能已任何后台更新如订阅的一部分启动的更新。 有关订阅的详细信息，请参阅[选择 ClickOnce 更新策略](http://msdn.microsoft.com/library/d8b6e7bb-4ea0-47f3-91cd-48580bdceccc)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdateCompleted">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.CheckForUpdateCompletedEventHandler CheckForUpdateCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.CheckForUpdateCompletedEventHandler CheckForUpdateCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CheckForUpdateCompleted As CheckForUpdateCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::CheckForUpdateCompletedEventHandler ^ CheckForUpdateCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.CheckForUpdateCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" /> 完成时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.CheckForUpdateCompletedEventArgs>类将告诉你，在其他事项、 版本的更新、 更新是多少，日期和可用的更新是必需还是可选之间。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted>来决定是否要求用户安装可用的应用程序更新。 如果更新是强制性的升级，<xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted>事件处理程序不会提示用户。 该示例需要部署的 Windows 窗体应用程序包括<xref:System.Windows.Forms.StatusStrip>控件，并且此控件包含<xref:System.Windows.Forms.ToolStripStatusLabel>控件名为`downloadStatus`。  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdateProgressChanged">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.DeploymentProgressChangedEventHandler CheckForUpdateProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.DeploymentProgressChangedEventHandler CheckForUpdateProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CheckForUpdateProgressChanged As DeploymentProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::DeploymentProgressChangedEventHandler ^ CheckForUpdateProgressChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.DeploymentProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在调用 <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" /> 时存在可用的进度更新的情况下发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateProgressChanged> 有关应用程序的部署的下载状态的报告清单。 这可以是用户通过慢速网络连接下载部署的重要信息。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateProgressChanged>事件来通知用户部署清单中有多少仍将来下载。 该示例需要部署的 Windows 窗体应用程序包括<xref:System.Windows.Forms.StatusStrip>控件，并且此控件包含<xref:System.Windows.Forms.ToolStripStatusLabel>控件名为`downloadStatus`...  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentDeployment">
      <MemberSignature Language="C#" Value="public static System.Deployment.Application.ApplicationDeployment CurrentDeployment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Deployment.Application.ApplicationDeployment CurrentDeployment" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.CurrentDeployment" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDeployment As ApplicationDeployment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Deployment::Application::ApplicationDeployment ^ CurrentDeployment { System::Deployment::Application::ApplicationDeployment ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.ApplicationDeployment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>返回此部署的当前 <see cref="T:System.Deployment.Application.ApplicationDeployment" />。</summary>
        <value>当前部署。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 无法创建实例<xref:System.Deployment.Application.ApplicationDeployment>直接在你的应用程序; 必须检索通过的有效实例<xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A>属性。  
  
 <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A>静态属性才有效只能从已部署使用的应用程序内[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]。 尝试从非调用此属性[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序将引发异常。 如果你正在开发的应用程序可能或可能尚未部署使用[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]，使用<xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A>属性要测试是否在当前程序[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序。  
  
   
  
## Examples  
 下面的代码示例检索<xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A>和检查，以确定是否已在过去三天中更新应用程序。  
  
 [!code-cpp[ClickOnceAPI#3](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#3)]
 [!code-csharp[ClickOnceAPI#3](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#3)]
 [!code-vb[ClickOnceAPI#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">尝试从非 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 应用程序调用此静态属性。</exception>
        <altmember cref="P:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed" />
      </Docs>
    </Member>
    <Member MemberName="CurrentVersion">
      <MemberSignature Language="C#" Value="public Version CurrentVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version CurrentVersion" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.CurrentVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ CurrentVersion { Version ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前正在运行的应用程序实例的部署版本。</summary>
        <value>当前的部署版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CurrentVersion%2A> 不同于<xref:System.Deployment.Application.ApplicationDeployment.UpdatedVersion%2A>如果较新的更新已安装但尚未调用<xref:System.Windows.Forms.Application.Restart%2A>。 如果部署清单配置为执行自动更新，你可以比较这两个值以确定如果应重新启动应用程序。  
  
   
  
## Examples  
 下面的代码示例定义的方法，确定是否[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]已更新应用程序。  
  
 [!code-cpp[ClickOnceAPI#3](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#3)]
 [!code-csharp[ClickOnceAPI#3](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#3)]
 [!code-vb[ClickOnceAPI#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">到本地计算机的完全访问权限。 关联枚举：<see cref="T:System.Security.Permissions.PermissionState" />。</permission>
        <altmember cref="P:System.Deployment.Application.ApplicationDeployment.UpdatedVersion" />
      </Docs>
    </Member>
    <Member MemberName="DataDirectory">
      <MemberSignature Language="C#" Value="public string DataDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.DataDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 数据目录的路径。</summary>
        <value>一个字符串，它包含应用程序的数据目录在本地磁盘上的路径。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroup">
      <MemberSignature Language="C#" Value="public void DownloadFileGroup (string groupName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadFileGroup(string groupName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadFileGroup (groupName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadFileGroup(System::String ^ groupName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="groupName">要下载的已命名文件组。 在 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 应用程序中，标记为“可选”的所有文件均需具备组名称。</param>
        <summary>根据需要下载一组可选文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序中，标记为"可选"应用程序清单中的文件不会下载在初始化或更新过程。 你可以使用<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A>方法以下载所有属于点播情况下，命名组的文件，以便它们不使用网络资源和磁盘空间直到您确定用户需要使用它们。 例如，某些用户可能需要使用其他用户可能无法调用它时，按天，你应用程序中包含的数据分析包。  
  
 若要使用你已下载了与程序集<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A>，附加到的事件侦听器<xref:System.AppDomain.AssemblyResolve>上的事件<xref:System.AppDomain.CurrentDomain%2A>。 有关示例，请参阅 =[演练： 使用 ClickOnce 部署 API 使用设计器按需下载程序集](http://msdn.microsoft.com/library/59a0dd5f-1cab-4f2f-b780-0ab7399905d5)。  
  
 所有文件都下载到[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序缓存中，因此独立于应用程序的当前版本。 假设某个应用程序下载的文件组后，用户安装新版本的应用程序，但稍后又还原为以前版本的应用程序。 在这种情况下，以前的版本仍将最初下载的文件的副本。 有关访问数据文件的详细信息，请参阅[访问本地数据和 ClickOnce 应用程序中的远程数据](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。  
  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> 在部分受信任的应用程序，即中任何工作[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]的运行应用程序限制的权限。 但是，如果你尝试动态加载程序集，你的应用程序将需要完全信任。  
  
 当前不支持按需下载的数据文件。  
  
 你的应用程序不会对之前的用户输入的响应<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A>方法返回。 如果你需要下载文件而不会中断用户的工作流，使用<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A>方法相反。  
  
 通过其单独的文件名称，不能下载单个文件。 若要下载单个文件，将其分配中的组名你[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]部署和下载组，请使用此方法。  
  
   
  
## Examples  
 下面的代码示例演示如何按需将程序集加载的侦听<xref:System.AppDomain.AssemblyResolve>事件。  
  
 [!code-csharp[ClickOnceOnDemandCmdLine#2](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceOnDemandCmdLine/CS/Form1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="groupName" /> 参数为 null 或零长度。</exception>
        <altmember cref="Overload:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DownloadFileGroupAsync">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>根据需要在后台下载一组可选文件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DownloadFileGroupAsync">
      <MemberSignature Language="C#" Value="public void DownloadFileGroupAsync (string groupName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadFileGroupAsync(string groupName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadFileGroupAsync (groupName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadFileGroupAsync(System::String ^ groupName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="groupName">要下载的已命名文件组。 在 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 应用程序中，标记为“可选”的所有文件均需具备组名称。</param>
        <summary>根据需要在后台下载一组可选文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序中，标记为"可选"应用程序清单中的文件不会下载在初始化或更新过程。 你可以使用<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A>方法以下载所有属于点播情况下，命名组的文件，以便它们不使用网络资源和磁盘空间直到您确定用户需要使用它们。 此方法适用于静态文件，不仅对于应用程序可能或可能不需要的程序集。 例如，某些用户可能需要使用其他用户可能无法调用它时，按天，你应用程序中包含的数据分析包。  
  
 若要下载按需程序集，将附加到的事件侦听器<xref:System.AppDomain.AssemblyResolve>上的事件<xref:System.AppDomain.CurrentDomain%2A>。 有关示例，请参阅[演练： 使用 ClickOnce 部署 API 按需下载程序集](http://msdn.microsoft.com/library/d20e2789-8621-4806-b5b7-841122da1456)。  
  
 所有程序集下载到[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序缓存。  
  
 所有静态文件下载到[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序的数据目录中，因此独立于应用程序的当前版本。 假设某个应用程序下载的文件组后，用户安装新版本的应用程序，但稍后又还原为以前版本的应用程序。 在这种情况下，以前的版本仍将最初下载的文件的副本。 有关访问静态文件的详细信息，请参阅[访问本地数据和 ClickOnce 应用程序中的远程数据](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。  
  
 你可以下载多个文件组，同时使用<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A>。 可以通过使用区分它们<xref:System.Deployment.Application.DeploymentProgressChangedEventArgs.Group%2A>属性<xref:System.Deployment.Application.DeploymentProgressChangedEventArgs>类，该类传递给<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupProgressChanged>事件。 如果你需要将更复杂的状态，则可以使用<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A>传入`state`对象。  
  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> 在部分受信任的应用程序，即中任何工作[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]的运行应用程序限制的权限。 但是，如果您试图从中动态加载程序集，你的应用程序将需要完全信任。  
  
 当前不支持按需下载的数据文件。  
  
 通过其单独的文件名称，不能下载单个文件。 若要下载单个文件，将其分配中的组名你[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]部署和下载组，请使用此方法。  
  
 若要取消异步下载，请调用<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsyncCancel%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="groupName" /> 参数为 null 或零长度。</exception>
        <exception cref="T:System.InvalidOperationException">一次不能启动多个 <paramref name="groupName" /> 下载。</exception>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroupAsync">
      <MemberSignature Language="C#" Value="public void DownloadFileGroupAsync (string groupName, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadFileGroupAsync(string groupName, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadFileGroupAsync (groupName As String, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadFileGroupAsync(System::String ^ groupName, System::Object ^ userState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="groupName">要下载的已命名文件组。 在 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 应用程序中，标记为“可选”的所有文件均需具备组名称。</param>
        <param name="userState">包含异步操作状态信息的任意对象。</param>
        <summary>根据需要在后台下载一组可选文件，并向事件回调传递一种应用程序状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序中，标记为"可选"应用程序清单中的文件不会下载在初始化或更新过程。 你可以使用<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A>方法以下载所有属于点播情况下，命名组的文件，以便它们不使用网络资源和磁盘空间直到您确定用户需要使用它们。 此方法适用于静态文件，不仅对于应用程序可能或可能不需要的程序集。 例如，某些用户可能需要使用其他用户可能无法调用它时，按天，你应用程序中包含的数据分析包。 若要下载按需程序集，将附加到的事件侦听器<xref:System.AppDomain.AssemblyResolve>上的事件<xref:System.AppDomain.CurrentDomain%2A>。  
  
 你可以通过使用同时下载多个文件组<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A>方法。 可以通过使用区分它们<xref:System.Deployment.Application.DeploymentProgressChangedEventArgs.Group%2A>属性<xref:System.Deployment.Application.DeploymentProgressChangedEventArgs>类，该类传递给<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupProgressChanged>事件。 如果你需要将更复杂的状态，则可以使用  
  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> 若要传入`state`对象。  
  
 所有静态文件下载到[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序的数据目录中，因此独立于应用程序的当前版本。 有关访问静态文件的详细信息，请参阅[访问本地数据和 ClickOnce 应用程序中的远程数据](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。 . 假设在某个应用程序下载的文件组后，用户安装新版本的应用程序，但是更高版本的用户将恢复为以前版本的应用程序。 在这种情况下，以前的版本仍将最初下载的文件的副本。  
  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> 在部分受信任的应用程序，即中任何工作[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]的运行应用程序限制的权限。 但是，如果您试图从中动态加载程序集，你的应用程序将需要完全信任。  
  
 当前不支持按需下载的数据文件。  
  
 若要取消异步下载，请调用<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsyncCancel%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="groupName" /> 参数为 null 或零长度。</exception>
        <exception cref="T:System.InvalidOperationException">一次不能启动多个 <paramref name="groupName" /> 下载。</exception>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroupAsyncCancel">
      <MemberSignature Language="C#" Value="public void DownloadFileGroupAsyncCancel (string groupName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadFileGroupAsyncCancel(string groupName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsyncCancel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadFileGroupAsyncCancel (groupName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadFileGroupAsyncCancel(System::String ^ groupName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="groupName">要下载的已命名文件组。 在 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 应用程序中，标记为“可选”的所有文件均需具备组名称。</param>
        <summary>取消异步文件下载。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="groupName" /> 不能为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroupCompleted">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.DownloadFileGroupCompletedEventHandler DownloadFileGroupCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.DownloadFileGroupCompletedEventHandler DownloadFileGroupCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DownloadFileGroupCompleted As DownloadFileGroupCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::DownloadFileGroupCompletedEventHandler ^ DownloadFileGroupCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.DownloadFileGroupCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>完成一个文件下载时在主应用程序线程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupCompleted>事件时调用的主应用程序线程上。 它是线程安全调用直接在此回调内的应用程序的 Windows 窗体控件。  
  
 检查<xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>属性<xref:System.ComponentModel.AsyncCompletedEventArgs>提供给此回调。 如果此属性为`null`，则下载已成功; 如果还没有`null`，安装未成功，并且你可以找到有关通过安装失败的详细信息<xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>属性。  
  
   
  
## Examples  
 下面的代码示例下载一组在后台的帮助文件。 该示例需要部署的 Windows 窗体应用程序包括<xref:System.Windows.Forms.StatusStrip>控件，并且此控件包含<xref:System.Windows.Forms.ToolStripStatusLabel>控件名为`downloadStatus`...  
  
 [!code-cpp[ClickOnceAPI#8](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#8)]
 [!code-csharp[ClickOnceAPI#8](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#8)]
 [!code-vb[ClickOnceAPI#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroupProgressChanged">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.DeploymentProgressChangedEventHandler DownloadFileGroupProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.DeploymentProgressChangedEventHandler DownloadFileGroupProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DownloadFileGroupProgressChanged As DeploymentProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::DeploymentProgressChangedEventHandler ^ DownloadFileGroupProgressChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.DeploymentProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当由 <see cref="Overload:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync" /> 调用启动的文件下载操作存在可用的状态信息时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupProgressChanged>事件时调用的主应用程序线程上。 它是线程安全调用直接在此回调内的应用程序的 Windows 窗体控件。  
  
 使用中提供的信息<xref:System.Deployment.Application.DeploymentProgressChangedEventArgs>进度将信息传递给你的用户。  
  
   
  
## Examples  
 下面的代码示例下载一组在后台的帮助文件。 该示例需要部署的 Windows 窗体应用程序包括<xref:System.Windows.Forms.StatusStrip>控件，并且此控件包含<xref:System.Windows.Forms.ToolStripStatusLabel>控件名为`downloadStatus`。  
  
 [!code-cpp[ClickOnceAPI#8](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#8)]
 [!code-csharp[ClickOnceAPI#8](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#8)]
 [!code-vb[ClickOnceAPI#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFileGroupDownloaded">
      <MemberSignature Language="C#" Value="public bool IsFileGroupDownloaded (string groupName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFileGroupDownloaded(string groupName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.IsFileGroupDownloaded(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFileGroupDownloaded (groupName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFileGroupDownloaded(System::String ^ groupName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="groupName">要下载的已命名文件组。 在 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 应用程序中，标记为“可选”的所有文件均需具备组名称。</param>
        <summary>检查已命名的文件组是否已下载到客户端计算机中。</summary>
        <returns>
          如果已为此应用程序的当前版本下载了该文件组，则为 <see langword="true" />；否则为 <see langword="false" />。 如果已安装了新版本的应用程序，而且新版本的应用程序未对文件组中的文件做任何添加、移除或更改，则 <see cref="M:System.Deployment.Application.ApplicationDeployment.IsFileGroupDownloaded(System.String)" /> 返回 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.IsFileGroupDownloaded%2A> 在没有任何安全请求的部分受信任的应用程序中的工作。  
  
 当你更新应用程序，[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]将任何按需数据文件从以前的版本复制到新版本的数据目录。 如果你下载这些文件的新版本，则应删除你想要防止旧版本并将其移到新版本的任何数据。  
  
   
  
## Examples  
 下面的代码示例下载中的所有文件`HelpFiles`组到磁盘。  
  
 [!code-cpp[ClickOnceAPI#8](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#8)]
 [!code-csharp[ClickOnceAPI#8](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#8)]
 [!code-vb[ClickOnceAPI#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">
          <paramref name="groupName" /> 不是应用程序清单中定义的文件组。</exception>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup(System.String)" />
        <altmember cref="Overload:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstRun">
      <MemberSignature Language="C#" Value="public bool IsFirstRun { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstRun" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.IsFirstRun" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstRun As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstRun { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此应用程序是否是第一次在客户端计算机上运行。</summary>
        <value>
          如果此版本的应用程序此前未在客户端计算机上运行过，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Deployment.Application.ApplicationDeployment.IsFirstRun%2A>以确定是否需要执行第一次你的应用程序运行的任何一次性初始化操作。  
  
 不要假定<xref:System.Deployment.Application.ApplicationDeployment.IsFirstRun%2A>设置`true`指示应用程序的此实例是第一个要向用户显示其用户界面。 由于系统调度进程方式，应用程序的一个实例可能具有其<xref:System.Deployment.Application.ApplicationDeployment.IsFirstRun%2A>属性设置为`true`，但另一个实例可能要在屏幕上呈现的第一个。 只要用户从一个版本升级到下一步，此属性的值被重置。 如果你想要执行操作，唯一非常第一个时间的任何版本运行应用程序，你将需要执行其他测试，例如检查创建第一次的文件是否存在或存储标志使用**应用程序设置**。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Deployment.Application.ApplicationDeployment.IsFirstRun%2A>决定是否要检查的文件组的更新`HelpFiles`。 如果已更新一个或多个文件，则会调用<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A>若要获得新版本。  
  
 [!code-csharp[ClickOnceAPI#9](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#9)]
 [!code-vb[ClickOnceAPI#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">到本地计算机的完全访问权限。 关联枚举：<see cref="T:System.Security.Permissions.PermissionState" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsNetworkDeployed">
      <MemberSignature Language="C#" Value="public static bool IsNetworkDeployed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsNetworkDeployed" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsNetworkDeployed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsNetworkDeployed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前应用程序是否为 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 应用程序。</summary>
        <value>
          如果该应用程序是 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 应用程序，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您的应用程序均可运行的内部和外部[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]（例如，如果你需要调试你的应用程序在本地计算机上部署之前） 的部署、 测试<xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A>之前访问<xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A>属性。  
  
 <xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A> 将返回`true`而不考虑是否安装或联机，承载应用程序以及是否从网站、 文件共享或 CD-ROM 安装它。  
  
   
  
## Examples  
 下面的代码示例检索<xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A>使用<xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A>首先以确保该引用不是`null`。  
  
 [!code-cpp[ClickOnceAPI#2](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#2)]
 [!code-csharp[ClickOnceAPI#2](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">到本地计算机的完全访问权限。 关联枚举：<see cref="T:System.Security.Permissions.PermissionState" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="TimeOfLastUpdateCheck">
      <MemberSignature Language="C#" Value="public DateTime TimeOfLastUpdateCheck { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime TimeOfLastUpdateCheck" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.TimeOfLastUpdateCheck" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeOfLastUpdateCheck As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime TimeOfLastUpdateCheck { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 上次检查应用程序更新时的日期和时间。</summary>
        <value>上次更新检查的 <see cref="T:System.DateTime" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序可以配置为订阅更新。 在此方案中，[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]轮询自动按部署清单中定义的时间间隔的应用程序的部署位置，并确定是否有可用更新。 <xref:System.Deployment.Application.ApplicationDeployment.TimeOfLastUpdateCheck%2A> 返回上次更新检查而不考虑它是否启动订阅或显式检查使用的时间<xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A>， <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A>， <xref:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate%2A>， <xref:System.Deployment.Application.ApplicationDeployment.Update%2A>，或<xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A>方法。  
  
 如果安装应用程序后，执行更新检查<xref:System.Deployment.Application.ApplicationDeployment.TimeOfLastUpdateCheck%2A>返回的安装时间。  
  
   
  
## Examples  
 下面的代码示例检查是否[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]已在过去三天中的可用更新检查应用程序。  
  
 [!code-cpp[ClickOnceAPI#3](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#3)]
 [!code-csharp[ClickOnceAPI#3](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#3)]
 [!code-vb[ClickOnceAPI#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">到本地计算机的完全访问权限。 关联枚举：<see cref="T:System.Security.Permissions.PermissionState" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public bool Update ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Update() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.Update" />
      <MemberSignature Language="VB.NET" Value="Public Function Update () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Update();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>开始同步下载和安装此应用程序的最新版本。</summary>
        <returns>
          如果应用程序已更新，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序被视为更新发布到指定的位置的应用程序的新版本时<xref:System.Deployment.Application.ApplicationDeployment.UpdateLocation%2A>，并且在应用程序的部署清单中的版本号当前大于应用程序的版本号用户的计算机上安装。  
  
 <xref:System.Deployment.Application.ApplicationDeployment.Update%2A>调用将阻止，直至下载到客户端计算机更新并将其安装到[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]缓存; 在此期间，应用程序不会对用户的响应性。 如果你想要维护应用程序响应能力或在下载时，使用显示的进度报告<xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A>方法相反。  
  
 <xref:System.Deployment.Application.ApplicationDeployment.Update%2A> 下载所有未标记为"可选"应用程序清单中的文件。 你可以通过使用下载可选文件按需<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A>或<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A>方法。  
  
 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 可能已将更新应用程序自动在调用时<xref:System.Deployment.Application.ApplicationDeployment.Update%2A>方法; 如果发生这种情况，调用此方法将引发<xref:System.InvalidOperationException>。  
  
 如果你已在你的部署中更新一个或多个文件，但不是刷新应用程序清单，你将收到<xref:System.Deployment.Application.InvalidDeploymentException>。 大多数情况下，重新部署你[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序可解决此问题。 如果上的部署清单或应用程序清单的公共密钥签名无效或缺失，也会收到此异常。  
  
 更新可能会请求比以前版本的应用程序更高级别的本地计算机上的信任。 如果应用程序使用受信任的应用程序部署，公共语言运行时 (CLR) 信任关系管理器将检查部署清单，以确定其是否包含有效的信任许可证。 如果部署清单不包含有效的信任许可证，[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]将停止安装，并引发<xref:System.Deployment.Application.TrustNotGrantedException>。 <xref:System.Deployment.Application.ApplicationDeployment.Update%2A>方法将永远不会显示一个提示，询问用户他们是否希望向其授予应用程序的权限运行。  
  
   
  
## Examples  
 下面的代码示例检查应用程序更新中;如果有可用的更新，它会安装它以同步方式。  
  
 [!code-cpp[ClickOnceAPI#6](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#6)]
 [!code-csharp[ClickOnceAPI#6](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#6)]
 [!code-vb[ClickOnceAPI#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Deployment.Application.TrustNotGrantedException">本地计算机未授予该应用程序执行其请求的操作所需的权限级别。</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 部署已损坏。 有关如何诊断和更正问题的提示，请参阅 [ClickOnce 部署疑难解答](http://msdn.microsoft.com/library/58e90012-f68b-4852-8ae9-58e361cbcc32)。</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">未能从其网络位置下载新部署。</exception>
        <exception cref="T:System.InvalidOperationException">当前应用程序正在更新。</exception>
        <permission cref="T:System.Security.PermissionSet">到本地计算机的完全访问权限。 关联枚举：<see cref="T:System.Security.Permissions.PermissionState" />。</permission>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate" />
      </Docs>
    </Member>
    <Member MemberName="UpdateAsync">
      <MemberSignature Language="C#" Value="public void UpdateAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>开始异步下载和安装此应用程序的最新版本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序被视为更新发布到指定的位置的应用程序的新版本时<xref:System.Deployment.Application.ApplicationDeployment.UpdateLocation%2A>，并且在应用程序的部署清单中的版本号当前大于应用程序的版本号用户的计算机上安装。  
  
 在下载更新，[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]将引发<xref:System.Deployment.Application.ApplicationDeployment.UpdateProgressChanged>上的主应用程序线程，以通知你下载的状态的事件处理程序。 当异步更新完成或遇到的异常，[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]将引发<xref:System.Deployment.Application.ApplicationDeployment.UpdateCompleted>在主应用程序线程上的事件。 检查<xref:System.ComponentModel.AsyncCompletedEventArgs>提供给此事件可以确定更新是否成功。  
  
 如果<xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A>引发异常，[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]调用<xref:System.Deployment.Application.ApplicationDeployment.UpdateCompleted>和设置<xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>属性<xref:System.ComponentModel.AsyncCompletedEventArgs>到已引发的异常。  
  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> 将下载在部署中未标记为"可选"应用程序清单中的所有文件。 你可以通过使用下载可选文件按需<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A>或<xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A>方法。  
  
 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 可能已将更新应用程序自动在调用时<xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A>方法; 如果发生这种情况，调用此方法将引发<xref:System.InvalidOperationException>。  
  
 如果你已在你的部署中更新一个或多个文件，但不是刷新应用程序清单，你将收到<xref:System.Deployment.Application.InvalidDeploymentException>。 大多数情况下，重新生成你的应用程序清单可解决此问题。 如果上的部署清单或应用程序清单的公共密钥签名无效或缺失，也会收到此异常。  
  
 更新可能会请求比以前版本的应用程序更高级别的本地计算机上的信任。 如果应用程序使用受信任的应用程序部署，公共语言运行时 (CLR) 信任关系管理器将检查部署清单，以确定其是否包含有效的信任许可证。 如果部署清单不包含有效的信任许可证，[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]将停止安装，并引发<xref:System.Deployment.Application.TrustNotGrantedException>。 <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> 将永远不会显示一个提示，询问用户他们想要授予应用程序的权限运行。  
  
   
  
## Examples  
 下面的代码示例确定在应用程序加载时; 是否可用的新更新如果所需的更新可用，它以异步方式安装更新。 该示例需要部署的 Windows 窗体应用程序包括<xref:System.Windows.Forms.StatusStrip>控件，并且此控件包含<xref:System.Windows.Forms.ToolStripStatusLabel>控件名为`downloadStatus`。  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Deployment.Application.TrustNotGrantedException">本地计算机未授予此应用程序执行其请求的操作所需的权限级别。</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 部署已损坏。 有关如何诊断和更正问题的提示，请参阅 [ClickOnce 部署疑难解答](http://msdn.microsoft.com/library/58e90012-f68b-4852-8ae9-58e361cbcc32)。</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">未能从其网络位置下载新部署。</exception>
        <permission cref="T:System.Security.PermissionSet">到本地计算机的完全访问权限。 关联枚举：<see cref="T:System.Security.Permissions.PermissionState" />。</permission>
        <altmember cref="E:System.Deployment.Application.ApplicationDeployment.UpdateCompleted" />
      </Docs>
    </Member>
    <Member MemberName="UpdateAsyncCancel">
      <MemberSignature Language="C#" Value="public void UpdateAsyncCancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateAsyncCancel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.UpdateAsyncCancel" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateAsyncCancel ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateAsyncCancel();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取消由 <see cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" /> 启动的异步更新。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsyncCancel%2A> 仅取消通过调用启动的更新<xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A>; 它不会取消订阅的一部分启动的更新。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">到本地计算机的完全访问权限。 关联枚举：<see cref="T:System.Security.Permissions.PermissionState" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="UpdateCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AsyncCompletedEventHandler UpdateCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AsyncCompletedEventHandler UpdateCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.UpdateCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UpdateCompleted As AsyncCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AsyncCompletedEventHandler ^ UpdateCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AsyncCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 通过调用 <see cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" /> 完成了应用程序升级时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateCompleted>事件时调用的主应用程序线程上。 你可能不会引发异常的情况下调用直接在此回调内的应用程序的 Windows 窗体控件。  
  
 检查<xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>属性<xref:System.ComponentModel.AsyncCompletedEventArgs>提供给此回调。 如果此属性为`null`，安装是否成功; 如果还没有`null`，安装未成功，并且你可以找到有关通过此安装故障的详细信息<xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>属性。 一旦已经下载的更新，你将需要调用<xref:System.Windows.Forms.Application.Restart%2A>方法<xref:System.Windows.Forms.Application>使用应用程序的较新版本。  
  
 如果更新安装已取消通过调用<xref:System.Deployment.Application.ApplicationDeployment.UpdateAsyncCancel%2A>、<xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A>属性<xref:System.ComponentModel.AsyncCompletedEventArgs>类将`true`。  
  
 若要使用此事件处理程序，你的应用程序必须同时导入<xref:System.Deployment.Application>和<xref:System.ComponentModel>命名空间。  
  
   
  
## Examples  
 下面的代码示例确定在应用程序加载时，是否有可用; 新的更新如果所需的更新可用，它以异步方式安装更新。 该示例需要部署的 Windows 窗体应用程序包括<xref:System.Windows.Forms.StatusStrip>控件，并且此控件包含<xref:System.Windows.Forms.ToolStripStatusLabel>控件名为`downloadStatus`。  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdatedApplicationFullName">
      <MemberSignature Language="C#" Value="public string UpdatedApplicationFullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UpdatedApplicationFullName" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.UpdatedApplicationFullName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UpdatedApplicationFullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UpdatedApplicationFullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取应用程序更新后的全名。</summary>
        <value>一个包含应用程序的全名的 <see cref="T:System.String" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdatedVersion">
      <MemberSignature Language="C#" Value="public Version UpdatedVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version UpdatedVersion" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.UpdatedVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UpdatedVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ UpdatedVersion { Version ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取最近下载的更新版本。</summary>
        <value>描述更新版本的 <see cref="T:System.Version" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdatedVersion%2A> 不同于<xref:System.Deployment.Application.ApplicationDeployment.CurrentVersion%2A>如果较新的更新已安装但尚未调用<xref:System.Windows.Forms.Application.Restart%2A>上<xref:System.Windows.Forms.Application>。 如果应用程序的部署清单配置为执行自动更新，你可以比较这两个值以确定是否应重新启动应用程序。  
  
 如果尚未更新应用程序，<xref:System.Deployment.Application.ApplicationDeployment.UpdatedVersion%2A>返回相同的值<xref:System.Deployment.Application.ApplicationDeployment.CurrentVersion%2A>。  
  
   
  
## Examples  
 下面的代码示例定义的方法，确定是否[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]已更新应用程序。  
  
 [!code-cpp[ClickOnceAPI#4](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#4)]
 [!code-csharp[ClickOnceAPI#4](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#4)]
 [!code-vb[ClickOnceAPI#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">到本地计算机的完全访问权限。 关联的枚举： <see cref="T:System.Security.Permissions.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="UpdateLocation">
      <MemberSignature Language="C#" Value="public Uri UpdateLocation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UpdateLocation" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UpdateLocation As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ UpdateLocation { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此应用程序从中更新自身的网站或文件共享。</summary>
        <value>以 HTTP、HTTPS 或文件 URL 表示的更新路径；或以 Windows 网络文件路径 (UNC) 表示的更新路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateLocation%2A> 可能不同于使用最初下载应用程序，如果应用程序的部署配置为使用更新重定向的网站。  
  
 只能在应用程序的部署清单，可以更改此值。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">到本地计算机的完全访问权限。 关联枚举：<see cref="T:System.Security.Permissions.PermissionState" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="UpdateProgressChanged">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.DeploymentProgressChangedEventHandler UpdateProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.DeploymentProgressChangedEventHandler UpdateProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.UpdateProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UpdateProgressChanged As DeploymentProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::DeploymentProgressChangedEventHandler ^ UpdateProgressChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.DeploymentProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>对于通过调用 <see cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" /> 方法启动的更新操作，当 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 存在关于此更新操作的新的状态信息时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateProgressChanged>事件时调用的主应用程序线程上。 你可能不会引发异常的情况下调用直接在此回调内的应用程序的 Windows 窗体控件。  
  
   
  
## Examples  
 下面的代码示例确定在应用程序加载时，是否有可用; 新的更新如果所需的更新可用，它以异步方式安装更新。  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>