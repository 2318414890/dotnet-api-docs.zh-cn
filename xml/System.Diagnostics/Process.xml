<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0f3b937515accae8f91569e4cac09306f70365d0" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061724" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供对本地和远程进程的访问权限并使你能够启动和停止本地系统进程。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Diagnostics.Process>组件提供了对计算机运行的进程的访问。 进程，简言之，是在正在运行的应用。 线程是操作系统向其分配处理器时间的基本单位。 线程可以执行进程，包括当前正由另一个线程执行的部件的任何的代码的部分。  
  
 <xref:System.Diagnostics.Process>组件是用于启动、 停止、 控制和监视应用的有用工具。 你可以使用<xref:System.Diagnostics.Process>组件，以获取正在运行的进程的列表或你可以启动一个新进程。 A<xref:System.Diagnostics.Process>组件用于访问系统进程。 后<xref:System.Diagnostics.Process>组件已初始化，所以可以用来获取有关正在运行的进程的信息。 此类信息包括的一组线程，加载的模块 （.dll 和.exe 文件），以及使用的进程的内存量等的性能信息。  
  
 此类型实现<xref:System.IDisposable>接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，调用其<xref:System.IDisposable.Dispose%2A>中的方法`try` / `catch`块。 若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅中的"使用实现 IDisposable 的对象"部分<xref:System.IDisposable>接口主题。  
  
> [!NOTE]
>  32 位进程无法访问的 64 位进程的模块。 如果你尝试从 32 位进程中获取有关的 64 位进程的信息，则会出现<xref:System.ComponentModel.Win32Exception>异常。 一个 64 位进程，另一方面，可以访问是 32 位进程的模块。  
  
 进程组件获取一组属性有关的信息在一次。 后<xref:System.Diagnostics.Process>组件获取有关任何组的一个成员的信息，它将缓存该组中的其他属性的值并不获得有关的其他成员的组的新信息，直到你调用<xref:System.Diagnostics.Process.Refresh%2A>方法。 因此，属性值不一定要比上次调用任何新<xref:System.Diagnostics.Process.Refresh%2A>方法。 组细分与依赖于操作系统。  
  
 如果你有系统中用引号中声明的路径变量，则必须启动任何进程在该位置中找到时，完全限定该路径。 否则，系统将不到的路径。 例如，如果`c:\mypath`不在你的路径，并将其使用引号引起来添加： `path = %path%;"c:\mypath"`，必须完全符合中的任何进程`c:\mypath`时启动它。  
  
 由其进程标识符，系统进程唯一标识系统上。 许多 Windows 资源，如进程也由其句柄，这可能不是在计算机上唯一标识。 句柄是资源的标识符的通用术语。 操作系统仍保持进程句柄，可通过<xref:System.Diagnostics.Process.Handle%2A>属性<xref:System.Diagnostics.Process>组件，即使该进程已退出。 因此，可以获取进程的管理信息，如<xref:System.Diagnostics.Process.ExitCode%2A>（通常或者为零表示成功或一个非零错误代码） 和<xref:System.Diagnostics.Process.ExitTime%2A>。 句柄是极其有价值的资源，所以句柄泄漏内存比危害更大。  
  
> [!NOTE]
>  此类包含链接要求，并且在类级别应用于所有成员继承要求。 A<xref:System.Security.SecurityException>直接调用方或派生的类没有完全信任权限时，将引发。 有关安全要求的详细信息，请参阅[链接需求](~/docs/framework/misc/link-demands.md)。  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] 说明  
 在.NET Framework 中，<xref:System.Diagnostics.Process>默认使用的类<xref:System.Console>编码，通常是代码页编码，为输入、 输出和错误流。 有关示例代码，代码页 437 上其区域性为英语 （美国） 的系统，是默认设置编码<xref:System.Console>类。 但是，[!INCLUDE[net_core](~/includes/net-core-md.md)]可能提供仅这些编码的有限的子集。 如果出现这种情况，它使用<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>作为默认的编码。  
  
 如果<xref:System.Diagnostics.Process>对象依赖于特定的代码页编码，就可以仍可以通过执行以下*之前*调用任何<xref:System.Diagnostics.Process>方法：  
  
1.  将 System.Text.Encoding.CodePages.dll 程序集的引用添加到你的项目。  
  
2.  检索<xref:System.Text.EncodingProvider>对象<xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType>属性。  
  
3.  传递<xref:System.Text.EncodingProvider>对象传递给<xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType>方法使编码的可用提供程序支持的其他编码。  
  
 <xref:System.Diagnostics.Process>类将自动使用默认系统编码而不 UTF8，前提是你在调用任何之前注册编码提供<xref:System.Diagnostics.Process>方法。  
  
   
  
## Examples  
 下面的示例使用的实例<xref:System.Diagnostics.Process>类启动的进程。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 下面的示例使用<xref:System.Diagnostics.Process>类本身和静态<xref:System.Diagnostics.Process.Start%2A>方法启动的进程。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 下面的 F # 示例定义`runProc`启动一个进程的函数捕获所有输出和错误的信息，并记录该进程已运行的毫秒数。  `runProc`函数具有三个参数： 应用程序以启动，要提供给应用程序，并开始目录的自变量的名称。  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 代码`runProc`函数是否已写入[ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment)和位于下[Microsoft 公共许可证](https://opensource.org/licenses/ms-pl)。  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此类不能由部分受信任的代码使用。</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">对继承者的完全信任。 此类不能由部分受信任的代码继承。</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.Process" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不指定<xref:System.Diagnostics.Process.MachineName%2A>属性，则默认为本地计算机 ("。")。  
  
 你有两个选项可用于将新<xref:System.Diagnostics.Process>组件与计算机上的进程。 第一个选项是使用构造函数来创建<xref:System.Diagnostics.Process>组件，设置的相应成员<xref:System.Diagnostics.Process.StartInfo%2A>属性并调用<xref:System.Diagnostics.Process.Start%2A>关联<xref:System.Diagnostics.Process>使用新的系统进程。 第二个选项是将关联<xref:System.Diagnostics.Process>与正在运行的系统进程，使用<xref:System.Diagnostics.Process.GetProcessById%2A>或之一<xref:System.Diagnostics.Process.GetProcesses%2A>返回值。  
  
 如果你使用`static`重载<xref:System.Diagnostics.Process.Start%2A>方法来启动一个新的系统进程，该方法创建一个新<xref:System.Diagnostics.Process>组件并将它与进程相关联。  
  
 当<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>属性设置为其默认值， `true`，您可以在类似于使用一种方法启动应用程序和文档`Run`对话框中的 windows`Start`菜单。 当<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>是`false`，你可以开始仅可执行文件。  
  
 可以在两种方式之一中启动，可以从命令行调用任何可执行文件： 通过设置的相应成员<xref:System.Diagnostics.Process.StartInfo%2A>属性和调用<xref:System.Diagnostics.Process.Start%2A>方法提供任何参数，或通过将传递到适当的参数`static` <xref:System.Diagnostics.Process.Start%2A>成员。  
  
 你可以创建<xref:System.Diagnostics.Process>组件通过使用构造函数中，一个静态<xref:System.Diagnostics.Process.Start%2A>重载，或任何<xref:System.Diagnostics.Process.GetProcessById%2A>， <xref:System.Diagnostics.Process.GetProcesses%2A>，或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。 你这样做之后，必须为关联进程的视图。 这不会自动更新自身，当进程属性更改在内存中的动态视图。 相反，您必须调用<xref:System.Diagnostics.Process.Refresh%2A>以更新组件的<xref:System.Diagnostics.Process>应用程序中的属性信息。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的基本优先级。</summary>
        <value>基本优先级，从关联进程的 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 计算。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BasePriority%2A>的过程是在关联进程内创建的线程的起始优先级。 你可以查看通过系统监视器的优先级基数计数器的基本优先级有关的信息。  
  
 基于的时间应早其他放置过程时，运行时间或其他提升，操作系统可以更改的基本优先级。  
  
 <xref:System.Diagnostics.Process.BasePriority%2A>属性，可以查看分配给过程的起始优先级。 但是，因为它是只读的不能使用<xref:System.Diagnostics.Process.BasePriority%2A>设置进程的优先级。 若要更改的优先级，使用<xref:System.Diagnostics.Process.PriorityClass%2A>属性。 <xref:System.Diagnostics.Process.BasePriority%2A>可查看使用系统监视器，而<xref:System.Diagnostics.Process.PriorityClass%2A>不是。 同时<xref:System.Diagnostics.Process.BasePriority%2A>和<xref:System.Diagnostics.Process.PriorityClass%2A>可以以编程方式查看。 下表显示之间的关系<xref:System.Diagnostics.Process.BasePriority%2A>值和<xref:System.Diagnostics.Process.PriorityClass%2A>值。  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 以下示例启动记事本实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 属性设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <exception cref="T:System.InvalidOperationException">该进程已退出。  
  
 或  
  
 尚未启动进程，因此没有进程 ID。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在应用程序的重定向 <see cref="P:System.Diagnostics.Process.StandardError" /> 流上开始进行异步读取操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardError%2A>可以读取流，同步或异步。 等方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>同步对执行读取的操作的错误输出流的过程。 这些同步读取操作不会完成之前关联<xref:System.Diagnostics.Process>写入其<xref:System.Diagnostics.Process.StandardError%2A>流处理时，或关闭流。  
  
 与此相反，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>开始异步读取操作上<xref:System.Diagnostics.Process.StandardError%2A>流。 此方法启用的指定的事件处理程序输出进行流式处理，并立即返回到调用方，流输出定向到事件处理程序时可以执行其他工作。  
  
 按照这些步骤上执行异步读取的操作<xref:System.Diagnostics.Process.StandardError%2A>为<xref:System.Diagnostics.Process>:  
  
1.  将 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 设置为 `false`。  
  
2.  将 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> 设置为 `true`。  
  
3.  添加到事件处理程序<xref:System.Diagnostics.Process.ErrorDataReceived>事件。 事件处理程序必须与匹配<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>委托签名。  
  
4.  启动<xref:System.Diagnostics.Process>。  
  
5.  调用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>为<xref:System.Diagnostics.Process>。 此调用会启动异步读取的操作上<xref:System.Diagnostics.Process.StandardError%2A>。  
  
 调用异步读取的操作开始时，事件处理程序时每次关联<xref:System.Diagnostics.Process>写入到的文本行其<xref:System.Diagnostics.Process.StandardError%2A>流。  
  
 你可以通过调用取消异步读的操作<xref:System.Diagnostics.Process.CancelErrorRead%2A>。 由调用方或事件处理程序，可以取消读取的操作。 取消之后，可以调用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>再次继续异步读取的操作。  
  
> [!NOTE]
>  不能混合在重定向流上的异步和同步读取的操作。 一次的重定向的流<xref:System.Diagnostics.Process>打开在异步或同步模式下，所有进一步读取该流上的操作必须处于相同的模式。 例如，不遵循<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>通过调用<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardError%2A>流，反之亦然。 但是，你可以读取在不同模式下的两个不同的流。 例如，你可以调用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>，然后调用<xref:System.IO.StreamReader.ReadLine%2A>为<xref:System.Diagnostics.Process.StandardOutput%2A>流。  
  
   
  
## Examples  
 下面的示例使用`net view`命令以列出在远程计算机上的可用的网络资源。 在用户提供的目标计算机名称作为命令行自变量。 用户还可以提供错误输出的文件名称。 该示例收集的 net 命令、 等待进程完成，然后写入到控制台的输出结果的输出。 如果在用户提供的可选错误文件，该示例会将错误写入文件。  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 属性为 <see langword="false" />。  
  
 \- 或 -  
  
 <see cref="P:System.Diagnostics.Process.StandardError" /> 流上已在进行异步读取操作。  
  
 \- 或 -  
  
 同步读取操作已使用 <see cref="P:System.Diagnostics.Process.StandardError" /> 流。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在应用程序的重定向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流上开始进行异步读取操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardOutput%2A>可以读取流，同步或异步。 等方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>同步对执行读取的操作过程的输出流。 这些同步读取操作不会完成之前关联<xref:System.Diagnostics.Process>写入其<xref:System.Diagnostics.Process.StandardOutput%2A>流处理时，或关闭流。  
  
 与此相反，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>开始异步读取操作上<xref:System.Diagnostics.Process.StandardOutput%2A>流。 此方法将启用流输出指定的事件处理程序并立即返回到调用方，流输出定向到事件处理程序时可以执行其他工作。  
  
 按照这些步骤上执行异步读取的操作<xref:System.Diagnostics.Process.StandardOutput%2A>为<xref:System.Diagnostics.Process>:  
  
1.  将 <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> 设置为 `false`。  
  
2.  将 <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> 设置为 `true`。  
  
3.  添加到事件处理程序<xref:System.Diagnostics.Process.OutputDataReceived>事件。 事件处理程序必须与匹配<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>委托签名。  
  
4.  启动<xref:System.Diagnostics.Process>。  
  
5.  调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>为<xref:System.Diagnostics.Process>。 此调用会启动异步读取的操作上<xref:System.Diagnostics.Process.StandardOutput%2A>。  
  
 调用异步读取的操作开始时，事件处理程序时每次关联<xref:System.Diagnostics.Process>写入到的文本行其<xref:System.Diagnostics.Process.StandardOutput%2A>流。  
  
 你可以通过调用取消异步读的操作<xref:System.Diagnostics.Process.CancelOutputRead%2A>。 由调用方或事件处理程序，可以取消读取的操作。 取消之后，可以调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>再次继续异步读取的操作。  
  
> [!NOTE]
>  不能混合在重定向流上的异步和同步读取的操作。 一次的重定向的流<xref:System.Diagnostics.Process>打开在异步或同步模式下，所有进一步读取该流上的操作必须处于相同的模式。 例如，不遵循<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>通过调用<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardOutput%2A>流，反之亦然。 但是，你可以读取在不同模式下的两个不同的流。 例如，你可以调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然后调用<xref:System.IO.StreamReader.ReadLine%2A>为<xref:System.Diagnostics.Process.StandardError%2A>流。  
  
   
  
## Examples  
 下面的示例演示如何执行上的重定向的异步读取的操作<xref:System.Diagnostics.Process.StandardOutput%2A>流`sort`命令。 `sort`命令是一个控制台应用程序，读取对文本输入进行排序。  
  
 该示例创建一个事件委托，它为`SortOutputHandler`事件处理程序并将其与关联<xref:System.Diagnostics.Process.OutputDataReceived>事件。 事件处理程序接收来自的重定向的文本行<xref:System.Diagnostics.Process.StandardOutput%2A>流，格式文本，并将文本写入屏幕。  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 属性为 <see langword="false" />。  
  
 \- 或 -  
  
 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流上已在进行异步读取操作。  
  
 \- 或 -  
  
 同步读取操作已使用 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取消在应用程序的重定向 <see cref="P:System.Diagnostics.Process.StandardError" /> 流上执行的异步读取操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 启动异步读取操作<xref:System.Diagnostics.Process.StandardError%2A>流。 <xref:System.Diagnostics.Process.CancelErrorRead%2A> 结束异步读取操作。  
  
 取消之后，您可以通过来继续异步读取的操作调用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>试。  
  
 当调用<xref:System.Diagnostics.Process.CancelErrorRead%2A>，所有正在进行读取操作<xref:System.Diagnostics.Process.StandardError%2A>完成和事件处理程序，则会禁用。 所有进一步重定向到输出<xref:System.Diagnostics.Process.StandardError%2A>保存在缓冲区中。 如果重新启用事件处理程序通过调用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>，已保存的输出发送到事件处理程序并异步读取的操作恢复。 如果你想要继续执行异步读取的操作之前更改事件处理程序，则必须在添加新的事件处理程序之前删除现有的事件处理程序：  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  不能混合使用异步和同步读取的操作的重定向<xref:System.Diagnostics.Process.StandardError%2A>流。 一次的重定向的流<xref:System.Diagnostics.Process>打开在异步或同步模式下，所有进一步读取该流上的操作必须处于相同的模式。 如果您取消异步，则读取上操作<xref:System.Diagnostics.Process.StandardError%2A>，然后需要从流中读取同样，你必须使用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>继续异步读取的操作。 不要遵循<xref:System.Diagnostics.Process.CancelErrorRead%2A>通过调用同步读取方法<xref:System.Diagnostics.Process.StandardError%2A>如<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，或<xref:System.IO.StreamReader.ReadToEnd%2A>。  
  
   
  
## Examples  
 下面的示例启动`nmake`命令与用户提供自变量。 错误和输出流异步读取被写入;收集的文本行是显示到控制台以及写入日志文件。 如果命令输出超出指定的行数，则会取消异步读取的操作。  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未针对异步读取操作启用 <see cref="P:System.Diagnostics.Process.StandardError" /> 流。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取消在应用程序的重定向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流上执行的异步读取操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 启动异步读取操作<xref:System.Diagnostics.Process.StandardOutput%2A>流。 <xref:System.Diagnostics.Process.CancelOutputRead%2A> 结束异步读取操作。  
  
 取消之后，您可以通过来继续异步读取的操作调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>试。  
  
 当调用<xref:System.Diagnostics.Process.CancelOutputRead%2A>，所有正在进行读取操作<xref:System.Diagnostics.Process.StandardOutput%2A>完成和事件处理程序，则会禁用。 所有进一步重定向到输出<xref:System.Diagnostics.Process.StandardOutput%2A>保存在缓冲区中。 如果重新启用事件处理程序通过调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，已保存的输出发送到事件处理程序并异步读取的操作恢复。 如果你想要继续执行异步读取的操作之前更改事件处理程序，则必须在添加新的事件处理程序之前删除现有的事件处理程序：  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  不能混合使用异步和同步读取的操作的重定向<xref:System.Diagnostics.Process.StandardOutput%2A>流。 一次的重定向的流<xref:System.Diagnostics.Process>打开在异步或同步模式下，所有进一步读取该流上的操作必须处于相同的模式。 如果您取消异步，则读取上操作<xref:System.Diagnostics.Process.StandardOutput%2A>，然后需要从流中读取同样，你必须使用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>继续异步读取的操作。 不要遵循<xref:System.Diagnostics.Process.CancelOutputRead%2A>通过调用同步读取方法<xref:System.Diagnostics.Process.StandardOutput%2A>如<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，或<xref:System.IO.StreamReader.ReadToEnd%2A>。  
  
   
  
## Examples  
 下面的示例启动`nmake`命令与用户提供自变量。 错误和输出流异步读取被写入;收集的文本行是显示到控制台以及写入日志文件。 如果命令输出超出指定的行数，则会取消异步读取的操作。  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未针对异步读取操作启用 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放与此组件关联的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Close%2A>方法会导致进程停止等待退出的等待，如果关闭进程句柄，并清除特定于进程的属性。 <xref:System.Diagnostics.Process.Close%2A> 它们将被从外部引用的情况下，不会关闭标准输出、 输入和错误的读取器和编写器。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Dispose%2A> 方法调用 <xref:System.Diagnostics.Process.Close%2A>。 放置<xref:System.Diagnostics.Process>对象在`using`块释放资源而无需调用<xref:System.Diagnostics.Process.Close%2A>。  
  
   
  
## Examples  
 以下示例启动记事本实例。 然后在 10 秒的最长 2 秒间隔检索关联进程的物理内存的使用量。 该示例检测在进程退出之前经过 10 秒后。 如果它仍在运行在 10 秒后，该示例将关闭进程。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通过向进程的主窗口发送关闭消息来关闭拥有用户界面的进程。</summary>
        <returns>
          如果成功发送了关闭消息，则为 <see langword="true" />；如果关联进程没有主窗口或禁用了主窗口(例如，如果当前显示模式对话框)，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 执行过程时，其消息循环将处于等待状态。 消息循环执行每次操作系统的 Windows 消息发送到进程。 调用<xref:System.Diagnostics.Process.CloseMainWindow%2A>将请求发送到接近主窗口中，其格式正确的应用程序，在关闭子窗口，并撤消应用程序的所有正在运行消息循环。 通过调用退出该进程的请求<xref:System.Diagnostics.Process.CloseMainWindow%2A>不会强制应用程序退出。 应用程序可以请求用户验证之前退出，或它可以拒绝退出。 若要强制应用程序退出，请使用<xref:System.Diagnostics.Process.Kill%2A>方法。 行为<xref:System.Diagnostics.Process.CloseMainWindow%2A>等同于用户关闭应用程序的主窗口中使用系统菜单。 因此，通过关闭主窗口退出该进程的请求不会强制应用程序立即退出。  
  
 该进程编辑的数据或分配给进程的资源可能会丢失如果调用<xref:System.Diagnostics.Process.Kill%2A>。 <xref:System.Diagnostics.Process.Kill%2A> 导致异常的进程终止，并应仅在必要时使用。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 启用过程的有序终止并关闭所有窗口，以使更为可取的接口的应用程序。 如果<xref:System.Diagnostics.Process.CloseMainWindow%2A>失败，你可以使用<xref:System.Diagnostics.Process.Kill%2A>终止进程。 <xref:System.Diagnostics.Process.Kill%2A> 是终止不具有图形界面的进程的唯一方法。  
  
 你可以调用<xref:System.Diagnostics.Process.Kill%2A>和<xref:System.Diagnostics.Process.CloseMainWindow%2A>仅的本地计算机运行的进程。 在退出的远程计算机上，不会导致进程。 仅可以查看在远程计算机上运行的进程的信息。  
  
   
  
## Examples  
 以下示例启动记事本实例。 然后在 10 秒最多两秒为间隔检索关联进程的物理内存的使用量。 该示例检测在进程退出之前经过 10 秒后。 如果它仍在运行在 10 秒后，该示例将关闭进程。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 属性设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <exception cref="T:System.InvalidOperationException">已经退出该进程。  
  
 或  
  
 没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>释放此进程使用的所有资源。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在进程终止时是否应引发 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</summary>
        <value>
          如果关联的进程终止（通过退出或者调用 <see cref="M:System.Diagnostics.Process.Kill" />）时应引发 <see cref="E:System.Diagnostics.Process.Exited" /> 事件，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。 请注意，<see cref="E:System.Diagnostics.Process.Exited" />引发事件即使的值<see cref="P:System.Diagnostics.Process.EnableRaisingEvents" />是<see langword="false" />时在进程退出期间或在用户执行之前<see cref="P:System.Diagnostics.Process.HasExited" />检查。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>属性提供的建议当操作系统已关闭进程时是否应通知该组件。 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>属性用于在异步处理，以通知应用程序进程已退出。 若要强制应用程序同步等待退出事件 （它中断的应用程序处理，直到退出事件发生为止），请使用<xref:System.Diagnostics.Process.WaitForExit%2A>方法。

> [!NOTE]
> 如果你使用 Visual Studio 并双击<xref:System.Diagnostics.Process>组件在项目中，<xref:System.Diagnostics.Process.Exited>自动生成事件委托和事件处理程序。 其他代码集<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>属性`false`。 必须更改此属性设置为`true`对事件处理程序时要执行关联的进程退出。

如果组件的<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>值是`true`，或当<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>是`false`和<xref:System.Diagnostics.Process.HasExited%2A>检查调用由组件，组件可以访问关联的进程，后者仍然的管理信息存储由操作系统。 此类信息包括<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.ExitCode%2A>。

关联的进程退出后，则<xref:System.Diagnostics.Process.Handle%2A>的组件不再指向现有进程资源。 相反，它可以仅用于访问有关的进程资源的操作系统的信息。 操作系统已注意到有尚未通过已发布的已退出进程的句柄<xref:System.Diagnostics.Process>组件，因此它会保留<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.Handle%2A>内存中的信息。

没有监视进程的退出会带来开销。 如果<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>是`true`、<xref:System.Diagnostics.Process.Exited>在关联的进程终止时，将引发事件。 程序<xref:System.Diagnostics.Process.Exited>在该时间运行的事件。

有时，你的应用程序将启动一个进程，但不需要其闭包的通知。 例如，你的应用程序可以启动记事本以允许用户执行文本的编辑，但没有任何进一步利用记事本应用程序。 你可以选择在进程退出，因为它不是与你的应用程序的持续操作时避免通知。 设置<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>到`false`可以节省系统资源。

## Examples  
下面的代码示例创建输出文件的进程。 它将设置<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>属性以使该进程引发<xref:System.Diagnostics.Process.Exited>退出时的事件。 <xref:System.Diagnostics.Process.Exited>事件处理程序会显示进程信息。

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通过启用当前线程的本机属性 <see langword="SeDebugPrivilege" />，将 <see cref="T:System.Diagnostics.Process" /> 组件置于与以特殊模式运行的操作系统进程交互的状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以特殊模式运行某些操作系统进程。 尝试读取的属性或将附加到这些进程不能除非你调用了<xref:System.Diagnostics.Process.EnterDebugMode%2A>组件上。 调用<xref:System.Diagnostics.Process.LeaveDebugMode%2A>不再需要对这些特殊模式运行的进程的访问。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当应用程序写入其重定向 <see cref="P:System.Diagnostics.Process.StandardError" /> 流中时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ErrorDataReceived>事件指示关联的进程已写入其重定向<xref:System.Diagnostics.Process.StandardError%2A>流。  
  
 事件只能在进行异步读取操作上<xref:System.Diagnostics.Process.StandardError%2A>。 若要开始异步读取的操作，必须重定向<xref:System.Diagnostics.Process.StandardError%2A>流<xref:System.Diagnostics.Process>，添加到事件处理程序<xref:System.Diagnostics.Process.ErrorDataReceived>事件，并调用<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>。 此后，<xref:System.Diagnostics.Process.ErrorDataReceived>事件信号进程写入到的重定向行每次<xref:System.Diagnostics.Process.StandardError%2A>流式传输，直到该进程退出，或调用<xref:System.Diagnostics.Process.CancelErrorRead%2A>。  
  
> [!NOTE]
>  正在处理的异步输出应用程序应调用<xref:System.Diagnostics.Process.WaitForExit>方法，以确保已刷新输出缓冲区。 请注意通过使用该指定超时<xref:System.Diagnostics.Process.WaitForExit(System.Int32)>重载未*不*确保已刷新输出缓冲区。
  
   
  
## Examples  
 下面的示例使用`net view`命令以列出在远程计算机上的可用的网络资源。 在用户提供的目标计算机名称作为命令行自变量。 用户还可以提供错误输出的文件名称。 该示例收集的 net 命令、 等待进程完成，然后写入到控制台的输出结果的输出。 如果在用户提供的可选错误文件，该示例会将错误写入文件。  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程终止时指定的值。</summary>
        <value>关联进程终止时指定的代码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.Process.ExitCode%2A>来获取系统过程返回时退出该循环的状态。 您可以使用的退出代码更像一个整数，返回值从`main()`过程。  
  
 <xref:System.Diagnostics.Process.ExitCode%2A>进程反映该进程的应用程序开发人员实现的特定约定的值。 如果你使用的退出代码值在你的代码中进行决策，请确保你知道使用应用程序进程的退出代码约定。  
  
 开发人员通常表明成功退出<xref:System.Diagnostics.Process.ExitCode%2A>值调用的方法可用于确定异常的进程终止原因的非零值零，并且指定的错误。 不需要遵循这些指导原则，但它们约定。  
  
 如果你尝试获取<xref:System.Diagnostics.Process.ExitCode%2A>该进程已退出之前，尝试将引发异常。 检查<xref:System.Diagnostics.Process.HasExited%2A>属性首先以验证是否已终止关联的进程。  
  
> [!NOTE]
>  当已重标准输出定向到异步事件处理程序中时，有可能，输出处理还未完成时<xref:System.Diagnostics.Process.HasExited%2A>返回`true`。 若要确保已完成异步事件处理，调用<xref:System.Diagnostics.Process.WaitForExit>在检查之前不接受任何参数的重载<xref:System.Diagnostics.Process.HasExited%2A>。  
  
 你可以使用<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>方法，使关联的进程退出。  
  
 关联的进程退出时收到通知的两种方式： 同步和异步方式。 同步通知依赖于调用<xref:System.Diagnostics.Process.WaitForExit%2A>方法来暂停应用程序处理，直到退出关联的组件。 异步通知依赖于<xref:System.Diagnostics.Process.Exited>事件。 使用异步通知时<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>必须设置为`true`为<xref:System.Diagnostics.Process>组件可以接收该进程已退出的通知。  
  
   
  
## Examples  
 以下示例启动记事本实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">进程尚未退出。  
  
 或  
  
 进程 <see cref="P:System.Diagnostics.Process.Handle" /> 无效。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.ExitCode" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在进程退出时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Exited>事件指示关联的进程退出。 此事件意味着任一进程终止 （中止） 或已成功关闭。 仅当，可能发生此事件的值<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>属性是`true`。  
  
 关联的进程退出时收到通知的两种方式： 同步和异步方式。 同步通知意味着调用<xref:System.Diagnostics.Process.WaitForExit%2A>方法进行阻止当前线程，直到在进程退出。 异步通知使用<xref:System.Diagnostics.Process.Exited>事件，允许调用线程继续在此期间执行。 在后一种情况下，<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>必须设置为`true`调用应用程序中，若要对 Exited 事件进行接收。  
  
 当操作系统关闭进程时，它将通知所有已注册 Exited 事件的处理其他进程。 在此期间，只需退出进程的句柄可以用于访问某些属性如<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.HasExited%2A>操作系统维护，直到它完全释放该句柄。  
  
> [!NOTE]
>  即使你具有已退出的进程的句柄，不能调用<xref:System.Diagnostics.Process.Start%2A>以重新连接到相同的进程。 调用<xref:System.Diagnostics.Process.Start%2A>自动释放关联的进程并与同一个文件，但为全新连接到进程<xref:System.Diagnostics.Process.Handle%2A>。  
  
 有关使用有关的详细信息<xref:System.Diagnostics.Process.Exited>事件在 Windows 窗体应用程序，请参阅<xref:System.Diagnostics.Process.SynchronizingObject%2A>属性。  
  
   
  
## Examples  
 下面的代码示例创建输出文件的进程。 它会发出<xref:System.Diagnostics.Process.Exited>事件时在进程退出因为<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>时创建的过程已设置属性。 <xref:System.Diagnostics.Process.Exited>事件处理程序会显示进程信息。  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程退出的时间。</summary>
        <value>
          <see cref="T:System.DateTime" />，它指示关联进程终止的时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果未终止过程，尝试检索<xref:System.Diagnostics.Process.ExitTime%2A>属性引发异常。 使用<xref:System.Diagnostics.Process.HasExited%2A>之前获取<xref:System.Diagnostics.Process.ExitTime%2A>属性来确定是否已终止关联的进程。  
  
   
  
## Examples  
 下面的代码示例创建输出文件的进程。 进程引发<xref:System.Diagnostics.Process.Exited>事件时退出，并在事件处理程序显示<xref:System.Diagnostics.Process.ExitTime%2A>属性和其他进程的信息。  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.ExitTime" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取新的 <see cref="T:System.Diagnostics.Process" /> 组件并将其与当前活动的进程关联。</summary>
        <returns>与运行调用应用程序的进程资源关联的新的 <see cref="T:System.Diagnostics.Process" /> 组件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法创建一个新<xref:System.Diagnostics.Process>实例，并将其与本地计算机上的进程资源关联。  
  
 如类似<xref:System.Diagnostics.Process.GetProcessById%2A>， <xref:System.Diagnostics.Process.GetProcessesByName%2A>，和<xref:System.Diagnostics.Process.GetProcesses%2A>方法，<xref:System.Diagnostics.Process.GetCurrentProcess%2A>将现有的资源与新关联<xref:System.Diagnostics.Process>组件。  
  
   
  
## Examples  
 下面的示例检索当前进程的信息在本地计算机，记事本本地计算机和在本地计算机上的特定进程上运行的所有实例上运行的进程。 然后，它将检索远程计算机上的相同的过程信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建新的 <see cref="T:System.Diagnostics.Process" /> 组件，并将其与您指定的现有进程资源关联。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">进程资源的系统唯一标识符。</param>
        <summary>返回新的 <see cref="T:System.Diagnostics.Process" /> 组件(给定本地计算机上某个进程的标识符)。</summary>
        <returns>与 <paramref name="processId" /> 参数标识的本地进程资源关联的 <see cref="T:System.Diagnostics.Process" /> 组件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法创建一个新<xref:System.Diagnostics.Process>组件并将它与本地计算机上的进程资源关联。 进程资源必须已经存在的计算机上，因为<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>不会创建一个系统资源，但而是将资源与应用程序生成相关联<xref:System.Diagnostics.Process>组件。 进程<xref:System.Diagnostics.Process.Id%2A>可以检索仅为当前计算机运行的进程。 在进程终止后，<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>时将其传递一个过期的标识符引发异常。  
  
 任何特定计算机上进程的标识符是唯一的。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 最多返回一个进程。 如果你想要获取运行特定应用程序，使用的所有进程<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。 如果运行指定的应用程序的计算机上存在多个进程<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>返回数组，其中包含所有关联的进程。 你可以查询每个标识符反过来这些进程。 可以在中查看进程标识符`Processes`面板的 Windows 任务管理器。 `PID`列显示分配给进程的进程标识符。  
  
   
  
## Examples  
 下面的示例检索当前进程的信息在本地计算机，记事本本地计算机和在本地计算机上的特定进程上运行的所有实例上运行的进程。 然后，它将检索远程计算机上的相同的过程信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="processId" /> 参数指定的进程未运行。 此标识符可能已过期。</exception>
        <exception cref="T:System.InvalidOperationException">此对象未启动该进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">进程资源的系统唯一标识符。</param>
        <param name="machineName">网络上计算机的名称。</param>
        <summary>返回新的 <see cref="T:System.Diagnostics.Process" /> 组件(给定进程标识符和网络中计算机的名称)。</summary>
        <returns>与 <paramref name="processId" /> 参数标识的远程进程资源关联的 <see cref="T:System.Diagnostics.Process" /> 组件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法创建一个新<xref:System.Diagnostics.Process>组件并将其与网络上的远程计算机上的进程资源关联。 进程资源必须已经存在在指定计算机上，因为<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>不会创建一个系统资源，但而是将资源与应用程序生成相关联<xref:System.Diagnostics.Process>组件。 进程<xref:System.Diagnostics.Process.Id%2A>可以检索仅为当前计算机运行的进程。 在进程终止后，<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>时将其传递一个过期的标识符引发异常。  
  
 任何特定计算机上进程的标识符是唯一的。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 最多返回一个进程。 如果你想要获取运行特定应用程序，使用的所有进程<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>。 如果运行指定的应用程序的计算机上存在多个进程<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>返回数组，其中包含所有关联的进程。 你可以查询每个标识符反过来这些进程。 可以在中查看进程标识符`Processes`面板的 Windows 任务管理器。 `PID`列显示分配给进程的进程标识符。  
  
 如果不指定`machineName`，则使用本地计算机。 或者，你可以通过设置`machineName`为值"。"或为空字符串 ("")。  
  
   
  
## Examples  
 下面的示例检索当前进程的信息在本地计算机，记事本本地计算机和在本地计算机上的特定进程上运行的所有实例上运行的进程。 然后，它将检索远程计算机上的相同的过程信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="processId" /> 参数指定的进程未运行。 此标识符可能已过期。  
  
 或  
  
 <paramref name="machineName" /> 参数的语法无效。 名称的长度可能为零 (0)。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">此对象未启动该进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建新的 <see cref="T:System.Diagnostics.Process" /> 组件的数组，并将它们与现有进程资源关联。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为本地计算机上的每个进程资源创建一个新的 <see cref="T:System.Diagnostics.Process" /> 组件。</summary>
        <returns>类型 <see cref="T:System.Diagnostics.Process" /> 的数组，表示本地计算机上运行的所有进程资源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于创建新的数组<xref:System.Diagnostics.Process>组件并将它们与本地计算机上的所有进程资源关联。 进程资源必须已经存在的本地计算机上，因为<xref:System.Diagnostics.Process.GetProcesses%2A>不会创建系统资源，但而是将资源与应用程序生成相关联<xref:System.Diagnostics.Process>组件。 因为操作系统本身正在运行的后台进程，此数组不为空。  
  
 如果您不想要检索所有计算机上运行的进程，你可以通过使用来限制它们的数量<xref:System.Diagnostics.Process.GetProcessById%2A>或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。 <xref:System.Diagnostics.Process.GetProcessById%2A> 创建<xref:System.Diagnostics.Process>与由传递给该方法的进程标识符标识系统上的进程关联的组件。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 创建的数组<xref:System.Diagnostics.Process>其关联的进程资源共享的可执行文件的组件你传递给方法。  
  
> [!NOTE]
>  可以在服务主机进程 (svchost.exe) 的同一个实例中加载多个 Windows 服务。 GetProcesses 不会确定这些单个服务; 示例：为此，请参阅<xref:System.ServiceProcess.ServiceController.GetServices%2A>。  
  
   
  
## Examples  
 下面的示例检索当前进程的信息在本地计算机，记事本本地计算机和在本地计算机上的特定进程上运行的所有实例上运行的进程。 然后，它将检索远程计算机上的相同的过程信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">从其中读取进程列表的计算机。</param>
        <summary>为指定计算机上的每个进程资源创建一个新的 <see cref="T:System.Diagnostics.Process" /> 组件。</summary>
        <returns>类型 <see cref="T:System.Diagnostics.Process" /> 的数组，表示指定计算机上运行的所有进程资源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于创建新的数组<xref:System.Diagnostics.Process>组件并将其与指定 （通常为远程） 的计算机上的所有进程资源关联。 进程资源必须已经存在的本地计算机上，因为<xref:System.Diagnostics.Process.GetProcesses%2A>不会创建系统资源，但而是将资源与应用程序生成相关联<xref:System.Diagnostics.Process>组件。 因为操作系统本身正在运行的后台进程，此数组不为空。  
  
 如果您不想要检索所有计算机上运行的进程，你可以通过使用来限制它们的数量<xref:System.Diagnostics.Process.GetProcessById%2A>或<xref:System.Diagnostics.Process.GetProcessesByName%2A>方法。 <xref:System.Diagnostics.Process.GetProcessById%2A> 创建<xref:System.Diagnostics.Process>与由传递给该方法的进程标识符标识系统上的进程关联的组件。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 创建的数组<xref:System.Diagnostics.Process>其关联的进程资源共享的可执行文件的组件你传递给方法。  
  
 此重载<xref:System.Diagnostics.Process.GetProcesses%2A>方法通常用于检索在网络上的远程计算机上运行的进程资源的列表，但你可以通过传递指定本地计算机"。"。  
  
> [!NOTE]
>  可以在服务主机进程 (svchost.exe) 的同一个实例中加载多个 Windows 服务。 GetProcesses 不会确定这些单个服务; 示例：为此，请参阅<xref:System.ServiceProcess.ServiceController.GetServices%2A>。  
  
   
  
## Examples  
 下面的示例检索当前进程的信息在本地计算机，记事本本地计算机和在本地计算机上的特定进程上运行的所有实例上运行的进程。 然后，它将检索远程计算机上的相同的过程信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 参数的语法无效。 其长度可能为零 (0)。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">操作系统平台不支持在远程计算机上进行此操作。</exception>
        <exception cref="T:System.InvalidOperationException">访问用于获取进程信息的性能计数器 API 时出现问题。 此异常特定于 Windows NT、Windows 2000 和 Windows XP。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">访问基础系统 API 时出现问题。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建新的 <see cref="T:System.Diagnostics.Process" /> 组件的数组，并将它们与共享指定的进程名称的所有现有进程资源关联。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">该进程的友好名称。</param>
        <summary>创建新的 <see cref="T:System.Diagnostics.Process" /> 组件的数组，并将它们与本地计算机上共享指定的进程名称的所有进程资源关联。</summary>
        <returns>类型 <see cref="T:System.Diagnostics.Process" /> 的数组，表示运行指定应用程序或文件的进程资源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于创建新的数组<xref:System.Diagnostics.Process>组件并将它们与正在本地计算机上的相同可执行文件的所有进程资源关联。 进程资源必须已经存在的计算机上，因为<xref:System.Diagnostics.Process.GetProcessesByName%2A>不会创建系统资源，但而是将它们与应用程序生成关联<xref:System.Diagnostics.Process>组件。 A`processName`可为指定当前未运行的本地计算机，因此该方法返回的数组可以是空的可执行文件。  
  
 进程名称是为了让进程，如 Outlook，不包含扩展名为.exe 或路径的友好名称。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 可帮助获取和操作与相同的可执行文件相关联的所有进程。 例如，可以传递作为可执行文件名`processName`参数，以便关闭该可执行文件的所有正在运行的实例。  
  
 尽管进程<xref:System.Diagnostics.Process.Id%2A>是唯一的系统上的单个进程资源，本地计算机上的多个进程可以运行指定的应用程序`processName`参数。 因此， <xref:System.Diagnostics.Process.GetProcessById%2A> ，最多返回一个进程但<xref:System.Diagnostics.Process.GetProcessesByName%2A>返回数组，其中包含所有关联的进程。 如果你需要操作使用标准的 API 调用的进程，可以查询每个标识符反过来这些进程。 无法访问进程资源，通过单独的进程名称中，但一旦检索到的数组<xref:System.Diagnostics.Process>已相关联的组件与进程资源，你可以启动、 终止和以其他方式操作的系统资源。  
  
   
  
## Examples  
 下面的示例检索当前进程的信息在本地计算机，记事本本地计算机和在本地计算机上的特定进程上运行的所有实例上运行的进程。 然后，它将检索远程计算机上的相同的过程信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">访问用于获取进程信息的性能计数器 API 时出现问题。 此异常特定于 Windows NT、Windows 2000 和 Windows XP。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">该进程的友好名称。</param>
        <param name="machineName">网络上计算机的名称。</param>
        <summary>创建新的 <see cref="T:System.Diagnostics.Process" /> 组件的数组，并将它们与远程计算机上共享指定进程名称的所有进程资源关联。</summary>
        <returns>类型 <see cref="T:System.Diagnostics.Process" /> 的数组，表示运行指定应用程序或文件的进程资源。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于创建新的数组<xref:System.Diagnostics.Process>组件并将它们与正在运行指定的计算机上的相同可执行文件的所有进程资源关联。 进程资源必须已经存在的计算机上，因为<xref:System.Diagnostics.Process.GetProcessesByName%2A>不会创建系统资源，但而是将它们与应用程序生成关联<xref:System.Diagnostics.Process>组件。 A`processName`可为指定当前未运行的本地计算机，因此该方法返回的数组可以是空的可执行文件。  
  
 进程名称是为了让进程，如 Outlook，不包含扩展名为.exe 或路径的友好名称。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 可帮助获取和操作与相同的可执行文件相关联的所有进程。 例如，可以传递作为可执行文件名`processName`参数，以便关闭该可执行文件的所有正在运行的实例。  
  
 尽管进程<xref:System.Diagnostics.Process.Id%2A>是唯一的系统上的单个进程资源，本地计算机上的多个进程可以运行指定的应用程序`processName`参数。 因此， <xref:System.Diagnostics.Process.GetProcessById%2A> ，最多返回一个进程但<xref:System.Diagnostics.Process.GetProcessesByName%2A>返回数组，其中包含所有关联的进程。 如果你需要操作使用标准的 API 调用的进程，可以查询每个标识符反过来这些进程。 无法访问进程资源，通过单独的进程名称中，但一旦检索到的数组<xref:System.Diagnostics.Process>已相关联的组件与进程资源，你可以启动、 终止和以其他方式操作的系统资源。  
  
 此重载可用于在本地计算机上以及在远程计算机获取进程。 使用"。"若要指定本地计算机。 存在另一个重载，默认情况下使用本地计算机。  
  
 你可以访问仅以查看有关进程的信息，统计信息，如的远程计算机上的进程。 无法关闭，终止 (使用<xref:System.Diagnostics.Process.Kill%2A>)，或在远程计算机上启动进程。  
  
   
  
## Examples  
 下面的示例检索当前进程的信息在本地计算机，记事本本地计算机和在本地计算机上的特定进程上运行的所有实例上运行的进程。 然后，它将检索远程计算机上的相同的过程信息。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 参数的语法无效。 其长度可能为零 (0)。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="machineName" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.PlatformNotSupportedException">操作系统平台不支持在远程计算机上进行此操作。</exception>
        <exception cref="T:System.InvalidOperationException">访问用于获取进程信息的性能计数器 API 时出现问题。 此异常特定于 Windows NT、Windows 2000 和 Windows XP。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">访问基础系统 API 时出现问题。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">调用非托管的代码。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的本机句柄。</summary>
        <value>进程启动时操作系统向关联进程分配的句柄。 系统使用此句柄来跟踪过程属性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序可以获得到的进程，可以使用作为参数传递给许多进程信息和控制功能的句柄。 你可以使用此句柄初始化<xref:System.Threading.WaitHandle>或调用与平台的本机方法调用。  
  
 此进程句柄是私有的某个应用程序，换而言之，句柄不能共享的过程。 进程也有过程<xref:System.Diagnostics.Process.Id%2A>这与<xref:System.Diagnostics.Process.Handle%2A>，是唯一的因此，在整个系统有效。  
  
 通过调用启动仅进程<xref:System.Diagnostics.Process.Start%2A>设置<xref:System.Diagnostics.Process.Handle%2A>的相应属性<xref:System.Diagnostics.Process>实例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">该进程尚未启动或已退出。 不能读取 <see cref="P:System.Diagnostics.Process.Handle" /> 属性，因为没有与此 <see cref="T:System.Diagnostics.Process" /> 实例关联的进程。  
  
 或  
  
 <see cref="T:System.Diagnostics.Process" /> 实例已附加到正在运行的进程，但您没有获取具有完全访问权限的句柄所需的权限。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.Handle" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取由进程打开的句柄数。</summary>
        <value>进程打开的操作系统句柄数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 句柄提供使进程可以引用的对象的方法。 进程可以获取指向文件、 资源、 消息队列和许多其他操作系统对象的句柄。 操作系统回收仅当句柄计数为零时，才与进程关联的内存。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 属性设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示关联进程是否已终止的值。</summary>
        <value>
          如果 <see cref="T:System.Diagnostics.Process" /> 组件引用的操作系统进程已终止，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值为`true`为<xref:System.Diagnostics.Process.HasExited%2A>指示关联的进程已终止，正常或异常。 可以请求，也可以强制关联的进程退出通过调用<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 如果到进程打开的句柄，操作系统将释放的进程内存时进程已退出，但会保留有关过程，如句柄、 退出代码和退出时的管理信息。 若要获取此信息，可以使用<xref:System.Diagnostics.Process.ExitCode%2A>和<xref:System.Diagnostics.Process.ExitTime%2A>属性。 这些属性将自动填充此组件已启动的进程。 发布的管理信息时所有<xref:System.Diagnostics.Process>与系统进程关联的组件将销毁，并没有更多的句柄保留至已退出进程。  
  
 独立于你的代码可以终止进程。 如果你在开始使用此组件的过程，系统将更新的值<xref:System.Diagnostics.Process.HasExited%2A>自动，即使独立关联的进程退出。  
  
> [!NOTE]
>  当已重标准输出定向到异步事件处理程序中时，有可能时此属性返回不具有完成输出处理`true`。 若要确保已完成异步事件处理，调用<xref:System.Diagnostics.Process.WaitForExit>在检查之前不接受任何参数的重载<xref:System.Diagnostics.Process.HasExited%2A>。  
  
   
  
## Examples  
 以下示例启动记事本实例。 然后在 10 秒最多两秒为间隔检索关联进程的物理内存的使用量。 该示例检测在进程退出之前经过 10 秒后。 如果它仍在运行在 10 秒后，该示例将关闭进程。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">没有与此对象关联的进程。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">无法检索该进程的退出代码。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的唯一标识符。</summary>
        <value>此 <see cref="T:System.Diagnostics.Process" /> 实例引用的、由系统生成的进程的唯一标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程<xref:System.Diagnostics.Process.Id%2A>不是有效如果关联的进程未运行。 因此，您应确保在尝试检索之前正在运行进程<xref:System.Diagnostics.Process.Id%2A>属性。 在进程终止，直到进程标识符唯一地标识在整个系统的过程。  
  
 你可以连接到新的本地或远程计算机运行的进程<xref:System.Diagnostics.Process>实例通过将传递到的进程标识符<xref:System.Diagnostics.Process.GetProcessById%2A>方法。 <xref:System.Diagnostics.Process.GetProcessById%2A> 是`static`创建一个新的组件的方法和设置<xref:System.Diagnostics.Process.Id%2A>新属性<xref:System.Diagnostics.Process>自动实例。  
  
 可以由系统重用进程标识符。 <xref:System.Diagnostics.Process.Id%2A>属性值是唯一的仅在关联的进程正在运行时。 进程已终止后，系统可以重复使用<xref:System.Diagnostics.Process.Id%2A>不相关的进程的属性值。  
  
 因为该标识符是唯一系统上，你可以将其传递给其他线程作为传递的替代方法<xref:System.Diagnostics.Process>实例。 此操作可以节省系统资源，又可保证正确标识进程。  
  
   
  
## Examples  
 下面的示例演示如何获取<xref:System.Diagnostics.Process.Id%2A>所有运行的应用程序实例。 代码创建记事本的新实例，将列出的记事本的所有实例，然后允许用户输入<xref:System.Diagnostics.Process.Id%2A>编号，以删除特定的实例。  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未设置此进程的 <see cref="P:System.Diagnostics.Process.Id" /> 属性。  
  
 或  
  
 没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 属性设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>立即停止关联的进程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> 强制终止的进程，而<xref:System.Diagnostics.Process.CloseMainWindow%2A>只请求在终止。 具有图形界面的进程执行时，其消息循环将处于等待状态。 消息循环执行每次操作系统的 Windows 消息发送到进程。 调用<xref:System.Diagnostics.Process.CloseMainWindow%2A>将请求发送到接近主窗口中，其格式正确的应用程序，在关闭子窗口，并撤消应用程序的所有正在运行消息循环。 通过调用退出该进程的请求<xref:System.Diagnostics.Process.CloseMainWindow%2A>不会强制应用程序退出。 应用程序可以请求用户验证之前退出，或它可以拒绝退出。 若要强制应用程序退出，请使用<xref:System.Diagnostics.Process.Kill%2A>方法。 行为<xref:System.Diagnostics.Process.CloseMainWindow%2A>等同于用户关闭应用程序的主窗口中使用系统菜单。 因此，通过关闭主窗口退出该进程的请求不会强制应用程序立即退出。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Kill%2A>方法以异步方式执行。 在调用<xref:System.Diagnostics.Process.Kill%2A>方法中，调用<xref:System.Diagnostics.Process.WaitForExit%2A>方法来等待进程退出，或检查<xref:System.Diagnostics.Process.HasExited%2A>属性来确定该进程已退出。  
  
 该进程编辑的数据或分配给进程的资源可能会丢失如果调用<xref:System.Diagnostics.Process.Kill%2A>。 <xref:System.Diagnostics.Process.Kill%2A> 导致异常的进程终止，应仅在必要时使用。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> 启用过程的有序终止并关闭所有窗口，以使更为可取的接口的应用程序。 如果<xref:System.Diagnostics.Process.CloseMainWindow%2A>失败，你可以使用<xref:System.Diagnostics.Process.Kill%2A>终止进程。 <xref:System.Diagnostics.Process.Kill%2A> 是终止不具有图形界面的进程的唯一方法。  
  
 你可以调用<xref:System.Diagnostics.Process.Kill%2A>和<xref:System.Diagnostics.Process.CloseMainWindow%2A>仅的本地计算机运行的进程。 在退出的远程计算机上，不会导致进程。 仅可以查看在远程计算机上运行的进程的信息。  
  
> [!NOTE]
>  如果调用<xref:System.Diagnostics.Process.Kill%2A>方法由时当前在终止进程，<xref:System.ComponentModel.Win32Exception>引发因访问被拒绝。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">无法终止相关联的进程。  
  
 或  
  
 进程将终止。  
  
 或  
  
 关联的进程是 Win16 可执行文件。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试为远程计算机上运行的进程调用 <see cref="M:System.Diagnostics.Process.Kill" />。 该方法仅对本地计算机上运行的进程可用。</exception>
        <exception cref="T:System.InvalidOperationException">已经退出该进程。  
  
 或  
  
 没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使 <see cref="T:System.Diagnostics.Process" /> 组件离开允许它与以特殊模式运行的操作系统进程交互的状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以特殊模式运行某些操作系统进程。 尝试读取的属性或将附加到这些进程不能除非你调用了<xref:System.Diagnostics.Process.EnterDebugMode%2A>组件上。 调用<xref:System.Diagnostics.Process.LeaveDebugMode%2A>不再需要对这些特殊模式运行的进程的访问。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程正在其上运行的计算机的名称。</summary>
        <value>关联进程正在其上运行的计算机的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以查看统计数据，并在远程计算机上，但是你运行的进程的进程信息不能调用<xref:System.Diagnostics.Process.Start%2A>， <xref:System.Diagnostics.Process.CloseMainWindow%2A>，或<xref:System.Diagnostics.Process.Kill%2A>在远程计算机上。  
  
> [!NOTE]
>  此属性关联的进程执行时在本地计算机上，返回一个句点 ("。") 为计算机名称。 应使用<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>属性获取正确的计算机名称。  
  
   
  
## Examples  
 若要使用下面的示例，你必须先在远程计算机上启动记事本的至少一个实例。 该示例请求的远程计算机记事本正在运行，且然后分别显示名称<xref:System.Diagnostics.Process.ProcessName%2A>， <xref:System.Diagnostics.Process.Id%2A>，和<xref:System.Diagnostics.Process.MachineName%2A>每个实例的属性。  
  
 [!code-cpp[process_GetProcessesByName2_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CPP/process_getprocessesbyname2_2.cpp#2)]
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的主模块。</summary>
        <value>用于启动进程的 <see cref="T:System.Diagnostics.ProcessModule" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程模块表示加载到特定的进程的.dll 或.exe 文件。 <xref:System.Diagnostics.Process.MainModule%2A>属性允许你查看有关用于启动进程，包括模块名称、 文件名和模块内存详细信息的可执行文件的信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MainModule" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">32 位进程正尝试访问 64 位进程的模块。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。  
  
 或  
  
 该进程已退出。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程主窗口的窗口句柄。</summary>
        <value>关联进程主窗口的系统生成的窗口句柄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 主窗口是由当前具有焦点的进程打开的窗口 (<xref:System.Windows.Forms.Form.TopLevel%2A>窗体)。 必须使用<xref:System.Diagnostics.Process.Refresh%2A>方法来刷新<xref:System.Diagnostics.Process>要获取当前的主窗口句柄，如果它已更改对象。 一般情况下，因为缓存的窗口句柄，则使用<xref:System.Diagnostics.Process.Refresh%2A>事先若要确保你将检索当前句柄。  
  
 你可以获取<xref:System.Diagnostics.Process.MainWindowHandle%2A>仅的本地计算机运行的进程的属性。 <xref:System.Diagnostics.Process.MainWindowHandle%2A>属性是用于唯一标识与进程相关联的窗口的值。  
  
 一个进程有一个仅当该过程提供一个图形界面与之关联的主窗口。 如果关联的进程没有主窗口中，<xref:System.Diagnostics.Process.MainWindowHandle%2A>值为零。 值也是对于进程已被隐藏，则为零，即处理，在任务栏中不可见。 这可能会在通知区域中，在任务栏最右侧显示为图标的进程的情况。  
  
 如果你刚刚启动了一个进程，并想要使用其主窗口句柄，请考虑使用<xref:System.Diagnostics.Process.WaitForInputIdle%2A>方法以允许该进程完成后从开始，确保已创建了主窗口句柄。 否则，将引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未定义 <see cref="P:System.Diagnostics.Process.MainWindowHandle" />，因为进程已退出。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取进程的主窗口标题。</summary>
        <value>进程的主窗口标题。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个进程有一个仅当该过程提供一个图形界面与之关联的主窗口。 如果关联的进程没有主窗口 (以便<xref:System.Diagnostics.Process.MainWindowHandle%2A>为零)，<xref:System.Diagnostics.Process.MainWindowTitle%2A>为空字符串 ("")。 如果你刚刚启动了一个进程，并想要使用其主窗口标题，请考虑使用<xref:System.Diagnostics.Process.WaitForInputIdle%2A>方法以允许该进程完成后从开始，确保已创建了主窗口句柄。 否则，系统将引发异常。  
  
> [!NOTE]
>  主窗口是当前具有焦点，则窗口请注意，这可能不是进程的主窗口。 必须使用<xref:System.Diagnostics.Process.Refresh%2A>方法来刷新<xref:System.Diagnostics.Process>要获取当前的主窗口句柄，如果它已更改对象。  
  
   
  
## Examples  
 下面的示例启动记事本实例，并检索进程主窗口的标题。  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未定义 <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 属性，因为进程已退出。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置关联进程允许的最大工作集大小（以字节为单位）。</summary>
        <value>内存中允许的进程的最大工作集大小(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程工作集是物理 RAM 内存中的当前可见的进程的内存页的集合。 这些页面为常驻性并且可用于应用程序使用而不会触发页面错误。  
  
 工作集包括共享和私有数据。 共享的数据包括包含应用程序的执行，包括页面.dll 文件和 system.dll 文件中的所有说明的页。 随着工作集大小的增加，则会增加内存需求。  
  
 进程都有最小和最大工作集大小。 每次创建一个进程资源时，系统都会保留等于最小工作集大小的进程的内存量。 虚拟内存管理器尝试保持至少最小内存量常驻进程处于活动状态，但决不会保留的最大大小超过时。  
  
 系统设置的默认工作集大小。 你可以修改使用这些大小<xref:System.Diagnostics.Process.MaxWorkingSet%2A>和<xref:System.Diagnostics.Process.MinWorkingSet%2A>成员。 但是，设置这些值不保证内存将保留或驻留。  
  
> [!NOTE]
>  如果增加进程工作集大小，你需要从系统的其余部分的物理内存。 确保你不会请求是太大，因为这样做会降低系统性能最小值或最大工作集大小。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">最大的工作集大小无效。 它必须大于或等于最小的工作集大小。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">无法从关联的进程资源中检索工作集信息。  
  
 或  
  
 进程标识符或进程句柄为零，因为尚未启动该进程。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。  
  
 或  
  
 该进程已退出。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置关联进程允许的最小工作集大小（以字节为单位）。</summary>
        <value>内存中进程所需的最小工作集大小(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程工作集是物理 RAM 内存中的当前可见的进程的内存页的集合。 这些页面为常驻性并且可用于应用程序使用而不会触发页面错误。  
  
 工作集包括共享和私有数据。 共享的数据包括包含应用程序的执行，包括页面.dll 文件和 system.dll 文件中的所有说明的页。 随着工作集大小的增加，则会增加内存需求。  
  
 进程都有最小和最大工作集大小。 每次创建一个进程资源时，系统都会保留等于最小工作集大小的进程的内存量。 虚拟内存管理器尝试保持至少最小内存量常驻进程处于活动状态，但决不会保留的最大大小超过时。  
  
 系统设置的默认工作集大小。 你可以修改使用这些大小<xref:System.Diagnostics.Process.MaxWorkingSet%2A>和<xref:System.Diagnostics.Process.MinWorkingSet%2A>成员。 但是，设置这些值不保证内存将保留或驻留。  
  
> [!NOTE]
>  如果增加进程工作集大小，你需要从系统的其余部分的物理内存。 确保你不会请求是太大，因为这样做会降低系统性能最小值或最大工作集大小。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">最小工作集大小无效。 它必须小于或等于最大工作集大小。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">无法从关联的进程资源中检索工作集信息。  
  
 或  
  
 进程标识符或进程句柄为零，因为尚未启动该进程。</exception>
        <exception cref="T:System.NotSupportedException">你正尝试访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。  
  
 或  
  
 该进程已退出。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已由关联进程加载的模块。</summary>
        <value>类型 <see cref="T:System.Diagnostics.ProcessModule" /> 的数组，表示已由关联进程加载的模块。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程模块表示加载到特定的进程的.dll 或.exe 文件。 A<xref:System.Diagnostics.ProcessModule>实例，您可以查看有关模块，包括模块名称、 文件名和模块内存详细信息的信息。  
  
 一个进程可以加载到内存中的多个模块。 例如，加载其他.dll 文件的.exe 文件具有多个模块。  
  
 之后启动该进程，此集合为空直到系统加载该进程。 如果进程都有一个主窗口，则可以调用<xref:System.Diagnostics.Process.WaitForInputIdle%2A>之前检索此属性，以确保集合非空时你可以获取的列表。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.Modules" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">您尝试访问系统进程或 Idle 进程的 <see cref="P:System.Diagnostics.Process.Modules" /> 属性。 这些进程没有模块。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的非分页系统内存量（以字节为单位）。</summary>
        <value>系统已为无法写入到虚拟内存分页文件的关联进程分配的内存量(以字节为单位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的非分页系统内存量（以字节为单位）。</summary>
        <value>为关联的进程分配的、不能写入虚拟内存分页文件中的系统内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值表示使用的过程中，以字节为单位的非分页的系统内存的当前大小。 系统内存是由操作系统的物理内存，并且分为分页和非页面缓冲池。 非分页的内存分配保留在系统内存，并且不会调出到虚拟内存分页文件。  
  
 此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。 属性值等于**池非分页字节数**进程的性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的一个实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示其退出代码，峰值内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>引发 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> 是引发的 API 方法<xref:System.Diagnostics.Process.Exited>事件。 调用<xref:System.Diagnostics.Process.OnExited%2A>导致<xref:System.Diagnostics.Process.Exited>事件发生，是唯一的方法来引发事件使用<xref:System.Diagnostics.Process>组件。 <xref:System.Diagnostics.Process.OnExited%2A> 主要用于从组件派生类时。  
  
 作为替代方法<xref:System.Diagnostics.Process.OnExited%2A>，你可以编写事件处理程序。 创建你自己的事件处理程序委托和事件处理方法。  
  
> [!NOTE]
>  如果你正在使用 Visual Studio 环境，一个事件处理程序委托 (AddOnExited) 和一个事件处理方法 (Process1_Exited) 会为您创建在拖动时<xref:System.Diagnostics.Process>组件拖动到窗体并双击该图标。 创建时要运行代码<xref:System.Diagnostics.Process.Exited>进入 Process1_Exited 过程发生的事件。 不需要创建<xref:System.Diagnostics.Process.OnExited%2A>成员，因为它已为您实现。  
  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Diagnostics.Process.OnExited%2A>派生类中的方法。  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>每次应用程序向其重定向 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流中写入行时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OutputDataReceived>事件指示关联<xref:System.Diagnostics.Process>编写一条线路，以换行符，向其重定向终止<xref:System.Diagnostics.Process.StandardOutput%2A>流。  
  
 该事件在异步读取操作期间启用上<xref:System.Diagnostics.Process.StandardOutput%2A>。 若要开始异步读取的操作，必须重定向<xref:System.Diagnostics.Process.StandardOutput%2A>流<xref:System.Diagnostics.Process>，添加到事件处理程序<xref:System.Diagnostics.Process.OutputDataReceived>事件，并调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>。 此后，<xref:System.Diagnostics.Process.OutputDataReceived>事件信号进程写入到的重定向行每次<xref:System.Diagnostics.Process.StandardOutput%2A>流式传输，直到该进程退出，或调用<xref:System.Diagnostics.Process.CancelOutputRead%2A>。  
  
> [!NOTE]
>  正在处理的异步输出应用程序应调用<xref:System.Diagnostics.Process.WaitForExit%2A>方法，以确保已刷新输出缓冲区。  
  
   
  
## Examples  
 下面的示例演示如何执行上的重定向的异步读取的操作<xref:System.Diagnostics.Process.StandardOutput%2A>流`ipconfig`命令。  
  
 该示例创建一个事件委托，它为`OutputHandler`事件处理程序并将其与关联<xref:System.Diagnostics.Process.OutputDataReceived>事件。 事件处理程序接收来自的重定向的文本行<xref:System.Diagnostics.Process.StandardOutput%2A>流，格式文本，并将其保存在更高版本显示在本示例的控制台窗口的输出字符串中。  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的分页内存量（以字节为单位）。</summary>
        <value>由可写入到虚拟内存分页文件的关联进程分配的内存量(以字节为单位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的分页内存量（以字节为单位）。</summary>
        <value>在虚拟内存分页文件中为关联进程分配的内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值表示内存中使用的过程，以字节为单位的虚拟内存分页文件的当前大小。 操作系统使用与物理内存结合使用的虚拟内存分页文件来管理每个进程的虚拟地址空间。 分页的内存不使用时，它可以被传输到磁盘上的虚拟内存分页文件。 若要获取由操作系统使用的进程的内存大小，使用<xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>属性。  
  
 此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。 属性值等于**页面文件字节**进程的性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动一个实例记事本应用程序，然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示其退出代码，峰值内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联进程分配的可分页系统内存量（以字节为单位）。</summary>
        <value>系统已为可写入到虚拟内存页面文件的关联进程分配的内存量(以字节为单位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联进程分配的可分页系统内存量（以字节为单位）。</summary>
        <value>为可写入虚拟内存分页文件的关联内存分配的系统内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值的值表示使用的过程中，以字节为单位的可分页系统内存的当前大小。 系统内存是由操作系统的物理内存，并且分为分页和非页面缓冲池。 分页的内存不使用时，它可以被传输到磁盘上的虚拟内存分页文件。 若要获取的进程使用的应用程序内存的大小，使用<xref:System.Diagnostics.Process.PagedMemorySize64%2A>属性。  
  
 此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。 属性值等于**Pool Paged Bytes**进程的性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的一个实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示其退出代码，峰值内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联的进程使用的虚拟内存分页文件中的最大内存量（以字节为单位）。</summary>
        <value>由可写入到虚拟内存分页文件的关联进程分配的最大内存量(以字节为单位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联的进程使用的虚拟内存分页文件中的最大内存量（以字节为单位）。</summary>
        <value>从启动关联的进程以来在为虚拟内存分页文件中关联进程分配的最大内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值的值表示自启动，以字节为单位的进程使用的虚拟内存分页文件中的内存的最大大小。 操作系统使用与物理内存结合使用的虚拟内存分页文件来管理每个进程的虚拟地址空间。 分页的内存不使用时，它可以被传输到磁盘上的虚拟内存分页文件。  
  
 此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。 属性值等于**页面文件字节峰值**进程的性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的一个实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示其退出代码，峰值内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程使用的最大虚拟内存量（以字节为单位）。</summary>
        <value>关联进程请求的最大虚拟内存量(以字节为单位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程使用的最大虚拟内存量（以字节为单位）。</summary>
        <value>从关联进程启动以来为关联进程分配的最大虚拟内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值表示自启动，以字节为单位的进程使用的虚拟内存的最大大小。 操作系统将映射到页加载在物理内存中，或存储在磁盘上的虚拟内存分页文件的页面的每个进程的虚拟地址空间。  
  
 此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。 属性值等于**虚拟字节峰值**进程的性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的一个实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示其退出代码，峰值内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的峰值工作集大小（以字节为单位）。</summary>
        <value>关联进程一次所需的最大物理内存量（以字节为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程工作集是物理 RAM 内存中的当前可见的进程的内存页的集合。 这些页面为常驻性并且可用于应用程序使用而不会触发页面错误。  
  
 工作集包括共享和私有数据。 共享的数据包括那些包含该进程执行，包括进程模块和系统库的所有说明的页。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程使用的最大物理内存量（以字节为单位）。</summary>
        <value>从启动关联进程以来为关联进程分配的最大物理内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值表示工作集内存进程使用的自启动，以字节为单位的最大的大小。 进程工作集是物理 RAM 内存中的当前可见的进程的内存页的集合。 这些页面为常驻性并且可用于应用程序使用而不会触发页面错误。  
  
 工作集包括共享和私有数据。 共享的数据包括那些包含该进程执行，包括从进程模块和系统库的说明的所有说明的页。  
  
 此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。 属性值等于**工作集峰值**进程的性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的一个实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示其退出代码，峰值内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示主窗口拥有焦点时是否应由操作系统暂时提升关联进程优先级。</summary>
        <value>
          如果进程离开等待状态时应动态提升进程优先级别，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 线程在进程中对其优先级类具有动态优先级枚举值之一的运行时 (<xref:System.Diagnostics.ProcessPriorityClass.Normal>， <xref:System.Diagnostics.ProcessPriorityClass.High>，或<xref:System.Diagnostics.ProcessPriorityClass.RealTime>)，在它离开等待状态时系统便暂时提升的线程的优先级。 此操作可防止其他进程中断当前线程的处理。 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>设置将影响所有现有的线程以及进程随后创建的任何线程。 若要还原正常的行为，请设置<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>属性`false`。  
  
> [!NOTE]
>  提升过高的优先级会耗尽基本操作系统和网络功能，导致与其他操作系统任务的问题的资源。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">未能从关联的进程资源检索到优先级提升信息。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。  
  
 或  
  
 进程标识符或进程句柄为零。 （进程尚未启动。）</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置关联进程的总体优先级类别。</summary>
        <value>关联进程的优先级类别，可从该类别计算进程的 <see cref="P:System.Diagnostics.Process.BasePriority" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 进程优先级类包含一系列线程优先级级别。 具有不同优先级的正在运行相对于进程的优先级类进程中运行的线程。 Win32 了七个基本优先级级别，每个类使用四个优先级类。 这些进程优先级类将在<xref:System.Diagnostics.ProcessPriorityClass>枚举，这样就可以将进程优先级设置为<xref:System.Diagnostics.ProcessPriorityClass.Idle>， <xref:System.Diagnostics.ProcessPriorityClass.Normal>， <xref:System.Diagnostics.ProcessPriorityClass.High>， <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>， <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>，或<xref:System.Diagnostics.ProcessPriorityClass.RealTime>。 基于的时间的进程需要其他出于放访问到处理器时，可以由操作系统已更改的运行时间或其他提升，基本优先级别。 此外，你可以设置<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>以暂时提升离开等待状态的线程的优先级。 当过程返回到等待状态时，将重置优先级。  
  
 <xref:System.Diagnostics.Process.BasePriority%2A>属性，可以查看分配给过程的起始优先级。 但是，因为它是只读的不能使用<xref:System.Diagnostics.Process.BasePriority%2A>属性来设置进程的优先级。 若要更改的优先级，使用<xref:System.Diagnostics.Process.PriorityClass%2A>属性，用于获取或设置进程的总体优先级类别。  
  
 不能使用系统监视器查看优先级类。 下表显示之间的关系<xref:System.Diagnostics.Process.BasePriority%2A>和<xref:System.Diagnostics.Process.PriorityClass%2A>值。  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 以下示例启动记事本实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">无法从关联的进程资源中设置或检索进程优先级信息。  
  
 或  
  
 进程标识符或进程句柄为零。 （进程尚未启动。）</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。</exception>
        <exception cref="T:System.PlatformNotSupportedException">当使用 Windows 98 或 Windows Millennium Edition (Windows Me) 时，已将 <see cref="P:System.Diagnostics.Process.PriorityClass" /> 设置为 <see langword="AboveNormal" /> 或 <see langword="BelowNormal" />。 这些平台不支持优先级类的这些值。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">无法设置优先级类，因为它不使用有效的值，如 <see cref="T:System.Diagnostics.ProcessPriorityClass" /> 枚举中所定义。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的专用内存量（以字节为单位）。</summary>
        <value>由关联的进程分配的、不能与其他进程共享的字节数。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的专用内存量（以字节为单位）。</summary>
        <value>为关联进程分配的不能与其他进程共享的内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值表示的过程，以字节为单位，不能共享与其他进程使用的内存的当前大小。  
  
 此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。 属性值等于**专用字节**进程的性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的一个实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示其退出代码，峰值内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此进程的特权处理器时间。</summary>
        <value>
          <see cref="T:System.TimeSpan" />，它指示进程在操作系统内核中运行代码所用的时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例启动记事本实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该进程的名称。</summary>
        <value>系统用以向用户标识该进程的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ProcessName%2A>属性包含可执行文件名称，例如 Outlook 中，不包含扩展名为.exe 或路径。 它可帮助获取和操作与相同的可执行文件相关联的所有进程。  
  
> [!NOTE]
>  上[!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)]操作系统，<xref:System.Diagnostics.Process.ProcessName%2A>属性可能会截断至 15 个字符，如果无法获取进程模块信息。  
  
 你可以调用<xref:System.Diagnostics.Process.GetProcessesByName%2A>，将其传递可执行文件名称，以检索包含指定的计算机上每个正在运行的实例的数组。 可以使用此数组，例如，若要关闭所有运行的可执行文件的实例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">进程没有标识符，或者没有与 <see cref="T:System.Diagnostics.Process" /> 关联的进程。  
  
 或  
  
 关联进程已退出。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <exception cref="T:System.NotSupportedException">进程不在此计算机上。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一些处理器，此进程中的线程可以按计划在这些处理器上运行。</summary>
        <value>位掩码，表示关联进程内的线程可以在其上运行的处理器。 默认值取决于计算机上的处理器数。 默认值为 2 <sup>n</sup> -1，其中 n 是处理器数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 2000 及更高版本，一个进程中的线程可以迁移处理器间重新加载处理器缓存每个迁移。 在高系统负荷情况下指定在哪个处理器应运行特定线程可以提高性能通过减少处理器缓存都会重新加载的次数。 处理器和线程之间的关联称为处理器关联。  
  
 每个处理器表示为一位。 位 0 是一个处理器，位 1 是处理器二，等等。 如果将位设置为值 1，进行线程分配情况下会选择相应的处理器。 当你将设置<xref:System.Diagnostics.Process.ProcessorAffinity%2A>值为零，操作系统线程的关联的计划算法组。 当<xref:System.Diagnostics.Process.ProcessorAffinity%2A>值设置为任一非零值，该值被解释为指定可供选择的处理器的位掩码。  
  
 下表显示了选择的<xref:System.Diagnostics.Process.ProcessorAffinity%2A>8 处理器系统值。  
  
|位掩码|二进制值|符合条件的处理器|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 和 2|  
|0x0007|00000000 00000111|1、 2 和 3|  
|0x0009|00000000 00001001|1 和 4|  
|0x007F|00000000 01111111|1、 2、 3、 4、 5、 6 和 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          未能从关联的进程资源设置或检索 <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 信息。  
  
 或  
  
 进程标识符或进程句柄为零。 （进程尚未启动。）</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">进程 <see cref="P:System.Diagnostics.Process.Id" /> 不可用。  
  
 或  
  
 该进程已退出。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>放弃已缓存到进程组件的关联仅存的任何相关信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 后<xref:System.Diagnostics.Process.Refresh%2A>调用，第一个请求有关每个属性的信息会导致进程组件从关联进程中获取新值。  
  
 当<xref:System.Diagnostics.Process>组件是关联的进程资源的属性值<xref:System.Diagnostics.Process>立即填充根据关联的进程的状态。 如果随后更改有关关联的进程的信息，这些更改不会反映在<xref:System.Diagnostics.Process>组件的缓存值。 <xref:System.Diagnostics.Process>组件时的进程资源的快照是对与其关联。 若要查看为关联进程的当前值，调用<xref:System.Diagnostics.Process.Refresh%2A>方法。  
  
   
  
## Examples  
 以下示例启动记事本实例。 然后在 10 秒最多两秒为间隔检索关联进程的物理内存的使用量。 该示例检测在进程退出之前经过 10 秒后。 如果它仍在运行在 10 秒后，该示例将关闭进程。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示进程的用户界面当前是否响应的值。</summary>
        <value>
          如果关联进程的用户界面当前响应系统，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果进程具有用户界面，<xref:System.Diagnostics.Process.Responding%2A>属性联系来确定进程是否正在响应用户输入的用户界面。 如果接口未立即响应<xref:System.Diagnostics.Process.Responding%2A>属性返回`false`。 使用此属性确定关联的进程的界面已停止响应。  
  
 如果进程不具有<xref:System.Diagnostics.Process.MainWindowHandle%2A>，此属性返回`true`。  
  
   
  
## Examples  
 以下示例启动记事本实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <exception cref="T:System.InvalidOperationException">没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.Responding" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此进程的本机句柄。</summary>
        <value>此进程的本机句柄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此句柄才只有一个调用组件启动该进程。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的终端服务会话标识符。</summary>
        <value>关联进程的终端服务会话标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.SessionId%2A>属性标识在其中应用程序当前正在运行的会话。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">没有与此进程关联的会话。</exception>
        <exception cref="T:System.InvalidOperationException">没有与此会话标识符关联的进程。  
  
 或  
  
 关联的进程不在此计算机上。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 98 不支持 <see cref="P:System.Diagnostics.Process.SessionId" /> 属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于读取应用程序错误输出的流。</summary>
        <value>可用于读取应用程序的标准错误流的 <see cref="T:System.IO.StreamReader" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Diagnostics.Process>将文本写入其标准错误流中，通常在控制台上显示文本。 通过将重定向<xref:System.Diagnostics.Process.StandardError%2A>流，你可以操作或取消进程的错误输出。 例如，你可以筛选文本、 格式设置不同，或将输出写入控制台和一个指定的日志文件。  
  
> [!NOTE]
>  若要使用<xref:System.Diagnostics.Process.StandardError%2A>，必须设置<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>到`false`，并且必须设置<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType>到`true`。 否则，读取从<xref:System.Diagnostics.Process.StandardError%2A>流时将引发异常。  
  
 重定向<xref:System.Diagnostics.Process.StandardError%2A>可以读取流，同步或异步。 等方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>同步对执行读取的操作的错误输出流的过程。 这些同步读取操作不会完成之前关联<xref:System.Diagnostics.Process>写入其<xref:System.Diagnostics.Process.StandardError%2A>流处理时，或关闭流。  
  
 与此相反，<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>开始异步读取操作上<xref:System.Diagnostics.Process.StandardError%2A>流。 此方法将启用流输出指定的事件处理程序并立即返回到调用方，流输出定向到事件处理程序时可以执行其他工作。  
  
 同步读取操作引入读取从调用方之间的依赖项<xref:System.Diagnostics.Process.StandardError%2A>流和子进程的写入该流。 这些依赖关系可能会导致死锁条件。 当调用方读取子进程的重定向流时，它是依赖于子。 调用方上读取操作会一直等到子写入流或关闭流。 子进程在编写时数据不足，无法填充其重定向的流，它是依赖于父。 子进程一直等到下一步的写入操作上的父项从完整的流中读取或关闭流。 当调用方和子进程互相等待来完成操作，并且都可以继续执行，死锁条件的结果。 可以通过评估的调用方和子进程之间的依赖关系来避免死锁。  
  
 下面的 C# 代码，例如，演示如何从重定向流中读取并等待子进程退出。  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 下面的代码示例通过调用来避免死锁条件`p.StandardError.ReadToEnd`之前`p.WaitForExit`。 如果父进程调用会导致死锁条件`p.WaitForExit`之前`p.StandardError.ReadToEnd`和子进程将足够多的文本以填充重定向的流。 父进程将无限期地等待子进程退出。 子进程将无限期地等待父从完整读取<xref:System.Diagnostics.Process.StandardError%2A>流。  
  
 从标准输出和标准错误流读取所有文本时类似问题。 下面的 C# 代码，例如，执行对这两种流的读取的操作。  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 下面的代码示例通过执行异步上读取操作来避免死锁条件<xref:System.Diagnostics.Process.StandardOutput%2A>流。 死锁条件结果如果父进程调用`p.StandardOutput.ReadToEnd`跟`p.StandardError.ReadToEnd`和子进程将足够多的文本以填充其错误流。 父进程将无限期地等待子进程以关闭其<xref:System.Diagnostics.Process.StandardOutput%2A>流。 子进程将无限期地等待父从完整读取<xref:System.Diagnostics.Process.StandardError%2A>流。  
  
 异步读取的操作可用于避免这些依赖关系和其潜在的死锁。 或者，可以通过创建两个线程并读取在单独线程上的每个流的输出来避免出现死锁条件。  
  
> [!NOTE]
>  不能混合在重定向流上的异步和同步读取的操作。 一次的重定向的流<xref:System.Diagnostics.Process>打开在异步或同步模式下，所有进一步读取该流上的操作必须处于相同的模式。 例如，不遵循<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>通过调用<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardError%2A>流，反之亦然。 但是，你可以读取在不同模式下的两个不同的流。 例如，你可以调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然后调用<xref:System.IO.StreamReader.ReadLine%2A>为<xref:System.Diagnostics.Process.StandardError%2A>流。  
  
   
  
## Examples  
 下面的示例使用`net use`命令和用户提供的参数映射的网络资源。 然后，读取标准错误流的 net 命令，并将其写入控制台。  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未对 <see cref="P:System.Diagnostics.Process.StandardError" /> 流进行重定向定义；请确保 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 设置为 <see langword="true" /> 且 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />。  
  
 \- 或 -  
  
 已打开 <see cref="P:System.Diagnostics.Process.StandardError" /> 流，以使用 <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> 进行异步读取操作。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于写入应用程序输入的流。</summary>
        <value>
          <see cref="T:System.IO.StreamWriter" />，可用于写入应用程序的标准输入流。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Diagnostics.Process>可以从其标准的输入流，通常是键盘读取输入的文本。 通过将重定向<xref:System.Diagnostics.Process.StandardInput%2A>流，你可以以编程方式指定输入。 例如，而不是使用键盘输入，你可以提供从指定文件的内容的文本或从另一个应用程序的输出。  
  
> [!NOTE]
>  若要使用<xref:System.Diagnostics.Process.StandardInput%2A>，必须设置<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>到`false`，并且必须设置<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType>到`true`。 否则，写入<xref:System.Diagnostics.Process.StandardInput%2A>流时将引发异常。  
  
   
  
## Examples  
 下面的示例演示如何将重定向<xref:System.Diagnostics.Process.StandardInput%2A>进程的流。 该示例启动`sort`命令重定向的输入。 然后会提示用户输入文本，并将传递给`sort`进程通过的重定向<xref:System.Diagnostics.Process.StandardInput%2A>流。 `sort`结果显示到控制台上的用户。  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.Process.StandardInput" /> 流尚未定义，因为 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> 设置为 <see langword="false" />。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于读取应用程序文本输出的流。</summary>
        <value>
          <see cref="T:System.IO.StreamReader" />，可用于读取应用程序的标准输出流。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Diagnostics.Process>将文本写入其标准的流，通常在控制台上显示文本。 通过将重定向<xref:System.Diagnostics.Process.StandardOutput%2A>流，你可以操作或取消进程的输出。 例如，你可以筛选文本、 格式设置不同，或将输出写入控制台和一个指定的日志文件。  
  
> [!NOTE]
>  若要使用<xref:System.Diagnostics.Process.StandardOutput%2A>，必须设置<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>到`false`，并且必须设置<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType>到`true`。 否则，读取从<xref:System.Diagnostics.Process.StandardOutput%2A>流时将引发异常。  
  
 重定向<xref:System.Diagnostics.Process.StandardOutput%2A>可以读取流，同步或异步。 等方法<xref:System.IO.StreamReader.Read%2A>， <xref:System.IO.StreamReader.ReadLine%2A>，和<xref:System.IO.StreamReader.ReadToEnd%2A>同步对执行读取的操作过程的输出流。 这些同步读取操作不会完成之前关联<xref:System.Diagnostics.Process>写入其<xref:System.Diagnostics.Process.StandardOutput%2A>流处理时，或关闭流。  
  
 与此相反，<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>开始异步读取操作上<xref:System.Diagnostics.Process.StandardOutput%2A>流。 此方法将启用流输出指定的事件处理程序并立即返回到调用方，流输出定向到事件处理程序时可以执行其他工作。  
  
 同步读取操作引入读取从调用方之间的依赖项<xref:System.Diagnostics.Process.StandardOutput%2A>流和子进程的写入该流。 这些依赖关系可能会导致死锁条件。 当调用方读取子进程的重定向流时，它是依赖于子。 调用方上读取操作会一直等到子写入流或关闭流。 子进程在编写时数据不足，无法填充其重定向的流，它是依赖于父。 子进程一直等到下一步的写入操作上的父项从完整的流中读取或关闭流。 当调用方和子进程互相等待来完成操作，并且都可以继续执行，死锁条件的结果。 可以通过评估的调用方和子进程之间的依赖关系来避免死锁。  
  
 下面的 C# 代码，例如，演示如何从重定向流中读取并等待子进程退出。  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 下面的代码示例通过调用来避免死锁条件`p.StandardOutput.ReadToEnd`之前`p.WaitForExit`。 如果父进程调用会导致死锁条件`p.WaitForExit`之前`p.StandardOutput.ReadToEnd`和子进程将足够多的文本以填充重定向的流。 父进程将无限期地等待子进程退出。 子进程将无限期地等待父从完整读取<xref:System.Diagnostics.Process.StandardOutput%2A>流。  
  
 从标准输出和标准错误流读取所有文本时类似问题。 下面的 C# 代码，例如，执行对这两种流的读取的操作。  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 下面的代码示例通过执行异步上读取操作来避免死锁条件<xref:System.Diagnostics.Process.StandardOutput%2A>流。 死锁条件结果如果父进程调用`p.StandardOutput.ReadToEnd`跟`p.StandardError.ReadToEnd`和子进程将足够多的文本以填充其错误流。 父进程将无限期地等待子进程以关闭其<xref:System.Diagnostics.Process.StandardOutput%2A>流。 子进程将无限期地等待父从完整读取<xref:System.Diagnostics.Process.StandardError%2A>流。  
  
 异步读取的操作可用于避免这些依赖关系和其潜在的死锁。 或者，可以通过创建两个线程并读取在单独线程上的每个流的输出来避免出现死锁条件。  
  
> [!NOTE]
>  不能混合在重定向流上的异步和同步读取的操作。 一次的重定向的流<xref:System.Diagnostics.Process>打开在异步或同步模式下，所有进一步读取该流上的操作必须处于相同的模式。 例如，不遵循<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>通过调用<xref:System.IO.StreamReader.ReadLine%2A>上<xref:System.Diagnostics.Process.StandardOutput%2A>流，反之亦然。 但是，你可以读取在不同模式下的两个不同的流。 例如，你可以调用<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>，然后调用<xref:System.IO.StreamReader.ReadLine%2A>为<xref:System.Diagnostics.Process.StandardError%2A>流。  
  
   
  
## Examples  
 下面的示例运行 ipconfig.exe 命令，并且将其标准输出重定向到示例的控制台窗口。  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未对 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流进行重定向定义；请确保 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 设置为 <see langword="true" /> 且 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />。  
  
 \- 或 -  
  
 已打开 <see cref="P:System.Diagnostics.Process.StandardOutput" /> 流，以使用 <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> 进行异步读取操作。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>启动进程资源并将其与 <see cref="T:System.Diagnostics.Process" /> 组件关联。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>启动(或重用)此 <see cref="T:System.Diagnostics.Process" /> 组件的 <see cref="P:System.Diagnostics.Process.StartInfo" /> 属性指定的进程资源，并将其与该组件关联。</summary>
        <returns>
          如果启动了进程资源，则为 <see langword="true" />；如果没有启动新的进程资源(例如，如果重用了现有进程)，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载来启动一个进程资源并将其与当前<xref:System.Diagnostics.Process>组件。 返回值`true`指示已启动了新的进程资源。 如果指定的进程资源<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>的成员<xref:System.Diagnostics.Process.StartInfo%2A>属性已在计算机上运行、 启动任何其他进程资源。 相反，正在运行的进程资源重复使用和`false`返回。  
  
 可以通过指定最初从中安装应用程序的位置 （例如，Web 地址） 来启动 ClickOnce 应用程序。 不通过指定其安装的位置在硬盘驱动器上启动 ClickOnce 应用程序。  
  
> [!NOTE]
>  如果你使用 Visual Studio 中，此重载<xref:System.Diagnostics.Process.Start%2A>方法是拖动后插入到代码中的一个<xref:System.Diagnostics.Process>组件拖放到设计器。 使用`Properties`窗口以展开`StartInfo`类别和写入到适当的值`FileName`属性。 所做的更改将显示在窗体的`InitializeComponent`过程。  
  
 此重载<xref:System.Diagnostics.Process.Start%2A>不`static`方法。 必须调用它的实例从<xref:System.Diagnostics.Process>类。 之前调用<xref:System.Diagnostics.Process.Start%2A>，你必须首先指定<xref:System.Diagnostics.Process.StartInfo%2A>此属性信息<xref:System.Diagnostics.Process>实例，因为该信息用于确定要启动的进程资源。  
  
 其他重载的<xref:System.Diagnostics.Process.Start%2A>方法`static`成员。 不需要创建的实例<xref:System.Diagnostics.Process>组件之前调用这些方法的重载。 相反，您可以调用<xref:System.Diagnostics.Process.Start%2A>为<xref:System.Diagnostics.Process>类本身，以及新<xref:System.Diagnostics.Process>已启动进程时是否创建组件。 或者，`null`返回如果重用了进程。 进程资源会自动与新关联<xref:System.Diagnostics.Process>组件返回<xref:System.Diagnostics.Process.Start%2A>方法。  
  
 <xref:System.Diagnostics.Process.StartInfo%2A>成员可用于复制的功能`Run`对话框中的 windows`Start`菜单。 可以在命令行中键入的任何内容可以通过设置中的相应值来启动<xref:System.Diagnostics.Process.StartInfo%2A>属性。 唯一<xref:System.Diagnostics.Process.StartInfo%2A>必须设置的属性是<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性。 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性不必是可执行文件。 它可以是为其扩展已在系统安装的应用程序与关联任何文件类型。 例如，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性可以具有.txt 扩展名，如果你具有使用编辑器 （如记事本） 相关联的文本文件或者如果你已经将提供一个文字处理的工具，如 Microsoft Word 的文本文件，它可以具有.doc 扩展名。  
  
 在命令行中，你可以指定要为特定类型的文件执行操作。 例如，您可以打印文档或编辑文本文件。 指定使用这些操作<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>的成员<xref:System.Diagnostics.Process.StartInfo%2A>属性。 对于其他类型的文件，你可以指定命令行自变量，在启动中的文件时`Run`对话框。 例如，作为参数传递一个 URL，如果指定为你的浏览器<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>。 这些参数可以指定在<xref:System.Diagnostics.Process.StartInfo%2A>属性的<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>成员。  
  
 如果你有系统中用引号中声明的路径变量，则必须启动任何进程在该位置中找到时，完全限定该路径。 否则，系统将不到的路径。 例如，如果`c:\mypath`不在你的路径，并将其使用引号引起来添加： `path = %path%;"c:\mypath"`，必须完全符合中的任何进程`c:\mypath`时启动它。  
  
> [!NOTE]
>  ASP.NET Web 页和服务器控件的代码在 Web 服务器上的 ASP.NET 工作进程的上下文中执行。  如果你使用<xref:System.Diagnostics.Process.Start%2A>在 ASP.NET Web 页或服务器控件中的方法，在具有受限权限的 Web 服务器上执行新进程。 进程不与客户端浏览器中，相同的上下文中启动，并且有权访问的用户桌面。  
  
 无论何时使用<xref:System.Diagnostics.Process.Start%2A>若要启动进程时，你可能需要将其关闭或冒系统资源。 关闭进程使用<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 你可以检查是否已关闭进程通过其<xref:System.Diagnostics.Process.HasExited%2A>属性。  
  
 有关托管线程中的单元状态的注意事项此处是必需的。 当<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`进程组件上<xref:System.Diagnostics.Process.StartInfo%2A>属性，请确保已通过将属性设置对应用程序中设置线程模型`[STAThread]`上`main()`方法。 否则，托管的线程可以处于`unknown`状态或将放入`MTA`状态时，发生冲突，而后一个<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。 某些方法要求使用的单元状态，不会`unknown`。 如果未显式设置该状态，那么当应用程序遇到这样的方法时，它默认为`MTA`，而一次设置，就不能更改的单元状态。 但是，`MTA`操作系统外壳程序管理线程时引发异常。  
  
   
  
## Examples  
 下面的示例使用的实例<xref:System.Diagnostics.Process>类启动的进程。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在 <see cref="T:System.Diagnostics.Process" /> 组件的 <see cref="P:System.Diagnostics.Process.StartInfo" /> 中未指定任何文件名。
 或者，当 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 或 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 为 <see langword="true" /> 时，<see cref="P:System.Diagnostics.Process.StartInfo" /> 属性的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 成员为 <see langword="true" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">打开关联的文件时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放此进程对象。</exception>
        <exception cref="T:System.PlatformNotSupportedException">不支持 shell 的操作系统（如，仅适用于.NET Core 的 Nano Server）不支持此方法。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">
          <see cref="T:System.Diagnostics.ProcessStartInfo" />，包含用于启动进程的信息(包括文件名和任何命令行参数)。</param>
        <summary>启动由包含进程启动信息(例如，要启动的进程的文件名)的参数指定的进程资源，并将该资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件关联。</summary>
        <returns>与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。 请注意，随着同一进程已在运行的实例启动的新进程将独立于其他进程。 此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载来通过指定启动进程资源<xref:System.Diagnostics.ProcessStartInfo>实例。 该重载将资源与新<xref:System.Diagnostics.Process>对象。  
  
> [!NOTE]
>  如果要启动的可执行文件的地址是 URL，则不会启动进程和`null`返回。  
  
 此重载使你无需首先创建一个新启动的进程<xref:System.Diagnostics.Process>实例。 使用此重载与<xref:System.Diagnostics.ProcessStartInfo>参数是创建一个新的显式步骤的替代方法<xref:System.Diagnostics.Process>实例，设置其<xref:System.Diagnostics.Process.StartInfo%2A>属性以及调用<xref:System.Diagnostics.Process.Start%2A>为<xref:System.Diagnostics.Process>实例。  
  
 使用<xref:System.Diagnostics.ProcessStartInfo>实例用作参数，你可以调用<xref:System.Diagnostics.Process.Start%2A>最控制内容传递到调用以启动该过程。 如果你需要将只能出现文件名或文件名称和自变量传递，则不需要创建新<xref:System.Diagnostics.ProcessStartInfo>实例，尽管这是一个选项。 唯一<xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType>必须设置的属性是<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性。 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性不需要表示一个可执行文件。 它可以是为其扩展已在系统安装的应用程序与关联任何文件类型。 例如，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性可以具有.txt 扩展名，如果你具有使用编辑器 （如记事本） 相关联的文本文件或者如果你已经将提供一个文字处理的工具，如 Microsoft Word 的文本文件，它可以具有.doc 扩展名。  
  
 可以通过指定最初从中安装应用程序的位置 （例如，Web 地址） 来启动 ClickOnce 应用程序。 不通过指定其安装的位置在硬盘驱动器上启动 ClickOnce 应用程序。  
  
 如果<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>和<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType>属性<xref:System.Diagnostics.Process.StartInfo%2A>实例设置了非托管`CreateProcessWithLogonW`调用函数，以启动该过程在新窗口即使<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType>属性值是`true`或<xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType>属性值是<xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>。 如果<xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType>属性是`null`、<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>属性必须为 UPN 格式*用户*@*DNS_domain_name*。   
  
 与其他重载的重载不同<xref:System.Diagnostics.Process.Start%2A>该操作没有参数不是`static`成员。 重载时你已创建的使用<xref:System.Diagnostics.Process>实例，指定的开始信息 （包括文件名称），并且想要启动一个进程资源并将其与现有<xref:System.Diagnostics.Process>实例。 使用之一`static`重载时你想要创建一个新<xref:System.Diagnostics.Process>组件而不是为现有组件启动一个进程。 此重载和没有参数的重载允许你通过使用指定的进程资源的开始信息<xref:System.Diagnostics.ProcessStartInfo>实例。  
  
 如果你有系统中用引号中声明的路径变量，则必须启动任何进程在该位置中找到时，完全限定该路径。 否则，系统将不到的路径。 例如，如果`c:\mypath`不在你的路径，并将其使用引号引起来添加： `path = %path%;"c:\mypath"`，必须完全符合中的任何进程`c:\mypath`时启动它。  
  
> [!NOTE]
>  ASP.NET Web 页和服务器控件的代码在 Web 服务器上的 ASP.NET 工作进程的上下文中执行。  如果你使用<xref:System.Diagnostics.Process.Start%2A>在 ASP.NET Web 页或服务器控件中的方法，在具有受限权限的 Web 服务器上执行新进程。 进程不与客户端浏览器中，相同的上下文中启动，并且有权访问的用户桌面。  
  
 无论何时使用<xref:System.Diagnostics.Process.Start%2A>若要启动进程时，你可能需要将其关闭或冒系统资源。 关闭进程使用<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 你可以检查是否已关闭进程通过其<xref:System.Diagnostics.Process.HasExited%2A>属性。  
  
 有关托管线程中的单元状态的注意事项此处是必需的。 当<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`上`startInfo`参数，请确保已通过将属性设置对应用程序中设置线程模型`[STAThread]`上`main()`方法。 否则，托管的线程可以处于`unknown`状态或将放入`MTA`状态时，发生冲突，而后一个<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。 某些方法要求使用的单元状态，不会`unknown`。 如果未显式设置该状态，那么当应用程序遇到这样的方法时，它默认为`MTA`，而一次设置，就不能更改的单元状态。 但是，`MTA`操作系统外壳程序管理线程时引发异常。  
  
   
  
## Examples  
 下面的示例首先生成的 Internet Explorer 实例，并在浏览器中显示的收藏夹文件夹的内容。 然后，启动 Internet Explorer 的一些其他实例，并显示某些特定的页或站点。 最后，它与时导航到特定站点最小化窗口启动 Internet Explorer。  
  
 有关此方法的其他用法的其他示例，请参阅的各个属性<xref:System.Diagnostics.ProcessStartInfo>类。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在 <paramref name="startInfo" /> 参数的 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 属性中未指定任何文件名。  
  
 或  
  
 <paramref name="startInfo" /> 参数的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 属性值为 <see langword="true" />，且 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> 或 <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> 属性的值也为 <see langword="true" />。  
  
 或  
  
 <paramref name="startInfo" /> 参数的 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 属性值为 <see langword="true" />，且 <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> 属性值不为 <see langword="null" /> 或空，或者 <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> 属性值不为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="startInfo" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放此进程对象。</exception>
        <exception cref="T:System.IO.FileNotFoundException">在 <paramref name="startInfo" /> 参数的 <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> 属性中指定的文件未找到。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">打开关联的文件时出错。  
  
 或  
  
 参数的长度与该进程的完整路径的长度的总和超过了 2080。 与此异常关联的错误消息可能为以下消息之一：“传递到系统调用的数据区域太小。” 或“拒绝访问。”</exception>
        <exception cref="T:System.PlatformNotSupportedException">不支持 shell 的操作系统（如，仅适用于.NET Core 的 Nano Server）不支持此方法。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要在进程中运行的文档或应用程序文件的名称。</param>
        <summary>通过指定文档或应用程序文件的名称来启动进程资源，并将资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件关联。</summary>
        <returns>与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。 请注意，随着同一进程已在运行的实例启动的新进程将独立于其他进程。 此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载来通过指定其文件名启动一个进程资源。 该重载将资源与新<xref:System.Diagnostics.Process>对象。  
  
> [!NOTE]
>  如果要启动的可执行文件的地址是 URL，则不会启动进程和`null`返回。  
  
 此重载使你无需首先创建一个新启动的进程<xref:System.Diagnostics.Process>实例。 该重载是创建一个新的显式步骤的替代方法<xref:System.Diagnostics.Process>实例，设置<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>的成员<xref:System.Diagnostics.Process.StartInfo%2A>属性，再调用<xref:System.Diagnostics.Process.Start%2A>为<xref:System.Diagnostics.Process>实例。  
  
 您可以通过设置启动 ClickOnce 应用程序`fileName`最初从中安装应用程序的位置 （例如，Web 地址） 的参数。 不通过指定其安装的位置在硬盘驱动器上启动 ClickOnce 应用程序。  
  
 通过指定其文件名称中启动进程是类似于键入中的信息`Run`对话框中的 windows`Start`菜单。 因此，文件名称不必表示一个可执行文件。 它可以是为其扩展已关联与应用程序在系统上安装任何文件类型。 例如的文件名称可以具有.txt 扩展名，如果你具有使用编辑器 （如记事本） 相关联的文本文件或者如果你已经将提供一个文字处理的工具，如 Microsoft Word 的文本文件，也可能产生.doc。 同样，在相同的方式`Run`对话框中可以接受使用或不具有.exe 扩展名的可执行文件名、 扩展名为.exe 中是可选`fileName`参数。 例如，你可以设置`fileName`参数以"Notepad.exe"或"记事本"。  
  
 此重载不允许进程的命令行自变量。 如果你需要指定一个或多个进程的命令行参数，使用<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType>或<xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType>重载。  
  
 与其他重载的重载不同<xref:System.Diagnostics.Process.Start%2A>该操作没有参数不是`static`成员。 重载时你已创建的使用<xref:System.Diagnostics.Process>实例，指定的开始信息 （包括文件名称），并且想要启动一个进程资源并将其与现有<xref:System.Diagnostics.Process>实例。 使用之一`static`重载时你想要创建一个新<xref:System.Diagnostics.Process>组件而不是为现有组件启动一个进程。 此重载和没有参数的重载允许你指定要启动的进程资源的文件名称。  
  
 如果你有系统中用引号中声明的路径变量，则必须启动任何进程在该位置中找到时，完全限定该路径。 否则，系统将不到的路径。 例如，如果`c:\mypath`不在你的路径，并将其使用引号引起来添加： `path = %path%;"c:\mypath"`，必须完全符合中的任何进程`c:\mypath`时启动它。  
  
> [!NOTE]
>  ASP.NET Web 页和服务器控件的代码在 Web 服务器上的 ASP.NET 工作进程的上下文中执行。  如果你使用<xref:System.Diagnostics.Process.Start%2A>在 ASP.NET Web 页或服务器控件中的方法，在具有受限权限的 Web 服务器上执行新进程。 进程不与客户端浏览器中，相同的上下文中启动，并且有权访问的用户桌面。  
  
 无论何时使用<xref:System.Diagnostics.Process.Start%2A>若要启动进程时，你可能需要将其关闭或冒系统资源。 关闭进程使用<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 你可以检查是否已关闭进程通过其<xref:System.Diagnostics.Process.HasExited%2A>属性。  
  
 有关托管线程中的单元状态的注意事项此处是必需的。 当<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`进程组件上<xref:System.Diagnostics.Process.StartInfo%2A>属性，请确保已通过将属性设置对应用程序中设置线程模型`[STAThread]`上`main()`方法。 否则，托管的线程可以处于`unknown`状态或将放入`MTA`状态时，发生冲突，而后一个<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。 某些方法要求使用的单元状态，不会`unknown`。 如果未显式设置该状态，那么当应用程序遇到这样的方法时，它默认为`MTA`，而一次设置，就不能更改的单元状态。 但是，`MTA`操作系统外壳程序管理线程时引发异常。  
  
   
  
## Examples  
 下面的示例首先生成的 Internet Explorer 实例，并在浏览器中显示的收藏夹文件夹的内容。 然后，启动 Internet Explorer 的一些其他实例，并显示某些特定的页或站点。 最后，它与时导航到特定站点最小化窗口启动 Internet Explorer。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">打开关联的文件时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放此进程对象。</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 环境变量具有一个包含引号的字符串。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要在进程中运行的应用程序文件的名称。</param>
        <param name="arguments">启动该进程时传递的命令行参数。</param>
        <summary>通过指定应用程序的名称和一组命令行参数来启动一个进程资源，并将该资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件相关联。</summary>
        <returns>与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。 请注意，随着同一进程已在运行的实例启动的新进程将独立于其他进程。 此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载来通过指定其文件名称和命令行参数启动一个进程资源。 该重载将资源与新<xref:System.Diagnostics.Process>对象。  
  
> [!NOTE]
>  如果要启动的可执行文件的地址是 URL，则不会启动进程和`null`返回。  
  
 此重载使你无需首先创建一个新启动的进程<xref:System.Diagnostics.Process>实例。 该重载是创建一个新的显式步骤的替代方法<xref:System.Diagnostics.Process>实例，设置<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>和<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>的成员<xref:System.Diagnostics.Process.StartInfo%2A>属性，再调用<xref:System.Diagnostics.Process.Start%2A>为<xref:System.Diagnostics.Process>实例。  
  
 通过指定其文件名称和参数启动进程是类似于输入文件的名称和命令行自变量中的`Run`对话框中的 windows`Start`菜单。 因此，文件名称不必表示一个可执行文件。 它可以是为其扩展已关联与应用程序在系统上安装任何文件类型。 例如的文件名称可以具有.txt 扩展名，如果你具有使用编辑器 （如记事本） 相关联的文本文件或者如果你已经将提供一个文字处理的工具，如 Microsoft Word 的文本文件，也可能产生.doc。 同样，在相同的方式`Run`对话框中可以接受使用或不具有.exe 扩展名的可执行文件名、 扩展名为.exe 中是可选`fileName`参数。 例如，你可以设置`fileName`参数以"Notepad.exe"或"记事本"。 如果`fileName`参数表示一个可执行文件，`arguments`参数可能表示要执行操作，例如文本文件中的文件`Notepad.exe myfile.txt`。 如果`fileName`参数表示的命令 (.cmd) 文件，`arguments`参数必须包括"`/c`"或"`/k`"参数来指定命令窗口退出还是完成后将保持。  
  
 与其他重载的重载不同<xref:System.Diagnostics.Process.Start%2A>该操作没有参数不是`static`成员。 重载时你已创建的使用<xref:System.Diagnostics.Process>实例，指定的开始信息 （包括文件名称），并且想要启动一个进程资源并将其与现有<xref:System.Diagnostics.Process>实例。 使用之一`static`重载时你想要创建一个新<xref:System.Diagnostics.Process>组件而不是为现有组件启动一个进程。 此重载和没有参数的重载允许你指定要启动进程资源和要传递的命令行自变量的文件名称。  
  
 如果你有系统中用引号中声明的路径变量，则必须启动任何进程在该位置中找到时，完全限定该路径。 否则，系统将不到的路径。 例如，如果`c:\mypath`不在你的路径，并将其使用引号引起来添加： `path = %path%;"c:\mypath"`，必须完全符合中的任何进程`c:\mypath`时启动它。  
  
> [!NOTE]
>  ASP.NET Web 页和服务器控件的代码在 Web 服务器上的 ASP.NET 工作进程的上下文中执行。  如果你使用<xref:System.Diagnostics.Process.Start%2A>在 ASP.NET Web 页或服务器控件中的方法，在具有受限权限的 Web 服务器上执行新进程。 进程不与客户端浏览器中，相同的上下文中启动，并且有权访问的用户桌面。  
  
 无论何时使用<xref:System.Diagnostics.Process.Start%2A>若要启动进程时，你可能需要将其关闭或冒系统资源。 关闭进程使用<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 你可以检查是否已关闭进程通过其<xref:System.Diagnostics.Process.HasExited%2A>属性...  
  
 有关托管线程中的单元状态的注意事项此处是必需的。 当<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>是`true`进程组件上<xref:System.Diagnostics.Process.StartInfo%2A>属性，请确保已通过将属性设置对应用程序中设置线程模型`[STAThread]`上`main()`方法。 否则，托管的线程可以处于`unknown`状态或将放入`MTA`状态时，发生冲突，而后一个<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>正在`true`。 某些方法要求使用的单元状态，不会`unknown`。 如果未显式设置该状态，那么当应用程序遇到这样的方法时，它默认为`MTA`，而一次设置，就不能更改的单元状态。 但是，`MTA`操作系统外壳程序管理线程时引发异常。  
  
   
  
## Examples  
 下面的示例首先生成的 Internet Explorer 实例，并在浏览器中显示的收藏夹文件夹的内容。 然后，启动 Internet Explorer 的一些其他实例，并显示某些特定的页或站点。 最后，它与时导航到特定站点最小化窗口启动 Internet Explorer。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="fileName" /> 或 <paramref name="arguments" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">打开关联的文件时出错。  
  
 或  
  
 参数的长度与该进程的完整路径的长度的总和超过了 2080。 与此异常关联的错误消息可能为以下消息之一：“传递到系统调用的数据区域太小。” 或“拒绝访问。”</exception>
        <exception cref="T:System.ObjectDisposedException">已释放此进程对象。</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 环境变量具有一个包含引号的字符串。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要在进程中运行的应用程序文件的名称。</param>
        <param name="userName">启动进程时使用的用户名。</param>
        <param name="password">包含启动进程时要使用的密码的 <see cref="T:System.Security.SecureString" />。</param>
        <param name="domain">启动进程时要使用的域。</param>
        <summary>通过指定应用程序的名称、用户名、密码和域来启动一个进程资源，并将该资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件关联起来。</summary>
        <returns>与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。 请注意，随着同一进程已在运行的实例启动的新进程将独立于其他进程。 此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载来通过指定其文件名称、 用户名、 密码和域中创建新的进程和其主线程。 然后，新进程指定的凭据 （用户、 域和密码） 的安全上下文中运行指定的可执行文件。  
  
> [!NOTE]
>  在可执行文件位于远程驱动器上，必须通过使用统一资源标识符 (URI)，不链接的驱动器号来标识网络共享。  
  
> [!NOTE]
>  如果要启动的可执行文件的地址是 URL，则不会启动进程和`null`返回。  
  
 此重载使你无需首先创建一个新启动的进程<xref:System.Diagnostics.Process>实例。 该重载是创建一个新的显式步骤的替代方法<xref:System.Diagnostics.Process>实例，设置<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>， <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Password%2A>，和<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>属性<xref:System.Diagnostics.Process.StartInfo%2A>属性，再调用<xref:System.Diagnostics.Process.Start%2A>为<xref:System.Diagnostics.Process>实例。  
  
 同样，在相同的方式**运行**对话框中可以接受使用或不具有.exe 扩展名的可执行文件名、 扩展名为.exe 中是可选`fileName`参数。 例如，你可以设置`fileName`参数以"Notepad.exe"或"记事本"。 如果`fileName`参数表示一个可执行文件，`arguments`参数可能表示要执行操作，例如文本文件中的文件`Notepad.exe myfile.txt`。  
  
> [!NOTE]
>  文件名称必须表示中的可执行文件<xref:System.Diagnostics.Process.Start%2A>具有重载`userName`， `password`，和`domain`参数。  
  
 无论何时使用<xref:System.Diagnostics.Process.Start%2A>若要启动进程时，你可能需要将其关闭或冒系统资源。 关闭进程使用<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 你可以检查是否已关闭进程通过其<xref:System.Diagnostics.Process.HasExited%2A>属性...  
  
   
  
## Examples  
 下面的代码示例演示了如何使用此重载，以启动可执行文件，并演示对引发<xref:System.ComponentModel.Win32Exception>时尝试启动应用程序与非可执行文件相关联。  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未指定文件名。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">打开关联的文件时出错。</exception>
        <exception cref="T:System.ObjectDisposedException">已释放此进程对象。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Linux 或 macOS （仅适用于.NET Core）不支持此方法。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要在进程中运行的应用程序文件的名称。</param>
        <param name="arguments">启动该进程时传递的命令行参数。</param>
        <param name="userName">启动进程时使用的用户名。</param>
        <param name="password">包含启动进程时要使用的密码的 <see cref="T:System.Security.SecureString" />。</param>
        <param name="domain">启动进程时要使用的域。</param>
        <summary>通过指定应用程序的名称、一组命令行参数、用户名、密码和域来启动一个进程资源，并将该资源与新的 <see cref="T:System.Diagnostics.Process" /> 组件关联起来。</summary>
        <returns>与进程资源关联的新 <see cref="T:System.Diagnostics.Process" />，如果未启动进程资源，则为 <see langword="null" />。 请注意，随着同一进程已在运行的实例启动的新进程将独立于其他进程。 此外，启动可能返回一个 <see cref="P:System.Diagnostics.Process.HasExited" /> 属性已设置为 <see langword="true" /> 的非 null 进程。 在这种情况下，启动的进程可能已激活现有实例自身，然后退出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载来通过指定其文件名、 命令行自变量、 用户名、 密码和域中创建新的进程和其主线程。 然后，新进程指定的凭据 （用户、 域和密码） 的安全上下文中运行指定的可执行文件。  
  
> [!NOTE]
>  在可执行文件位于远程驱动器上，必须通过使用统一资源标识符 (URI)，不链接的驱动器号来标识网络共享。  
  
> [!NOTE]
>  如果要启动的可执行文件的地址是 URL，则不会启动进程和`null`返回。  
  
 此重载使你无需首先创建一个新启动的进程<xref:System.Diagnostics.Process>实例。 该重载是创建一个新的显式步骤的替代方法<xref:System.Diagnostics.Process>实例，设置<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>， <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>， <xref:System.Diagnostics.ProcessStartInfo.Password%2A>，和<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>属性<xref:System.Diagnostics.Process.StartInfo%2A>属性，再调用<xref:System.Diagnostics.Process.Start%2A>为<xref:System.Diagnostics.Process>实例。  
  
 同样，在相同的方式**运行**对话框中可以接受使用或不具有.exe 扩展名的可执行文件名、 扩展名为.exe 中是可选`fileName`参数。 例如，你可以设置`fileName`参数以"Notepad.exe"或"记事本"。 如果`fileName`参数表示一个可执行文件，`arguments`参数可能表示要执行操作，例如文本文件中的文件`Notepad.exe myfile.txt`。  
  
> [!NOTE]
>  文件名称必须表示中的可执行文件<xref:System.Diagnostics.Process.Start%2A>具有重载`userName`， `password`，和`domain`参数。  
  
 无论何时使用<xref:System.Diagnostics.Process.Start%2A>若要启动进程时，你可能需要将其关闭或冒系统资源。 关闭进程使用<xref:System.Diagnostics.Process.CloseMainWindow%2A>或<xref:System.Diagnostics.Process.Kill%2A>。 你可以检查是否已关闭进程通过其<xref:System.Diagnostics.Process.HasExited%2A>属性...  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">未指定文件名。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">打开关联的文件时出错。  
  
 或  
  
 参数的长度与该关联文件的完整路径的长度的总和超过了 2080。 与此异常关联的错误消息可能为以下消息之一：“传递到系统调用的数据区域太小。” 或“拒绝访问。”</exception>
        <exception cref="T:System.ObjectDisposedException">已释放此进程对象。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Linux 或 macOS （仅适用于.NET Core）不支持此方法。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要传递给 <see cref="T:System.Diagnostics.Process" /> 的 <see cref="M:System.Diagnostics.Process.Start" /> 方法的属性。</summary>
        <value>表示启动进程时要使用的数据的 <see cref="T:System.Diagnostics.ProcessStartInfo" />。 这些自变量包括用于启动该进程的可执行文件或文档的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> 表示要用于启动过程的参数集。 当<xref:System.Diagnostics.Process.Start%2A>调用时，<xref:System.Diagnostics.Process.StartInfo%2A>用于指定要启动的进程。 仅将必需<xref:System.Diagnostics.Process.StartInfo%2A>成员设置是<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性。 通过指定启动进程<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性是类似于键入中的信息**运行**对话框中的 windows**启动**菜单。 因此，<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性不需要表示一个可执行文件。 它可以是为其扩展已关联与应用程序在系统上安装任何文件类型。 例如<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>如果你具有使用编辑器 （如记事本） 相关联的文本文件或者如果你已经将提供一个文字处理的工具，如 Microsoft Word 的文本文件，也可能产生.doc 可以具有.txt 扩展名。 同样，在相同的方式**运行**对话框中可以接受使用或不具有.exe 扩展名的可执行文件名、 扩展名为.exe 中是可选<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>成员。 例如，你可以设置<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性设置为"Notepad.exe"或"记事本"。  
  
 您可以通过设置启动 ClickOnce 应用程序<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>最初从中安装应用程序的位置 （例如，Web 地址） 的属性。 不通过指定其安装的位置在硬盘驱动器上启动 ClickOnce 应用程序。  
  
 如果文件名涉及非可执行文件，例如.doc 文件，你可以包括一个谓词指定要对该文件执行的操作。 例如，你可以设置<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>到以.doc 扩展名的文件的"打印"。 中指定的文件名称<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性不需要具有扩展名，如果你手动输入的值<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>属性。 但是，如果你使用<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>属性来确定哪些谓词的可用，必须包括扩展名。  
  
 你可以更改中指定的参数<xref:System.Diagnostics.Process.StartInfo%2A>你调用的时间属性<xref:System.Diagnostics.Process.Start%2A>进程上的方法。 启动过程后，更改<xref:System.Diagnostics.Process.StartInfo%2A>值不会影响或重新启动关联的进程。 如果调用<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>方法替换<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>和<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType>属性集，则非托管`CreateProcessWithLogonW`调用函数，以启动该过程在新窗口即使<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>属性值是`true`或<xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>属性值是<xref:System.Diagnostics.ProcessWindowStyle.Hidden>。  
  
 如果你未使用<xref:System.Diagnostics.Process.Start%2A>方法来启动一个进程，<xref:System.Diagnostics.Process.StartInfo%2A>属性不会反映用于启动进程的参数。 例如，如果你使用<xref:System.Diagnostics.Process.GetProcesses%2A>获取的计算机上，运行的进程的数组<xref:System.Diagnostics.Process.StartInfo%2A>每个属性<xref:System.Diagnostics.Process>不包含的原始文件名或用于启动进程的自变量。  
  
 当启动进程时，文件名是填充 （只读） 的文件<xref:System.Diagnostics.Process.MainModule%2A>属性。 如果你想要检索进程启动后与进程相关联的可执行文件，请使用<xref:System.Diagnostics.Process.MainModule%2A>属性。 如果你想要设置的可执行文件<xref:System.Diagnostics.Process>实例为其关联的进程尚未启动，请使用<xref:System.Diagnostics.Process.StartInfo%2A>属性的<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>成员。 因为的成员<xref:System.Diagnostics.Process.StartInfo%2A>属性是自变量传递给<xref:System.Diagnostics.Process.Start%2A>方法的过程中，更改<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>属性关联的进程启动后将不会重置<xref:System.Diagnostics.Process.MainModule%2A>属性。 这些属性仅用于初始化关联的进程。  
  
   
  
## Examples  
 下面的示例填充<xref:System.Diagnostics.Process.StartInfo%2A>在其上执行的操作与要执行的文件，和它是否应显示用户界面。 有关其他示例，请参阅属性参考页<xref:System.Diagnostics.ProcessStartInfo>类。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">指定 <see cref="P:System.Diagnostics.Process.StartInfo" /> 的值为 <see langword="null" />。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程启动的时间。</summary>
        <value>指示进程启动的时间的对象。 如果进程未运行，将会引发异常。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.StartTime" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <exception cref="T:System.InvalidOperationException">该进程已退出。  
  
 或  
  
 该进程尚未启动。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">调用 Windows 函数时出错。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于封送由于进程退出事件而发出的事件处理程序调用的对象。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" />，它用于封送由于进程上的 <see cref="E:System.Diagnostics.Process.Exited" /> 事件而发出的事件处理程序调用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>是`null`，方法，用于处理<xref:System.Diagnostics.Process.Exited>事件调用从系统线程池线程上。 有关系统线程池的详细信息，请参阅<xref:System.Threading.ThreadPool>。  
  
 当<xref:System.Diagnostics.Process.Exited>事件由 visual 的 Windows 窗体组件，如处理<xref:System.Windows.Forms.Button>，通过系统线程池访问组件可能不起作用，或者可能会导致异常。 通过设置来避免这<xref:System.Diagnostics.Process.SynchronizingObject%2A>到 Windows 窗体组件时，这将导致处理的方法<xref:System.Diagnostics.Process.Exited>事件在其创建该组件在同一线程上调用。  
  
 如果<xref:System.Diagnostics.Process>在内部使用[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]在 Windows 窗体设计器中，<xref:System.Diagnostics.Process.SynchronizingObject%2A>自动设置为包含的控件<xref:System.Diagnostics.Process>。 例如，如果你将放置<xref:System.Diagnostics.Process>的设计器上`Form1`(其继承自<xref:System.Windows.Forms.Form>)<xref:System.Diagnostics.Process.SynchronizingObject%2A>属性<xref:System.Diagnostics.Process>设置为的实例`Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 通常情况下，此属性设置时该组件放置在控件或窗体中，因为这些组件绑定到特定线程。  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在关联进程中运行的一组线程。</summary>
        <value>类型 <see cref="T:System.Diagnostics.ProcessThread" /> 的数组，表示当前在关联进程中运行的操作系统线程。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 线程在进程中执行代码。 每个进程开始使用单线程，其主线程。 任何线程可以创建其他线程。 在一个进程内的线程都共享进程的地址空间。  
  
 使用<xref:System.Diagnostics.ProcessThread>可获取与当前进程关联的所有线程。 主线程不一定是位于索引零数组中。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">进程没有 <see cref="P:System.Diagnostics.Process.Id" />，或者没有与 <see cref="T:System.Diagnostics.Process" /> 实例关联的进程。  
  
 或  
  
 关联进程已退出。</exception>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)；将 <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> 设置为 <see langword="false" />，以在 Windows 98 和 Windows Me 上访问此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果适用，则将进程的名称格式化为字符串，并与父组件类型组合。</summary>
        <returns>
          <see cref="P:System.Diagnostics.Process.ProcessName" />，与基组件的 <see cref="M:System.Object.ToString" /> 返回值组合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例启动记事本实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          Windows 98 不支持 <see cref="M:System.Diagnostics.Process.ToString" />。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此进程的总的处理器时间。</summary>
        <value>
          <see cref="T:System.TimeSpan" />，它指示关联进程使用 CPU 的时间。 此值是 <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> 和 <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> 的和。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例启动记事本实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此进程的用户处理器时间。</summary>
        <value>
          <see cref="T:System.TimeSpan" />，它指示关联进程在该进程的应用程序部分内(而不是在操作系统内核中)运行代码所用的时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下示例启动记事本实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示进程的退出代码。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <exception cref="T:System.NotSupportedException">你正试图访问在远程计算机上运行的进程的 <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> 属性。 此属性仅可用于本地计算机上运行的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取进程的虚拟内存大小（以字节为单位）。</summary>
        <value>关联进程请求的虚拟内存量(以字节为单位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联进程分配的虚拟内存量（以字节为单位）。</summary>
        <value>为关联进程分配的虚拟内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值表示使用的过程中，以字节为单位的虚拟内存的当前大小。 操作系统将映射到页加载在物理内存中，或存储在磁盘上的虚拟内存分页文件的页面的每个进程的虚拟地址空间。  
  
 此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。 属性值等于**虚拟字节**进程的性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的一个实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示其退出代码，峰值内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>设置等待关联进程退出的时间段，并在该段时间结束前或该进程退出前，阻止当前线程执行。 若要避免妨碍当前线程，请使用 <see cref="E:System.Diagnostics.Process.Exited" /> 事件。  
  
 有关代码示例，请参阅 <see cref="P:System.Diagnostics.Process.StandardError" /> 和 <see cref="P:System.Diagnostics.Process.ExitCode" /> 属性参考页。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示 <see cref="T:System.Diagnostics.Process" /> 组件无限期地等待关联进程退出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> 使当前线程等待，直到在关联的进程终止。  过程调用的所有其他方法后，应调用它。 若要避免妨碍当前线程，请使用 <xref:System.Diagnostics.Process.Exited> 事件。  
  
 此方法指示<xref:System.Diagnostics.Process>组件等待无限进程和事件处理程序退出的时间量。 这会导致应用程序停止响应。 例如，如果你调用<xref:System.Diagnostics.Process.CloseMainWindow%2A>对于具有用户界面的进程，对操作系统的请求，终止关联的进程可能不会处理如果进程被编写为从来不用输入其消息循环。  
  
> [!NOTE]
>  在[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]及早期版本、<xref:System.Diagnostics.Process.WaitForExit>重载会等待<xref:System.Int32.MaxValue>毫秒 （大约 24 天），并不是无限期。 此外，以前的版本不会等待事件处理程序，以退出如果完整<xref:System.Int32.MaxValue>时间已达到。  
  
 此重载可确保所有处理均已都完成，包括的重定向的标准输出的异步事件处理。 在调用后，应使用此重载<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>重载时标准输出已被重定向到异步事件处理程序。  
  
 当关联的进程退出 （即，当它关闭的情况下通过操作系统通过正常或不正常终止） 时，系统存储过程的管理信息，并返回到调用一样组件<xref:System.Diagnostics.Process.WaitForExit>。 <xref:System.Diagnostics.Process>组件然后可以访问的信息，其中包括<xref:System.Diagnostics.Process.ExitTime%2A>，通过使用<xref:System.Diagnostics.Process.Handle%2A>已退出进程。  
  
 关联的进程已退出，因为<xref:System.Diagnostics.Process.Handle%2A>组件属性不再指向现有进程资源。 相反，句柄仅用于访问有关的进程资源的操作系统的信息。 系统是不通过已发布的已退出进程的句柄感知<xref:System.Diagnostics.Process>组件，因此它会保留<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.Handle%2A>之前的内存中的信息<xref:System.Diagnostics.Process>组件明确释放这些资源。 出于此原因，任何时候您调用<xref:System.Diagnostics.Process.Start%2A>为<xref:System.Diagnostics.Process>实例时，调用<xref:System.Diagnostics.Process.Close%2A>当关联的进程已终止并不再需要有关它的任何管理信息。 <xref:System.Diagnostics.Process.Close%2A> 释放分配给已退出的进程的内存。  
  
   
  
## Examples  
 请参阅备注部分的<xref:System.Diagnostics.Process.StandardError%2A>属性参考页。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">无法访问等待设置。</exception>
        <exception cref="T:System.SystemException">尚未设置进程 <see cref="P:System.Diagnostics.Process.Id" />，而且不存在可从其确定 <see cref="P:System.Diagnostics.Process.Id" /> 属性的 <see cref="P:System.Diagnostics.Process.Handle" />。  
  
 或  
  
 没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。  
  
 或  
  
 你正尝试为远程计算机上运行的进程调用 <see cref="M:System.Diagnostics.Process.WaitForExit" />。 此方法仅对本地计算机上运行的进程可用。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">等待关联进程退出的时间(以毫秒为单位)。 最大值为 32 位整数的最大可能值，这对于操作系统而言表示无限大。</param>
        <summary>指示 <see cref="T:System.Diagnostics.Process" /> 组件在指定的毫秒数内等待关联进程退出。</summary>
        <returns>
          如果关联进程已退出，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 使当前线程等待，直到在关联的进程终止。 过程调用的所有其他方法后，应调用它。 若要避免妨碍当前线程，请使用 <xref:System.Diagnostics.Process.Exited> 事件。  
  
 此方法指示<xref:System.Diagnostics.Process>组件等待有限进程退出的时间量。 如果终止该请求被拒绝，因为，关联的进程不退出的时间间隔结束`false`被返回到调用的过程。 你可以指定<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>为`milliseconds`，和<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType>将的行为相同<xref:System.Diagnostics.Process.WaitForExit>重载。 如果向方法传递 0 （零），它将返回`true`仅当已经退出进程; 否则，它立即返回`false`。  
  
> [!NOTE]
>  在[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]和早期版本中，如果`milliseconds`是-1，<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>重载会等待<xref:System.Int32.MaxValue>毫秒 （大约 24 天），并不是无限期。  
  
 当已重标准输出定向到异步事件处理程序中时，有可能，输出处理还未完成此方法返回时。 若要确保已完成异步事件处理，调用<xref:System.Diagnostics.Process.WaitForExit>接收后不接受任何参数的重载`true`从此重载。 为了帮助确保<xref:System.Diagnostics.Process.Exited>在 Windows 窗体应用程序中正确处理事件，请将设置<xref:System.Diagnostics.Process.SynchronizingObject%2A>属性。  
  
 关联的进程的退出时 （正通过正常或异常终止操作系统关闭） 时，系统存储过程的管理信息并返回到调用一样组件<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>。 <xref:System.Diagnostics.Process>组件然后可以访问的信息，其中包括<xref:System.Diagnostics.Process.ExitTime%2A>，通过使用<xref:System.Diagnostics.Process.Handle%2A>已退出进程。  
  
 关联的进程已退出，因为<xref:System.Diagnostics.Process.Handle%2A>组件属性不再指向现有进程资源。 相反，句柄仅用于访问有关的进程资源的操作系统的信息。 系统是不通过已发布的已退出进程的句柄感知<xref:System.Diagnostics.Process>组件，因此它会保留<xref:System.Diagnostics.Process.ExitTime%2A>和<xref:System.Diagnostics.Process.Handle%2A>之前的内存中的信息<xref:System.Diagnostics.Process>组件明确释放这些资源。 出于此原因，任何时候您调用<xref:System.Diagnostics.Process.Start%2A>为<xref:System.Diagnostics.Process>实例时，调用<xref:System.Diagnostics.Process.Close%2A>当关联的进程已终止并不再需要有关它的任何管理信息。 <xref:System.Diagnostics.Process.Close%2A> 释放分配给已退出的进程的内存。  
  
   
  
## Examples  
 请参阅的代码示例<xref:System.Diagnostics.Process.ExitCode%2A>属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">无法访问等待设置。</exception>
        <exception cref="T:System.SystemException">尚未设置进程 <see cref="P:System.Diagnostics.Process.Id" />，而且不存在可从其确定 <see cref="P:System.Diagnostics.Process.Id" /> 属性的 <see cref="P:System.Diagnostics.Process.Handle" />。  
  
 或  
  
 没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。  
  
 或  
  
 你正尝试为远程计算机上运行的进程调用 <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />。 此方法仅对本地计算机上运行的进程可用。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="milliseconds" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使 <see cref="T:System.Diagnostics.Process" /> 组件等待关联进程进入空闲状态。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使 <see cref="T:System.Diagnostics.Process" /> 组件无限期地等待关联进程进入空闲状态。 此重载仅适用于具有用户界面并因此具有消息循环的进程。</summary>
        <returns>
          如果关联进程已经达到空闲状态，则为 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.Process.WaitForInputIdle>以强制应用程序消息循环已返回到空闲状态等待处理。 用户界面的进程执行时，其消息循环将执行每次操作系统的 Windows 消息发送到进程。 然后，该进程返回到消息循环。 说进程时它正在等待消息的消息循环内处于空闲状态。 此状态非常有用，例如，当你的应用程序需要等待启动的进程以完成创建其主窗口之前与该窗口的应用程序通信时。  
  
 如果进程不具有消息循环，<xref:System.Diagnostics.Process.WaitForInputIdle>引发<xref:System.InvalidOperationException>。  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle>重载指示<xref:System.Diagnostics.Process>组件无限期地等待进程变为空闲状态消息循环中。 此指令可能会导致应用程序停止响应。 例如，如果过程始终写入其消息循环立即退出，如下所示的代码片段`while(true)`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">进程不具有图形界面。  
  
 或  
  
 发生未知错误。 进程无法进入空闲状态。  
  
 或  
  
 已经退出该进程。  
  
 或  
  
 没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">1 到 <see cref="F:System.Int32.MaxValue" /> 的值以毫秒为单位指定了等待关联进程变为空闲状态的时间量。 0 值指定立即返回，而 -1 值则指定无限期等待。</param>
        <summary>使 <see cref="T:System.Diagnostics.Process" /> 组件在指定的毫秒数内等待关联进程进入空闲状态。 此重载仅适用于具有用户界面并因此具有消息循环的进程。</summary>
        <returns>
          如果关联进程已经达到空闲状态，则为 <see langword="true" />；否则，为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>以强制应用程序消息循环已返回到空闲状态等待处理。 用户界面的进程执行时，其消息循环将执行每次操作系统的 Windows 消息发送到进程。 然后，该进程返回到消息循环。 说进程时它正在等待消息的消息循环内处于空闲状态。 此状态非常有用，例如，当你的应用程序需要等待启动的进程以完成创建其主窗口之前与该窗口的应用程序通信时。  
  
 如果进程不具有消息循环，<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>引发<xref:System.InvalidOperationException>。  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>重载指示<xref:System.Diagnostics.Process>组件等待有限的进程变为空闲状态消息循环中的时间量。 如果关联的进程不具有进入空闲状态的时间间隔结束循环仍在处理消息，因为`false`被返回到调用的过程。  
  
 有关处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">进程不具有图形界面。  
  
 或  
  
 发生未知错误。 进程无法进入空闲状态。  
  
 或  
  
 已经退出该进程。  
  
 或  
  
 没有与此 <see cref="T:System.Diagnostics.Process" /> 对象关联的进程。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取关联进程的物理内存使用量（以字节为单位）。</summary>
        <value>关联进程当前使用的物理内存总量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值表示工作集内存使用的过程中，以字节为单位的当前大小。 进程工作集是物理 RAM 内存中的当前可见的进程的内存页的集合。 这些页面为常驻性并且可用于应用程序使用而不会触发页面错误。  
  
 工作集包括共享和私有数据。 共享的数据包括那些包含该进程执行，包括进程模块和系统库的所有说明的页。  
  
   
  
## Examples  
 以下示例启动记事本实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示进程的退出代码。  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为关联的进程分配的物理内存量（以字节为单位）。</summary>
        <value>为关的进程分配的物理内存量(以字节为单位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此属性的值表示工作集内存使用的过程中，以字节为单位的当前大小。 进程工作集是物理 RAM 内存中的当前可见的进程的内存页的集合。 这些页面为常驻性并且可用于应用程序使用而不会触发页面错误。  
  
 工作集包括共享和私有数据。 共享的数据包括那些包含该进程执行，包括进程模块和系统库中的说明的所有说明的页。  
  
 此属性可以用于监视与 32 位处理器或 64 位处理器的计算机上的内存使用情况。 属性值等于**工作集大小**进程的性能计数器。  
  
   
  
## Examples  
 下面的代码示例启动记事本应用程序的一个实例。 该示例然后检索并显示关联的进程的各种属性。 该示例检测时在进程退出，并显示其退出代码，峰值内存统计信息。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">该平台是 Windows 98 或 Windows Millennium Edition (Windows Me)，不支持此属性。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>