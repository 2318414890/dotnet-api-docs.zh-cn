<Type Name="PerformanceCounter" FullName="System.Diagnostics.PerformanceCounter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2d5b576ac4d02a0fac72c6d473bb056677092d91" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36343551" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class PerformanceCounter : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit PerformanceCounter extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.PerformanceCounter" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PerformanceCounter&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class PerformanceCounter sealed : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type PerformanceCounter = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.PerformanceCounterInstaller))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a Windows NT performance counter component.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounter>组件可以用于读取现有预定义或自定义计数器和发布 （写入） 性能数据到自定义计数器。  
  
 有许多 Windows 性能监视器中列出的预定义的计数器[添加计数器对话框](http://go.microsoft.com/fwlink/p/?LinkId=257854)。 若要了解有关.NET Framework 性能计数器，请参阅[性能计数器](~/docs/framework/debug-trace-profile/performance-counters.md)。  
  
 此类型实现<xref:System.IDisposable>接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，调用其<xref:System.IDisposable.Dispose%2A>中的方法`try` / `catch`块。 若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅中的"使用实现 IDisposable 的对象"部分<xref:System.IDisposable>接口主题。  
  
> [!IMPORTANT]
>  在版本 1.0 和 1.1 版.NET Framework 中，此类要求直接调用方是完全受信任。 从.NET Framework 2.0 版开始，此类要求<xref:System.Diagnostics.PerformanceCounterPermission>针对特定操作。 强烈建议<xref:System.Diagnostics.PerformanceCounterPermission>不授予给不完全受信任的代码。  能够读取和写入性能计数器允许代码执行操作，例如枚举执行进程和获取有关它们的信息。  
>   
>  此外，传递<xref:System.Diagnostics.PerformanceCounter>不太受信任代码的对象可以创建一个安全问题。 决不要将传递性能计数器对象，如<xref:System.Diagnostics.PerformanceCounterCategory>或<xref:System.Diagnostics.PerformanceCounter>到不太受信任的代码。  
  
 若要读取从性能计数器，创建的实例<xref:System.Diagnostics.PerformanceCounter>类中，设置<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，以及 （可选）<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>或<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>属性，，然后调用<xref:System.Diagnostics.PerformanceCounter.NextValue%2A>方法才能性能计数器读取。  
  
 若要发布性能计数器数据，创建一个或多个使用的自定义计数器<xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=nameWithType>方法，创建的实例<xref:System.Diagnostics.PerformanceCounter>类中，设置<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>，<xref:System.Diagnostics.PerformanceCounter.CounterName%2A>和 （可选）<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>或<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>属性，然后调用<xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>， <xref:System.Diagnostics.PerformanceCounter.Increment%2A>，或<xref:System.Diagnostics.PerformanceCounter.Decrement%2A>方法，或者设置<xref:System.Diagnostics.PerformanceCounter.RawValue%2A>属性可以更改你的自定义计数器的值。  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>， <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>，和<xref:System.Diagnostics.PerformanceCounter.Decrement%2A>方法使用联锁更新计数器值。 这将有助于避免计数器值准确多线程或多进程方案，但是也导致对性能产生负面影响。 如果你不需要互锁的准确性操作提供，你可以更新<xref:System.Diagnostics.PerformanceCounter.RawValue%2A>属性直接为多达 5 倍的性能提高。  但是，在多线程情况下，某些更新对计数器值可能会忽略，导致不准确的数据。  
  
 计数器是通过其上的性能收集数据的机制。 注册表存储的所有计数器，其中每个与相关的系统功能的特定区域的名称。 示例包括一个处理器忙碌时间、 内存使用情况或通过网络连接接收的字节数。  
  
 通过其名称和其位置唯一地标识每个计数器。 在文件路径包括驱动器、 目录、 一个或多个子目录和文件名称的方式相同，计数器信息包含以下四个元素： 计算机、 类别、 类别实例和计数器名称。  
  
 计数器信息必须包括类别中或性能对象，该计数器测量数据对象。 计算机的类别包括物理组件，如处理器、 磁盘和内存。 也有系统类别，如进程和线程。 每个类别相关的功能元素在计算机中，有一组标准计数器分配给它。 在 Windows 2000 的系统监视器中，添加计数器对话框的性能对象下拉列表中列出了这些对象，你必须将其包含的计数器路径中。 性能数据是按分组到类别与其相关。  
  
 在某些情况下，可以存在的相同类别的多个副本。 例如，几种进程和线程同时运行，而某些计算机包含多个处理器。 类别副本称为类别实例，并且每个实例都有一组分配给它的标准计数器。 如果某个类别可有多个实例，实例规范必须包含的计数器信息中。  
  
 若要获取执行必要的计算所需的初始或以前的值的计数器的性能数据，请调用<xref:System.Diagnostics.PerformanceCounter.NextValue%2A>方法两次，并使用返回的信息，根据你的应用程序的需要。  
  
> [!NOTE]
>  使用安装的性能计数器类别[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]使用单独的共享的内存，每个性能计数器类别都有自己的内存。 你可以通过创建 DWORD 注册表项 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services 中名为 FileMappingSize 指定单独的共享内存的大小\\*\<类别名称 >* \性能。 FileMappingSize 值设置为该类别的共享的内存大小。 默认大小为十进制的 131072。 如果不存在，FileMappingSize 值`fileMappingSize`特性值`performanceCounters`使用 Machine.config 文件中指定的元素时，导致的配置文件处理的其他开销。 您可以在注册表中设置的文件映射大小来实现应用程序启动时的性能改进。 有关文件映射大小的详细信息，请参阅[ &lt;performanceCounters&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/performancecounters-element.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将<xref:System.Diagnostics.PerformanceCounter>类创建和使用<xref:System.Diagnostics.PerformanceCounterType.AverageCount64>计数器类型。 上面的示例创建类别、 设置计数器，收集数据的计数器和调用从<xref:System.Diagnostics.CounterSampleCalculator>类来解释性能计数器数据。 为中间和最终结果将显示在控制台窗口中。 有关其他性能计数器类型的其他示例，请参阅<xref:System.Diagnostics.PerformanceCounterType>枚举。  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#1)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#1)]
 [!code-vb[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.PerformanceCounterType" />
    <altmember cref="T:System.Diagnostics.CounterCreationData" />
    <altmember cref="T:System.Diagnostics.CounterCreationDataCollection" />
    <altmember cref="T:System.Diagnostics.CounterSample" />
    <altmember cref="T:System.Diagnostics.CounterSampleCalculator" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直接调用方的完全信任。 此类不能由部分受信任的代码使用。</permission>
        <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.PerformanceCounter" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new, read-only instance of the <see cref="T:System.Diagnostics.PerformanceCounter" /> class, without associating the instance with any system or custom performance counter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载的构造函数集<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，和<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>属性设置为空字符串 ("")，并将设置<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>到本地计算机中，属性 ("。")。  
  
 此构造函数不会初始化性能计数器，以便不将该实例关联与本地计算机上的现有计数器。 若要指向特定性能计数器，设置<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，以及 （可选）<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>和<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>之前读取任何其他属性或尝试从计数器读取的属性。 若要写入的性能计数器，设置<xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A>属性`false`。  
  
> [!NOTE]
>  <xref:System.Security.Permissions.HostProtectionAttribute>应用于此成员的特性具有以下<xref:System.Security.Permissions.HostProtectionAttribute.Resources%2A>属性值： <xref:System.Security.Permissions.HostProtectionResource.Synchronization> &#124; <xref:System.Security.Permissions.HostProtectionResource.SharedState>。 <xref:System.Security.Permissions.HostProtectionAttribute> 不影响桌面应用程序（通常通过双击图标、键入命令或在浏览器中输入 URL 来启动这些应用程序）。 有关详细信息，请参阅<xref:System.Security.Permissions.HostProtectionAttribute>类或[SQL Server 编程和宿主保护特性](~/docs/framework/performance/sql-server-programming-and-host-protection-attributes.md)。  
  
   
  
## Examples  
 下面的代码示例创建的默认实例<xref:System.Diagnostics.PerformanceCounter>类。 创建实例后， <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，和<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>属性值设置了，以及对的调用结果<xref:System.Diagnostics.PerformanceCounter.NextValue%2A>方法会显示。  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Me), which does not support performance counters.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用于写入性能计数器类别，如果<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />属性是<see langword="false" />。 关联的枚举： <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">The name of the performance counter category (performance object) with which this performance counter is associated.</param>
        <param name="counterName">The name of the performance counter.</param>
        <summary>Initializes a new, read-only instance of the <see cref="T:System.Diagnostics.PerformanceCounter" /> class and associates it with the specified system or custom performance counter on the local computer. This constructor requires that the category have a single instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参数字符串不区分大小写。  
  
 此重载用于访问所属类别包含的单个性能计数器类别实例在本地计算机上的计数器。 如果你尝试使用此构造函数来指出这<xref:System.Diagnostics.PerformanceCounter>实例与包含多个实例，该构造函数引发异常的类别。 此重载可以访问任何只读或读/写计数器，但会在只读模式下。 A<xref:System.Diagnostics.PerformanceCounter>使用此重载创建的实例无法写入该计数器，即使该计数器本身是读/写。  
  
 此重载的构造函数集<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>和<xref:System.Diagnostics.PerformanceCounter.CounterName%2A>中传递的值的属性，设置<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>到本地计算机中，属性"。"，并将设置<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>属性为空字符串 ("")。  
  
 此构造函数初始化性能计数器，并将实例与本地计算机上的现有计数器 （系统或自定义计数器） 相关联。 您为传递的值<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>和<xref:System.Diagnostics.PerformanceCounter.CounterName%2A>属性必须指向本地计算机上的现有性能计数器。  
  
> [!NOTE]
>  若要读取 Windows Vista、 Windows XP Professional x64 Edition 或 Windows Server 2003 中的性能计数器，你必须是 Performance Monitor Users 组的成员或具有管理权限。  
>   
>  若要避免无需提升你的特权来访问在 Windows Vista 中的性能计数器，请将自己添加到 Performance Monitor Users 组。  
>   
>  在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> is an empty string ("").  -or-  <paramref name="counterName" /> is an empty string ("").  -or-  The category specified does not exist.  -or-  The category specified is marked as multi-instance and requires the performance counter to be created with an instance name.  -or-  <paramref name="categoryName" /> and <paramref name="counterName" /> have been localized into different languages.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> or <paramref name="counterName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when accessing a system API.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Me), which does not support performance counters.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code that is executing without administrative privileges attempted to read a performance counter.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用于写入性能计数器类别，如果<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />属性是<see langword="false" />。 关联的枚举： <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, bool readOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, bool readOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, readOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, bool readOnly);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * bool -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, readOnly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="readOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="categoryName">The name of the performance counter category (performance object) with which this performance counter is associated.</param>
        <param name="counterName">The name of the performance counter.</param>
        <param name="readOnly">
          <see langword="true" /> to access the counter in read-only mode (although the counter itself could be read/write); <see langword="false" /> to access the counter in read/write mode.</param>
        <summary>Initializes a new, read-only or read/write instance of the <see cref="T:System.Diagnostics.PerformanceCounter" /> class and associates it with the specified system or custom performance counter on the local computer. This constructor requires that the category contain a single instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参数字符串不区分大小写。  
  
 此重载用于访问的只读或读/写所属类别包含的单个性能计数器类别实例在本地计算机上的计数器。 如果你尝试使用此构造函数来指出这<xref:System.Diagnostics.PerformanceCounter>实例与包含多个实例，该构造函数引发异常的类别。  
  
 此重载的构造函数集<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，和<xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A>中传递的值的属性，设置<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>到本地计算机中，属性"。"，并将设置<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>属性为空字符串 ("")。  
  
 此构造函数初始化性能计数器，并将实例与本地计算机上的现有计数器 （系统或自定义计数器） 相关联。 您为传递的值<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>和<xref:System.Diagnostics.PerformanceCounter.CounterName%2A>属性必须指向本地计算机上的现有性能计数器。 如果你指向的性能计数器实例不是有效的调用的构造函数引发异常。  
  
> [!NOTE]
>  你可以使用此重载以连接到系统计数器，但无法写入到系统计数器。 因此，设置`readOnly`到`false`时连接到系统计数器引发构造函数引发异常。  
  
> [!NOTE]
>  若要读取 Windows Vista、 Windows XP Professional x64 Edition 或 Windows Server 2003 中的性能计数器，你必须是 Performance Monitor Users 组的成员或具有管理权限。  
>   
>  若要避免无需提升你的特权来访问在 Windows Vista 中的性能计数器，请将自己添加到 Performance Monitor Users 组。  
>   
>  在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
   
  
## Examples  
 下面的代码示例创建的实例<xref:System.Diagnostics.PerformanceCounter>类。 此示例传入类别名称、 计数器名称和标志值，该值指示计数器不只读的。 此代码示例是一个更大的示例的一部分<xref:System.Diagnostics.PerformanceCounter>类。  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#2)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#2)]
 [!code-vb[PerformanceCounterType.AverageCounter64#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <paramref name="categoryName" /> is an empty string ("").  -or-  The <paramref name="counterName" /> is an empty string ("").  -or-  The category specified does not exist. (if <paramref name="readOnly" /> is <see langword="true" />).  -or-  The category specified is not a .NET Framework custom category (if <paramref name="readOnly" /> is <see langword="false" />).  -or-  The category specified is marked as multi-instance and requires the performance counter to be created with an instance name.  -or-  <paramref name="categoryName" /> and <paramref name="counterName" /> have been localized into different languages.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> or <paramref name="counterName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when accessing a system API.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Me), which does not support performance counters.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code that is executing without administrative privileges attempted to read a performance counter.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用于写入性能计数器类别，如果<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />属性是<see langword="false" />。 关联的枚举： <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">The name of the performance counter category (performance object) with which this performance counter is associated.</param>
        <param name="counterName">The name of the performance counter.</param>
        <param name="instanceName">The name of the performance counter category instance, or an empty string (""), if the category contains a single instance.</param>
        <summary>Initializes a new, read-only instance of the <see cref="T:System.Diagnostics.PerformanceCounter" /> class and associates it with the specified system or custom performance counter and category instance on the local computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参数字符串不区分大小写。  
  
 此重载的构造函数集<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，和<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>属性的值传入，并设置<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>到本地计算机中，属性"。"。  
  
 此构造函数初始化性能计数器，并将实例与本地计算机上的现有计数器 （系统或自定义计数器） 相关联。 您为传递的值<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，和<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>属性必须指向本地计算机上的现有性能计数器。 如果你指向的性能计数器实例不是有效的调用的构造函数引发异常。  
  
 此重载可以访问任何只读或读/写计数器，但会在只读模式下。 A<xref:System.Diagnostics.PerformanceCounter>使用此重载创建的实例无法写入该计数器，即使该计数器本身是读/写。  
  
 若要创建的性能类别实例，指定`instanceName`上<xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>构造函数。 如果指定的类别实例`instanceName`已存在的新对象将引用现有的类别实例。  
  
> [!NOTE]
>  若要读取 Windows Vista、 Windows XP Professional x64 Edition 或 Windows Server 2003 中的性能计数器，你必须是 Performance Monitor Users 组的成员或具有管理权限。  
>   
>  若要避免无需提升你的特权来访问在 Windows Vista 中的性能计数器，请将自己添加到 Performance Monitor Users 组。  
>   
>  在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> is an empty string ("").  -or-  <paramref name="counterName" /> is an empty string ("").  -or-  The category specified is not valid.  -or-  The category specified is marked as multi-instance and requires the performance counter to be created with an instance name.  -or-  <paramref name="instanceName" /> is longer than 127 characters.  -or-  <paramref name="categoryName" /> and <paramref name="counterName" /> have been localized into different languages.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> or <paramref name="counterName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when accessing a system API.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Me), which does not support performance counters.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code that is executing without administrative privileges attempted to read a performance counter.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用于写入性能计数器类别，如果<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />属性是<see langword="false" />。 关联的枚举： <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName, bool readOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName, bool readOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String, readOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName, bool readOnly);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string * bool -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName, readOnly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="readOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="categoryName">The name of the performance counter category (performance object) with which this performance counter is associated.</param>
        <param name="counterName">The name of the performance counter.</param>
        <param name="instanceName">The name of the performance counter category instance, or an empty string (""), if the category contains a single instance.</param>
        <param name="readOnly">
          <see langword="true" /> to access a counter in read-only mode; <see langword="false" /> to access a counter in read/write mode.</param>
        <summary>Initializes a new, read-only or read/write instance of the <see cref="T:System.Diagnostics.PerformanceCounter" /> class and associates it with the specified system or custom performance counter and category instance on the local computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参数字符串不区分大小写。  
  
 此重载用于访问性能计数器中任意一种只读或读/写模式。  
  
 此重载的构造函数集<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，和<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>在中，它并设置传递到值的属性<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>到本地计算机中，属性"。"。  
  
 此构造函数初始化性能计数器，并将实例与本地计算机上的现有计数器 （系统或自定义计数器） 相关联。 您为传递的值<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，和<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>属性必须指向本地计算机上的现有性能计数器。 如果你指向的性能计数器实例不是有效的调用的构造函数引发异常。  
  
> [!NOTE]
>  你可以使用此重载以连接到系统计数器，但无法写入到系统计数器。 因此，设置`readOnly`到`false`时连接到系统计数器引发构造函数引发异常。  
  
 若要创建的性能类别实例，指定`instanceName`上<xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>构造函数。 如果指定的类别实例`instanceName`已存在的新对象将引用现有的类别实例。  
  
> [!NOTE]
>  若要读取 Windows Vista、 Windows XP Professional x64 Edition 或 Windows Server 2003 中的性能计数器，你必须是 Performance Monitor Users 组的成员或具有管理权限。  
>   
>  若要避免无需提升你的特权来访问在 Windows Vista 中的性能计数器，请将自己添加到 Performance Monitor Users 组。  
>   
>  在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> is an empty string ("").  -or-  <paramref name="counterName" /> is an empty string ("").  -or-  The read/write permission setting requested is invalid for this counter.  -or-  The category specified does not exist (if <paramref name="readOnly" /> is <see langword="true" />).  -or-  The category specified is not a .NET Framework custom category (if <paramref name="readOnly" /> is <see langword="false" />).  -or-  The category specified is marked as multi-instance and requires the performance counter to be created with an instance name.  -or-  <paramref name="instanceName" /> is longer than 127 characters.  -or-  <paramref name="categoryName" /> and <paramref name="counterName" /> have been localized into different languages.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> or <paramref name="counterName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when accessing a system API.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Me), which does not support performance counters.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code that is executing without administrative privileges attempted to read a performance counter.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用于写入性能计数器类别，如果<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />属性是<see langword="false" />。 关联的枚举： <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PerformanceCounter (string categoryName, string counterName, string instanceName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string categoryName, string counterName, string instanceName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (categoryName As String, counterName As String, instanceName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PerformanceCounter(System::String ^ categoryName, System::String ^ counterName, System::String ^ instanceName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.PerformanceCounter : string * string * string * string -&gt; System.Diagnostics.PerformanceCounter" Usage="new System.Diagnostics.PerformanceCounter (categoryName, counterName, instanceName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="categoryName" Type="System.String" />
        <Parameter Name="counterName" Type="System.String" />
        <Parameter Name="instanceName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="categoryName">The name of the performance counter category (performance object) with which this performance counter is associated.</param>
        <param name="counterName">The name of the performance counter.</param>
        <param name="instanceName">The name of the performance counter category instance, or an empty string (""), if the category contains a single instance.</param>
        <param name="machineName">The computer on which the performance counter and its associated category exist.</param>
        <summary>Initializes a new, read-only instance of the <see cref="T:System.Diagnostics.PerformanceCounter" /> class and associates it with the specified system or custom performance counter and category instance, on the specified computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参数字符串不区分大小写。  
  
 此重载的构造函数集<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>， <xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>，和<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>中传递的值的属性。  
  
 此构造函数初始化性能计数器，并将实例与指定的计算机上的现有计数器 （系统或自定义计数器） 相关联。 您为传递的值<xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>和<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>属性必须指向现有的性能计数器。 如果你指向的性能计数器实例不是有效的调用的构造函数引发异常。 此重载可以访问任何只读或读/写计数器，但会在只读模式下。 A<xref:System.Diagnostics.PerformanceCounter>使用此重载创建的实例无法写入该计数器，即使该计数器本身是读/写。  
  
> [!NOTE]
>  无法写入远程性能计数器。 没有任何重载均不允许你指定的读/写实例<xref:System.Diagnostics.PerformanceCounter>连接到远程计算机的类。  
  
 若要创建的性能类别实例，指定`instanceName`上<xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>构造函数。 如果指定的类别实例`instanceName`已存在的新对象将引用现有的类别实例。  
  
> [!NOTE]
>  若要读取 Windows Vista、 Windows XP Professional x64 Edition 或 Windows Server 2003 中的性能计数器，你必须是 Performance Monitor Users 组的成员或具有管理权限。  
>   
>  若要避免无需提升你的特权来访问在 Windows Vista 中的性能计数器，请将自己添加到 Performance Monitor Users 组。  
>   
>  在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
> [!NOTE]
>  在 Windows Vista 中，当远程计算机为属于工作组中，你可能需要禁用 UAC，以便本地用户帐户未进行筛选，并可以将提升为管理员帐户。 出于安全原因，禁用 UAC 应为最后一招。 在禁用 UAC 的信息，请参阅[用户帐户控制和 WMI](http://go.microsoft.com/fwlink/?LinkId=91617)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="categoryName" /> is an empty string ("").  -or-  <paramref name="counterName" /> is an empty string ("").  -or-  The read/write permission setting requested is invalid for this counter.  -or-  The counter does not exist on the specified computer.  -or-  The category specified is marked as multi-instance and requires the performance counter to be created with an instance name.  -or-  <paramref name="instanceName" /> is longer than 127 characters.  -or-  <paramref name="categoryName" /> and <paramref name="counterName" /> have been localized into different languages.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="machineName" /> parameter is not valid.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="categoryName" /> or <paramref name="counterName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when accessing a system API.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Me), which does not support performance counters.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code that is executing without administrative privileges attempted to read a performance counter.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用于写入性能计数器类别，如果<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />属性是<see langword="false" />。 关联的枚举： <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="performanceCounter.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins the initialization of a <see cref="T:System.Diagnostics.PerformanceCounter" /> instance used on a form or by another component. The initialization occurs at runtime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]设计环境使用此方法来启动一个组件，窗体或由另一个组件使用的初始化。 <xref:System.Diagnostics.PerformanceCounter.EndInit%2A>方法初始化已结束。 使用<xref:System.Diagnostics.PerformanceCounter.BeginInit%2A>和<xref:System.Diagnostics.PerformanceCounter.EndInit%2A>方法阻止完全初始化之前使用该组件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CategoryName">
      <MemberSignature Language="C#" Value="public string CategoryName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CategoryName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CategoryName" />
      <MemberSignature Language="VB.NET" Value="Public Property CategoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CategoryName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CategoryName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.CategoryName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CategoryValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the performance counter category for this performance counter.</summary>
        <value>此性能计数器与之关联的性能计数器类别 （性能对象） 的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>中显示`Performance Object`字段的性能计数器管理器 MMC 管理单元中`Add Counter`对话框。  
  
 性能计数器监视类别中或计算机上的性能对象的行为。 类别包括物理组件 （如处理器、 磁盘和内存） 和系统对象 （如进程和线程）。 与相同的性能对象相关的系统计数器都分组到类别，该值指示其常见的焦点。 当你创建的实例<xref:System.Diagnostics.PerformanceCounter>类，你首先指示该组件将进行交互，且然后从该类别中选择一个计数器的类别。  
  
 例如，一个 Windows 计数器类别是内存类别。 此类别中的系统计数器跟踪内存数据，如可用的字节数和缓存的字节数。 如果你想要使用在你的应用程序中缓存的字节，则将创建的实例<xref:System.Diagnostics.PerformanceCounter>组件，将其连接到内存类别，然后挑选该类别中的相应计数器 （在此情况下，缓存字节）。  
  
 尽管你的系统可以使许多更多计数器类别可用，你将可能与之交互最频繁的类别将是缓存、 内存、 对象、 物理磁盘、 过程、 处理器、 服务器、 系统和线程类别。  
  
   
  
## Examples  
 下面的代码示例创建的默认实例<xref:System.Diagnostics.PerformanceCounter>类。 创建实例后， <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，和<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>属性值设置了，以及对的调用结果<xref:System.Diagnostics.PerformanceCounter.NextValue%2A>方法会显示。  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="P:System.Diagnostics.PerformanceCounter.CategoryName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Me), which does not support performance counters.</exception>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="performanceCounter.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes the performance counter and frees all the resources allocated by this performance counter instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此关联时<xref:System.Diagnostics.PerformanceCounter>实例驻留在服务器上，系统的性能计数器初始化实例，并分配内存以包含计数器样本信息。 <xref:System.Diagnostics.PerformanceCounter.Close%2A>方法释放由对象分配的资源。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseSharedResources">
      <MemberSignature Language="C#" Value="public static void CloseSharedResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CloseSharedResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.CloseSharedResources" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CloseSharedResources ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CloseSharedResources();" />
      <MemberSignature Language="F#" Value="static member CloseSharedResources : unit -&gt; unit" Usage="System.Diagnostics.PerformanceCounter.CloseSharedResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Frees the performance counter library shared state allocated by the counters.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用于读取性能计数器类别。 关联的枚举： <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CounterHelp">
      <MemberSignature Language="C#" Value="public string CounterHelp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CounterHelp" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterHelp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterHelp As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CounterHelp { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CounterHelp : string" Usage="System.Diagnostics.PerformanceCounter.CounterHelp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("A description describing the counter.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the description for this performance counter.</summary>
        <value>此性能计数器测量的数量或项的说明。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 显示性能计数器管理器 MMC 管理单元的添加计数器对话框<xref:System.Diagnostics.PerformanceCounter.CounterHelp%2A>当用户从计数器列表中选择一个计数器，并单击解释按钮的文本。  
  
 创建新的计数器，请使用<xref:System.Diagnostics.PerformanceCounter.CounterHelp%2A>文本以描述该计数器的监视器执行操作，以便用户可以确定是否将计数器添加到系统监视器的显示。  
  
> [!NOTE]
>  如果值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>属性是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process>和性能计数器类别使用.NET Framework 版本 1.0 或 1.1 版中，创建<xref:System.InvalidOperationException>引发。 使用早期版本创建的性能计数器类别使用全局共享的内存，并且的值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>必须<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。 如果在版本 1.0 或 1.1 的.NET framework 上运行的应用程序不使用类别，删除并重新创建该类别。  
  
> [!NOTE]
>  若要读取 Windows Vista、 Windows XP Professional x64 Edition 或 Windows Server 2003 中的性能计数器，你必须是 Performance Monitor Users 组的成员或具有管理权限。  
>   
>  若要避免无需提升你的特权来访问在 Windows Vista 中的性能计数器，请将自己添加到 Performance Monitor Users 组。  
>   
>  在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Diagnostics.PerformanceCounter" /> instance is not associated with a performance counter.  -or-  The <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> property is set to <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> when using global shared memory.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Me), which does not support performance counters.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code that is executing without administrative privileges attempted to read a performance counter.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用于读取性能计数器类别。 关联的枚举： <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CounterName">
      <MemberSignature Language="C#" Value="public string CounterName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CounterName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterName" />
      <MemberSignature Language="VB.NET" Value="Public Property CounterName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CounterName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CounterName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.CounterName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.CounterNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the performance counter that is associated with this <see cref="T:System.Diagnostics.PerformanceCounter" /> instance.</summary>
        <value>该计数器，通常描述所计算的数量的名称。 此名称显示在列表中计数器的性能计数器管理器 MMC 管理单元中的添加计数器对话框。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以获取可用预先存在的计数器列表从 Windows 性能管理器的[添加计数器对话框](http://go.microsoft.com/fwlink/p/?LinkId=257854)。  
  
   
  
## Examples  
 下面的代码示例演示如何设置<xref:System.Diagnostics.PerformanceCounter.CounterName%2A>为典型的计数器名称的属性。  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="P:System.Diagnostics.PerformanceCounter.CounterName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Me), which does not support performance counters.</exception>
      </Docs>
    </Member>
    <Member MemberName="CounterType">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterType CounterType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterType CounterType" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.CounterType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterType As PerformanceCounterType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterType CounterType { System::Diagnostics::PerformanceCounterType get(); };" />
      <MemberSignature Language="F#" Value="member this.CounterType : System.Diagnostics.PerformanceCounterType" Usage="System.Diagnostics.PerformanceCounter.CounterType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The type of the counter.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the counter type of the associated performance counter.</summary>
        <value>A<see cref="T:System.Diagnostics.PerformanceCounterType" />描述同时监视应用程序和它包含的值的性质与计数器交互的方式 (例如，计算和非计算所得)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.PerformanceCounterType>枚举包含性能计数器可与之交互的类型。 某些计数器类型表示计算所得的值，如系统已进行的计数器度量值的平均值。 其他类型表示原始，或非计算所得，值。 下表显示将与最常交互的计数器类型。  
  
|计数器的责任|PerformanceCounterType 值|示例|  
|------------------------------|----------------------------------|-------------|  
|维护项或操作的简单的计数。|`NumberOfItems32`|跟踪收到作为 32 位整数的订单数。|  
|维护更高容量简单计数。|`NumberOfItems64`|跟踪的订单量很大的站点的数量，存储为一个 64 位整数。|  
|跟踪项目或每秒的操作的数目。|`RateOfCountsPerSecond32`|在站点上每秒接收的跟踪订单。|  
|跟踪项目或每秒操作数更高容量的数目。|`RateOfCountsPerSecond64`|跟踪订单上每秒钟接收非常高容量的站点。|  
|计算的平均时间来执行进程或处理项目|`AverageTimer32`|计算一份订单所要处理的平均时间。|  
  
 在创建其类型需要使用相应的基本计数器的计数器时，您必须声明的计数器和中的基本<xref:System.Diagnostics.CounterCreationDataCollection>则将传递给<xref:System.Diagnostics.PerformanceCounterCategory.Create%2A?displayProperty=nameWithType>方法。  
  
> [!NOTE]
>  如果值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>属性是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process>和性能计数器类别使用.NET Framework 版本 1.0 或 1.1 版中，创建<xref:System.InvalidOperationException>引发。 使用早期版本创建的性能计数器类别使用全局共享的内存，并且的值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>必须<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。 如果在版本 1.0 或 1.1 的.NET framework 上运行的应用程序不使用类别，删除并重新创建该类别。  
  
> [!NOTE]
>  若要读取 Windows Vista、 Windows XP Professional x64 Edition 或 Windows Server 2003 中的性能计数器，你必须是 Performance Monitor Users 组的成员或具有管理权限。  
>   
>  若要避免无需提升你的特权来访问在 Windows Vista 中的性能计数器，请将自己添加到 Performance Monitor Users 组。  
>   
>  在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The instance is not correctly associated with a performance counter.  -or-  The <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> property is set to <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> when using global shared memory.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Me), which does not support performance counters.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code that is executing without administrative privileges attempted to read a performance counter.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用于读取性能计数器类别。 关联的枚举： <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />。</permission>
        <altmember cref="T:System.Diagnostics.PerformanceCounterType" />
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public long Decrement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Decrement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Decrement" />
      <MemberSignature Language="VB.NET" Value="Public Function Decrement () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Decrement();" />
      <MemberSignature Language="F#" Value="member this.Decrement : unit -&gt; int64" Usage="performanceCounter.Decrement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Decrements the associated performance counter by one through an efficient atomic operation.</summary>
        <returns>The decremented counter value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以编写仅向自定义计数器。 所有系统计数器都是只读的。  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>， <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>，和<xref:System.Diagnostics.PerformanceCounter.Decrement%2A>方法使用联锁更新计数器值。 这将有助于避免计数器值准确多线程或多进程方案，但是也导致对性能产生负面影响。 如果你不需要互锁的准确性操作提供，你可以更新<xref:System.Diagnostics.PerformanceCounter.RawValue%2A>属性直接为多达 5 倍的性能提高。  但是，在多线程情况下，某些更新对计数器值可能会忽略，导致不准确的数据。  
  
> [!NOTE]
>  如果值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>属性是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process>和性能计数器类别使用.NET Framework 版本 1.0 或 1.1 版中，创建<xref:System.InvalidOperationException>引发。 使用早期版本创建的性能计数器类别使用全局共享的内存，并且的值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>必须<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。 如果在版本 1.0 或 1.1 的.NET framework 上运行的应用程序不使用类别，删除并重新创建该类别。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The counter is read-only, so the application cannot decrement it.  -or-  The instance is not correctly associated with a performance counter.  -or-  The <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> property is set to <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> when using global shared memory.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when accessing a system API.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Me), which does not support performance counters.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用于写入性能计数器类别，如果<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />属性是<see langword="false" />。 关联的枚举： <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
        <threadsafe>此方法是线程安全的。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="DefaultFileMappingSize">
      <MemberSignature Language="C#" Value="public static int DefaultFileMappingSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static int32 DefaultFileMappingSize" />
      <MemberSignature Language="DocId" Value="F:System.Diagnostics.PerformanceCounter.DefaultFileMappingSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared DefaultFileMappingSize As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static int DefaultFileMappingSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultFileMappingSize : int" Usage="System.Diagnostics.PerformanceCounter.DefaultFileMappingSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies the size, in bytes, of the global memory shared by performance counters. The default size is 524,288 bytes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="performanceCounter.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="performanceCounter.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ends the initialization of a <see cref="T:System.Diagnostics.PerformanceCounter" /> instance that is used on a form or by another component. The initialization occurs at runtime.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]设计环境使用此方法来结束用于窗体或由另一个组件使用的组件的初始化。 <xref:System.Diagnostics.PerformanceCounter.BeginInit%2A>方法开始初始化。 使用<xref:System.Diagnostics.PerformanceCounter.BeginInit%2A>和<xref:System.Diagnostics.PerformanceCounter.EndInit%2A>方法阻止完全初始化之前使用该组件。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用于写入性能计数器类别，如果<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />属性是<see langword="false" />。 关联的枚举： <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public long Increment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Increment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.Increment" />
      <MemberSignature Language="VB.NET" Value="Public Function Increment () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Increment();" />
      <MemberSignature Language="F#" Value="member this.Increment : unit -&gt; int64" Usage="performanceCounter.Increment " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Increments the associated performance counter by one through an efficient atomic operation.</summary>
        <returns>The incremented counter value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以编写仅向自定义计数器。 所有系统计数器都是只读的。  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>， <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>，和<xref:System.Diagnostics.PerformanceCounter.Decrement%2A>方法使用联锁更新计数器值。 这将有助于避免计数器值准确多线程或多进程方案，但是也导致对性能产生负面影响。 如果你不需要互锁的准确性操作提供，你可以更新<xref:System.Diagnostics.PerformanceCounter.RawValue%2A>属性直接为多达 5 倍的性能提高。  但是，在多线程情况下，某些更新对计数器值可能会忽略，导致不准确的数据。  
  
> [!NOTE]
>  如果值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>属性是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process>和性能计数器类别使用.NET Framework 版本 1.0 或 1.1 版中，创建<xref:System.InvalidOperationException>引发。 使用早期版本创建的性能计数器类别使用全局共享的内存，并且的值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>必须<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。 如果在版本 1.0 或 1.1 的.NET framework 上运行的应用程序不使用类别，删除并重新创建该类别。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The counter is read-only, so the application cannot increment it.  -or-  The instance is not correctly associated with a performance counter.  -or-  The <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> property is set to <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> when using global shared memory.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when accessing a system API.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Me), which does not support performance counters.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用于写入性能计数器类别，如果<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />属性是<see langword="false" />。 关联的枚举： <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
        <threadsafe>此方法是线程安全的。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="IncrementBy">
      <MemberSignature Language="C#" Value="public long IncrementBy (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 IncrementBy(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.IncrementBy(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function IncrementBy (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long IncrementBy(long value);" />
      <MemberSignature Language="F#" Value="member this.IncrementBy : int64 -&gt; int64" Usage="performanceCounter.IncrementBy value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">The value to increment by. (A negative value decrements the counter.)</param>
        <summary>Increments or decrements the value of the associated performance counter by a specified amount through an efficient atomic operation.</summary>
        <returns>The new counter value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以编写仅向自定义计数器。 所有系统计数器都是只读的。  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>， <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>，和<xref:System.Diagnostics.PerformanceCounter.Decrement%2A>方法使用联锁更新计数器值。 这将有助于避免计数器值准确多线程或多进程方案，但是也导致对性能产生负面影响。 如果你不需要互锁的准确性操作提供，你可以更新<xref:System.Diagnostics.PerformanceCounter.RawValue%2A>属性直接为多达 5 倍的性能提高。  但是，在多线程情况下，某些更新对计数器值可能会忽略，导致不准确的数据。  
  
> [!NOTE]
>  如果值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>属性是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process>和性能计数器类别使用.NET Framework 版本 1.0 或 1.1 版中，创建<xref:System.InvalidOperationException>引发。 使用早期版本创建的性能计数器类别使用全局共享的内存，并且的值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>必须<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。 如果在版本 1.0 或 1.1 的.NET framework 上运行的应用程序不使用类别，删除并重新创建该类别。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>方法来向计数器递增。 此代码示例是一个更大的示例的一部分<xref:System.Diagnostics.PerformanceCounter>类。  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#3)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#3)]
 [!code-vb[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The counter is read-only, so the application cannot increment it.  -or-  The instance is not correctly associated with a performance counter.  -or-  The <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> property is set to <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> when using global shared memory.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when accessing a system API.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Me), which does not support performance counters.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用于写入性能计数器类别，如果<see cref="P:System.Diagnostics.PerformanceCounter.ReadOnly" />属性是<see langword="false" />。 关联的枚举： <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
        <threadsafe>此方法是线程安全的。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="InstanceLifetime">
      <MemberSignature Language="C#" Value="public System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.PerformanceCounterInstanceLifetime InstanceLifetime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceLifetime As PerformanceCounterInstanceLifetime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::PerformanceCounterInstanceLifetime InstanceLifetime { System::Diagnostics::PerformanceCounterInstanceLifetime get(); void set(System::Diagnostics::PerformanceCounterInstanceLifetime value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceLifetime : System.Diagnostics.PerformanceCounterInstanceLifetime with get, set" Usage="System.Diagnostics.PerformanceCounter.InstanceLifetime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.PerformanceCounterInstanceLifetime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the lifetime of a process.</summary>
        <value>
          <see cref="T:System.Diagnostics.PerformanceCounterInstanceLifetime" /> 值之一。 默认值为 <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Global" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用.NET Framework 版本 1.0 或 1.1 创建性能计数器类别时，它使用全局共享的内存，并且的值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>必须<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。 如果在版本 1.0 或 1.1 的.NET framework 上运行的应用程序不使用类别，删除并重新创建该类别。  
  
> [!NOTE]
>  如果值<xref:System.Diagnostics.PerformanceCounter.CounterType%2A>属性是<xref:System.Diagnostics.PerformanceCounterCategoryType.SingleInstance>、<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>值必须是性能计数器<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value set is not a member of the <see cref="T:System.Diagnostics.PerformanceCounterInstanceLifetime" /> enumeration.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> is set after the <see cref="T:System.Diagnostics.PerformanceCounter" /> has been initialized.</exception>
      </Docs>
    </Member>
    <Member MemberName="InstanceName">
      <MemberSignature Language="C#" Value="public string InstanceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InstanceName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.InstanceName" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InstanceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.InstanceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.InstanceNameConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an instance name for this performance counter.</summary>
        <value>性能计数器类别实例或空字符串的名称 ("")，如果计数器为单实例的计数器。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  实例名称必须少于 128 个字符的长度。  
  
 在某些情况下，类别分为实例，跟踪有关类别相关的对象的多个匹配项的数据。 实例应用于整个类别，而不是各个计数器。 在类别中的每个计数器都有该类别定义的每个实例。 例如，进程类别包含名为空闲和系统的实例。 进程类别中的每个计数器因此包含每个实例，其中显示了有关空闲的进程或系统进程的信息的数据。  
  
 许多类别不包含多个实例，因此，你可以将此属性为空，指示没有实例都与类别关联。  
  
 如果此<xref:System.Diagnostics.PerformanceCounter>实例指向非自定义类别中，你可以选择从仅对现有的类别实例。 你可以仅在自定义的类别，可用于定义为多个计数器和类别需要实例中创建新类别实例。  
  
 若要创建的性能类别实例，指定`instanceName`上<xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>构造函数。 如果指定的类别实例`instanceName`已存在的新对象将引用现有的类别实例。  
  
> [!NOTE]
>  不使用字符"（"，"）"，"#"、"\\"，或"/"中的实例名称。 如果使用上述任一字符，则性能控制台 (请参阅[运行时分析](~/docs/framework/debug-trace-profile/runtime-profiling.md)) 可能无法正确显示实例值。  
  
 如果实例名称自动生成的并且可能包含字符"（"，"）"，"#"、"\\"，或"/"，使用下表中的字符映射。  
  
|字符|映射的字符|  
|---------------|----------------------|  
|(|[|  
|)|]|  
|#|_|  
|\|_|  
|/|_|  
  
 <xref:System.AppDomain.FriendlyName%2A>属性<xref:System.AppDomain>获取从对象<xref:System.AppDomain.CurrentDomain%2A?displayProperty=nameWithType>属性是实例名称可包含无效字符的一个常见原因。  
  
   
  
## Examples  
 下面的代码示例创建的默认实例<xref:System.Diagnostics.PerformanceCounter>类。 创建实例后， <xref:System.Diagnostics.PerformanceCounter.CategoryName%2A>， <xref:System.Diagnostics.PerformanceCounter.CounterName%2A>，和<xref:System.Diagnostics.PerformanceCounter.InstanceName%2A>属性值设置了，以及对的调用结果<xref:System.Diagnostics.PerformanceCounter.NextValue%2A>方法会显示。  
  
 [!code-cpp[PerfCounter#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerfCounter/CPP/perfcounter.cpp#1)]
 [!code-csharp[PerfCounter#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerfCounter/CS/perfcounter.cs#1)]
 [!code-vb[PerfCounter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerfCounter/VB/perfcounter.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.PerformanceCounter.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO("What's the machine name format?")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the computer name for this performance counter</summary>
        <value>在其的性能计数器和其关联的类别所驻留的服务器。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以在本地计算机上写入仅对驻留的计数器的值。 但是，你可以读取计数器值从为其企业中的任何计算机具有访问权限。  
  
 当你将设置<xref:System.Diagnostics.PerformanceCounter.MachineName%2A>属性以指向远程计算机，<xref:System.Diagnostics.PerformanceCounter>实例会尝试打开该计算机上的计数器。 如果计数器不存在，则设置此属性将引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Diagnostics.PerformanceCounter.MachineName" /> format is invalid.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Me), which does not support performance counters.</exception>
      </Docs>
    </Member>
    <Member MemberName="NextSample">
      <MemberSignature Language="C#" Value="public System.Diagnostics.CounterSample NextSample ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Diagnostics.CounterSample NextSample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.NextSample" />
      <MemberSignature Language="VB.NET" Value="Public Function NextSample () As CounterSample" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::CounterSample NextSample();" />
      <MemberSignature Language="F#" Value="member this.NextSample : unit -&gt; System.Diagnostics.CounterSample" Usage="performanceCounter.NextSample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.CounterSample</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtains a counter sample, and returns the raw, or uncalculated, value for it.</summary>
        <returns>A <see cref="T:System.Diagnostics.CounterSample" /> that represents the next raw value that the system obtains for this counter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法通常用于包含非计算所得的值的计数器。  
  
> [!NOTE]
>  如果值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>属性是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process>和性能计数器类别使用.NET Framework 版本 1.0 或 1.1 版中，创建<xref:System.InvalidOperationException>引发。 使用早期版本创建的性能计数器类别使用全局共享的内存，并且的值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>必须<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。 如果在版本 1.0 或 1.1 的.NET framework 上运行的应用程序不使用类别，删除并重新创建该类别。  
  
> [!NOTE]
>  若要读取 Windows Vista、 Windows XP Professional x64 Edition 或 Windows Server 2003 中的性能计数器，你必须是 Performance Monitor Users 组的成员或具有管理权限。  
>   
>  若要避免无需提升你的特权来访问在 Windows Vista 中的性能计数器，请将自己添加到 Performance Monitor Users 组。  
>   
>  在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Diagnostics.PerformanceCounter.NextSample%2A>方法来获取计数器的下一个非计算所得的值。 此代码示例是一个更大的示例的一部分<xref:System.Diagnostics.PerformanceCounter>类。  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#3)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#3)]
 [!code-vb[PerformanceCounterType.AverageCounter64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The instance is not correctly associated with a performance counter.  -or-  The <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> property is set to <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> when using global shared memory.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when accessing a system API.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Me), which does not support performance counters.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code that is executing without administrative privileges attempted to read a performance counter.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用于读取性能计数器类别。 关联的枚举： <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="NextValue">
      <MemberSignature Language="C#" Value="public float NextValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float32 NextValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.NextValue" />
      <MemberSignature Language="VB.NET" Value="Public Function NextValue () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; float NextValue();" />
      <MemberSignature Language="F#" Value="member this.NextValue : unit -&gt; single" Usage="performanceCounter.NextValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtains a counter sample and returns the calculated value for it.</summary>
        <returns>The next calculated value that the system obtains for this counter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  如果计数器的计算的值取决于两个计数器读取，第一次读取的操作返回 0.0。 重置要指定不同的计数器的性能计数器属性等效于创建新的性能计数器，并使用新的属性的第一个读取的操作返回 0.0。 对的调用之间的建议的延迟时间<xref:System.Diagnostics.PerformanceCounter.NextValue%2A>方法为 1 秒，以允许要执行的下一个增量读的计数器。  
  
> [!NOTE]
>  若要读取性能计数器，你必须具有管理权限。 在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Diagnostics.PerformanceCounterType.ElapsedTime>计数器，然后使用<xref:System.Diagnostics.PerformanceCounter.NextValue%2A>方法以显示一段时间的计数器的值。  
  
 [!code-cpp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CPP/elapsedtime.cpp#2)]
 [!code-csharp[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/CS/elapsedtime.cs#2)]
 [!code-vb[PerformanceCounterType.ElapsedTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.ElapsedTime/VB/elapsedtime.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The instance is not correctly associated with a performance counter.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when accessing a system API.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Me), which does not support performance counters.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code that is executing without administrative privileges attempted to read a performance counter.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用于读取性能计数器类别。 关联的枚举： <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Read" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="RawValue">
      <MemberSignature Language="C#" Value="public long RawValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 RawValue" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.RawValue" />
      <MemberSignature Language="VB.NET" Value="Public Property RawValue As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long RawValue { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.RawValue : int64 with get, set" Usage="System.Diagnostics.PerformanceCounter.RawValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The raw value of the counter.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the raw, or uncalculated, value of this counter.</summary>
        <value>计数器的原始值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果计数器类型为 32 位大小，并且你尝试将此属性设置为太大，无法安装一个值，该属性会截断到 32 位的值。 在读取本地计算机上的自定义计数器时，使用<xref:System.Diagnostics.PerformanceCounter.RawValue%2A>属性，而不是计算得出的值可以产生显著提高性能的足够的原始值的情况。  
  
 如果你正在阅读的计数器是只读的则获取<xref:System.Diagnostics.PerformanceCounter.RawValue%2A>属性的属性称为次采样的计数器。 此操作等效于初始调用<xref:System.Diagnostics.PerformanceCounter.NextSample%2A>方法。 如果您随后调用<xref:System.Diagnostics.PerformanceCounter.NextSample%2A>，你可以对两个调用返回的值执行计算。  
  
 由于系统计数器是只读的您可以获取但未设置其原始值。  
  
> [!NOTE]
>  <xref:System.Diagnostics.PerformanceCounter.Increment%2A>， <xref:System.Diagnostics.PerformanceCounter.IncrementBy%2A>，和<xref:System.Diagnostics.PerformanceCounter.Decrement%2A>方法使用联锁更新计数器值。 这将有助于避免计数器值准确多线程或多进程方案，但是也导致对性能产生负面影响。 如果你不需要互锁的准确性操作提供，你可以更新<xref:System.Diagnostics.PerformanceCounter.RawValue%2A>属性直接为多达 5 倍的性能提高。  但是，在多线程情况下，某些更新对计数器值可能会忽略，导致不准确的数据。  
  
> [!NOTE]
>  如果值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>属性是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process>和性能计数器类别使用.NET Framework 版本 1.0 或 1.1 版中，创建<xref:System.InvalidOperationException>引发。 使用早期版本创建的性能计数器类别使用全局共享的内存，并且的值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>必须<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。 如果在版本 1.0 或 1.1 的.NET framework 上运行的应用程序不使用类别，删除并重新创建该类别。  
  
> [!NOTE]
>  若要读取 Windows Vista、 Windows XP Professional x64 Edition 或 Windows Server 2003 中的性能计数器，你必须是 Performance Monitor Users 组的成员或具有管理权限。  
>   
>  若要避免无需提升你的特权来访问在 Windows Vista 中的性能计数器，请将自己添加到 Performance Monitor Users 组。  
>   
>  在 Windows Vista 中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Diagnostics.CounterSample>类来显示的值<xref:System.Diagnostics.PerformanceCounter.RawValue%2A>计数器的属性。  
  
 [!code-cpp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/cpp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CPP/averagecount32.cpp#1)]
 [!code-csharp[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/csharp/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/CS/averagecount32.cs#1)]
 [!code-vb[PerformanceCounterType.AverageCounter64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/PerformanceCounterType.AverageCounter64/VB/averagecount32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You are trying to set the counter's raw value, but the counter is read-only.  -or-  The instance is not correctly associated with a performance counter.  -or-  The <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> property is set to <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> when using global shared memory.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when accessing a system API.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Me), which does not support performance counters.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Code that is executing without administrative privileges attempted to read a performance counter.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用于写入性能计数器类别。 关联的枚举： <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.PerformanceCounter.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool with get, set" Usage="System.Diagnostics.PerformanceCounter.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The accessability level of the counter.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether this <see cref="T:System.Diagnostics.PerformanceCounter" /> instance is in read-only mode.</summary>
        <value>
          <see langword="true" />如果<see cref="T:System.Diagnostics.PerformanceCounter" />实例是否处于只读模式 （即使该计数器本身是自定义的.NET Framework 计数器）;<see langword="false" />如果它处于读/写模式。 默认值是由构造函数设置的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于系统计数器，<xref:System.Diagnostics.PerformanceCounter.ReadOnly%2A>应始终`true`。 无法写入系统计数器。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveInstance">
      <MemberSignature Language="C#" Value="public void RemoveInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.PerformanceCounter.RemoveInstance" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveInstance ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveInstance();" />
      <MemberSignature Language="F#" Value="member this.RemoveInstance : unit -&gt; unit" Usage="performanceCounter.RemoveInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.PerformanceCounter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deletes the category instance specified by the <see cref="T:System.Diagnostics.PerformanceCounter" /> object <see cref="P:System.Diagnostics.PerformanceCounter.InstanceName" /> property.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以删除仅用于自定义计数器实例。 所有系统计数器都是只读的因此在尝试删除其中一个将引发异常。  
  
> [!NOTE]
>  若要避免可能的争用情况，在释放性能计数器共享内存时，建议<xref:System.Diagnostics.PerformanceCounter.RemoveInstance%2A>方法调用从<xref:System.AppDomain.DomainUnload>事件处理程序。  
  
 若要创建的性能类别实例，指定`instanceName`上<xref:System.Diagnostics.PerformanceCounter.%23ctor%2A>构造函数。 如果指定的类别实例`instanceName`已存在的新对象将引用现有的类别实例。  
  
> [!NOTE]
>  如果值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>属性是<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Process>和性能计数器类别使用.NET Framework 版本 1.0 或 1.1 版中，创建<xref:System.InvalidOperationException>引发。 使用早期版本创建的性能计数器类别使用全局共享的内存，并且的值<xref:System.Diagnostics.PerformanceCounter.InstanceLifetime%2A>必须<xref:System.Diagnostics.PerformanceCounterInstanceLifetime.Global>。 如果在版本 1.0 或 1.1 的.NET framework 上运行的应用程序不使用类别，删除并重新创建该类别。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This counter is read-only, so any instance that is associated with the category cannot be removed.  -or-  The instance is not correctly associated with a performance counter.  -or-  The <see cref="P:System.Diagnostics.PerformanceCounter.InstanceLifetime" /> property is set to <see cref="F:System.Diagnostics.PerformanceCounterInstanceLifetime.Process" /> when using global shared memory.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">An error occurred when accessing a system API.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The platform is Windows 98 or Windows Millennium Edition (Me), which does not support performance counters.</exception>
        <permission cref="T:System.Diagnostics.PerformanceCounterPermission">用于写入性能计数器类别。 关联的枚举： <see cref="F:System.Diagnostics.PerformanceCounterPermissionAccess.Write" />。</permission>
      </Docs>
    </Member>
  </Members>
</Type>