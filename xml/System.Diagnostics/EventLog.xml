<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b2145a11bbb9faa94763035b22147eede6d4adee" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30400601" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供与 Windows 事件日志的交互。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog> 可访问或自定义 Windows 事件日志，记录有关重要的软件或硬件事件的信息。 使用<xref:System.Diagnostics.EventLog>，可以从现有日志读取、 将条目写入到日志、 创建或删除事件源，删除日志，并响应日志条目。 创建事件源时，你还可以创建新的日志。  
  
> [!IMPORTANT]
>  此类型实现<xref:System.IDisposable>接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，调用其<xref:System.IDisposable.Dispose%2A>中的方法`try` / `catch`块。 若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅中的"使用实现 IDisposable 的对象"部分<xref:System.IDisposable>接口主题。  
  
 除了提供对个人事件日志和其条目访问<xref:System.Diagnostics.EventLog>类可访问的所有事件日志的集合。 你可以使用`static`的成员<xref:System.Diagnostics.EventLog>若要删除日志，获取日志列表、 创建或删除源，或确定是否计算机已包含一个特定的源。  
  
 有三个默认事件日志： 应用程序、 系统和安全。 安全日志是只读的。 其他应用程序和安装，如 Active Directory 的服务可能具有其他事件日志。  
  
 安全注意事项在使用时有<xref:System.Diagnostics.EventLog>类。 <xref:System.Diagnostics.EventLog> 需要<xref:System.Diagnostics.EventLogPermission>的.NET Framework 2.0 和更高版本中的特定操作或在.NET Framework 1.0 和 1.1 中的完全信任权限。 我们建议，<xref:System.Diagnostics.EventLogPermission>不授予给部分受信任的代码。  你决不要将传递任何事件日志的对象，包括<xref:System.Diagnostics.EventLogEntryCollection>和<xref:System.Diagnostics.EventLogEntry>对象，不太受信任的代码。 例如，创建<xref:System.Diagnostics.EventLog>对象、 写入条目，然后将<xref:System.Diagnostics.EventLog>到部分受信任的代码的对象可以为创建安全问题，因为能够读取和写入事件日志允许代码执行操作，如发布另一个应用程序的名称的事件日志消息。  
  
 从 Windows Vista 开始，用户帐户控制 (UAC) 决定用户的凭据。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要运行的代码访问安全日志，首先必须将你的凭据从标准用户提升至管理员。 通过打开应用程序的快捷菜单启动应用程序时可以执行此操作 （如果你使用鼠标，右键单击应用程序图标） 并指示你想要以管理员身份运行。  
  
 你可以使用<xref:System.Diagnostics.EventLog>来创建自定义你可以查看通过服务器的事件日志的事件查看器。 使用<xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>方法以在事件查看器显示你的事件日志的本地化的名称。 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>方法来配置你的事件日志的行为，当它达到其最大日志大小。  
  
 若要从事件日志中读取，指定日志名称 (<xref:System.Diagnostics.EventLog.Log%2A>属性) 和服务器计算机名称 (<xref:System.Diagnostics.EventLog.MachineName%2A>事件日志的属性。 如果你未指定服务器的计算机名称，本地计算机，"。"，则假定。 不需要指定事件源 (<xref:System.Diagnostics.EventLog.Source%2A>属性)，因为源是只有需要写入日志。 <xref:System.Diagnostics.EventLog.Entries%2A>属性自动填充的条目的事件日志的列表。  
  
 若要写入事件日志，请指定或创建事件源 (<xref:System.Diagnostics.EventLog.Source%2A>属性)。 若要创建新的事件源的计算机上，必须具有管理凭据。 事件源将你的应用程序注册的有效项源作为事件日志。 事件源可用于写入一次只有一个日志。 <xref:System.Diagnostics.EventLog.Source%2A>属性可以是任何随机字符串，但该名称必须是不同于计算机上的其他源。 事件源通常是应用程序或另一个标识字符串的名称。 尝试创建重复<xref:System.Diagnostics.EventLog.Source%2A>值引发异常。 但是，单个事件日志可能与多个源。  
  
 如果事件日志的事件源关联<xref:System.Diagnostics.EventLog>实例不存在，则创建新的事件源。 若要创建的事件源在 Windows Vista 或更高版本或 Windows Server 2003，必须具有管理凭据。  
  
 此要求是因为必须搜索所有事件日志，包括安全日志，以确定事件源是否是唯一的。 从 Windows Vista 开始，用户没有权限访问安全事件日志中。因此，<xref:System.Security.SecurityException>引发。  
  
> [!IMPORTANT]
>  创建或删除事件源需要通过使用命名的互斥体的基础代码的同步。 如果具有高特权的应用程序锁定命名互斥体，尝试创建或删除事件源将导致应用程序停止响应，直到该锁被释放。 若要防止此问题，永远不会授予<xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>到不受信任的代码的权限。 此外，<xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>权限可能允许绕开其他权限和仅应授予高度受信任的代码。  
  
 应用程序和服务应写入应用程序日志或自定义日志。 设备驱动程序应写入系统日志。 如果未显式设置<xref:System.Diagnostics.EventLog.Log%2A>属性，默认为应用程序日志的事件日志。  
  
> [!NOTE]
>  无需进行任何以防止应用程序编写为任何已注册的源。  如果应用程序被授予<xref:System.Diagnostics.EventLogPermissionAccess.Write>权限，它可以编写任何有效的源的计算机上注册的事件。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法来向事件日志写入事件。 必须指定事件源写入事件;你必须创建并在编写与源的第一个条目之前，配置事件源。  
  
 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并且尝试写入新的源的事件写入操作将失败。 你可以使用配置新的源<xref:System.Diagnostics.EventLogInstaller>对象或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理凭据。  
  
 每个源可以一次; 写入只有一个事件日志但是，你的应用程序可以使用多个源写入多个事件日志。 例如，你的应用程序可能需要为不同的事件日志或不同的资源文件配置的多个源。 若要更改现有源的配置详细信息，必须删除源，然后使用新的配置创建。 如果其他应用程序或组件使用的现有源，请使用更新的配置，而不是删除现有的源创建新的源。  
  
 你可以先使用本地化的资源注册事件源，为你的事件类别和消息字符串。 你的应用程序可以通过使用资源标识符而不指定的实际字符串值编写事件日志条目。 请参阅<xref:System.Diagnostics.EventLogInstaller>和<xref:System.Diagnostics.EventSourceCreationData>有关的资源文件配置您的源的详细信息的类。  
  
 如果你的应用程序将直接写入事件日志的字符串值，你不需要设置源的文件属性的资源。 要写入本地化的项还是要直接写入字符串，则必须配置源。 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
 写入事件时，你必须至少指定一个消息字符串或消息字符串的资源标识符。 其他事件属性都是可选的。 可选事件设置的示例包括：  
  
-   你可以设置<xref:System.Diagnostics.EventLogEntryType>指定事件查看器显示的项的图标。  
  
-   如果你的应用程序使用类别进行筛选的事件，可以指定事件的类别标识符。  
  
-   如果你想要将其他信息与给定的事件相关联，你可以将二进制数据附加到事件项。  
  
> [!IMPORTANT]
>  事件日志记录占用磁盘空间、 处理器时间和其他系统资源。 请务必仅记录基本信息。 我们建议将事件日志调用放在错误路径中，而不是在主代码路径中，因此它们不会影响性能。  
  
 有关的实例的初始属性值的列表<xref:System.Diagnostics.EventLog>，请参阅<xref:System.Diagnostics.EventLog.%23ctor%2A>构造函数。  
  
   
  
## Examples  
 下面的示例创建事件源`MySource`如果它尚不存在，并将项写入事件日志`MyNewLog`。  
  
> [!NOTE]
>  从 Windows Vista 开始，你必须以管理员身份运行此应用程序。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 类的新实例。 不将该实例与任何日志关联。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 之前调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>，指定<xref:System.Diagnostics.EventLog.Source%2A>属性<xref:System.Diagnostics.EventLog>实例。 如果您仅读取<xref:System.Diagnostics.EventLog.Entries%2A>从日志中，您可以另行指定仅<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>属性。  
  
> [!NOTE]
>  如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本地计算机 ("。") 假定。  
  
 下表显示的实例的初始属性值<xref:System.Diagnostics.EventLog>。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空字符串 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|空字符串 ("")。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|本地计算机 ("。")。|  
  
   
  
## Examples  
 下面的示例创建源`MySource`如果它尚不存在，并将项写入事件日志`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">本地计算机上日志的名称。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 类的新实例。 将该实例与本地计算机上的日志关联。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载设置<xref:System.Diagnostics.EventLog.Log%2A>属性`logName`参数。 之前调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>，指定<xref:System.Diagnostics.EventLog.Source%2A>属性<xref:System.Diagnostics.EventLog>实例。 如果您仅读取<xref:System.Diagnostics.EventLog.Entries%2A>从日志中，您可以另行指定仅<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>属性。  
  
> [!NOTE]
>  如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本地计算机 ("。") 假定。 此重载构造函数指定<xref:System.Diagnostics.EventLog.Log%2A>属性，但您可以更改此读取操作之前<xref:System.Diagnostics.EventLog.Entries%2A>属性。  
  
 如果你在指定的源<xref:System.Diagnostics.EventLog.Source%2A>属性从其他源的计算机上，后续调用都是唯一<xref:System.Diagnostics.EventLog.WriteEntry%2A>如果不存在具有指定名称，创建一个日志。  
  
 下表显示的实例的初始属性值<xref:System.Diagnostics.EventLog>。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空字符串 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` 参数。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|本地计算机 ("。")。|  
  
   
  
## Examples  
 下面的示例读取在事件日志中，"myNewLog"本地计算机上的项。  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">日志名称为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">日志名称无效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">指定算机上日志的名称。</param>
        <param name="machineName">日志所在的计算机。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 类的新实例。 将该实例与指定计算机上的日志关联。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载设置<xref:System.Diagnostics.EventLog.Log%2A>属性`logName`参数和<xref:System.Diagnostics.EventLog.MachineName%2A>属性`machineName`参数。 之前调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>，指定<xref:System.Diagnostics.EventLog.Source%2A>属性<xref:System.Diagnostics.EventLog>。 如果您仅读取<xref:System.Diagnostics.EventLog.Entries%2A>从日志中，您可以另行指定仅<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>属性。  
  
> [!NOTE]
>  此重载构造函数指定<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>属性，但您可以更改之前读取或是<xref:System.Diagnostics.EventLog.Entries%2A>属性。  
  
 下表显示的实例的初始属性值<xref:System.Diagnostics.EventLog>。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空字符串 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` 参数。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` 参数。|  
  
   
  
## Examples  
 下面的示例读取在事件日志中，"myNewLog"计算机"myServer"上的项。  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">日志名称为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">日志名称无效。  
  
 或  
  
 计算机名称无效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">指定的计算机上日志的名称</param>
        <param name="machineName">日志所在的计算机。</param>
        <param name="source">事件日志项的源。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 类的新实例。 将实例与指定的计算机上的日志关联，并为 <see cref="T:System.Diagnostics.EventLog" /> 实例创建或分配指定的源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数设置<xref:System.Diagnostics.EventLog.Log%2A>属性`logName`参数，<xref:System.Diagnostics.EventLog.MachineName%2A>属性`machineName`参数，与<xref:System.Diagnostics.EventLog.Source%2A>属性`source`参数。 <xref:System.Diagnostics.EventLog.Source%2A>属性是必需的写入事件日志时。 但是，如果你只是从读取事件日志，仅<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>属性都是必需 （只要服务器上的事件日志具有已与它关联的源）。 如果你只是读取从事件日志，可能可以满足另一个重载构造函数。  
  
 下表显示的实例的初始属性值<xref:System.Diagnostics.EventLog>。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|`source` 参数。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` 参数。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` 参数。|  
  
   
  
## Examples  
 下面的示例一个项写入事件日志中，"MyNewLog"，使用源""的本地计算机上。  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">日志名称为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">日志名称无效。  
  
 或  
  
 计算机名称无效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>开始初始化用于窗体或由其他组件使用的 <see cref="T:System.Diagnostics.EventLog" />。 此初始化在运行时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]设计环境使用此方法来开始使用窗体或由另一个组件的组件的初始化。 <xref:System.Diagnostics.EventLog.EndInit%2A>方法初始化已结束。 使用<xref:System.Diagnostics.EventLog.BeginInit%2A>和<xref:System.Diagnostics.EventLog.EndInit%2A>方法阻止中完全初始化之前使用的控件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Diagnostics.EventLog" /> 已初始化完毕。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从事件日志中移除所有项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件日志设置最大大小，它确定它们可以包含的项数。 当事件日志已满时，它将停止记录新的事件信息，或开始覆盖以前的项。 如果事件录制停止后，你可以使用此方法要清除日志中的现有条目，并允许它重新开始记录事件。 你必须具有到日志驻留以清除事件日志条目的计算机的管理员权限。  
  
 <xref:System.Diagnostics.EventLog.Clear%2A> 关闭事件日志、 释放事件句柄，检索新读取和写入句柄，并重新打开事件日志。 对方法的调用后收到的事件不会清除与现有的事件中。  
  
   
  
## Examples  
 下面的示例清除事件日志。  
  
> [!CAUTION]
>  因为应用程序、 系统、 安全性和其他非自定义日志可能包含重要信息;请确保在执行此示例代码之前指定自定义日志。 此示例将删除自定义日志`myNewLog`。  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">未成功清除事件日志。  
  
 或  
  
 无法打开日志。 一个 Windows 错误代码不可用。</exception>
        <exception cref="T:System.ArgumentException">没有为 <see cref="P:System.Diagnostics.EventLog.Log" /> 属性指定值。 确保日志名称不是一个空字符串。</exception>
        <exception cref="T:System.InvalidOperationException">该日志不存在。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭事件日志并释放读写句柄。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.Close%2A>调用方法的受保护<xref:System.ComponentModel.Component.Dispose%2A>方法。 不需要调用<xref:System.Diagnostics.EventLog.Close%2A>之前调用<xref:System.ComponentModel.Component.Dispose%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">事件日志的读句柄或写句柄未成功释放。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立一个能够将事件信息写入到系统的特定日志中的应用程序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" />
      </Parameters>
      <Docs>
        <param name="sourceData">事件源及其目标事件日志的配置属性。</param>
        <summary>通过使用为该事件源和对应的事件日志指定的配置属性，建立一个写入本地化事件消息的有效事件源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载用于配置新的源用于将本地计算机或远程计算机上写入事件日志条目。 不需要使用此方法从事件日志进行读取。  
  
 <xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法使用输入`sourceData` <xref:System.Diagnostics.EventSourceCreationData.Source%2A>，<xref:System.Diagnostics.EventSourceCreationData.LogName%2A>和<xref:System.Diagnostics.EventSourceCreationData.MachineName%2A>属性以创建新的源和其关联的事件日志在目标计算机上的注册表值。 新的源名称不能与现有源名称或目标计算机上的现有事件日志名称匹配。 如果<xref:System.Diagnostics.EventSourceCreationData.LogName%2A>属性未设置，为应用程序事件日志注册源。 如果<xref:System.Diagnostics.EventSourceCreationData.MachineName%2A>未设置，在本地计算机上注册源。  
  
> [!NOTE]
>  若要创建的事件源在 Windows Vista 或更高版本或 Windows Server 2003，必须具有管理权限。  
>   
>  此要求的原因是所有的事件日志，包括安全性，必须进行搜索以确定事件源是否唯一。 从 Windows Vista 开始，用户没有权限访问安全事件日志中。因此，<xref:System.Security.SecurityException>引发。  
>   
>  从 Windows Vista 开始，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行的代码访问安全日志，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>事件写入事件日志。 必须指定事件源写入事件;你必须创建并在编写与源的第一个条目之前，配置事件源。  
  
 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 你可以创建现有的事件日志或新的事件日志的事件源。 在创建新的源的新的事件日志时，系统将为该日志，此源注册，但之前向其中写入的第一个条目，将不会创建日志。  
  
 操作系统将事件日志存储为文件。 当你使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>若要创建新的事件日志，关联的文件存储在指定的计算机上的 %SystemRoot%\System32\Config 目录。 通过追加的前 8 个字符设置的文件名称<xref:System.Diagnostics.EventLog.Log%2A>".evt"文件扩展名的属性。  
  
 每个源可以仅写入只有一个事件日志一次;但是，你的应用程序可以使用多个源写入多个事件日志。 例如，你的应用程序可能需要为不同的事件日志或不同的资源文件配置的多个源。  
  
 你可以先使用本地化的资源文件注册事件源，为你的事件类别和消息字符串。 你的应用程序可以写入事件日志项使用资源标识符，而不指定实际的字符串。 事件查看器使用的资源标识符来查找并显示基于当前语言设置的本地化的资源文件中的相应字符串。 你可以注册为事件类别、 消息和参数插入字符串，单独的文件，或者也可以注册为所有三种类型的字符串的相同资源文件。 使用<xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>， <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>， <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>，和<xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A>属性来配置要向事件日志写入本地化的条目的源。 如果你的应用程序将直接写入事件日志的字符串值，你不需要设置这些属性。  
  
 要写入本地化的项还是要直接写入字符串，则必须配置源。 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
 若要更改现有源的配置详细信息，必须删除源，然后使用新的配置创建。 如果其他应用程序或组件使用的现有源，请使用更新的配置，而无需删除现有的源创建新的源。  
  
> [!NOTE]
>  如果源配置为事件日志，并且重新配置为另一个事件日志，必须重新启动计算机才能使更改生效。  
  
   
  
## Examples  
 下面的示例确定是否将名为事件源`SampleApplicationSource`已在本地计算机上注册。 如果事件源不存在，该示例设置源的消息资源文件，并创建新的事件源。 最后，该示例设置使用中的资源标识符值的事件日志的本地化的显示名称`DisplayNameMsgId`和中的资源文件路径`messageFile`。  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 该示例使用以下的消息文本文件，内置于 EventLogMsgs.dll 的资源库。 消息文本文件是从其创建的消息资源文件的源。 消息文本文件定义的资源标识符和类别、 事件消息和参数插入字符串的文本。 具体而言，为事件日志的本地化名称定义了资源标识符 5001。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">在 <paramref name="sourceData" /> 中指定的计算机名称无效。  
  
 \- 或 -  
  
 在 <paramref name="sourceData" /> 中指定的源名称为 <see langword="null" />。  
  
 \- 或 -  
  
 在 <paramref name="sourceData" /> 中指定的日志名称无效。 事件日志名称必须由可打印字符组成，且不得包含字符“*”、“?”或“\\”。  
  
 \- 或 -  
  
 在 <paramref name="sourceData" /> 中指定的日志名称对用户日志创建无效。 事件日志名称 AppEvent、SysEvent 和 SecEvent 是保留为系统使用的。  
  
 \- 或 -  
  
 该日志名称与一个现有事件源名称相匹配。  
  
 \- 或 -  
  
 在 <paramref name="sourceData" /> 中指定的源名称导致注册表项路径的长度超过 254 个字符。  
  
 \- 或 -  
  
 在 <paramref name="sourceData" /> 中指定的日志名称的前 8 个字符不唯一。  
  
 \- 或 -  
  
 在 <paramref name="sourceData" /> 中指定的源名称已经注册过。  
  
 \- 或 -  
  
 在 <paramref name="sourceData" /> 中指定的源名称与一个现有事件日志名称相匹配。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceData" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在本地计算机上注册时所采用的源名称。</param>
        <param name="logName">源的项写入的日志名。 可能的值包括“应用程序”、“系统”或自定义事件日志。</param>
        <summary>建立指定的源名称作为向本地计算机上的日志中写入日志项的有效事件源。 此方法还可在本地计算机上创建一个新的自定义日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载来创建自定义日志，或要创建并注册<xref:System.Diagnostics.EventLog.Source%2A>向本地计算机上现有的日志。  
  
 如果`logName`是`null`或空字符串 ("") 时调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>，日志将默认为应用程序日志。 如果本地计算机上不存在该日志，系统创建自定义日志，并将注册应用程序作为<xref:System.Diagnostics.EventLog.Source%2A>为该日志。  
  
> [!NOTE]
>  若要创建的事件源在 Windows Vista 或更高版本或 Windows Server 2003，必须具有管理权限。  
>   
>  此要求的原因是所有的事件日志，包括安全性，必须进行搜索以确定事件源是否唯一。 从 Windows Vista 开始，用户没有权限访问安全事件日志中。因此，<xref:System.Security.SecurityException>引发。  
>   
>  在 Windows Vista 或更高版本中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行的代码访问安全日志，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 只需创建事件源，如果要写入事件日志。 然后再写入事件日志条目，你必须将注册事件源的事件日志有效的事件源。 当你编写日志条目时，系统将使用<xref:System.Diagnostics.EventLog.Source%2A>以查找相应的日志要在其中放置你的条目。 如果您正在读取事件日志，你可以指定<xref:System.Diagnostics.EventLog.Source%2A>，或<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>。  
  
> [!NOTE]
>  你不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果要连接到本地计算机上的日志。 如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>时从日志读取本地计算机 ("。") 假定。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>事件写入事件日志。 必须指定事件源写入事件;你必须创建并在编写与源的第一个条目之前，配置事件源。  
  
 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 你可以创建现有的事件日志或新的事件日志的事件源。 在创建新的源的新的事件日志时，系统将为该日志，此源注册，但之前向其中写入的第一个条目，将不会创建日志。  
  
 操作系统将事件日志存储为文件。 当你使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>若要创建新的事件日志，关联的文件存储在指定的计算机上的 %SystemRoot%\System32\Config 目录。 通过追加的前 8 个字符设置的文件名称<xref:System.Diagnostics.EventLog.Log%2A>".evt"文件扩展名的属性。  
  
 必须是唯一的本地计算机; 上的源新的源名称不能与现有源名称或现有的事件日志名称匹配。 每个源可以一次; 写入只有一个事件日志但是，你的应用程序可以使用多个源写入多个事件日志。 例如，你的应用程序可能需要为不同的事件日志或不同的资源文件配置的多个源。  
  
 要写入本地化的项还是要直接写入字符串，则必须配置源。 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
 若要更改现有源的配置详细信息，必须删除源，然后使用新的配置创建。 如果其他应用程序或组件使用的现有源，请使用更新的配置，而无需删除现有的源创建新的源。  
  
> [!NOTE]
>  如果源已映射到某个日志并重新映射到新的日志，必须重新启动计算机才能使更改生效。  
  
   
  
## Examples  
 下面的示例创建源`MySource`如果它尚不存在，并将项写入事件日志`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 为空字符串 ("") 或 <see langword="null" />。  
  
 \- 或 -  
  
 <paramref name="logName" /> 不是有效的事件日志名称。 事件日志名称必须由可打印字符组成，且不得包含字符“*”、“?”或“\\”。  
  
 \- 或 -  
  
 <paramref name="logName" />对用户日志创建无效。 事件日志名称 AppEvent、SysEvent 和 SecEvent 是保留为系统使用的。  
  
 \- 或 -  
  
 该日志名称与一个现有事件源名称相匹配。  
  
 \- 或 -  
  
 此源名称导致注册表项路径的长度超过 254 个字符。  
  
 \- 或 -  
  
 <paramref name="logName" /> 的前 8 个字符与现有事件日志名称的前 8 个字符相匹配。  
  
 \- 或 -  
  
 无法注册该源，因为它已存在于本地计算机上。  
  
 \- 或 -  
  
 该源名称与一个现有事件日志名称相匹配。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能在本地计算机上打开。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在指定计算机上注册时所采用的源。</param>
        <param name="logName">源的项写入的日志名。 可能的值包括“应用程序”、“系统”或自定义事件日志。 如果不指定值，则 <c>logName</c> 默认为应用程序。</param>
        <param name="machineName">用来注册此事件源的计算机名称，对于本地计算机则为“.”。</param>
        <summary>建立指定的源名称作为向指定计算机上的日志中写入项的有效事件源。 此方法还可用于在指定计算机上创建一个新的自定义日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载来创建自定义日志，或要创建并注册<xref:System.Diagnostics.EventLog.Source%2A>向指定的计算机上现有的日志。  
  
 如果`logName`是`null`或空字符串 ("") 时调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>，日志将默认为应用程序日志。 如果指定的计算机上不存在该日志，系统创建自定义日志，并将注册应用程序作为<xref:System.Diagnostics.EventLog.Source%2A>为该日志。  
  
 只需创建事件源，如果要写入事件日志。 然后再写入事件日志条目，你必须将注册事件源的事件日志有效的事件源。 当你编写日志条目时，系统将使用<xref:System.Diagnostics.EventLog.Source%2A>以查找相应的日志要在其中放置你的条目。 如果您正在读取事件日志，你可以指定<xref:System.Diagnostics.EventLog.Source%2A>，或<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>。  
  
> [!NOTE]
>  若要创建的事件源在 Windows Vista 或更高版本或 Windows Server 2003，必须具有管理权限。  
>   
>  此要求的原因是所有的事件日志，包括安全性，必须进行搜索以确定事件源是否唯一。 在 Windows Vista 或更高版本，用户没有权限访问安全事件日志中。因此，<xref:System.Security.SecurityException>引发。  
>   
>  在 Windows Vista 或更高版本中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行的代码访问安全日志，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>事件写入事件日志。 必须指定事件源写入事件;你必须创建并在编写与源的第一个条目之前，配置事件源。  
  
 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 你可以创建现有的事件日志或新的事件日志的事件源。 在创建新的源的新的事件日志时，系统将为该日志，此源注册，但之前向其中写入的第一个条目，将不会创建日志。  
  
 操作系统将事件日志存储为文件。 当你使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>若要创建新的事件日志，关联的文件存储在指定的计算机上的 %SystemRoot%\System32\Config 目录。 通过追加的前 8 个字符设置的文件名称<xref:System.Diagnostics.EventLog.Log%2A>".evt"文件扩展名的属性。  
  
 必须是唯一的本地计算机; 上的源新的源名称不能与现有源名称或现有的事件日志名称匹配。 每个源可以一次; 写入只有一个事件日志但是，你的应用程序可以使用多个源写入多个事件日志。 例如，你的应用程序可能需要为不同的事件日志或不同的资源文件配置的多个源。  
  
 要写入本地化的项还是要直接写入字符串，则必须配置源。 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
 若要更改现有源的配置详细信息，必须删除源，然后使用新的配置创建。 如果其他应用程序或组件使用的现有源，请使用更新的配置，而无需删除现有的源创建新的源。  
  
> [!NOTE]
>  如果源已映射到某个日志并重新映射到新的日志，必须重新启动计算机才能使更改生效。  
  
   
  
## Examples  
 下面的示例创建源`MySource`计算机上`MyServer`，和一个项写入事件日志`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 不是有效的计算机名称。  
  
 \- 或 -  
  
 <paramref name="source" /> 为空字符串 ("") 或 <see langword="null" />。  
  
 \- 或 -  
  
 <paramref name="logName" /> 不是有效的事件日志名称。 事件日志名称必须由可打印字符组成，且不得包含字符“*”、“?”或“\\”。  
  
 \- 或 -  
  
 <paramref name="logName" />对用户日志创建无效。 事件日志名称 AppEvent、SysEvent 和 SecEvent 是保留为系统使用的。  
  
 \- 或 -  
  
 该日志名称与一个现有事件源名称相匹配。  
  
 \- 或 -  
  
 此源名称导致注册表项路径的长度超过 254 个字符。  
  
 \- 或 -  
  
 <paramref name="logName" /> 的前 8 个字符与指定计算机上现有事件日志名称的前 8 个字符相匹配。  
  
 \- 或 -  
  
 源无法注册，因为它已存在于指定的计算机上。  
  
 \- 或 -  
  
 该源名称与一个现有事件源名称相匹配。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能在指定的计算机上打开。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>移除日志资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要删除的日志的名称。 可能的值包括：“应用程序”、“安全性”、“系统”和计算机上的任何自定义事件日志。</param>
        <summary>从本地计算机上移除事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你想要删除的日志位于本地计算机上，请使用此方法。 你可以删除的计算机上，任何日志，前提是您具有适当的注册表权限。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> 删除指定的日志`logName`来自本地计算机。 如果你想要删除仅源注册到日志，请调用<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。 如果你只想要删除的日志条目，调用<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A> 和<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，以便它们可以调用类本身上。 不需要创建的新实例<xref:System.Diagnostics.EventLog>调用任何一种方法。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A>方法首先删除存储日志的内容的文件。 然后，访问注册表，并删除为该日志注册的所有事件源。 如果重新创建在以后的日志时，你应该它们是否要重用再次注册事件源。 如果不注册事件源和其他用户的事件源编写无需指定日志名称，将在应用程序事件日志中创建事件源。 因此，应用程序以前曾经将条目写入到删除并重新创建的日志将写入到应用程序日志相反，因为它现在包含事件源。  
  
> [!NOTE]
>  重新创建事件日志可以是一个复杂的过程。 避免删除任何系统创建事件日志，如应用程序日志。  
  
 删除通过调用日志<xref:System.Diagnostics.EventLog.Delete%2A>会自动删除已注册到该日志的源。 这会使其他应用程序使用该日志不起作用。  
  
   
  
## Examples  
 下面的示例从本地计算机中删除日志。 该示例可确定从其源日志。  
  
> [!NOTE]
>  多个源可能会写入事件日志。 在删除之前自定义日志，请确保没有其他源写入该日志。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> 为空字符串 ("") 或 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能在本地计算机上打开。  
  
 \- 或 -  
  
 本地计算机上不存在该日志。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">未成功清除事件日志。  
  
 或  
  
 无法打开日志。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要删除的日志的名称。 可能的值包括：“应用程序”、“安全”、“系统”和指定计算机上的任何自定义事件日志。</param>
        <param name="machineName">要从中删除日志的计算机名称，对于本地计算机则为“.”。</param>
        <summary>从指定计算机上移除事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你想要删除的日志位于远程计算机上，请使用此方法。 你可以删除的计算机上，任何日志，前提是您具有适当的注册表权限。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A> 删除指定的日志`logName`从指定的计算机`machineName`。 如果你想要删除仅源注册到日志，请调用<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。 如果你只想要删除的日志条目，调用<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A> 和<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，以便它们可以调用类本身上。 不需要创建的实例<xref:System.Diagnostics.EventLog>调用任何一种方法。  
  
 此方法首先删除存储日志的内容的文件。 然后，访问注册表，并删除为该日志注册的所有事件源。 如果重新创建在以后的日志时，你应该它们是否要重用再次注册事件源。 如果不注册事件源和其他用户的事件源编写无需指定日志名称，将在应用程序事件日志中创建事件源。 因此，应用程序以前曾经将条目写入到删除并重新创建的日志将写入到应用程序日志相反，因为它现在包含事件源。  
  
> [!NOTE]
>  重新创建事件日志可以是一个复杂的过程。 避免删除任何系统创建事件日志，如应用程序日志。  
  
 删除通过调用日志<xref:System.Diagnostics.EventLog.Delete%2A>会自动删除已注册到该日志的源。 这会使其他应用程序使用该日志不起作用。  
  
   
  
## Examples  
 下面的示例从指定的计算机中删除日志。 该示例可确定从其源日志。  
  
> [!NOTE]
>  多个源可能会写入事件日志。 在删除之前自定义日志，请确保没有其他源写入该日志。  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="logName" /> 为空字符串 ("") 或 <see langword="null" />。  
  
 \- 或 -  
  
 <paramref name="machineName" /> 不是有效的计算机名称。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能在指定的计算机上打开。  
  
 \- 或 -  
  
 指定的计算机上不存在该日志。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">未成功清除事件日志。  
  
 或  
  
 无法打开日志。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从事件日志中移除应用程序的事件源注册。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在事件日志系统中用来注册的名称。</param>
        <summary>从本地计算机的事件日志中移除事件源注册。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于删除的注册<xref:System.Diagnostics.EventLog.Source%2A>来自本地计算机。 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 访问本地计算机上的注册表并删除的应用程序作为有效的事件源注册。  
  
 如果你不再需要它来写入该日志条目，则可以删除你的组件作为有效的事件源。 例如，如果你需要将你的组件从一个日志更改为另一个可能会执行此操作。 因为源一次只能注册到一个日志，更改日志，您必须删除当前的注册。  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 删除中仅注册到日志的源。 如果你想要移除日志本身，调用<xref:System.Diagnostics.EventLog.Delete%2A>。 如果你只想要删除的日志条目，调用<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A> 和<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，以便它们可以调用类本身上。 不需要创建的实例<xref:System.Diagnostics.EventLog>调用任何一种方法。  
  
 删除通过调用日志<xref:System.Diagnostics.EventLog.Delete%2A>会自动删除已注册到该日志的源。 这会使其他应用程序使用该日志不起作用。  
  
> [!NOTE]
>  如果源已映射到某个日志并重新映射到新的日志，必须重新启动计算机才能使更改生效。  
  
   
  
## Examples  
 下面的示例从本地计算机中删除源。 该示例确定从其源日志，然后删除该日志。  
  
> [!NOTE]
>  多个源可能会写入事件日志。 在删除之前自定义日志，请确保没有其他源写入该日志。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">本地计算机的注册表中不存在 <paramref name="source" /> 参数。  
  
 \- 或 -  
  
 您对事件日志的注册表项没有写访问权。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在事件日志系统中用来注册的名称。</param>
        <param name="machineName">要从中移除注册的计算机名，对于本地计算机则为“.”。</param>
        <summary>从指定的计算机上移除应用程序的事件源注册。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载用于删除的注册<xref:System.Diagnostics.EventLog.Source%2A>从远程计算机。 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 访问指定的计算机上的注册表`machineName`并删除应用程序作为有效的事件源的注册。  
  
 如果你不再需要它来写入该日志条目，则可以删除你的组件作为有效的事件源。 例如，如果你需要将你的组件从一个日志更改为另一个可能会执行此操作。 因为源一次只能注册到一个日志，更改日志，您必须删除当前的注册。  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 删除中仅注册到日志的源。 如果你想要移除日志本身，调用<xref:System.Diagnostics.EventLog.Delete%2A>。 如果你只想要删除的日志条目，调用<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A> 和<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，以便它们可以调用类本身上。 不需要创建的实例<xref:System.Diagnostics.EventLog>调用任何一种方法。  
  
 删除通过调用日志<xref:System.Diagnostics.EventLog.Delete%2A>会自动删除已注册到该日志的源。 这会使其他应用程序使用该日志不起作用。  
  
> [!NOTE]
>  如果源已映射到某个日志并重新映射到新的日志，必须重新启动计算机才能使更改生效。  
  
   
  
## Examples  
 下面的示例从指定的计算机中删除源。 该示例确定从其源日志，然后删除该日志。  
  
> [!NOTE]
>  多个源可能会写入事件日志。 在删除之前自定义日志，请确保没有其他源写入该日志。  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 参数无效。  
  
 \- 或 -  
  
 指定计算机的注册表中不存在 <paramref name="source" /> 参数。  
  
 \- 或 -  
  
 您对事件日志的注册表项没有写访问权。</exception>
        <exception cref="T:System.InvalidOperationException">
          无法删除 <paramref name="source" />，原因是在注册表中，<paramref name="source" /> 的父注册表项不包含与其同名的子项。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。</param>
        <summary>释放由 <see cref="T:System.Diagnostics.EventLog" /> 占用的非托管资源，还可以另外再释放托管资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法称为由公共`Dispose()`方法和<xref:System.Object.Finalize%2A>方法。 `Dispose()` 调用受保护`Dispose(Boolean)`方法替换`disposing`参数设置为`true`。 <xref:System.Object.Finalize%2A> 调用`Dispose`与`disposing`设置为`false`。  
  
 当`disposing`参数为 true 时，此方法释放由任何托管对象持有的全部资源此<xref:System.Diagnostics.EventLog>引用。 此方法调用每个引用对象的 `Dispose()` 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> 可以由其他对象多次调用。 在重写<see langword="Dispose(Boolean)" />请注意不要引用已释放的以前调用中的对象<see langword="Dispose" />。 有关如何实现详细信息<see langword="Dispose(Boolean)" />，请参阅[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
 有关详细信息<see langword="Dispose" />和<see cref="M:System.Object.Finalize" />，请参阅[清洗向上非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，用以指示 <see cref="T:System.Diagnostics.EventLog" /> 是否接收 <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> 事件通知。</summary>
        <value>
          如果 <see cref="T:System.Diagnostics.EventLog" /> 在有项写入日志时接收通知，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>属性确定是否<xref:System.Diagnostics.EventLog>条目写入到日志时引发事件。 当该属性是`true`，接收组件<xref:System.Diagnostics.EventLog.EntryWritten>事件将收到通知任何时间在指定的日志中写入一项<xref:System.Diagnostics.EventLog.Log%2A>属性。 如果<xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>是`false`，会引发任何事件。  
  
> [!NOTE]
>  仅在本地计算机上写入项时，可以接收事件通知。 无法接收在远程计算机上写入项的通知。  
  
   
  
## Examples  
 下面的示例处理<xref:System.Diagnostics.EventLog.EntryWritten>事件。  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">事件日志位于远程计算机上。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>结束用于窗体或由其他组件使用的 <see cref="T:System.Diagnostics.EventLog" /> 的初始化。 此初始化在运行时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]设计环境使用此方法来结束使用窗体或由另一个组件的组件的初始化。 <xref:System.Diagnostics.EventLog.BeginInit%2A>方法开始初始化。 使用<xref:System.Diagnostics.EventLog.BeginInit%2A>和<xref:System.Diagnostics.EventLog.EndInit%2A>方法阻止控件完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取事件日志的内容。</summary>
        <value>
          <see cref="T:System.Diagnostics.EventLogEntryCollection" />，保留事件日志中的项。 每个项均与 <see cref="T:System.Diagnostics.EventLogEntry" /> 类的一个实例关联。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.EventLog.Entries%2A>成员从事件日志中读取时。  
  
 因为该属性是只读的不能修改一项或写入日志使用<xref:System.Diagnostics.EventLog.Entries%2A>。 相反，指定<xref:System.Diagnostics.EventLog.Source%2A>并调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>写入新的日志项。 你可以使用<xref:System.Diagnostics.EventLog.Entries%2A>若要计算的事件日志中的条目数并查看每个<xref:System.Diagnostics.EventLogEntry>集合中。 使用索引<xref:System.Diagnostics.EventLogEntryCollection.Item%2A>成员，如检索有关特定条目，信息<xref:System.Diagnostics.EventLogEntry.Message%2A>， <xref:System.Diagnostics.EventLogEntry.Category%2A>， <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>，或<xref:System.Diagnostics.EventLogEntry.EntryType%2A>。  
  
 不需要指定<xref:System.Diagnostics.EventLog.Source%2A>时仅从日志中读取。 你可以仅指定<xref:System.Diagnostics.EventLog.Log%2A>名称和<xref:System.Diagnostics.EventLog.MachineName%2A>（服务器计算机名称） 属性<xref:System.Diagnostics.EventLog>实例。 在任一情况下，<xref:System.Diagnostics.EventLog.Entries%2A>成员会自动填充的条目的事件日志的列表。 此列表以读取各个项中，可以选择适当的索引的项。  
  
 读取和写入日志项之间的一个重要区别在于不需要显式调用读取的方法。 后<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>指定，<xref:System.Diagnostics.EventLog.Entries%2A>属性自动填充。 如果你更改的值<xref:System.Diagnostics.EventLog.Log%2A>或<xref:System.Diagnostics.EventLog.MachineName%2A>属性，<xref:System.Diagnostics.EventLog.Entries%2A>属性重新填充你阅读下一次。  
  
> [!NOTE]
>  你不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果要连接到日志。 如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本地计算机，"。"，则假定。  
  
   
  
## Examples  
 下面的示例读取在事件日志中，"MyNewLog"本地计算机上的项。  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>向本地计算机上的事件日志写入项时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要获取事件通知，必须设置<xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>到`true`。 只有在本地计算机上写入项时，只能接收事件通知。 无法接收在远程计算机上写入项的通知。  
  
 创建 <xref:System.Diagnostics.EventLog.EntryWritten> 委托时，需要标识将要处理该事件的方法。 若要将事件与事件处理程序关联，请将该委托的一个实例添加到事件中。 每当发生该事件时，直到移除了该委托，都会调用事件处理程序。 有关与委托一起处理事件的详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 系统响应<xref:System.Diagnostics.EventLog.WriteEntry%2A>仅当最后一个写入事件发生至少为六秒以前。 这意味着你将仅收到一个<xref:System.Diagnostics.EventLog.EntryWritten>六秒间隔内的事件通知，即使多个事件日志更改时发生。 如果插入到的调用之间的足够长的休眠时间间隔 （大约为 10 秒钟） <xref:System.Diagnostics.EventLog.WriteEntry%2A>，你不太可能丢失事件。 但是，如果更频繁地发生写入事件，你可能无法收到事件通知，直到下一个间隔。 通常情况下，丢失的事件通知将不丢失，而延迟。  
  
   
  
## Examples  
 下面的示例处理一个项写入事件。  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定指定的日志是否存在。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要搜索的日志的名称。 可能的值包括：“应用程序”、“安全性”、“系统”、其他应用程序特定的日志（如与 Active Directory 关联的日志）或计算机上的任何自定义日志。</param>
        <summary>确定该日志是否存在于本地计算机上。</summary>
        <returns>
          如果该日志存在于本地计算机上，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于确定本地计算机上是否存在日志。 如果你想要确定是否在本地计算机上，使用存在的源<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
 因为此方法访问注册表，你必须在本地计算机，则具有相应的注册表权限否则，查询将返回`false`。  
  
 因为你无法在同一台计算机上为新的日志的现有的日志名称，使用此方法之前创建新的日志以确定是否指定`logName`本地计算机上已存在。 `logName`参数不区分大小写。  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> 是`static`方法，使其可以调用类本身上。 不需要创建的实例<xref:System.Diagnostics.EventLog>调用<xref:System.Diagnostics.EventLog.Exists%2A>。  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">logName 为 <see langword="null" /> 或该值为空。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要搜索的日志。 可能的值包括：“应用程序”、“安全性”、“系统”、其他应用程序特定的日志（如与 Active Directory 关联的日志）或计算机上的任何自定义日志。</param>
        <param name="machineName">要在其上搜索日志的计算机的名称，对于本地计算机则为“.”。</param>
        <summary>确定该日志是否存在于指定计算机上。</summary>
        <returns>
          如果该日志存在于指定的计算机上，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法以确定远程计算机上是否存在日志。 如果你想要确定源是否存在的远程计算机上，使用<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
 因为此方法访问注册表，你必须指定计算机上具有相应的注册表权限否则，查询将返回`false`。  
  
 由于你无法在同一台计算机上为新的日志的现有的日志名称，使用此方法在创建新日志之前确定如果一个具有指定`logName`按指定的服务器上已存在`machineName`参数。 `logName`和`machineName`参数不区分大小写。  
  
 <xref:System.Diagnostics.EventLog.Exists%2A> 是`static`方法，使其可以调用类本身上。 不需要创建的新实例<xref:System.Diagnostics.EventLog>调用<xref:System.Diagnostics.EventLog.Exists%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 参数的格式无效。 请确保对在其上执行搜索的计算机使用了正确的语法。  
  
 或  
  
 <paramref name="logName" /> 为 <see langword="null" /> 或该值为空。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建事件日志的数组。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在本地计算机上搜索所有的事件日志并创建一个包含该列表的 <see cref="T:System.Diagnostics.EventLog" /> 对象数组。</summary>
        <returns>
          <see cref="T:System.Diagnostics.EventLog" /> 类型的数组，表示本地计算机上的日志。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数组<xref:System.Diagnostics.EventLog>对象是本地计算机上的所有事件日志的快照时对调用<xref:System.Diagnostics.EventLog.GetEventLogs%2A>进行。 这不是动态集合，因此它不反映的删除或创建的实时日志。 你应验证数组中的日志存在之前读取或写入到它。 数组通常包含至少三个日志： 应用程序、 系统和安全。 如果你在本地计算机上创建自定义日志，则它们将显示以及数组中。  
  
 若要检索事件日志的列表，你必须具有相应的注册表权限。 这些权限是与调用所需的相同<xref:System.Diagnostics.EventLog.Exists%2A>和<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
   
  
## Examples  
 下面的示例枚举的本地计算机上定义的事件日志，并显示每个事件日志的配置详细信息。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">您对注册表没有读访问权。  
  
 或  
  
 计算机上没有事件日志服务。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">在其上搜索事件日志的计算机。</param>
        <summary>在给定计算机上搜索所有事件日志并创建一个包含该列表的 <see cref="T:System.Diagnostics.EventLog" /> 对象数组。</summary>
        <returns>
          <see cref="T:System.Diagnostics.EventLog" /> 类型的数组，表示给定计算机上的日志。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数组<xref:System.Diagnostics.EventLog>对象是指定的计算机上的所有事件日志的快照`machineName`参数时对调用<xref:System.Diagnostics.EventLog.GetEventLogs%2A>进行。 这不是动态集合，因此它不反映的删除或创建的实时日志。 你应验证数组中的日志存在之前读取或写入到它。 数组通常包含至少三个日志： 应用程序、 系统和安全。 如果指定的计算机上创建自定义日志，则它们将显示以及数组中。  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A> 是`static`方法，使其可以调用上<xref:System.Diagnostics.EventLog>类本身。 不需要创建的实例<xref:System.Diagnostics.EventLog>要使其对方法的调用对象。  
  
 若要检索事件日志的列表，你必须具有相应的注册表权限。 这些权限是与调用所需的相同<xref:System.Diagnostics.EventLog.Exists%2A>和<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
   
  
## Examples  
 下面的示例获取在计算机"myServer"上的日志的列表。 然后，它将输出的每个日志的名称。  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 参数是无效的计算机名称。</exception>
        <exception cref="T:System.InvalidOperationException">您对注册表没有读访问权。  
  
 或  
  
 计算机上没有事件日志服务。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置读取或写入的日志名称。</summary>
        <value>日志的名称。 这可以是“应用程序”、“系统”、“安全性”或一个自定义的日志名称。 默认值为空字符串("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，在服务器上存在三个日志文件： 应用程序、 系统和安全。 应用程序和服务使用应用程序日志文件。 设备驱动程序使用的系统日志文件。 启用审核后，系统会在安全日志中生成成功和失败审核事件。 如果你有其他安装，如 Windows 服务器上的 Active Directory 的应用程序可能有其他默认日志文件。 此外，你可以创建本地或远程计算机上的自定义日志文件。 自定义日志可帮助组织您的项比你的组件的默认应用程序日志中写入事件时所允许的方式更详细的方式。  
  
> [!NOTE]
>  日志名称被限制为 8 个字符。 根据系统，MyLogSample1 和 MyLogSample2 都是相同的日志。  
  
 如果写入事件日志时，它没有足够可用于指定<xref:System.Diagnostics.EventLog.Log%2A>属性。 必须将关联<xref:System.Diagnostics.EventLog.Source%2A>使用事件日志资源连接到的特定日志的属性。 不需要指定<xref:System.Diagnostics.EventLog.Source%2A>时仅从一个日志，但事件源中读取必须是与服务器的注册表中的事件日志资源相关联。 你可以仅指定<xref:System.Diagnostics.EventLog.Log%2A>名称和<xref:System.Diagnostics.EventLog.MachineName%2A>（服务器计算机名称） 以从其中进行读取。  
  
> [!NOTE]
>  你不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果要连接到日志。 如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本地计算机 ("。") 假定。  
  
 如果<xref:System.Diagnostics.EventLog.Source%2A>未指定属性，调用<xref:System.Diagnostics.EventLog.Log%2A>返回空字符串，如果<xref:System.Diagnostics.EventLog.Log%2A>未显式设置 (通过设置<xref:System.Diagnostics.EventLog.Log%2A>属性，或通过构造函数)。 如果<xref:System.Diagnostics.EventLog.Source%2A>已指定，<xref:System.Diagnostics.EventLog.Log%2A>返回该源已注册到日志的名称。  
  
 一个源一次仅注册到一个日志。 如果<xref:System.Diagnostics.EventLog.Source%2A>属性已设置的实例<xref:System.Diagnostics.EventLog>，不能更改<xref:System.Diagnostics.EventLog.Log%2A>属性中的为该<xref:System.Diagnostics.EventLog>而无需更改的值<xref:System.Diagnostics.EventLog.Source%2A>或调用<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>第一个。 如果你更改<xref:System.Diagnostics.EventLog.Log%2A>属性后的<xref:System.Diagnostics.EventLog.Source%2A>属性已设置，编写日志条目会引发异常。  
  
 操作系统将事件日志存储为文件。 当你使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>若要创建新的事件日志，关联的文件存储在指定的计算机上的 %SystemRoot%\System32\Config 目录。 通过追加的前 8 个字符设置的文件名称<xref:System.Diagnostics.EventLog.Log%2A>".evt"文件扩展名的属性。  
  
 无法创建新的日志使用<xref:System.Diagnostics.EventLog.Log%2A>单独 （而不指定日志的源） 的属性。 你可以调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>，在一个新的日志名称作为参数传递，然后调用<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。 但是，目的是通常以创建 （并将条目写入） 新的应用程序特定日志，或用于从现有日志读取。  
  
 如果<xref:System.Diagnostics.EventLog.Log%2A>值更改，关闭事件日志并释放所有事件句柄。  
  
> [!CAUTION]
>  如果你设置<xref:System.Diagnostics.EventLog.Log%2A>属性不存在日志的名称，系统将附加<xref:System.Diagnostics.EventLog>向应用程序日志中，但不会警告你它正在使用不是你指定的日志。  
  
   
  
## Examples  
 下面的示例读取在事件日志中，"NewEventLog"本地计算机上的项。  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取事件日志的友好名称。</summary>
        <value>一个表示系统的事件查看器中事件日志的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 Windows Vista 或更高版本，则用户没有访问安全日志的权限。 如果你正在运行 Windows Vista 或更高版本作为一个用户，你将获得<xref:System.Security.SecurityException>当你尝试访问安全日志中的事件的显示名称。  
>   
>  在 Windows Vista 或更高版本中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行的代码访问安全日志，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
   
  
## Examples  
 下面的示例将枚举在本地计算机上定义的事件日志，并显示<xref:System.Diagnostics.EventLog.LogDisplayName%2A>每个事件日志。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此计算机的注册表中不存在指定的 <see cref="P:System.Diagnostics.EventLog.Log" />。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">读取指定的注册表项的功能。 关联的枚举： <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">它能够访问指定的注册表密钥如果它是一个远程的键。 关联的枚举： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">事件源的名称。</param>
        <param name="machineName">要从中删除日志的计算机名称，对于本地计算机则为“.”。</param>
        <summary>获取指定的源注册到的日志的名称。</summary>
        <returns>与注册表中的指定源关联的日志名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件源指示什么来记录事件。 通常很的应用程序，名称或名称的子组件的应用程序，如果应用程序非常大。 应用程序和服务应写入应用程序日志或自定义日志。 设备驱动程序应写入系统日志。  
  
 在你创建新的源，可以仅写入一个日志一次，系统将你的应用程序的事件日志注册为有效项源。 <xref:System.Diagnostics.EventLog.Source%2A>属性可以是任意字符串，但名称不能由计算机上的其他源。 尝试创建重复的<xref:System.Diagnostics.EventLog.Source%2A>值引发异常。 但是，单个事件日志可以有许多不同的源向其写入。  
  
   
  
## Examples  
 下面的示例从本地计算机中删除源。 该示例确定从其源日志，然后删除该日志。  
  
> [!NOTE]
>  多个源可能会写入事件日志。 在删除之前自定义日志，请确保没有其他源写入该日志。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在其上读取或写入事件的计算机的名称。</summary>
        <value>事件日志驻留的服务器的名称。 默认为本地计算机 (".")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果写入事件日志时，必须将关联<xref:System.Diagnostics.EventLog.Source%2A>使用你要将其连接到的特定日志的事件日志对象。 不需要指定<xref:System.Diagnostics.EventLog.Source%2A>时仅从日志中读取的属性。 你可以仅指定<xref:System.Diagnostics.EventLog.Log%2A>名称和<xref:System.Diagnostics.EventLog.MachineName%2A>（服务器计算机名称）。  
  
> [!NOTE]
>  不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果要连接到日志。 如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本地计算机 ("。") 假定。  
  
 一个源一次仅注册到一个日志。 如果<xref:System.Diagnostics.EventLog.Source%2A>属性已设置的实例<xref:System.Diagnostics.EventLog>，不能更改<xref:System.Diagnostics.EventLog.MachineName%2A>属性中的为该<xref:System.Diagnostics.EventLog>而无需更改的值<xref:System.Diagnostics.EventLog.Source%2A>或调用<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>第一个。 如果你更改<xref:System.Diagnostics.EventLog.MachineName%2A>属性，<xref:System.Diagnostics.EventLog>关闭所有句柄并重新附加到的日志和新的计算机上的源。  
  
 <xref:System.Diagnostics.EventLog.MachineName%2A>值不能为空字符串。 如果显式设置，则默认为本地计算机 ("。")。  
  
   
  
## Examples  
 下面的示例读取在事件日志中，"NewEventLog"指定计算机上的项。  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">计算机名称无效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置最大事件日志大小（以 KB 为单位）。</summary>
        <value>最大事件日志大小（以 KB 为单位）。 默认值为 512，表示最大文件大小为 512 KB。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>属性表示的事件日志文件的大小限制。 当在事件日志达到配置的大小限制<xref:System.Diagnostics.EventLog.OverflowAction%2A>值确定是否将丢弃新条目，或是否新条目覆盖旧条目。  
  
> [!NOTE]
>  此属性表示此实例所表示的事件日志的配置设置。 当事件日志达到其最大大小时，此属性指定操作系统如何处理为事件日志已注册的所有事件源都写入新条目。  
  
   
  
## Examples  
 下面的示例枚举的本地计算机上定义的事件日志，并显示每个事件日志的配置详细信息。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指定值小于 64，或大于 4194240，或不是 64 的偶数倍。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> 值不是有效的日志名。  
  
 \- 或 -  
  
 事件日志的注册表项无法在目标计算机上打开。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取要在事件日志中保留项的天数。</summary>
        <value>事件日志中的项被保留的天数。 默认值为 7。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>属性可以检查事件日志的当前设置。 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>若要更改的最小天数必须保留在事件日志中的每个条目数。  
  
 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>值取决于在事件日志的已配置的溢出行为。 如果<xref:System.Diagnostics.OverflowAction>事件日志的属性设置为<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>，则<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>值为 0。 如果<xref:System.Diagnostics.OverflowAction>事件日志的属性设置为<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>，则<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>值为-1。 如果<xref:System.Diagnostics.OverflowAction>事件日志的属性设置为<xref:System.Diagnostics.OverflowAction.OverwriteOlder>，则<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>值是大于零，并且表示的事件日志已满时保留事件日志条目的天数。  
  
 溢出行为仅会在事件日志达到其容量限制时发生。 当<xref:System.Diagnostics.EventLog>具有其<xref:System.Diagnostics.EventLog.OverflowAction%2A>设置为<xref:System.Diagnostics.OverflowAction.OverwriteOlder>，和在事件日志达到其最大大小，则新条目如果它们可以将其保留时间超出的条目只能写入<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>段。 事件项保留最短期限适合定期存档事件日志时的不同而不同。 否则，则可能在事件日志达到其限制时丢失新条目。 若要避免丢失新的事件信息，请设置基于对您的存档计划为特定的事件日志的事件的最小保留天数。  
  
   
  
## Examples  
 下面的示例枚举的本地计算机上定义的事件日志，并显示每个事件日志的配置详细信息。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" />
        <Parameter Name="retentionDays" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="action">向事件日志写入新项的溢出行为。</param>
        <param name="retentionDays">每个事件日志项要保留的最小天数。 只有在 <c>action</c> 设置为 <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" /> 时，才使用此参数。</param>
        <summary>更改已配置的行为，以便在事件日志达到其最大文件大小时写入新项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件日志的溢出行为指定要写入到日志已达到其最大文件大小新条目时，会发生什么情况。  
  
> [!NOTE]
>  溢出行为仅在事件日志达到其最大文件大小时生效。 溢出行为不会影响到可以容纳其他事件日志条目的日志写入新的条目。  
  
 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>方法配置事件日志的溢出行为。 <xref:System.Diagnostics.EventLog> 实例。 为指定的事件日志中调用此方法后<xref:System.Diagnostics.EventLog.Log%2A>属性，<xref:System.Diagnostics.EventLog.OverflowAction%2A>和<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>属性值反映新配置的溢出行为。  
  
> [!NOTE]
>  此属性表示此实例所表示的事件日志的配置设置。 当事件日志达到其最大大小时，此属性指定操作系统如何处理为事件日志已注册的所有事件源都写入新条目。  
  
 设置`action`参数<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>以指示新条目覆盖最旧条目时<xref:System.Diagnostics.EventLog>达到其最大大小。 如果`action`参数设置为<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>、`retentionDays`参数值将被忽略。  
  
 设置`action`参数<xref:System.Diagnostics.OverflowAction.OverwriteOlder>以指示每个新条目将覆盖旧条目时<xref:System.Diagnostics.EventLog>达到其最大大小。 指定在日志中使用的事件必须保留的天数`retentionDays`参数。 保持期内写入的事件不会覆盖通过新的条目。  
  
 设置`action`参数<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>丢弃新事件时已达到最大日志大小。 如果`action`参数设置为<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>、`retentionDays`参数值将被忽略。  
  
> [!CAUTION]
>  将溢出策略设置为<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>指定当事件日志已满而丢弃新条目。 如果你使用此设置，请确保定期存档和清除避免达到其最大大小限制事件日志。  
  
   
  
## Examples  
 下面的示例显示一个指定的事件日志的已配置的溢出策略，并允许用户选择新事件日志的溢出策略设置。  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> 不是有效的 <see cref="P:System.Diagnostics.EventLog.OverflowAction" /> 值。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="retentionDays" /> 小于 1 或大于 365。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> 值不是有效的日志名。  
  
 \- 或 -  
  
 事件日志的注册表项无法在目标计算机上打开。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已配置的行为，以便在事件日志达到其最大文件大小时存储新项。</summary>
        <value>
          <see cref="T:System.Diagnostics.OverflowAction" /> 值，指定在事件日志达到其最大日志大小时存储新项的已配置行为。 默认值为 <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件日志大小增大新事件写入到它们。 每个事件日志的配置的最大大小限制;<xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>属性定义的最大事件日志文件大小所允许的千字节数。  
  
 使用<xref:System.Diagnostics.EventLog.OverflowAction%2A>要检查其最大大小在事件日志的已配置的溢出行为的属性值。 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>方法来更改事件日志的溢出行为。  
  
> [!NOTE]
>  溢出行为仅在事件日志达到其最大文件大小时生效。 溢出行为不会影响到可以容纳其他事件日志条目的日志写入新的条目。  
  
   
  
## Examples  
 下面的示例枚举的本地计算机上定义的事件日志，并显示每个事件日志的配置详细信息。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" />
        <Parameter Name="resourceId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="resourceFile">本地化资源文件的完全指定的路径。</param>
        <param name="resourceId">在资源文件内指明一个本地化字符串的资源标识符。</param>
        <summary>指定该事件日志的本地化名称，它显示在服务器事件查看器中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>注册以及自定义事件日志事件查看器中显示的本地化的名称。  
  
 指定的资源标识符必须对应于在资源文件中定义的本地化字符串。 事件查看器显示使用本地化的字符串和当前区域性设置的自定义事件日志名称。 例如，你可以定义多个资源文件中的不同区域性的本地化的事件日志名称。 事件查看器显示当前用户的区域性设置相对应的本地化的字符串。  
  
 如果事件查看器无法从资源文件中，加载本地化的字符串，或如果没有显示名称已注册的事件日志中，事件查看器显示中定义的事件日志名称<xref:System.Diagnostics.EventLog.Log%2A>。  
  
> [!NOTE]
>  不需要注册预定义的事件日志的显示名称。 操作系统注册应用程序、 系统和安全事件日志的本地化的显示名称。  
  
   
  
## Examples  
 下面的示例确定是否将名为事件源`SampleApplicationSource`已在本地计算机上注册。 如果事件源不存在，该示例设置源的消息资源文件，并创建新的事件源。 最后，该示例设置使用中的资源标识符值的事件日志的本地化的显示名称`DisplayNameMsgId`和中的资源文件路径`messageFile`。  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 该示例使用以下的消息文本文件，内置于 EventLogMsgs.dll 的资源库。 消息文本文件是从其创建的消息资源文件的源。 消息文本文件定义的资源标识符和类别、 事件消息和参数插入字符串的文本。 具体而言，为事件日志的本地化名称定义了资源标识符 5001。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Diagnostics.EventLog.Log" /> 值不是有效的日志名。  
  
 \- 或 -  
  
 事件日志的注册表项无法在目标计算机上打开。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFile" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在写入事件日志时要注册和使用的源名称。</summary>
        <value>在事件日志中注册为项源的名称。 默认值为空字符串("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件源指示什么来记录事件。 通常很的应用程序，名称或名称的子组件的应用程序，如果应用程序非常大。 应用程序和服务应写入应用程序日志或自定义日志。 设备驱动程序应写入系统日志。  
  
 只需指定事件源，如果要写入事件日志。 然后再写入事件日志条目，你必须将注册事件源的事件日志有效的事件源。 当你编写日志条目时，系统将使用<xref:System.Diagnostics.EventLog.Source%2A>属性以查找要在其中放置你的输入适当的日志。 如果您正在读取事件日志，你可以指定<xref:System.Diagnostics.EventLog.Source%2A>，或<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>。  
  
> [!NOTE]
>  你不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果要连接到本地计算机上的日志。 如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本地计算机 ("。") 假定。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>事件写入事件日志。 必须指定事件源写入事件;你必须创建并在编写与源的第一个条目之前，配置事件源。  
  
 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 你可以创建现有的事件日志或新的事件日志的事件源。 在创建新的源的新的事件日志时，系统将为该日志，此源注册，但之前向其中写入的第一个条目，将不会创建日志。  
  
 必须是唯一的本地计算机; 上的源新的源名称不能与现有源名称或现有的事件日志名称匹配。 每个源可以一次; 写入只有一个事件日志但是，你的应用程序可以使用多个源写入多个事件日志。 例如，你的应用程序可能需要为不同的事件日志或不同的资源文件配置的多个源。  
  
 如果你更改<xref:System.Diagnostics.EventLog.Source%2A>值，<xref:System.Diagnostics.EventLog>到它注册已关闭并释放所有事件句柄。  
  
 要写入本地化的项还是要直接写入字符串，则必须配置源。 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
 若要更改现有源的配置详细信息，必须删除源，然后使用新的配置创建。 如果其他应用程序或组件使用的现有源，请使用更新的配置，而无需删除现有的源创建新的源。  
  
> [!NOTE]
>  如果源已映射到某个日志并重新映射到新的日志，必须重新启动计算机才能使更改生效。  
  
   
  
## Examples  
 下面的示例创建源`MySource`如果它尚不存在，并将项写入事件日志`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在计算机的注册表中搜索给定的事件源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">事件源的名称。</param>
        <summary>确定事件源是否已在本地计算机上注册。</summary>
        <returns>
          如果事件源已在本地计算机上注册，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于确定本地计算机上是否存在事件源。 如果你想要确定本地计算机，使用上是否存在日志<xref:System.Diagnostics.EventLog.Exists%2A>。  
  
 因为此方法访问注册表，你必须在本地计算机，则具有相应的注册表权限否则为<xref:System.Security.SecurityException>将引发。  
  
> [!NOTE]
>  若要搜索的事件源在 Windows Vista 或更高版本或 Windows Server 2003，必须具有管理权限。  
>   
>  此要求的原因是所有的事件日志，包括安全性，必须进行搜索以确定事件源是否唯一。 从 Windows Vista 开始，用户没有权限访问安全事件日志中。因此，<xref:System.Security.SecurityException>引发。  
>   
>  从 Windows Vista 开始，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
> [!NOTE]
>  在下执行服务<xref:System.ServiceProcess.ServiceAccount.LocalSystem>帐户没有执行此方法所需的权限。 解决方法是检查中是否存在事件源<xref:System.ServiceProcess.ServiceInstaller>，并且如果它不存在，在安装程序中创建源。  
  
 因为你无法为新的源的同一台计算机上的现有源名称，使用此方法尝试之前调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>以确保源指定的名称与`source`本地计算机上尚不存在。 `source`参数不区分大小写。  
  
   
  
## Examples  
 下面的示例创建源`MySource`如果它尚不存在，并将项写入事件日志`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          未找到 <paramref name="source" />，无法搜索部分或全部事件日志。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">事件源的名称。</param>
        <param name="machineName">在其上查看的计算机的名称，对于本地计算机则为“.”。</param>
        <summary>确定事件源是否已在指定的计算机上注册。</summary>
        <returns>
          如果事件源已在给定计算机上注册，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于确定指定的计算机上是否存在事件源`machineName`参数。 如果你想要确定使用指定的计算机上是否存在日志<xref:System.Diagnostics.EventLog.Exists%2A>。  
  
 因为此方法访问注册表，你必须在给定的服务器中; 上具有相应的注册表权限否则为<xref:System.Security.SecurityException>将引发。  
  
> [!NOTE]
>  若要搜索的事件源在 Windows Vista 或更高版本或 Windows Server 2003，必须具有管理权限。  
>   
>  此要求的原因是所有的事件日志，包括安全性，必须进行搜索以确定事件源是否唯一。 从 Windows Vista 开始，用户没有权限访问安全事件日志中。因此，<xref:System.Security.SecurityException>引发。  
>   
>  从 Windows Vista 开始，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码，首先必须将你的特权从标准用户提升至管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
> [!NOTE]
>  在下执行服务<xref:System.ServiceProcess.ServiceAccount.LocalSystem>帐户没有执行此方法所需的权限。 解决方法是检查中是否存在事件源<xref:System.ServiceProcess.ServiceInstaller>，并且如果它不存在，在安装程序中创建源。  
  
 因为你无法为新的源的同一台计算机上的现有源名称，使用此方法尝试之前调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>以确保源指定的名称与`source`计算机上尚不存在。 `source`和`machineName`参数不区分大小写。  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A> 是`static`方法，使其可以调用类本身上。 不需要创建的实例<xref:System.Diagnostics.EventLog>调用<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
   
  
## Examples  
 下面的示例创建源`MySource`计算机上`MyServer`，和一个项写入事件日志`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> 是无效的计算机名称。</exception>
        <exception cref="T:System.Security.SecurityException">
          未找到 <paramref name="source" />，无法搜索部分或全部事件日志。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于封送事件处理程序调用的对象，该调用在有 <see cref="T:System.Diagnostics.EventLog" /> 项写入事件时发出。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" />，用于封送由事件日志上的 <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> 事件引发的事件处理程序调用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>是`null`，方法处理<xref:System.Diagnostics.EventLog.EntryWritten>事件调用从系统线程池线程上。 系统线程池的详细信息，请参阅<xref:System.Threading.ThreadPool>。  
  
 当<xref:System.Diagnostics.EventLog.EntryWritten>事件由 visual Windows 窗体组件，如按钮，通过系统线程池访问组件可能无法工作，或可能导致的异常处理。 通过设置来避免这<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>到 Windows 窗体组件时，这将导致处理的方法<xref:System.Diagnostics.EventLog.EntryWritten>事件在其创建该组件在同一线程上调用。  
  
 如果<xref:System.Diagnostics.EventLog>在内部使用[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]在 Windows 窗体设计器中，<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>自动设置为控件包含<xref:System.Diagnostics.EventLog>。 例如，如果你将放置<xref:System.Diagnostics.EventLog>form1 设计器上 (其继承自<xref:System.Windows.Forms.Form>)<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>属性<xref:System.Diagnostics.EventLog>被设置为 form1 的实例。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将项写入事件日志。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">要写入事件日志的字符串。</param>
        <summary>将信息类型项与给定的消息文本一起写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法与此关联的事件日志中写入信息项<xref:System.Diagnostics.EventLog>实例。 如果你想要指定任何其他<xref:System.Diagnostics.EventLogEntryType>，使用的不同重载<xref:System.Diagnostics.EventLog.WriteEntry%2A>。  
  
> [!NOTE]
>  `message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
 必须设置<xref:System.Diagnostics.EventLog.Source%2A>属性你<xref:System.Diagnostics.EventLog>组件之前可以将条目写入日志。 你必须创建并在编写与源的第一个条目之前，配置事件源。  
  
 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 如果在指定的源<xref:System.Diagnostics.EventLog.Source%2A>此属性<xref:System.Diagnostics.EventLog>写入你的组件，在计算机上未注册实例<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>并注册源。  
  
> [!NOTE]
>  如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>为你<xref:System.Diagnostics.EventLog>实例然后才能调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本地计算机 ("。") 假定。  
  
 如果系统需要注册<xref:System.Diagnostics.EventLog.Source%2A>通过调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>和<xref:System.Diagnostics.EventLog.Log%2A>未上设置属性你<xref:System.Diagnostics.EventLog>实例，该日志将默认为应用程序日志。  
  
> [!NOTE]
>  许多上面列出的异常由错误生成的注册过程中发生<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
> [!NOTE]
>  如果远程计算机中写入一个条目，消息 （文本字符串） 的值可能不是你所预期如果远程计算机未在运行.NET Framework。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。  
  
   
  
## Examples  
 下面的示例创建源`MySource`如果它尚不存在，并将项写入事件日志`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
 或  
  
 该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
 \- 或 -  
  
 已为其他事件日志注册了该源。  
  
 \- 或 -  
  
 消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
 \- 或 -  
  
 此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <summary>将错误、警告、信息、成功审核或失败审核项与给定的消息文本一起写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法的指定项写入<xref:System.Diagnostics.EventLogEntryType>到事件日志。 `type`指示由一个图标和事件查看器日志中的类型列中的文本。  
  
> [!NOTE]
>  `message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
 必须设置<xref:System.Diagnostics.EventLog.Source%2A>属性你<xref:System.Diagnostics.EventLog>组件之前可以将条目写入日志。 你必须创建并在编写与源的第一个条目之前，配置事件源。  
  
 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 如果在指定的源<xref:System.Diagnostics.EventLog.Source%2A>此属性<xref:System.Diagnostics.EventLog>写入你的组件，在计算机上未注册实例<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>并注册源。  
  
> [!NOTE]
>  如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>为你<xref:System.Diagnostics.EventLog>实例然后才能调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本地计算机 ("。") 假定。  
  
 如果系统需要注册<xref:System.Diagnostics.EventLog.Source%2A>通过调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>和<xref:System.Diagnostics.EventLog.Log%2A>未上设置属性你<xref:System.Diagnostics.EventLog>实例，该日志将默认为应用程序日志。  
  
> [!NOTE]
>  上面列出的许多异常由错误生成的注册过程中发生<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
> [!NOTE]
>  如果远程计算机中写入一个条目，消息 （文本字符串） 的值可能不是你所预期如果远程计算机未在运行.NET Framework。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。  
  
   
  
## Examples  
 下面的示例在本地计算机上，向事件日志中，"MyNewLog"写入警告项。  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
 或  
  
 该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
 \- 或 -  
  
 已为其他事件日志注册了该源。  
  
 \- 或 -  
  
 消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
 \- 或 -  
  
 此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在指定计算机上注册时所采用的源。</param>
        <param name="message">要写入事件日志的字符串。</param>
        <summary>使用指定的注册事件源将信息类型项与给定的消息文本一起写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法要使用已注册为相应的日志的事件源的源的事件日志中写入信息项。 如果你想要指定任何其他<xref:System.Diagnostics.EventLogEntryType>，使用的不同重载<xref:System.Diagnostics.EventLog.WriteEntry%2A>。  
  
 你必须创建并在编写与源的第一个条目之前，配置事件源。 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。  
>   
>  `message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
   
  
## Examples  
 下面的示例创建源`MySource`如果它尚不存在，并将项写入事件日志`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 值是空字符串 ("")。  
  
 \- 或 -  
  
 <paramref name="source" /> 值为 <see langword="null" />。  
  
 \- 或 -  
  
 消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
 \- 或 -  
  
 此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <param name="eventID">事件的应用程序特定标识符。</param>
        <summary>将一个具有给定消息文本和应用程序定义的事件标识符的项写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法写入与应用程序定义条目`eventID`到事件日志。 `eventID`与源一起唯一地标识事件。 每个应用程序可以定义其自己的编号的事件以及它们映射到其中的描述字符串。 事件查看器显示这些字符串值，以帮助用户了解发生的问题和建议采取的操作。  
  
> [!NOTE]
>  `message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
 除了事件标识符，还可以指定<xref:System.Diagnostics.EventLogEntryType>写入到事件日志的事件。 `type`指示由一个图标和事件查看器日志中的类型列中的文本。 此参数指示事件类型是否是错误、 警告、 信息、 成功审核或失败审核。  
  
 必须设置<xref:System.Diagnostics.EventLog.Source%2A>属性你<xref:System.Diagnostics.EventLog>组件之前可以将条目写入日志。 你必须创建并在编写与源的第一个条目之前，配置事件源。  
  
 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 如果在指定的源<xref:System.Diagnostics.EventLog.Source%2A>此属性<xref:System.Diagnostics.EventLog>写入你的组件，在计算机上未注册实例<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>并注册源。  
  
> [!NOTE]
>  如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>为你<xref:System.Diagnostics.EventLog>实例然后才能调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本地计算机 ("。") 假定。  
  
 如果系统需要注册<xref:System.Diagnostics.EventLog.Source%2A>通过调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>和<xref:System.Diagnostics.EventLog.Log%2A>未上设置属性你<xref:System.Diagnostics.EventLog>实例，该日志将默认为应用程序日志。  
  
> [!NOTE]
>  上面列出的许多异常由错误生成的注册过程中发生<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
> [!NOTE]
>  如果远程计算机中写入一个条目，消息 （文本字符串） 的值可能不是你所预期如果远程计算机未在运行.NET Framework。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
 或  
  
 该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
 \- 或 -  
  
 已为其他事件日志注册了该源。  
  
 \- 或 -  
  
 <paramref name="eventID" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
 \- 或 -  
  
 消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
 \- 或 -  
  
 此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在指定计算机上注册时所采用的源。</param>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <summary>使用指定的注册事件源，将错误、警告、信息、成功审核或失败审核项与给定的消息文本一起写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法的指定项写入<xref:System.Diagnostics.EventLogEntryType>到事件日志中，将源使用已注册为相应的日志的事件源。 `type`指示由一个图标和事件查看器日志中的类型列中的文本。  
  
> [!NOTE]
>  `message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
 你必须创建并在编写与源的第一个条目之前，配置事件源。 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。  
  
   
  
## Examples  
 下面的示例在本地计算机上，向事件日志中，"MyNewLog"写入警告项。  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 值是空字符串 ("")。  
  
 \- 或 -  
  
 <paramref name="source" /> 值为 <see langword="null" />。  
  
 \- 或 -  
  
 消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
 \- 或 -  
  
 此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <param name="eventID">事件的应用程序特定标识符。</param>
        <param name="category">与消息关联的应用程序特定子类别。</param>
        <summary>将一个具有给定消息文本、应用程序定义的事件标识符和应用程序定义的类别的项写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法写入与应用程序定义条目`category`到事件日志。 事件查看器将使用到按事件源写入筛选器事件类别。 事件查看器可将类别显示为数字值，或者它可以作为资源标识符使用类别，以显示本地化的类别字符串。  
  
> [!NOTE]
>  `category`参数应是正数值。 负类别值显示为正补数在事件查看器。 例如，– 10 显示为 65526，为 65535 为-1。  
  
> [!NOTE]
>  `message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
 若要在事件查看器中显示本地化的类别字符串，必须使用事件源使用类别资源文件，配置和设置`category`类别资源文件中的资源标识符。 如果事件源没有配置的类别资源文件，或指定`category`没有索引在类别资源文件中，一个字符串，则事件查看器将显示该条目的数字类别值。 配置类别资源文件，以及数量的类别字符串在资源文件中，使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>类。  
  
 除了类别，你可以指定要写入事件日志事件的事件标识符。 事件标识符以及事件源，唯一标识的事件。 每个应用程序可以定义其自己的编号的事件以及它们映射到其中的描述字符串。 事件查看器显示这些字符串值，以帮助用户了解发生的问题和建议采取的操作。  
  
 最后，你可以指定<xref:System.Diagnostics.EventLogEntryType>写入到事件日志的事件。 `type`指示由一个图标和事件查看器日志中的类型列中的文本。 此参数指示事件类型是否是错误、 警告、 信息、 成功审核或失败审核。  
  
 必须设置<xref:System.Diagnostics.EventLog.Source%2A>属性你<xref:System.Diagnostics.EventLog>组件之前可以将条目写入日志。 你必须创建并在编写与源的第一个条目之前，配置事件源。  
  
 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 如果在指定的源<xref:System.Diagnostics.EventLog.Source%2A>此属性<xref:System.Diagnostics.EventLog>写入你的组件，在计算机上未注册实例<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>并注册源。  
  
> [!NOTE]
>  如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>为你<xref:System.Diagnostics.EventLog>实例然后才能调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本地计算机 ("。") 假定。  
  
 如果系统需要注册<xref:System.Diagnostics.EventLog.Source%2A>通过调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>和<xref:System.Diagnostics.EventLog.Log%2A>未上设置属性你<xref:System.Diagnostics.EventLog>实例，该日志将默认为应用程序日志。  
  
> [!NOTE]
>  上面列出的许多异常由错误生成的注册过程中发生<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
> [!NOTE]
>  如果远程计算机中写入一个条目，消息 （文本字符串） 的值可能不是你所预期如果远程计算机未在运行.NET Framework。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
 或  
  
 该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
 \- 或 -  
  
 已为其他事件日志注册了该源。  
  
 \- 或 -  
  
 <paramref name="eventID" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
 \- 或 -  
  
 消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
 \- 或 -  
  
 此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在指定计算机上注册时所采用的源。</param>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <param name="eventID">事件的应用程序特定标识符。</param>
        <summary>使用指定的注册事件源，将一个具有给定消息文本和应用程序定义的事件标识符的项写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法写入与应用程序定义条目`eventID`到事件日志中，将源使用已注册为相应的日志的事件源。 `eventID`，以及源，唯一标识事件。 每个应用程序可以定义其自己的编号的事件以及它们映射到其中的描述字符串。 事件查看器将这些字符串向用户以帮助用户了解发生的问题并建议采取的操作。  
  
> [!NOTE]
>  `message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
 此重载的事件标识符，除了<xref:System.Diagnostics.EventLog.WriteEntry%2A>允许您指定<xref:System.Diagnostics.EventLogEntryType>写入到事件日志的事件。 `type`指示由一个图标和事件查看器日志中的类型列中的文本。 此参数指示事件类型是否是错误、 警告、 信息、 成功审核或失败审核。  
  
 你必须创建并在编写与源的第一个条目之前，配置事件源。 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 值是空字符串 ("")。  
  
 \- 或 -  
  
 <paramref name="source" /> 值为 <see langword="null" />。  
  
 \- 或 -  
  
 <paramref name="eventID" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
 \- 或 -  
  
 消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
 \- 或 -  
  
 此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <param name="eventID">事件的应用程序特定标识符。</param>
        <param name="category">与消息关联的应用程序特定子类别。</param>
        <param name="rawData">包含与此项关联的二进制数据的字节数组。</param>
        <summary>将一个具有给定消息文本、应用程序定义的事件标识符和应用程序定义的类别的项写入事件日志，并向消息追加二进制数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载将应用程序定义特定于事件的数据写入事件日志。 事件查看器不解释该数据。它仅在组合的十六进制转义序列和文本格式显示原始数据。 特定于事件的数据应谨慎使用，包括它仅当你确信它将会对某人调试问题很有用。 特定于事件的数据还可用于存储应用程序可以处理独立于事件查看器的信息。 例如，你无法专门为事件，编写一个查看器或编写扫描日志文件，并创建报告，包括来自特定事件的数据的信息的程序。  
  
 除了二进制数据，还可以指定应用程序定义的类别和应用程序定义的事件标识符。 事件查看器将使用到按事件源写入筛选器事件类别。 事件查看器可将类别显示为数字值，或者它可以作为资源标识符使用类别，以显示本地化的类别字符串。  
  
> [!NOTE]
>  `message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
> [!NOTE]
>  `category`参数应是正数值。 负类别值显示为正补数在事件查看器。 例如，– 10 显示为 65526，为 65535 为-1。  
  
 若要在事件查看器中显示本地化的类别字符串，必须使用事件源使用类别资源文件，配置和设置`category`类别资源文件中的资源标识符。 如果事件源没有配置的类别资源文件，或指定`category`没有索引在类别资源文件中，一个字符串，则事件查看器将显示该条目的数字类别值。 配置类别资源文件，以及数量的类别字符串在资源文件中，使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>类。  
  
 事件标识符以及事件源，唯一标识的事件。 每个应用程序可以定义其自己的编号的事件以及它们映射到其中的描述字符串。 事件查看器显示这些字符串值，以帮助用户了解发生的问题和建议采取的操作。  
  
 最后，你可以指定<xref:System.Diagnostics.EventLogEntryType>写入到事件日志的事件。 `type`指示由一个图标和事件查看器日志中的类型列中的文本。 此参数指示事件类型是否是错误、 警告、 信息、 成功审核或失败审核。  
  
 必须设置<xref:System.Diagnostics.EventLog.Source%2A>属性你<xref:System.Diagnostics.EventLog>组件之前可以将条目写入日志。 你必须创建并在编写与源的第一个条目之前，配置事件源。  
  
 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 如果在指定的源<xref:System.Diagnostics.EventLog.Source%2A>此属性<xref:System.Diagnostics.EventLog>写入你的组件，在计算机上未注册实例<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>并注册源。  
  
> [!NOTE]
>  如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>为你<xref:System.Diagnostics.EventLog>实例然后才能调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本地计算机 ("。") 假定。  
  
 如果系统需要注册<xref:System.Diagnostics.EventLog.Source%2A>通过调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>和<xref:System.Diagnostics.EventLog.Log%2A>未上设置属性你<xref:System.Diagnostics.EventLog>实例，该日志将默认为应用程序日志。  
  
> [!NOTE]
>  上面列出的许多异常由错误生成的注册过程中发生<xref:System.Diagnostics.EventLog.Source%2A>。  
  
 要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
> [!NOTE]
>  如果远程计算机中写入一个条目，消息 （文本字符串） 的值可能不是你所预期如果远程计算机未在运行.NET Framework。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
 或  
  
 该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
 \- 或 -  
  
 已为其他事件日志注册了该源。  
  
 \- 或 -  
  
 <paramref name="eventID" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
 \- 或 -  
  
 消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
 \- 或 -  
  
 此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在指定计算机上注册时所采用的源。</param>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <param name="eventID">事件的应用程序特定标识符。</param>
        <param name="category">与消息关联的应用程序特定子类别。</param>
        <summary>通过使用指定的注册事件源，将一个具有给定消息文本、应用程序定义的事件标识符和应用程序定义的类别的项写入事件日志。 事件查看器可使用 <paramref name="category" /> 筛选日志中的事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法写入与应用程序定义条目`category`到事件日志中，使用已注册为相应的日志的事件源的源。 事件查看器将使用到按事件源写入筛选器事件类别。 事件查看器可将类别显示为数字值，或者它可以作为资源标识符使用类别，以显示本地化的类别字符串。  
  
> [!NOTE]
>  `category`参数应是正数值。 负类别值显示为正补数在事件查看器。 例如，– 10 显示为 65526，为 65535 为-1。  
  
 若要在事件查看器中显示本地化的类别字符串，必须使用事件源使用类别资源文件，配置和设置`category`类别资源文件中的资源标识符。 如果事件源没有配置的类别资源文件，或指定`category`没有索引在类别资源文件中，一个字符串，则事件查看器将显示该条目的数字类别值。 配置类别资源文件，以及数量的类别字符串在资源文件中，使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>类。  
  
 除了类别，你可以指定要写入事件日志事件的事件标识符。 事件标识符以及事件源，唯一标识的事件。 每个应用程序可以定义其自己的编号的事件以及它们映射到其中的描述字符串。 事件查看器显示这些字符串值，以帮助用户了解发生的问题和建议采取的操作。  
  
 最后，你可以指定<xref:System.Diagnostics.EventLogEntryType>写入到事件日志的事件。 `type`指示由一个图标和事件查看器日志中的类型列中的文本。 此参数指示事件类型是否是错误、 警告、 信息、 成功审核或失败审核。  
  
 你必须创建并在编写与源的第一个条目之前，配置事件源。 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。  
>   
>  `message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 值是空字符串 ("")。  
  
 \- 或 -  
  
 <paramref name="source" /> 值为 <see langword="null" />。  
  
 \- 或 -  
  
 <paramref name="eventID" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
 \- 或 -  
  
 消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
 \- 或 -  
  
 此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在指定计算机上注册时所采用的源。</param>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type">
          <see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <param name="eventID">事件的应用程序特定标识符。</param>
        <param name="category">与消息关联的应用程序特定子类别。</param>
        <param name="rawData">包含与此项关联的二进制数据的字节数组。</param>
        <summary>（使用指定的注册事件源）将一个包含给定消息文本、应用程序定义的事件标识符和应用程序定义的类别的项写入事件日志，并向消息追加二进制数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法将应用程序定义特定于事件的数据写入事件日志中，使用已注册为相应的日志的事件源的源。 事件查看器不解释该数据。它仅在组合的十六进制转义序列和文本格式显示原始数据。 应谨慎; 使用特定于事件的数据仅当你确信它将会很有用，则将其包含。 特定于事件的数据还可用于存储应用程序可以处理独立于事件查看器的信息。 例如，你无法专门为事件，编写一个查看器或编写扫描日志文件，并创建报告，包括来自特定事件的数据的信息的程序。  
  
 除了二进制数据，还可以指定应用程序定义的类别和应用程序定义的事件标识符。 事件查看器将使用到按事件源写入筛选器事件类别。 事件查看器可将类别显示为数字值，或者它可以作为资源标识符使用类别，以显示本地化的类别字符串。  
  
> [!NOTE]
>  `category`参数应是正数值。 负类别值显示为正补数在事件查看器。 例如，– 10 将显示为 65526，为 65535 为-1。  
  
 若要在事件查看器中显示本地化的类别字符串，必须使用事件源使用类别资源文件，配置和设置`category`类别资源文件中的资源标识符。 如果事件源没有配置的类别资源文件，或指定`category`没有索引在类别资源文件中，一个字符串，则事件查看器将显示该条目的数字类别值。 配置类别资源文件，以及数量的类别字符串在资源文件中，使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>类。  
  
 事件标识符，以及事件源，唯一标识的事件。 每个应用程序可以定义其自己的编号的事件以及它们映射到其中的描述字符串。 事件查看器显示这些字符串值，以帮助用户了解发生的问题和建议采取的操作。  
  
 最后，你可以指定<xref:System.Diagnostics.EventLogEntryType>写入到事件日志的事件。 `type`指示由一个图标和事件查看器日志中的类型列中的文本。 此参数指示事件类型是否是错误、 警告、 信息、 成功审核或失败审核。  
  
 你必须创建并在编写与源的第一个条目之前，配置事件源。 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 要写入本地化的项还是要直接写入字符串，则必须配置源。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法直接写入事件日志将写入给定的字符串; 它不使用可本地化的消息资源文件。 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来写入事件时使用本地化的消息资源文件。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
> [!NOTE]
>  如果`message`参数包含 NUL 字符，则在 NUL 字符处终止事件日志的消息中。  
>   
>  `message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 值是空字符串 ("")。  
  
 \- 或 -  
  
 <paramref name="source" /> 值为 <see langword="null" />。  
  
 \- 或 -  
  
 <paramref name="eventID" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
 \- 或 -  
  
 消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
 \- 或 -  
  
 此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向事件日志写入本地化事件项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">表示本地化事件日志项的 <see cref="T:System.Diagnostics.EventInstance" /> 实例。</param>
        <param name="values">要合并到事件日志项的消息文本中的字符串数组。</param>
        <summary>向事件日志写入本地化项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法写入事件日志写入本地化的项。 使用资源标识符，而不是字符串值中指定的事件属性。 事件查看器使用的资源标识符来显示的本地化的资源文件中的相应字符串<xref:System.Diagnostics.EventLog.Source%2A>。 需要在编写使用资源标识符的事件前，必须将源注册相应的资源文件。  
  
 输入`instance`实例指定的事件消息和属性。 设置<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`输入源消息资源文件中定义的消息。 你可以选择性地设置<xref:System.Diagnostics.EventInstance.CategoryId%2A>和<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`输入事件项的类别和事件类型定义。 你还可以指定要插入本地化的消息文本的独立于语言的字符串的数组。 设置`values`到`null`如果事件消息不包含替换字符串的格式设置占位符。  
  
 必须设置<xref:System.Diagnostics.EventLog.Source%2A>属性你<xref:System.Diagnostics.EventLog>组件之前使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>。 指定的源必须配置用于本地化的项写入事件日志中。源至少必须具有一个用于定义消息资源文件。  
  
 你必须创建并在编写与源的第一个条目之前，配置事件源。 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 要写入本地化的项还是要直接写入字符串，则必须配置源。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法如果你的应用程序将直接写入事件日志的字符串值。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
> [!NOTE]
>  如果你向远程计算机的值写入条目`message`字符串可能不是你所预期如果远程计算机未在运行.NET Framework。 此外，`message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
   
  
## Examples  
 下面的示例将两个审核项写入事件日志`myNewLog`。 该示例创建一个新的事件源和新的事件日志，如果它们尚不存在本地计算机上。 事件消息文本被指定的资源文件中使用的资源标识符。  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 该示例使用以下的消息文本文件，内置于 EventLogMsgs.dll 的资源库。 消息文本文件是从其创建的消息资源文件的源。 消息文本文件定义的资源标识符和类别、 事件消息和参数插入字符串的文本。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
 或  
  
 该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
 \- 或 -  
  
 已为其他事件日志注册了该源。  
  
 \- 或 -  
  
 <paramref name="instance.InstanceId" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
 \- 或 -  
  
 <paramref name="values" /> 超过了 256 个元素。  
  
 \- 或 -  
  
 <paramref name="values" /> 元素中有一个超过了 32766 个字节。  
  
 \- 或 -  
  
 此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">表示本地化事件日志项的 <see cref="T:System.Diagnostics.EventInstance" /> 实例。</param>
        <param name="data">包含与此项关联的二进制数据的字节数组。</param>
        <param name="values">要合并到事件日志项的消息文本中的字符串数组。</param>
        <summary>写入包含给定的事件数据、消息替换字符串和关联的二进制数据的事件日志项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法要使用其他特定于事件的数据的本地化的项写入事件日志。 使用资源标识符，而不是字符串值中指定的事件属性。 事件查看器使用的资源标识符来显示的本地化的资源文件中的相应字符串<xref:System.Diagnostics.EventLog.Source%2A>。 需要在编写使用资源标识符的事件前，必须将源注册相应的资源文件。  
  
 输入`instance`实例指定的事件消息和属性。 设置<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`输入源消息资源文件中定义的消息。 你可以选择性地设置<xref:System.Diagnostics.EventInstance.CategoryId%2A>和<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`输入事件项的类别和事件类型定义。 你还可以指定要插入本地化的消息文本的独立于语言的字符串的数组。 设置`values`到`null`如果事件消息不包含替换字符串的格式设置占位符。  
  
 指定与事件时为事件提供更多详细信息所需的二进制数据。 例如，使用`data`参数，以包括有关特定错误的信息。 事件查看器不解释关联的事件数据中;它采用组合的十六进制转义序列和文本格式显示的数据。 应谨慎; 使用特定于事件的数据仅当你确信它将会很有用，则将其包含。 特定于事件的数据还可用于存储应用程序可以处理独立于事件查看器的信息。 例如，你无法专门为事件，编写一个查看器或编写扫描事件日志，并创建报告，包括来自特定事件的数据的信息的程序。  
  
 必须设置<xref:System.Diagnostics.EventLog.Source%2A>属性你<xref:System.Diagnostics.EventLog>组件之前使用组件之前<xref:System.Diagnostics.EventLog.WriteEvent%2A>。 指定的源必须配置用于本地化的项写入事件日志中。源至少必须具有一个用于定义消息资源文件。  
  
 你必须创建并在编写与源的第一个条目之前，配置事件源。 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
> [!NOTE]
>  如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>为你<xref:System.Diagnostics.EventLog>实例然后才能调用<xref:System.Diagnostics.EventLog.WriteEvent%2A>，本地计算机 ("。") 假定。  
  
 要写入本地化的项还是要直接写入字符串，则必须配置源。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法如果你的应用程序将直接写入事件日志的字符串值。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
> [!NOTE]
>  如果你向远程计算机的值写入条目`message`字符串可能不是你所预期如果远程计算机未在运行.NET Framework。 此外，`message`字符串不能包含 %*n*，其中*n*是整数值 (例如，%1)，因为事件查看器会将其视为插入字符串。 Internet 协议版本 6 (IPv6) 地址只能包含此字符序列，因为无法记录事件消息包含 IPv6 地址。  
  
   
  
## Examples  
 下面的示例将两个审核项写入事件日志`myNewLog`。 该示例创建一个新的事件源和新的事件日志，如果它们尚不存在本地计算机上。 事件消息文本被指定的资源文件中使用的资源标识符。  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 该示例使用以下的消息文本文件，内置于 EventLogMsgs.dll 的资源库。 消息文本文件是从其创建的消息资源文件的源。 消息文本文件定义的资源标识符和类别、 事件消息和参数插入字符串的文本。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
 或  
  
 该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
 \- 或 -  
  
 已为其他事件日志注册了该源。  
  
 \- 或 -  
  
 <paramref name="instance.InstanceId" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
 \- 或 -  
  
 <paramref name="values" /> 超过了 256 个元素。  
  
 \- 或 -  
  
 <paramref name="values" /> 元素中有一个超过了 32766 个字节。  
  
 \- 或 -  
  
 此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">在指定的计算机上为应用程序注册的事件源的名称。</param>
        <param name="instance">表示本地化事件日志项的 <see cref="T:System.Diagnostics.EventInstance" /> 实例。</param>
        <param name="values">要合并到事件日志项的消息文本中的字符串数组。</param>
        <summary>使用指定的已注册事件源写入包含给定事件数据和消息替换字符串的事件日志项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法使用已注册为相应的日志的事件源的源的事件日志写入本地化的项。 使用资源标识符，而不是字符串值中指定的事件属性。 事件查看器使用的资源标识符来显示源的本地化的资源文件中的相应字符串。 需要在编写使用资源标识符的事件前，必须将源注册相应的资源文件。  
  
 输入`instance`实例指定的事件消息和属性。 设置<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`输入源消息资源文件中定义的消息。 你可以选择性地设置<xref:System.Diagnostics.EventInstance.CategoryId%2A>和<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`输入事件项的类别和事件类型定义。 你还可以指定要插入本地化的消息文本的独立于语言的字符串的数组。 设置`values`到`null`如果事件消息不包含替换字符串的格式设置占位符。  
  
 指定的源之前，必须注册为事件日志使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>。 指定的源必须配置用于本地化的项写入事件日志中。源至少必须具有一个用于定义消息资源文件。  
  
 你必须创建并在编写与源的第一个条目之前，配置事件源。 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 要写入本地化的项还是要直接写入字符串，则必须配置源。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法如果你的应用程序将直接写入事件日志的字符串值。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
   
  
## Examples  
 下面的示例将现有的事件日志写入信息性事件条目和警告事件项。 事件消息文本被指定的资源文件中使用的资源标识符。 该示例假定已为该源中注册相应的资源文件。  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 该示例使用以下的消息文本文件，内置于 EventLogMsgs.dll 的资源库。 消息文本文件是从其创建的消息资源文件的源。 消息文本文件定义的资源标识符和类别、 事件消息和参数插入字符串的文本。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 值是空字符串 ("")。  
  
 \- 或 -  
  
 <paramref name="source" /> 值为 <see langword="null" />。  
  
 \- 或 -  
  
 <paramref name="instance.InstanceId" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
 \- 或 -  
  
 <paramref name="values" /> 超过了 256 个元素。  
  
 \- 或 -  
  
 <paramref name="values" /> 元素中有一个超过了 32766 个字节。  
  
 \- 或 -  
  
 此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">在指定的计算机上为应用程序注册的事件源的名称。</param>
        <param name="instance">表示本地化事件日志项的 <see cref="T:System.Diagnostics.EventInstance" /> 实例。</param>
        <param name="data">包含与此项关联的二进制数据的字节数组。</param>
        <param name="values">要合并到事件日志项的消息文本中的字符串数组。</param>
        <summary>使用指定的已注册事件源，写入包含给定的事件数据、消息替换字符串和关联的二进制数据的事件日志项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法更多特定于事件的数据的本地化的项写入事件日志中，使用已注册为相应的日志的事件源的源。 使用资源标识符，而不是字符串值中指定的事件属性。 事件查看器使用的资源标识符来显示源的本地化的资源文件中的相应字符串。 需要在编写使用资源标识符的事件前，必须将源注册相应的资源文件。  
  
 输入`instance`实例指定的事件消息和属性。 设置<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`输入源消息资源文件中定义的消息。 你可以选择性地设置<xref:System.Diagnostics.EventInstance.CategoryId%2A>和<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`输入事件项的类别和事件类型定义。 你还可以指定要插入本地化的消息文本的独立于语言的字符串的数组。 设置`values`到`null`如果事件消息不包含替换字符串的格式设置占位符。  
  
 指定与事件时为事件提供更多详细信息所需的二进制数据。 例如，使用`data`参数，以包括有关特定错误的信息。 事件查看器不解释关联的事件数据中;它采用组合的十六进制转义序列和文本格式显示的数据。 应谨慎; 使用特定于事件的数据仅当你确信它将会很有用，则将其包含。 特定于事件的数据还可用于存储应用程序可以处理独立于事件查看器的信息。 例如，你无法专门为事件，编写一个查看器或编写扫描事件日志，并创建报告，包括来自特定事件的数据的信息的程序。  
  
 指定的源之前，必须注册为事件日志使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>。 指定的源必须配置用于本地化的项写入事件日志中。源至少必须具有一个用于定义消息资源文件。  
  
 你必须创建并在编写与源的第一个条目之前，配置事件源。 在你的应用程序的安装过程中创建新的事件源。 这样，可以为操作系统来刷新其已注册的事件源的列表和其配置的时间。 如果操作系统未刷新其事件源的列表，并尝试写入新的源的事件写入操作将失败。 你可以配置新的源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。 若要创建新的事件源的计算机上，必须具有管理权限。  
  
 要写入本地化的项还是要直接写入字符串，则必须配置源。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法如果你的应用程序将直接写入事件日志的字符串值。  
  
 如果你的应用程序将使用资源标识符和字符串值的条目，则必须注册两个单独的源。 例如，使用资源文件，配置一个源，然后使用在该源<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法来编写使用到事件日志的资源标识符的条目。 然后创建不同的源，而无需资源文件，并使用在该源<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法使用该源的事件日志中直接写入字符串。  
  
   
  
## Examples  
 下面的示例将现有的事件日志写入信息性事件条目和警告事件项。 事件消息文本被指定的资源文件中使用的资源标识符。 该示例假定已为该源中注册相应的资源文件。  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 该示例使用以下的消息文本文件，内置于 EventLogMsgs.dll 的资源库。 消息文本文件是从其创建的消息资源文件的源。 消息文本文件定义的资源标识符和类别、 事件消息和参数插入字符串的文本。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="source" /> 值是空字符串 ("")。  
  
 \- 或 -  
  
 <paramref name="source" /> 值为 <see langword="null" />。  
  
 \- 或 -  
  
 <paramref name="instance.InstanceId" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
 \- 或 -  
  
 <paramref name="values" /> 超过了 256 个元素。  
  
 \- 或 -  
  
 <paramref name="values" /> 元素中有一个超过了 32766 个字节。  
  
 \- 或 -  
  
 此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="instance" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入的计算机上的事件日志信息。 关联的枚举： <see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>