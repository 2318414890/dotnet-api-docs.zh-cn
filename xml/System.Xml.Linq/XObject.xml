<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="XObject.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac521d2fddfb97fd2308d0e542f7e64ec71a761941f.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">21d2fddfb97fd2308d0e542f7e64ec71a761941f</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XObject">
          <source>Represents a node or an attribute in an XML tree.</source>
          <target state="translated">表示 XML 树中的节点或属性。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XObject">
          <source>This class is the abstract common base class for <ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph> and <ph id="ph2">&lt;xref:System.Xml.Linq.XAttribute&gt;</ph>.</source>
          <target state="translated">此类是抽象的公共基类<ph id="ph1">&lt;xref:System.Xml.Linq.XNode&gt;</ph>和<ph id="ph2">&lt;xref:System.Xml.Linq.XAttribute&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XObject">
          <source>It provides some basic functionality that is common to both classes, such as annotations, and raising events when nodes have changed.</source>
          <target state="translated">它提供了一些普遍适用于这两个类，如批注，并引发事件时节点发生了更改的基本功能。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XObject">
          <source>Note that annotations are not part of the XML infoset; they are not serialized or deserialized.</source>
          <target state="translated">请注意，批注不是 XML 信息集的一部分，不对它们进行序列化和反序列化。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XObject.AddAnnotation(System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> that contains the annotation to add.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>，其中包含要添加的批注。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XObject.AddAnnotation(System.Object)">
          <source>Adds an object to the annotation list of this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">将对象添加到此 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 的批注列表。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.AddAnnotation(System.Object)">
          <source>Note that annotations are not part of the infoset; they are not persisted, or displayed by <ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ToString%2A&gt;</ph>.</source>
          <target state="translated">请注意，批注不 infoset; 的一部分未保留，或显示<ph id="ph1">&lt;xref:System.Xml.Linq.XNode.ToString%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.AddAnnotation(System.Object)">
          <source>Also, if you import an XML Namespace into your VB project and call AddAnnotation with the SaveOptions.OmitDuplicateNamespaces enumeration value, then only one element will contain the XML Namespace attribute instead of every element.</source>
          <target state="translated">此外，如果你导入到 VB 项目的 XML Namespace 并调用 AddAnnotation 带有 SaveOptions.OmitDuplicateNamespaces 枚举值，然后仅有一个元素将包含 XML Namespace 特性而不是每个元素。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.AddAnnotation(System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Removing duplicate namespaces in XML Literals<ept id="p1">](http://blogs.msdn.com/b/vbteam/archive/2010/06/09/removing-duplicate-namespaces-in-xml-literals-shyam-namboodiripad.aspx)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>在 XML 文本中删除重复的命名空间<ept id="p1">](http://blogs.msdn.com/b/vbteam/archive/2010/06/09/removing-duplicate-namespaces-in-xml-literals-shyam-namboodiripad.aspx)</ept>。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.AddAnnotation(System.Object)">
          <source>The following example adds an annotation to an <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph>.</source>
          <target state="translated">下面的示例将添加到批注<ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.AddAnnotation(System.Object)">
          <source>This example produces the following output:</source>
          <target state="translated">该示例产生下面的输出：</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XObject.Annotation(System.Type)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the annotation to retrieve.</source>
          <target state="translated">要检索的批注的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XObject.Annotation(System.Type)">
          <source>Gets the first annotation object of the specified type from this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">从此 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 获取指定类型的第一个批注对象。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XObject.Annotation(System.Type)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> that contains the first annotation object that matches the specified type, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if no annotation is of the specified type.</source>
          <target state="translated">包含与指定类型匹配的第一个批注对象的 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>；如果没有指定类型的批注，则为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.Annotation(System.Type)">
          <source>The following example adds an annotation to an <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph>.</source>
          <target state="translated">下面的示例将添加到批注<ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.Annotation(System.Type)">
          <source>It then retrieves the annotation, specifying the type to retrieve.</source>
          <target state="translated">然后检索批注，指定要检索的类型。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.Annotation(System.Type)">
          <source>This example produces the following output:</source>
          <target state="translated">该示例产生下面的输出：</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.Annotation``1">
          <source>The type of the annotation to retrieve.</source>
          <target state="translated">要检索的批注类型。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XObject.Annotation``1">
          <source>Get the first annotation object of the specified type from this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">从此 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 获取指定类型的第一个批注对象。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XObject.Annotation``1">
          <source>The first annotation object that matches the specified type, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no annotation is of the specified type.</source>
          <target state="translated">与指定类型匹配的第一个批注对象；如果没有指定类型的批注，则为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.Annotation``1">
          <source>The following example adds an annotation to an element, and then retrieves it through this method.</source>
          <target state="translated">下面的示例将批注添加到元素，，然后通过此方法中检索它。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.Annotation``1">
          <source>This example produces the following output:</source>
          <target state="translated">该示例产生下面的输出：</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XObject.Annotations(System.Type)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the annotations to retrieve.</source>
          <target state="translated">要检索的批注的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XObject.Annotations(System.Type)">
          <source>Gets a collection of annotations of the specified type for this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">获取此 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 的指定类型的批注集合。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XObject.Annotations(System.Type)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> that contains the annotations that match the specified type for this <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> 的 <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>，其中包含与此 <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 的指定类型匹配的批注。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.Annotations(System.Type)">
          <source>The following example adds some annotations to an <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph>, then retrieves a collection of annotations by using this method.</source>
          <target state="translated">下面的示例将添加到某些批注<ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph>，然后使用此方法检索批注的集合。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.Annotations(System.Type)">
          <source>This example produces the following output:</source>
          <target state="translated">该示例产生下面的输出：</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.Annotations``1">
          <source>The type of the annotations to retrieve.</source>
          <target state="translated">要检索的批注类型。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XObject.Annotations``1">
          <source>Gets a collection of annotations of the specified type for this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">获取此 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 的指定类型的批注集合。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XObject.Annotations``1">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> that contains the annotations for this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>，其中包含此 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 的批注。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.Annotations``1">
          <source>The following example uses this method to retrieve annotations on an element.</source>
          <target state="translated">下面的示例使用此方法检索元素上的批注。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.Annotations``1">
          <source>This example produces the following output:</source>
          <target state="translated">该示例产生下面的输出：</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XObject.BaseUri">
          <source>Gets the base URI for this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">获取此 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 的基 URI。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.BaseUri">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the base URI for this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>，其中包含此 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 的基 URI。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.BaseUri">
          <source>Using LINQ to XML, you can deserialize XML in a number of fashions.</source>
          <target state="translated">使用 LINQ to XML，你可以反序列化数 fashions 中的 XML。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.BaseUri">
          <source>You can parse it from a string, load it from a file, or read it from a <ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph> or an <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">你可以从字符串分析它、 从文件，加载或读取从<ph id="ph1">&lt;xref:System.IO.TextReader&gt;</ph>或<ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.BaseUri">
          <source>In all of these cases, LINQ to XML uses one or another of the concrete subclasses of <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>.</source>
          <target state="translated">在所有这些情况下，LINQ to XML 使用一个或另一个的具体子类<ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.BaseUri">
          <source>Sometimes the <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> has the base URI, and sometimes it does not.</source>
          <target state="translated">有时<ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>具有基本 URI，而有时不。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.BaseUri">
          <source>For instance, when loading from a file, the <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> knows the base URI, but when reading from an <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> that was created because of calling the <ph id="ph3">&lt;xref:System.Xml.Linq.XElement.Parse%2A&gt;</ph> method, there is no possibility of the <ph id="ph4">&lt;xref:System.Xml.XmlReader&gt;</ph> reporting a base URI; the XML was in a string.</source>
          <target state="translated">例如，当从文件加载<ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>知道的基 URI，但从读取<ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>因调用而创建<ph id="ph3">&lt;xref:System.Xml.Linq.XElement.Parse%2A&gt;</ph>方法，不可能的<ph id="ph4">&lt;xref:System.Xml.XmlReader&gt;</ph>reporting 的基 URI; 已在 XML字符串。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.BaseUri">
          <source>If, when parsing or loading the XML, you specify <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetBaseUri&gt;</ph>, LINQ to XML will request the base URI for each node as the <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> returns the node.</source>
          <target state="translated">如果，当分析或加载 XML，则指定<ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetBaseUri&gt;</ph>，LINQ to XML 将请求为每个节点的基 URI<ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph>返回的节点。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.BaseUri">
          <source>If the reader has the base URI, LINQ to XML will save the information with the LINQ to XML node.</source>
          <target state="translated">如果读取器的基 URI，LINQ to XML 会将信息保存用于 LINQ to XML 节点。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.BaseUri">
          <source>This property returns that information.</source>
          <target state="translated">此属性返回该信息。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.BaseUri">
          <source>If the underlying <ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph> does not have the base URI, then this property will return an empty string.</source>
          <target state="translated">如果基础<ph id="ph1">&lt;xref:System.Xml.XmlReader&gt;</ph>不具有的基 URI，则此属性将返回空字符串。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.BaseUri">
          <source>Setting <ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetBaseUri&gt;</ph> when loading an XML tree will result in slower parsing.</source>
          <target state="translated">设置<ph id="ph1">&lt;xref:System.Xml.Linq.LoadOptions.SetBaseUri&gt;</ph>时加载 XML 树将导致在分析速度变慢。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.BaseUri">
          <source>When setting the base URI for an XML tree, LINQ to XML puts an annotation on the root of the tree.</source>
          <target state="translated">在设置一个 XML 树的基 URI 时，LINQ to XML 会将批注放在树的根。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.BaseUri">
          <source>This property is a computed property, and navigates up the tree to find the base URI.</source>
          <target state="translated">此属性是一个计算的属性，并向上浏览树，若要查找的基 URI。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.BaseUri">
          <source>The following example loads the base URI and line information as it loads the file.</source>
          <target state="translated">加载时为它的文件，下面的示例将加载的基本 URI 和行信息。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.BaseUri">
          <source>It then prints the base URI and the line information.</source>
          <target state="translated">然后打印的基 URI 和行信息。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.BaseUri">
          <source>This example uses the following XML document: <bpt id="p1">[</bpt>Sample XML File: Typical Purchase Order (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/0606c09f-6e43-4f8d-95c8-e8e2e08d2348)</ept>.</source>
          <target state="translated">本示例使用以下 XML 文档：<bpt id="p1">[</bpt>示例 XML 文件：典型采购订单 (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/0606c09f-6e43-4f8d-95c8-e8e2e08d2348)</ept>。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.BaseUri">
          <source>This example produces the following output:</source>
          <target state="translated">该示例产生下面的输出：</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="E:System.Xml.Linq.XObject.Changed">
          <source>Raised when this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> or any of its descendants have changed.</source>
          <target state="translated">在此 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 或其任何子代发生了更改时引发。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changed">
          <source>Events are raised only when an XML tree is modified, not when it is constructed.</source>
          <target state="translated">仅当修改 XML 树时，不在构造时，会引发事件。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changed">
          <source>This is because you have to add an event handler to an event before you can receive events, and you cannot add an event handler before you have a reference to an <ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph>.</source>
          <target state="translated">这是因为你需要将事件处理程序添加到事件中，然后才能接收事件，并且不能添加事件处理程序之后才可以对引用, <ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changed">
          <source>You cannot get a reference to an <ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph> before the XML tree is constructed.</source>
          <target state="translated">无法获取对引用<ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph>XML 树进行构造。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changed">
          <source>This means that during functional construction of an XML tree, you will not receive events.</source>
          <target state="translated">这意味着在 XML 树的函数构造，您不会收到事件。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changed">
          <source>You should be careful when modifying an XML tree within one of these events, because doing this might lead to unexpected results.</source>
          <target state="translated">修改 XML 树中的这些事件，因为执行此操作可能导致意外结果时，你应当小心。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changed">
          <source>For example, if you receive a <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> event, and while the event is being processed you remove the node from the tree, you might not receive the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> event.</source>
          <target state="translated">例如，如果你收到<ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph>事件，并且在处理该事件时从树中删除节点，则您可能不会收到<ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changed">
          <source>When an event is being processed, it is valid to modify an XML tree other than the one that contains the node that is receiving the event; it is even valid to modify the same tree provided the modifications do not affect the specific nodes on which the event was raised.</source>
          <target state="translated">处理事件时，它是有效地修改 XML 树而非在包含在接收事件; 的节点是修改同一个树，修改不影响在其引发事件的特定节点提供更有效。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changed">
          <source>However, if you modify the area of the tree that contains the node receiving the event, the events that you receive and the impact to the tree are undefined.</source>
          <target state="translated">但是，如果你修改包含接收事件的节点的区域，那么你收到的事件和到树的影响是树的不确定。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changed">
          <source>The following example adds an event handler to the root element of an XML tree.</source>
          <target state="translated">下面的示例将一个事件处理程序添加到 XML 树的根元素。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changed">
          <source>It then modifies the tree, causing LINQ to XML to raise some events.</source>
          <target state="translated">然后，它会修改树中，导致 LINQ to XML 来引发某些事件。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changed">
          <source>This example produces the following output:</source>
          <target state="translated">该示例产生下面的输出：</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changed">
          <source>Events are useful when you want to maintain some aggregate information in an XML tree.</source>
          <target state="translated">当您希望在 XML 树中保留一些聚合信息时事件非常有用。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changed">
          <source>For example, you may want maintain an invoice total that is the sum of the line items of the invoice.</source>
          <target state="translated">例如，您可能想保留一份发票合计，计算发票上各个项目的总和。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changed">
          <source>This example uses events to maintain the total of all of the child elements under the complex element <ph id="ph1">`Items`</ph>.</source>
          <target state="translated">本示例使用事件来维护复杂元素 <ph id="ph1">`Items`</ph> 之下所有子元素的总和。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changed">
          <source>This code produces the following output:</source>
          <target state="translated">此代码生成以下输出：</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="E:System.Xml.Linq.XObject.Changing">
          <source>Raised when this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> or any of its descendants are about to change.</source>
          <target state="translated">当此 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 或其任何子代要发生更改时引发。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changing">
          <source>Events are raised only from modification of an XML tree, not from construction of an XML tree.</source>
          <target state="translated">只能从 XML 树的修改，而不在构造 XML 树的则会引发事件。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changing">
          <source>You have to add an event handler to an event before you can receive events, and you can't add an event handler before you have a reference to an <ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph>.</source>
          <target state="translated">你必须将事件处理程序添加到事件中，然后才能接收事件，并且不能添加事件处理程序之后才可以对引用, <ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changing">
          <source>You can't get a reference to an <ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph> before the XML tree is constructed.</source>
          <target state="translated">无法获取对引用<ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph>XML 树进行构造。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changing">
          <source>This means that during functional construction of an XML tree, you will not receive events.</source>
          <target state="translated">这意味着在 XML 树的函数构造，您不会收到事件。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changing">
          <source>You should be careful when modifying an XML tree within one of these events, because doing this might lead to unexpected results.</source>
          <target state="translated">修改 XML 树中的这些事件，因为执行此操作可能导致意外结果时，你应当小心。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changing">
          <source>For example, if you receive a <ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph> event, and while the event is being processed you remove the node from the tree, you might not receive the <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph> event.</source>
          <target state="translated">例如，如果你收到<ph id="ph1">&lt;xref:System.Xml.Linq.XObject.Changing&gt;</ph>事件，并且在处理该事件时从树中删除节点，则您可能不会收到<ph id="ph2">&lt;xref:System.Xml.Linq.XObject.Changed&gt;</ph>事件。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changing">
          <source>When an event is being processed, it is valid to modify an XML tree other than the one that contains the node that is receiving the event; it is even valid to modify the same tree provided the modifications do not affect the specific nodes on which the event was raised.</source>
          <target state="translated">处理事件时，它是有效地修改 XML 树而非在包含在接收事件; 的节点是修改同一个树，修改不影响在其引发事件的特定节点提供更有效。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changing">
          <source>However, if you modify the area of the tree that contains the node receiving the event, the events that you receive and the impact to the tree are undefined.</source>
          <target state="translated">但是，如果你修改包含接收事件的节点的区域，那么你收到的事件和到树的影响是树的不确定。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changing">
          <source>The following example adds an event handler to the root element of an XML tree.</source>
          <target state="translated">下面的示例将一个事件处理程序添加到 XML 树的根元素。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changing">
          <source>It then modifies the tree, causing LINQ to XML to raise some events.</source>
          <target state="translated">然后，它会修改树中，导致 LINQ to XML 来引发某些事件。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Xml.Linq.XObject.Changing">
          <source>This example produces the following output:</source>
          <target state="translated">该示例产生下面的输出：</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XObject.Document">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XDocument" /&gt;</ph> for this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">获取此 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XDocument" /&gt;</ph> 的 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.Document">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XDocument" /&gt;</ph> for this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">用于此 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XDocument" /&gt;</ph> 的 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.Document">
          <source>The following example creates a document with some complex content.</source>
          <target state="translated">下面的示例创建具有一些复杂内容的文档。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.Document">
          <source>It then uses this property to retrieve the document for the <ph id="ph1">`Child`</ph> element.</source>
          <target state="translated">它然后使用此属性来在文档中检索<ph id="ph1">`Child`</ph>元素。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.Document">
          <source>This example produces the following output:</source>
          <target state="translated">该示例产生下面的输出：</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XObject.NodeType">
          <source>Gets the node type for this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">获取此 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 的节点类型。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.NodeType">
          <source>The node type for this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">此 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 的节点类型。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.NodeType">
          <source>Because all classes that derive from <ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph> contain a <ph id="ph2">&lt;xref:System.Xml.Linq.XObject.NodeType%2A&gt;</ph> property, you can write code that operates on collections of concrete subclass of <ph id="ph3">&lt;xref:System.Xml.Linq.XObject&gt;</ph>.</source>
          <target state="translated">因为派生自的所有类<ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph>包含<ph id="ph2">&lt;xref:System.Xml.Linq.XObject.NodeType%2A&gt;</ph>属性，你可以编写代码进行操作的具体子类的集合<ph id="ph3">&lt;xref:System.Xml.Linq.XObject&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.NodeType">
          <source>Your code can then test for the node type of each node in the collection.</source>
          <target state="translated">集合中每个节点的节点类型随后可以测试你的代码。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.NodeType">
          <source>The following example uses this method to retrieve the node type for a variety of nodes.</source>
          <target state="translated">下面的示例使用此方法来检索各种节点的节点类型。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.NodeType">
          <source>This example produces the following output:</source>
          <target state="translated">该示例产生下面的输出：</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XObject.Parent">
          <source>Gets the parent <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">获取此 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 的父级 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.Parent">
          <source>The parent <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> of this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">此 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XElement" /&gt;</ph> 的父级 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.Parent">
          <source>If this <ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph> has no parent element, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">如果此<ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph>没有任何父元素中，此属性返回<ph id="ph2">`null`</ph>。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.Parent">
          <source>This property returns the parent element, and as children nodes of an <ph id="ph1">&lt;xref:System.Xml.Linq.XDocument&gt;</ph> have no parent element, this property returns <ph id="ph2">`null`</ph> for them.</source>
          <target state="translated">此属性返回的父元素的子节点的以及<ph id="ph1">&lt;xref:System.Xml.Linq.XDocument&gt;</ph>不有任何父元素，此属性返回<ph id="ph2">`null`</ph>它们。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.Parent">
          <source>The following example uses this method.</source>
          <target state="translated">下面的示例使用此方法。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.Parent">
          <source>This example produces the following output:</source>
          <target state="translated">该示例产生下面的输出：</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XObject.RemoveAnnotations(System.Type)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of annotations to remove.</source>
          <target state="translated">要移除的批注的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XObject.RemoveAnnotations(System.Type)">
          <source>Removes the annotations of the specified type from this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">从此 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 移除指定类型的批注。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.RemoveAnnotations(System.Type)">
          <source>The following example creates an element with four annotations on it.</source>
          <target state="translated">下面的示例创建具有四个批注的元素。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.RemoveAnnotations(System.Type)">
          <source>It then uses this method to remove two of them.</source>
          <target state="translated">它然后使用此方法删除其中的两个。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.RemoveAnnotations(System.Type)">
          <source>This example produces the following output:</source>
          <target state="translated">该示例产生下面的输出：</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.RemoveAnnotations``1">
          <source>The type of annotations to remove.</source>
          <target state="translated">要移除的批注的类型。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XObject.RemoveAnnotations``1">
          <source>Removes the annotations of the specified type from this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">从此 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 移除指定类型的批注。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.RemoveAnnotations``1">
          <source>The following example creates an element with four annotations on it.</source>
          <target state="translated">下面的示例创建具有四个批注的元素。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.RemoveAnnotations``1">
          <source>It then uses this method to remove two of them.</source>
          <target state="translated">它然后使用此方法删除其中的两个。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.RemoveAnnotations``1">
          <source>This example produces the following output:</source>
          <target state="translated">该示例产生下面的输出：</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#HasLineInfo">
          <source>Gets a value indicating whether or not this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> has line information.</source>
          <target state="translated">获取一个值，该值指示此 <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 是否具有行信息。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#HasLineInfo">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> has line information, otherwise <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 具有行信息，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#HasLineInfo">
          <source>You can call this method to determine whether the <ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph> contains valid line information.</source>
          <target state="translated">你可以调用此方法以确定是否<ph id="ph1">&lt;xref:System.Xml.Linq.XObject&gt;</ph>包含有效的行信息。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#HasLineInfo">
          <source>This method is an explicit interface member implementation of a method in the <ph id="ph1">&lt;xref:System.Xml.IXmlLineInfo&gt;</ph> interface, so in order to call this method, it is necessary to cast to <ph id="ph2">&lt;xref:System.Xml.IXmlLineInfo&gt;</ph>.</source>
          <target state="translated">此方法是显式接口成员的实现中的方法<ph id="ph1">&lt;xref:System.Xml.IXmlLineInfo&gt;</ph>接口，所以为了调用此方法，它有必要强制转换为<ph id="ph2">&lt;xref:System.Xml.IXmlLineInfo&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#HasLineInfo">
          <source>This example loads a small XML tree from a file, setting the options to set base URI and retain line information.</source>
          <target state="translated">从文件中，设置选项以设置基 URI 和保留行信息，此示例加载一个小型 XML 树。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#HasLineInfo">
          <source>It then adds another element that does not have line information.</source>
          <target state="translated">然后，它会添加没有行信息的另一个元素。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#HasLineInfo">
          <source>It then prints the line information for each element in the tree.</source>
          <target state="translated">然后，它将输出树中每个元素的行信息。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#HasLineInfo">
          <source>This example produces the following output:</source>
          <target state="translated">该示例产生下面的输出：</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#LineNumber">
          <source>Gets the line number that the underlying <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> reported for this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">获取基础 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> 为此 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 报告的行号。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#LineNumber">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> that contains the line number reported by the <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> for this <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>，其中包含 <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> 为此 <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 报告的行号。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#LineNumber">
          <source>This method is an explicit interface member implementation of a method in the <ph id="ph1">&lt;xref:System.Xml.IXmlLineInfo&gt;</ph> interface, so in order to call this method, it is necessary to cast to <ph id="ph2">&lt;xref:System.Xml.IXmlLineInfo&gt;</ph>.</source>
          <target state="translated">此方法是显式接口成员的实现中的方法<ph id="ph1">&lt;xref:System.Xml.IXmlLineInfo&gt;</ph>接口，所以为了调用此方法，它有必要强制转换为<ph id="ph2">&lt;xref:System.Xml.IXmlLineInfo&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#LineNumber">
          <source>This example loads a small XML tree from a file, setting the options to set base URI and retain line information.</source>
          <target state="translated">从文件中，设置选项以设置基 URI 和保留行信息，此示例加载一个小型 XML 树。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#LineNumber">
          <source>It then adds another element that does not have line information.</source>
          <target state="translated">然后，它会添加没有行信息的另一个元素。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#LineNumber">
          <source>It then prints the line information for each element in the tree.</source>
          <target state="translated">然后，它将输出树中每个元素的行信息。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#LineNumber">
          <source>This example produces the following output:</source>
          <target state="translated">该示例产生下面的输出：</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#LinePosition">
          <source>Gets the line position that the underlying <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> reported for this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">获取基础 <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> 为此 <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 报告的行位置。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#LinePosition">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> that contains the line position reported by the <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> for this <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph>.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>，其中包含 <ph id="ph2">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> 为此 <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XObject" /&gt;</ph> 报告的行位置。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#LinePosition">
          <source>This method is an explicit interface member implementation of a method in the <ph id="ph1">&lt;xref:System.Xml.IXmlLineInfo&gt;</ph> interface, so in order to call this method, it is necessary to cast to <ph id="ph2">&lt;xref:System.Xml.IXmlLineInfo&gt;</ph>.</source>
          <target state="translated">此方法是显式接口成员的实现中的方法<ph id="ph1">&lt;xref:System.Xml.IXmlLineInfo&gt;</ph>接口，所以为了调用此方法，它有必要强制转换为<ph id="ph2">&lt;xref:System.Xml.IXmlLineInfo&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#LinePosition">
          <source>This example loads a small XML tree from a file, setting the options to set base URI and retain line information.</source>
          <target state="translated">从文件中，设置选项以设置基 URI 和保留行信息，此示例加载一个小型 XML 树。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#LinePosition">
          <source>It then adds another element that does not have line information.</source>
          <target state="translated">然后，它会添加没有行信息的另一个元素。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#LinePosition">
          <source>It then prints the line information for each element in the tree.</source>
          <target state="translated">然后，它将输出树中每个元素的行信息。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#LinePosition">
          <source>This example produces the following output:</source>
          <target state="translated">该示例产生下面的输出：</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>