<Type Name="LinqDataSource" FullName="System.Web.UI.WebControls.LinqDataSource">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="43113d93d80de9936c4290c834d8d861c9f352d4" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36581607" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class LinqDataSource : System.Web.UI.WebControls.ContextDataSource, System.Web.DynamicData.IDynamicDataSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit LinqDataSource extends System.Web.UI.WebControls.ContextDataSource implements class System.Web.DynamicData.IDynamicDataSource, class System.Web.UI.IDataSource" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.LinqDataSource" />
  <TypeSignature Language="VB.NET" Value="Public Class LinqDataSource&#xA;Inherits ContextDataSource&#xA;Implements IDynamicDataSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class LinqDataSource : System::Web::UI::WebControls::ContextDataSource, System::Web::DynamicData::IDynamicDataSource" />
  <TypeSignature Language="F#" Value="type LinqDataSource = class&#xA;    inherit ContextDataSource&#xA;    interface IDynamicDataSource&#xA;    interface IDataSource" />
  <AssemblyInfo>
    <AssemblyName>System.Web.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.WebControls.ContextDataSource</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.DynamicData.IDynamicDataSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Selecting")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("ContextTypeName")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.LinqDataSourceDesigner, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Drawing.ToolboxBitmap(typeof(System.Web.UI.WebControls.LinqDataSource), "LinqDataSource.bmp")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>允许通过标记文本在 ASP.NET 网页中使用语言集成查询 (LINQ) 来检索和修改数据对象中的数据。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本主题内容：  
  
-   [介绍](#introduction)  
  
-   [操作顺序](#order_of_operations)  
  
-   [对数据进行排序](#ordering_data)  
  
-   [数据分组](#grouping_data)  
  
-   [数据修改](#data_modifications)  
  
-   [在运行时计算值](#evaluating_value_at_run_time)  
  
-   [使用存储过程](#working_with_stored_procedures)  
  
-   [声明性语法](#declarative_syntax)  
  
<a name="introduction"></a>   
## <a name="introduction"></a>介绍  
 语言集成查询 (LINQ) 是定义一组查询运算符，以便在任何声明性方式表示遍历、 筛选和投影操作的查询语法。基于网络的编程语言。 数据对象可以是内存中数据收集或从数据库中表示数据的对象。 你可以检索或修改数据而无需编写 SQL 命令为每个操作。  
  
 <xref:System.Web.UI.WebControls.LinqDataSource>控制，你可以使用 ASP.NET Web 页中的 LINQ 通过标记文本中设置属性。 <xref:System.Web.UI.WebControls.LinqDataSource>控件使用 LINQ to SQL 会自动生成数据命令。 有关 LINQ to SQL 的详细信息，请参阅[LINQ to SQL](http://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655)。  
  
 当你从内存中的数据集合在检索数据时，您设置<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性设置为包含数据收集的类。 你设置<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性的属性或字段的返回数据集合。 例如，可能有一个名为类`Person`，其中包含一个名为属性`FavoriteCities`返回的字符串值的数组。 在这种情况下，设置<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性`Person`并设置<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性`FavoriteCities`。  
  
 在查询数据库时，你必须首先创建表示数据库和其表的实体类。 你可以使用[!INCLUDE[vs_ordesigner_long](~/includes/vs-ordesigner-long-md.md)]或 SqlMetal.exe 实用程序来生成这些类。 然后设置<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性表示数据库的类并设置<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性表示数据库表的属性。  
  
<a name="order_of_operations"></a>   
## <a name="order-of-operations"></a>操作顺序  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件应用数据操作顺序如下：  
  
1.  其中 （指定哪些数据记录返回）。  
  
2.  Order By （排序）。  
  
3.  Group By （共享的值的聚合数据记录）。  
  
4.  Order By （排序分组数据） 的组。  
  
5.  （指定的字段或属性返回） 的选择。  
  
6.  自动排序 （由用户选定的属性数据记录进行排序）。  
  
7.  自动页 （检索已由用户选择的数据记录的子集）。  
  
 您可以添加到条件<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性筛选从查询返回的数据记录。 如果<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>未设置属性，<xref:System.Web.UI.WebControls.LinqDataSource>控件中检索此数据对象中的每个记录。  
  
<a name="ordering_data"></a>   
## <a name="ordering-data"></a>对数据进行排序  
 你使用<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性来指定从返回的数据要作为排序依据的属性的名称。  
  
> [!NOTE]
>  当你使用<xref:System.Web.UI.WebControls.LinqDataSource>控件替换为[!INCLUDE[ss2k](~/includes/ss2k-md.md)]或[!INCLUDE[ssEW](~/includes/ssew-md.md)]和<xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A>属性设置为`true`，你必须提供中的值<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性。 默认情况下，<xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A>属性是`true`。 如果将值赋给<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性，你还必须包括所有的 identity 列在查询中返回的属性列表。  
  
<a name="grouping_data"></a>   
## <a name="grouping-data"></a>数据分组  
 你使用<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性以指定哪些属性用于合并具有相同的值的数据记录。 在您对数据进行分组，你可以纳入`Key`和`It`，它们动态创建中的属性，<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 `Key`属性是指中或多个用于对数据进行分组的属性的值。 例如，如果通过名为的属性组`Category`、`Key`属性将包含中的所有唯一值`Category`属性。 `It`属性指的数据分组中的单个记录的集合。 可以循环访问`It`属性，以检索已经合并分组操作中的单个记录。 例如，如果通过名为的属性组`Category`、`It`属性包含所有的共享中的常见值的单个记录`Category`属性。  
  
 你使用<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性来指定要用于对分组的数据进行排序的属性。 数据，进行分组时<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性指定分组的数据中各记录的排序方式。  
  
 默认情况下，<xref:System.Web.UI.WebControls.LinqDataSource>控件中检索数据对象中的所有属性的值。 你使用<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性来指定的属性以返回你是否想要使用的可用属性的子集。 选择操作应用后 Where、 Order By 和 Group By 操作。 因此，如果 Select 子句中创建一个别名，别名不可用的其他子句中。  
  
<a name="data_modifications"></a>   
## <a name="data-modifications"></a>数据修改  
 你可以指定是否使用启用数据修改<xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A>， <xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A>，和<xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A>属性。 修改数据的用户界面<xref:System.Web.UI.WebControls.LinqDataSource>控件通常提供通过数据绑定控件，如<xref:System.Web.UI.WebControls.DetailsView>控件。 除了设置<xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A>， <xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A>，或<xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A>到`true`，启用自动数据修改所需的以下条件：  
  
-   <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性无法分配一个值。  
  
-   <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性无法分配一个值。  
  
-   分配给类<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性必须派生自<xref:System.Data.Linq.DataContext>。  
  
-   分配给属性<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性必须派生自<xref:System.Data.Linq.Table%601>。  
  
 你可以限制在两种方式的数据绑定控件中显示的属性。 你可以设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性号码中的属性，或者你可以通过添加定义的字段的数据绑定控件<xref:System.Web.UI.WebControls.DataControlField>控件。 但是，如果你设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性，则表示无法启用自动更新、 插入和删除操作。 如果你想要启用自动数据修改，在你使用的可用属性的子集时，不要设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 相反，此数据对象中检索所有属性和管理哪些显示通过使用数据绑定控件。 当你使用<xref:System.Web.UI.WebControls.DetailsView>控件或<xref:System.Web.UI.WebControls.GridView>控件，你还必须设置<xref:System.Web.UI.WebControls.DetailsView.AutoGenerateRows%2A>或<xref:System.Web.UI.WebControls.GridView.AutoGenerateColumns%2A>属性设置为`false`。 这可以防止数据绑定控件自动包括按钮用于编辑和删除数据。 数据绑定控件中不显示任何值存储视图状态中。 它们是不变时传递给数据源执行数据更新。  
  
<a name="evaluating_value_at_run_time"></a>   
## <a name="evaluating-values-at-run-time"></a>在运行时计算值  
 如果你需要在运行时以进行排序，评估值筛选或分组的值，你可以将参数添加到<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>， <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>， <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A>，或<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合。  
  
 如果你想要指定默认值，你可以将参数添加到<xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A>集合。  
  
 如果你想要检查或修改值，数据操作执行之前，你可以处理<xref:System.Web.UI.WebControls.LinqDataSource.Deleting>， <xref:System.Web.UI.WebControls.LinqDataSource.Inserting>， <xref:System.Web.UI.WebControls.LinqDataSource.Selecting>，或<xref:System.Web.UI.WebControls.LinqDataSource.Updating>事件。 若要取消数据操作，也可在检查根据用户输入的数据类中设置属性时出现的验证错误，你还可以处理这些事件。  
  
 若要检查值，数据操作完成之后，处理<xref:System.Web.UI.WebControls.LinqDataSource.Deleted>， <xref:System.Web.UI.WebControls.LinqDataSource.Inserted>， <xref:System.Web.UI.WebControls.LinqDataSource.Selected>，或<xref:System.Web.UI.WebControls.LinqDataSource.Updated>事件。  
  
<a name="working_with_stored_procedures"></a>   
## <a name="working-with-stored-procedures"></a>使用存储过程  
 你使用<xref:System.Web.UI.WebControls.LinqDataSource>控件从存储过程检索数据，通过创建的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件。 在事件处理程序，你表示存储的过程的数据上下文类中调用该方法并将结果设置为<xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A>属性<xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs>对象。 如果你要启用自动更新、 插入和删除操作的数据，从方法返回的类型必须与匹配中指定的类型<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性。 有关创建数据上下文方法的详细信息，请参阅[如何： 创建 DataContext 方法映射到存储的过程和函数 （O/R 设计器）](http://msdn.microsoft.com/library/e7ca32f1-50b3-48af-ad92-ceafd749296a)。  
  
<a name="declarative_syntax"></a>   
## <a name="declarative-syntax"></a>声明性语法  
  
```  
<asp:LinqDataSource  
    AutoGenerateOrderByClause="True|False"  
    AutoGenerateWhereClause="True|False"  
    AutoPage="True|False"  
    AutoSort="True|False"  
    ContextTypeName="string"  
    EnableDelete="True|False"  
    EnableInsert="True|False"  
    EnableTheming="True|False"  
    EnableUpdate="True|False"  
    EnableViewState="True|False"  
    GroupBy="string"  
    ID="string"  
    OnContextCreated="ContextCreated event handler"  
    OnContextCreating="ContextCreating event handler"  
    OnContextDisposing="ContextDisposing event handler"  
    OnDataBinding="DataBinding event handler"  
    OnDeleted="Deleted event handler"  
    OnDeleting="Deleting event handler"  
    OnDisposed="Disposed event handler"  
    OnInit="Init event handler"  
    OnInserted="Inserted event handler"  
    OnInserting="Inserting event handler"  
    OnLoad="Load event handler"  
    OnPreRender="PreRender event handler"  
    OnSelected="Selected event handler"  
    OnSelecting="Selecting event handler"  
    OnUnload="Unload event handler"  
    OnUpdated="Updated event handler"  
    OnUpdating="Updating event handler"  
    OrderBy="string"  
    runat="server"  
    Select="string"  
    SkinID="string"  
    StoreOriginalValuesInViewState="True|False"  
    TableName="string"  
    Visible="True|False"  
    Where="string"  
>  
        <GroupByParameters />  
        <InsertParameters />  
        <OrderByParameters />  
        <SelectParameters />  
        <WhereParameters />  
</asp:LinqDataSource>  
```  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>从名为的实体类中检索数据的控件`Products`。 实体类无法通过使用生成[!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]或 SqlMetal.exe 实用程序。 <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性设置为返回中具有值的记录`Price`属性大于 50。 A<xref:System.Web.UI.WebControls.GridView>控件绑定到<xref:System.Web.UI.WebControls.LinqDataSource>控件来显示数据。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default5.aspx#5)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default5.aspx#5)]  
  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>使用户能够更新、 删除和插入记录的数据源中的控件。 A<xref:System.Web.UI.WebControls.DetailsView>控件绑定到<xref:System.Web.UI.WebControls.LinqDataSource>控件，从而使用户能够查看和修改数据。 请注意任何 SQL 命令才能选择、 更新、 删除或插入记录。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 下面的示例演示的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>设置的数据对象的事件基于网页中的值。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/cs/Default3.aspx.cs#3)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/vb/Default3.aspx.vb#3)]  
  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>即控制配置到组的两个列。 `Key`属性引用具有两个属性的对象`ProductCategory`和`Color`。 所表示的对象`It`是重命名 （别名） `Products`。 重命名`Products`对象包含分组中各记录的集合。 每个实例将包含中的所有列`Products`表。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#1)]  
  
 下面的示例显示了两个<xref:System.Web.UI.WebControls.ListView>显示中的数据的控件<xref:System.Web.UI.WebControls.LinqDataSource>上一示例中的控件。 一个<xref:System.Web.UI.WebControls.ListView>控件显示分组的数据，以及其他<xref:System.Web.UI.WebControls.ListView>控件将显示属于该组的产品的各个名称。 嵌套的数据绑定控件的<xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A>属性设置为`Products`，即的别名`It`对象。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LinqDataSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LinqDataSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoGenerateOrderByClause">
      <MemberSignature Language="C#" Value="public bool AutoGenerateOrderByClause { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoGenerateOrderByClause" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoGenerateOrderByClause As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoGenerateOrderByClause { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoGenerateOrderByClause : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件是否根据 <see cref="P:System.Web.UI.WebControls.LinqDataSource.OrderByParameters" /> 集合中的值动态创建 Order By 子句。</summary>
        <value>
          <see langword="true" /> 如果<see cref="T:System.Web.UI.WebControls.LinqDataSource" />控件创建的 Order By 子句; 否则为<see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你将设置<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>属性`true`、<xref:System.Web.UI.WebControls.LinqDataSource>控件动态创建 Order By 子句中的值为基础<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合。 <xref:System.Web.UI.WebControls.LinqDataSource>控件对数据进行排序的第一个参数，并为每个其他参数的数据，此外进行排序。 参数包含`null`或 Order By 子句中不包含空值。  
  
 未设置<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性时<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>设置为`true`，因为分析器可动态创建的 Order By 子句。 <xref:System.Web.UI.WebControls.LinqDataSource>控件将引发异常，如果<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>设置为`true`和<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性分配值。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>控件替换为<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>设置为`true`。 参数包含在<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>排序基于属性的数据名用户的集合选择从<xref:System.Web.UI.WebControls.DropDownList>控件。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default8.aspx#8)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default8.aspx#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoGenerateWhereClause">
      <MemberSignature Language="C#" Value="public bool AutoGenerateWhereClause { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoGenerateWhereClause" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoGenerateWhereClause As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoGenerateWhereClause { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoGenerateWhereClause : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.AutoGenerateWhereClause</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件是否基于 <see cref="P:System.Web.UI.WebControls.LinqDataSource.WhereParameters" /> 集合中定义的值来动态创建 Where 子句。</summary>
        <value>如果 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件将创建 Where 子句，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你将设置<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>属性`true`、<xref:System.Web.UI.WebControls.LinqDataSource>控件动态创建 Where 子句中的参数从<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合。 你将添加到每个参数<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合中必须具有其<xref:System.Web.UI.WebControls.Parameter.Name%2A>属性设置为与匹配正在查询的数据对象中的属性的值。 自动生成 Where 子句将检查是否在指定的值<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合等于数据对象中匹配的属性的值。 如果你提供多个参数，则这些参数将与逻辑`AND`操作。 参数包含`null`或空值不包括在 Where 子句。  
  
 自动生成<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>子句可以仅测试相等性和链接参数只能与`AND`操作。 未设置<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>属性`true`如果你有要添加不会测试相等性的条件或你必须与参数替换`OR`操作。 你可以通过设置完成这些任务<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>属性`false`和添加中的占位符<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>中每个参数的属性<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合。 在<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性，作为每个占位符名称的开头 @ 符号。  
  
 未设置<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性时<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>属性是`true`，因为分析器可动态创建 Where 子句。 <xref:System.Web.UI.WebControls.LinqDataSource>控件将引发异常，如果<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>属性是`true`和<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性分配值。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>控件替换为<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>设置为`true`。 A<xref:System.Web.UI.WebControls.GridView>控件绑定到<xref:System.Web.UI.WebControls.LinqDataSource>控件来显示从查询返回的数据。 A<xref:System.Web.UI.WebControls.DropDownList>控件是因为它包含具有三个值填充。 参数包含在<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>具有名称设置为集合`Category,`与数据对象的属性之一匹配。 其<xref:System.Web.UI.WebControls.ControlParameter.ControlID%2A>属性设置为的 ID<xref:System.Web.UI.WebControls.DropDownList>控件。 <xref:System.Web.UI.WebControls.LinqDataSource>控件自动创建<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>筛选器记录的属性基于用户从选择的值<xref:System.Web.UI.WebControls.DropDownList>控件。 查询返回的记录其`Category`用户从所选的值匹配属性<xref:System.Web.UI.WebControls.DropDownList>控件。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default7.aspx#7)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default7.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoPage">
      <MemberSignature Language="C#" Value="public bool AutoPage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoPage" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoPage As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoPage { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoPage : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.AutoPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件是否支持在运行时在数据的各部分之间导航。</summary>
        <value>如果用户可以对数据进行分页，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A>属性`true`若要在中启用分页<xref:System.Web.UI.WebControls.LinqDataSource>控件。 若要使用户能够对数据进行分页，连接提供用于对分页的接口的数据绑定控件<xref:System.Web.UI.WebControls.LinqDataSource>控件。 当<xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A>属性设置为`true`、<xref:System.Web.UI.WebControls.LinqDataSource>控件中检索仅足够数据绑定控件中的一页的记录。 它使用<xref:System.Linq.Enumerable.Skip%2A>和<xref:System.Linq.Enumerable.Take%2A>方法来检索当前页的记录。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>控件替换为<xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A>属性设置为`true`和<xref:System.Web.UI.WebControls.GridView>绑定到控件<xref:System.Web.UI.WebControls.LinqDataSource>控件。 <xref:System.Web.UI.WebControls.GridView.AllowPaging%2A>属性<xref:System.Web.UI.WebControls.GridView>控件设置为`true`提供接口，可使用户数据进行分页。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSort">
      <MemberSignature Language="C#" Value="public bool AutoSort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSort" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoSort" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoSort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoSort { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSort : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.AutoSort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件是否支持在运行时对数据进行排序。</summary>
        <value>如果用户可以对数据进行排序，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件支持两种方法对数据进行排序。 你可以使用<xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A>属性来启用运行时排序也可以设置<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性来定义在设计时的排序。  
  
 设置<xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A>属性`true`中启用排序<xref:System.Web.UI.WebControls.LinqDataSource>基于的数据绑定控件的排序表达式的控件。 数据绑定控件提供的接口，使用户能够在运行时选择要用于排序的属性。  
  
 你可以以编程方式设置通过设置返回数据的顺序<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性的属性或用于排序的属性。 当<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性设置为一个属性和<xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A>属性是`true`，从数据绑定控件的排序表达式应用中的表达式之后<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性。 因此，这将确定数据的最终排序。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>控件替换为<xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A>属性设置为`true`和<xref:System.Web.UI.WebControls.GridView>绑定到控件<xref:System.Web.UI.WebControls.LinqDataSource>控件。 <xref:System.Web.UI.WebControls.GridView.AllowSorting%2A>属性<xref:System.Web.UI.WebControls.GridView>控件设置为`true`提供允许对数据进行排序的用户界面。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextCreated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; ContextCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; ContextCreated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.ContextCreated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextCreated As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ ContextCreated;" />
      <MemberSignature Language="F#" Value="member this.ContextCreated : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.ContextCreated : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在创建上下文类型对象实例后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理<xref:System.Web.UI.WebControls.LinqDataSource.ContextCreated>事件以进行检查的上下文类型对象或检查在创建对象时引发的异常。 检索中的上下文类型对象<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A>属性<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>与此事件相关联的对象。 检索从数据操作过程中引发的异常<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性。  
  
 上下文类型对象选择、 更新、 插入和删除操作过程中创建，并且在整个请求重复。  
  
 没有时不引发该事件的一次。 这是以编程方式设置<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A>期间的对象属性<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件。 附加条件是原始值不需要存储在或中的对象的视图状态，<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A>属性实现<xref:System.Data.Linq.ITable>接口。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextCreating">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt; ContextCreating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt; ContextCreating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.ContextCreating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextCreating As EventHandler(Of LinqDataSourceContextEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceContextEventArgs ^&gt; ^ ContextCreating;" />
      <MemberSignature Language="F#" Value="member this.ContextCreating : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt; " Usage="member this.ContextCreating : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在创建上下文类型对象实例前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，<xref:System.Web.UI.WebControls.LinqDataSource>控件创建一个实例中指定的类型<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性。 <xref:System.Web.UI.WebControls.LinqDataSource>控件调用要创建对象的实例的数据上下文对象的默认构造函数。 很可能你必须使用非默认构造函数，或你必须创建不同的对象中指定从<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性。 在这种情况下，你必须处理<xref:System.Web.UI.WebControls.LinqDataSource.ContextCreating>事件和手动创建的数据上下文对象。  
  
 在选择、 更新、 插入和删除操作期间创建上下文类型对象。  
  
 没有时不引发该事件的一次。 这是以编程方式设置<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A>的事件处理程序中某个对象的属性<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件。 附加条件是原始值不需要存储在或中的对象的视图状态，<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A>属性实现<xref:System.Data.Linq.ITable>接口。  
  
   
  
## Examples  
 下面的示例演示如何通过使用期间的非默认构造函数创建的数据上下文对象<xref:System.Web.UI.WebControls.LinqDataSource.ContextCreating>事件。 该代码将分配到对象<xref:System.Web.UI.WebControls.LinqDataSourceContextEventArgs.ObjectInstance%2A>属性。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.ContextCreating#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.ContextCreating/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.ContextCreating#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.ContextCreating/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextDisposing">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt; ContextDisposing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt; ContextDisposing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.ContextDisposing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextDisposing As EventHandler(Of LinqDataSourceDisposeEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceDisposeEventArgs ^&gt; ^ ContextDisposing;" />
      <MemberSignature Language="F#" Value="member this.ContextDisposing : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt; " Usage="member this.ContextDisposing : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在释放上下文类型对象前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你处理<xref:System.Web.UI.WebControls.LinqDataSource.ContextDisposing>若要手动释放对象或执行清理该对象被销毁之前即特定于该对象的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextTypeName">
      <MemberSignature Language="C#" Value="public override string ContextTypeName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContextTypeName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.ContextTypeName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContextTypeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContextTypeName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextTypeName : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.ContextTypeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置包含属性（其值包含要检索的数据）的类型的名称。</summary>
        <value>要从中检索数据的类的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你使用<xref:System.Web.UI.WebControls.LinqDataSource>控制从内存中数据集合或数据库检索数据，必须指定两个属性。 第一个是表示数据源的数据上下文类。 第二个是中包含的数据的数据上下文类的属性。 你设置<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性设置为数据上下文类并且你的名称设<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>到包含数据的数据集合的属性。  
  
 例如，当从数据库检索数据，则设置<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性表示数据库的类的名称。 此外设置<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性表示数据库中的表的属性。 若要从数据库中生成类，请使用[!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]或 SqlMetal.exe 实用工具来自动生成这些类。  
  
 当从内存中的数据集合 （如数组） 中检索数据时，设置<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性设置为包含数组属性的类的名称。 然后设置<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性用于获取数组的属性。  
  
 若要启用自动更新、 插入或删除操作通过<xref:System.Web.UI.WebControls.LinqDataSource>控制分配给类<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性必须派生自<xref:System.Data.Linq.DataContext>。 此外，此属性分配给<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性必须派生自<xref:System.Data.Linq.Table%601>。 如果你不需要以启用自动更新、 插入或删除操作，则可以分配到的类的任何类型的名称<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性。  
  
 有关如何从一个类的实例中选择数据的信息，请参阅<xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A>属性。  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>到包含的字符串数组的类的属性。 它还演示如何将属性设置为一个类 (由生成[!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]) 表示的数据库。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/Default.aspx#2)]  
  
 名为的类`ExampleDataContext`，表示数据库表中不会显示此示例。 对于此示例正常工作，必须创建此类，通过添加一个命名的 Example.dbml 并拖动一个表名为拖动到的电影的 LINQ 到 SQL 类[!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]。 一个名为类`ExampleDataContext`一个属性名为`Movies`生成。  
  
 下面的示例显示名为的类`MovieLibrary`中引用<xref:System.Web.UI.WebControls.LinqDataSource>控件。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/App_Code/MovieLibrary.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/App_Code/MovieLibrary.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateQueryableView">
      <MemberSignature Language="C#" Value="protected override System.Web.UI.WebControls.QueryableDataSourceView CreateQueryableView ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.WebControls.QueryableDataSourceView CreateQueryableView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.CreateQueryableView" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateQueryableView () As QueryableDataSourceView" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::WebControls::QueryableDataSourceView ^ CreateQueryableView();" />
      <MemberSignature Language="F#" Value="override this.CreateQueryableView : unit -&gt; System.Web.UI.WebControls.QueryableDataSourceView" Usage="linqDataSource.CreateQueryableView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.QueryableDataSourceView</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回可查询的视图。</summary>
        <returns>可查询的视图。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateView">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.LinqDataSourceView CreateView ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.LinqDataSourceView CreateView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.CreateView" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateView () As LinqDataSourceView" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::LinqDataSourceView ^ CreateView();" />
      <MemberSignature Language="F#" Value="abstract member CreateView : unit -&gt; System.Web.UI.WebControls.LinqDataSourceView&#xA;override this.CreateView : unit -&gt; System.Web.UI.WebControls.LinqDataSourceView" Usage="linqDataSource.CreateView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.LinqDataSourceView</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建与此控件相关联的 <see cref="T:System.Web.UI.WebControls.LinqDataSourceView" /> 类的新实例。</summary>
        <returns>充当数据绑定控件的接口的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要提供自定义视图，可以重写此方法在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public int Delete (System.Collections.IDictionary keys, System.Collections.IDictionary oldValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Delete(class System.Collections.IDictionary keys, class System.Collections.IDictionary oldValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.Delete(System.Collections.IDictionary,System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function Delete (keys As IDictionary, oldValues As IDictionary) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Delete(System::Collections::IDictionary ^ keys, System::Collections::IDictionary ^ oldValues);" />
      <MemberSignature Language="F#" Value="member this.Delete : System.Collections.IDictionary * System.Collections.IDictionary -&gt; int" Usage="linqDataSource.Delete (keys, oldValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.IDictionary" />
        <Parameter Name="oldValues" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="keys">要删除的记录的行键值。</param>
        <param name="oldValues">为检测数据冲突而计算的行值。</param>
        <summary>执行删除操作。</summary>
        <returns>受删除操作影响的记录数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常情况下，则不需要调用<xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A>在代码中的方法。 当你使用<xref:System.Web.UI.WebControls.LinqDataSource>控件与数据绑定控件，数据绑定控件将自动调用<xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A>方法如果用户执行操作以删除一条记录。 显式调用<xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A>方法如果你想要创建你自己的过程删除数据。 例如，你可以调用<xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A>当你想要删除一条记录的方法基于之外的数据绑定控件的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Deleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.Deleted : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>完成删除操作后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理<xref:System.Web.UI.WebControls.LinqDataSource.Deleted>事件来捕获删除操作中，从任何异常，也可后在操作完成后检查输出参数。 你可以检索来自的输出参数<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>传递给事件处理程序的对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection DeleteParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection DeleteParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.DeleteParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeleteParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ DeleteParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeleteParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.DeleteParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 类不使用此属性。</summary>
        <value>参数的集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Deleting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt; Deleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt; Deleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Deleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleting As EventHandler(Of LinqDataSourceDeleteEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceDeleteEventArgs ^&gt; ^ Deleting;" />
      <MemberSignature Language="F#" Value="member this.Deleting : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt; " Usage="member this.Deleting : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>执行删除操作前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理<xref:System.Web.UI.WebControls.LinqDataSource.Deleting>事件，以便验证要删除，以检查数据类，若要更改在删除操作中前, 一个值，或若要取消删除操作中的数据验证错误的对象。 <xref:System.Web.UI.WebControls.LinqDataSource>控制将传递<xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs>向事件处理程序的对象<xref:System.Web.UI.WebControls.LinqDataSource.Deleting>事件。 <xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs>对象包含将被删除并使你能够取消删除操作的数据。 如果数据类将引发<xref:System.Web.UI.WebControls.LinqDataSourceValidationException>异常，<xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs>对象包含在该异常<xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs.Exception%2A>属性。  
  
 如果在事件处理程序中引发异常<xref:System.Web.UI.WebControls.LinqDataSource.Deleting>事件，你必须处理该事件处理程序中的异常。 此异常不会传递到事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Deleted>事件 (通过<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>对象)。 <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性包含仅后引发的异常<xref:System.Web.UI.WebControls.LinqDataSource.Deleting>事件。  
  
   
  
## Examples  
 下面的示例演示的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Deleting>事件。 代码将会取消删除操作中的属性上基于<xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs.OriginalObject%2A>属性和值从 Web 页。 在示例中，当`OnSale`属性设置为`true`，用户必须选择<xref:System.Web.UI.WebControls.CheckBox>控件来确认是否删除了记录。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Deleting#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Deleting/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Deleting#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Deleting/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableDelete">
      <MemberSignature Language="C#" Value="public bool EnableDelete { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableDelete" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableDelete" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableDelete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableDelete { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableDelete : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.EnableDelete" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EnableDelete</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否可以通过 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件删除数据记录。</summary>
        <value>如果启用了自动删除操作，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A>属性`true`如果想要使用户能够删除数据记录通过<xref:System.Web.UI.WebControls.LinqDataSource>控件。 当<xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A>是`true`、<xref:System.Web.UI.WebControls.LinqDataSource>控件使用 LINQ to SQL 会自动创建的命令删除的数据。 必须包括一个接口，使用户可以选择一条记录以删除，如<xref:System.Web.UI.WebControls.DetailsView>控件。  
  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件不支持自动删除操作时<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性或<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性设置。 在这种情况下，<xref:System.Web.UI.WebControls.LinqDataSource>控件将引发异常，如果尝试删除操作。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>具有控件<xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A>设置为`true`。 A<xref:System.Web.UI.WebControls.DetailsView>控件显示的数据并创建一个允许用户删除数据记录的按钮。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableInsert">
      <MemberSignature Language="C#" Value="public bool EnableInsert { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableInsert" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableInsert" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableInsert As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableInsert { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableInsert : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.EnableInsert" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EnableInsert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否可以通过 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件插入数据记录。</summary>
        <value>如果启用了自动插入操作，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A>属性`true`如果想要使用户能够插入新数据记录通过<xref:System.Web.UI.WebControls.LinqDataSource>控件。 当<xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A>是`true`、<xref:System.Web.UI.WebControls.LinqDataSource>控件使用 LINQ to SQL 来自动创建命令插入数据。 必须包括一个供用户插入一个新记录，例如界面<xref:System.Web.UI.WebControls.DetailsView>控件。  
  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件不支持自动插入操作时<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性或<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性设置。 在这种情况下，<xref:System.Web.UI.WebControls.LinqDataSource>控件将引发异常，如果尝试插入操作。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>具有控件<xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A>设置为`true`。 A<xref:System.Web.UI.WebControls.DetailsView>控件显示的数据并显示将该控件为插入的模式，其中用户可以创建并保存一条新记录切换按钮。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableObjectTracking">
      <MemberSignature Language="C#" Value="public bool EnableObjectTracking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableObjectTracking" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableObjectTracking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableObjectTracking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableObjectTracking : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否跟踪对数据上下文对象所做的更改。</summary>
        <value>如果跟踪数据上下文对象的更改，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking%2A> LINQ 到 SQL 数据上下文对象中选择数据时，才使用属性。  
  
 当你与只读数据交互时，设置<xref:System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking%2A>属性`false`能改善性能，因为数据不缓存以确定是否有更改。 但是，它还将禁用延迟的执行查询。 此属性必须设置为`true`如果你想要使用延迟的执行查询。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      </Docs>
    </Member>
    <Member MemberName="EnableUpdate">
      <MemberSignature Language="C#" Value="public bool EnableUpdate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableUpdate" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableUpdate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableUpdate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableUpdate : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.EnableUpdate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EnableUpdate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否可以通过 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件更新数据记录。</summary>
        <value>如果启用了自动更新操作，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A>属性`true`如果想要使用户能够通过使用更新的数据记录<xref:System.Web.UI.WebControls.LinqDataSource>控件。 当<xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A>是`true`、<xref:System.Web.UI.WebControls.LinqDataSource>控件使用 LINQ to SQL 会自动创建的命令以更新的数据。 必须包含一个界面，从而让用户更新的记录，如<xref:System.Web.UI.WebControls.DetailsView>控件。  
  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件不支持自动更新操作时<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性或<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性设置。 在这种情况下，<xref:System.Web.UI.WebControls.LinqDataSource>控件将引发异常，如果尝试更新操作。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>具有控件<xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A>设置为`true`。 A<xref:System.Web.UI.WebControls.DetailsView>控件显示的数据并创建供用户更新的数据记录的按钮。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupBy">
      <MemberSignature Language="C#" Value="public string GroupBy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string GroupBy" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.GroupBy" />
      <MemberSignature Language="VB.NET" Value="Public Property GroupBy As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ GroupBy { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.GroupBy : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.GroupBy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定用于对检索到的数据进行分组的属性。</summary>
        <value>一个字符串，用于创建 Group By 子句。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你使用<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性来指定哪些属性用于将合并具有相同的值的数据记录。 例如，如果你设置<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性`Name`，查询具有相同的所有记录`Name`作为单个合并记录返回属性值。  
  
 你可以将分配到多个属性<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>括中的所有属性的属性`new`函数，并使用逗号分隔每个属性。 例如，若要按属性分组`Name`然后`Category`，将其设置<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性`new(Name, Category)`。  
  
 用于分组属性中的值返回通过名为的生成属性`Key`。 您包括`Key`中的属性<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性来检索已分组的值。 你可以设置`Key`属性使用别名`As`关键字，但你无需使用别名。 例如，你可能会设置<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>到名为的属性的属性`Category`。 你可以检索中的合并的值`Category`通过设置属性<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性`new(Key As ProductCategory)`。  
  
 你可以通过包括访问分组中的各记录`It`中的属性<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 `It`属性包含共享中的分组属性的值的记录的集合。 可以循环访问`It`属性来检索单个记录。  
  
 <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性通常用于聚合方法。 你可以使用以下聚合方法：  
  
-   `Count()`  
  
-   `Average(` *列* `)`  
  
-   `Sum(` *列* `)`  
  
-   `Max(` *列* `)`  
  
-   `Min(` *列* `)`  
  
-   `Where(` *条件* `)`  
  
-   `Any()`  
  
-   `All(` *条件* `)`  
  
 有关详细信息，请参阅[NIB: LinqDataSource Web 服务器控件概述](http://msdn.microsoft.com/library/104cfc3f-7385-47d3-8a51-830dfa791136)和[How to： 分组和聚合数据使用 LinqDataSource 控件](http://msdn.microsoft.com/library/b922cf69-251f-4158-b405-ea960993a1af)。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>通过名为的属性对返回的数据进行分组的控件`Category`。 它返回共享的值，并计算的分组记录的平均价格。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default3.aspx#3)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default3.aspx#3)]  
  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>即控制配置到组的两个列。 `Key`属性引用具有两个属性的对象`ProductCategory`和`Color`。 所表示的对象`It`已重命名`Products`。 重命名`Products`对象包含的分组，各记录的集合，每个实例包含从 Products 表的所有列。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#1)]  
  
 下面的示例显示了两个<xref:System.Web.UI.WebControls.ListView>控件用于显示从数据<xref:System.Web.UI.WebControls.LinqDataSource>上一示例中的控件。 一个<xref:System.Web.UI.WebControls.ListView>控件显示分组的数据，另一个<xref:System.Web.UI.WebControls.ListView>控件将显示属于该组的产品的各个名称。 嵌套的数据绑定控件的<xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A>属性设置为`Products`，即的别名`It`对象。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupByParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection GroupByParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection GroupByParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.GroupByParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GroupByParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ GroupByParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GroupByParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.GroupByParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于创建 Group By 子句的参数集合。</summary>
        <value>用于创建 Group By 子句的参数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件使用中的参数<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>集合以在运行时创建 Group By 子句。 通常不会使用<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>对数据进行分组的集合。 相反，你可以使用<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性。 你使用<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>仅在时收集 Group By 子句中的值必须在运行时设置，并且该值不是属性名称。 例如，使用<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>是否基于对数据进行分组的集合`LastName`数据记录中的属性将为用户提供一个值。  
  
 如果你想对数据进行分组的属性，并且不需要在运行时设置该属性，则可以定义中的分组属性<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性。 例如，若要从数据库表中返回按分组`LastName`，将其设置<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>为"LastName"不带任何参数。 如果你想对动态数据进行分组的属性，创建的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件和自定义<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>根据需要的属性。  
  
 不能将属性的名称分配中的参数的值作为<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>集合。 你将参数添加到<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>集合，当你想要添加到条件<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>必须在运行时设置的属性。  
  
 在中设置值<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>集合，将名称分配给每个参数并将中的占位符<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性中的为该命名参数。 在 Group By 子句中，作为开头的每个参数名称 @ 符号。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public int Insert (System.Collections.IDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Insert(class System.Collections.IDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.Insert(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (values As IDictionary) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Insert(System::Collections::IDictionary ^ values);" />
      <MemberSignature Language="F#" Value="member this.Insert : System.Collections.IDictionary -&gt; int" Usage="linqDataSource.Insert values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="values">要插入到数据源的行值。</param>
        <summary>执行插入操作。</summary>
        <returns>受插入操作影响的行数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常情况下，则不需要调用<xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A>在代码中的方法。 数据绑定控件将自动调用<xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A>方法如果用户执行操作以插入新记录。 显式调用<xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A>方法如果你想要创建你自己的过程用于插入数据。  
  
   
  
## Examples  
 下面的示例演示如何以编程方式在数据源中插入新记录，用户单击按钮后。 在代码传递<xref:System.Collections.Specialized.ListDictionary>对象，其中包含默认值复制到<xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A>方法。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Insert#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/cs/Default2.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/vb/Default2.aspx.vb#1)]  
  
 下面的示例演示上一示例的标记。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.Insert#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.Insert#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Inserted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Inserted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Inserted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Inserted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Inserted As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Inserted;" />
      <MemberSignature Language="F#" Value="member this.Inserted : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.Inserted : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>完成插入操作后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理<xref:System.Web.UI.WebControls.LinqDataSource.Inserted>事件来捕获插入操作的任何异常，也可在插入操作完成之后检查的值。 您可以通过将新值<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>传递给事件处理程序的对象。 例如，你可以使用<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>对象以检索生成的数据库以进行新的数据记录的标识属性。  
  
   
  
## Examples  
 下面的示例演示如何创建的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Inserted>检查的异常并检索新的记录的标识属性的事件。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSourceStatusEventArgs#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceStatusEventArgs/cs/Default.aspx#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSourceStatusEventArgs#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceStatusEventArgs/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Inserting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt; Inserting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt; Inserting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Inserting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Inserting As EventHandler(Of LinqDataSourceInsertEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceInsertEventArgs ^&gt; ^ Inserting;" />
      <MemberSignature Language="F#" Value="member this.Inserting : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt; " Usage="member this.Inserting : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>执行插入操作前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理<xref:System.Web.UI.WebControls.LinqDataSource.Inserting>事件，以便验证的对象要插入、 检查数据类，若要更改在插入操作中前, 一个值，或取消插入操作中的数据验证错误。 <xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs>为此事件包含要插入的数据源中的新对象，对象将传递到事件处理程序。  
  
 如果在插入操作时，发生验证错误<xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs>对象包含由数据类引发验证异常。 如果要插入的值与在数据类中，属性的类型不匹配或未通过自定义的验证检查，将发生验证错误。 中的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Inserting>事件，您可以检索验证异常，并采取相应的操作。  
  
 如果在事件处理程序中引发异常<xref:System.Web.UI.WebControls.LinqDataSource.Inserting>事件，你必须处理该事件处理程序中的异常。 此异常不会传递到事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Inserted>事件 (通过<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>对象)。 <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性包含仅后引发的异常<xref:System.Web.UI.WebControls.LinqDataSource.Inserting>事件。  
  
   
  
## Examples  
 下面的示例演示的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Inserting>修改数据之前插入操作的事件。 从对象<xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs.NewObject%2A>属性被强制转换为名为的类型`Product`。 `DateModified`属性`Product`对象设置为当前日期和时间。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Inserting#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Inserting/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Inserting#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Inserting/vb/Default.aspx.vb#1)]  
  
 下面的示例演示的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Inserting>检索验证异常的事件。  
  
```vb  
Protected Sub LinqDataSource_Inserting(ByVal sender As Object, _  
        ByVal e As LinqDataSourceInsertEventArgs)  
    If (e.Exception IsNot Nothing) Then  
        For Each innerException As KeyValuePair(Of String, Exception) _  
               In e.Exception.InnerExceptions  
            Label1.Text &= innerException.Key & ": " & _  
                innerException.Value.Message & "<br />"  
        Next  
        e.ExceptionHandled = True  
    End If  
End Sub  
```  
  
```csharp  
protected void LinqDataSource_Inserting(object sender,   
        LinqDataSourceInsertEventArgs e)  
{  
    if (e.Exception != null)  
    {  
        foreach (KeyValuePair<string, Exception> innerException in   
             e.Exception.InnerExceptions)  
        {  
        Label1.Text += innerException.Key + ": " +   
            innerException.Value.Message + "<br />";  
        }  
        e.ExceptionHandled = true;  
    }  
}  
```  
  
 前面的示例检索验证异常。 如果值与属性的类型不匹配，则可能引发异常。 它还可能如以下示例中的自定义检查从引发。 `OnAgeChanging`方法检查的数量`Age`属性不是负数。  
  
```csharp  
partial void  OnAgeChanging(int? value)  
{  
    if (value < 0)  
    {  
        throw new Exception("Age cannot be a negative number.");  
    }  
}  
```  
  
```vb  
Private Sub OnAgeChanging(ByVal value As System.Nullable(Of Integer))  
    If (value < 0) Then  
        Throw New Exception("Age cannot be a negative number.")  
    End If  
End Sub  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection InsertParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection InsertParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.InsertParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InsertParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ InsertParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InsertParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.InsertParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在插入操作过程中使用的参数的集合。</summary>
        <value>在插入操作过程中使用的参数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常将所需的插入操作的值传递给<xref:System.Web.UI.WebControls.LinqDataSource>由数据绑定控件的控件。 插入参数，如果你想要提供默认值或定义是否将转换到的空值可指定`null`。 无需将插入，只需为在用户不提供一个值时必须处理值的每个值提供一个参数。  
  
 在中提供的值<xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A>集合仅用于在数据源中定义但未绑定数据控件中的字段。 例如，假设数据库表具有列名称、 地址和邮政编码，分别名为但<xref:System.Web.UI.WebControls.ListView>已绑定到表的控件绑定到的名称和地址字段仅。 中的值<xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A>集合将仅用于邮政编码字段。 它们不用于为名称和地址字段。 即使为这些字段中输入任何值，也是如此。 如果数据中的所有字段的数据绑定控件自动生成字段源中的任何值<xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A>将使用集合。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>控件，其提供中的默认值的参数<xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A>集合。 如果用户未提供的值`Category`属性，则参数提供的默认值保存在数据库中。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#9](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default9.aspx#9)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#9](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default9.aspx#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="linqDataSource.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件数据。</param>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 对象。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="linqDataSource.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" /> 对象。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.Unload" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OrderBy">
      <MemberSignature Language="C#" Value="public string OrderBy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OrderBy" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderBy" />
      <MemberSignature Language="VB.NET" Value="Public Property OrderBy As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OrderBy { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OrderBy : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.OrderBy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定用于对检索到的数据进行排序的字段。</summary>
        <value>一个字符串，用于创建 Order By 子句。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你使用<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性来指定从返回的数据要用于排序的属性。 对数据进行排序的属性必须存在于原始数据源，但是它没有要包括在<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 你可以添加一个空格和`Ascending`， `ASC`， `Descending`，或`DESC`到中的属性<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>才能指定如何返回已排序的数据的字符串。  
  
 你可以提供多个属性中的<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>通过使用逗号分隔每个属性的属性。 例如，到排序依据属性名为`LastName`和`FirstName`，将其设置<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性设置为"姓氏 FirstName"。  
  
> [!NOTE]
>  当你使用<xref:System.Web.UI.WebControls.LinqDataSource>控件替换为[!INCLUDE[ss2k](~/includes/ss2k-md.md)]或[!INCLUDE[ssEW](~/includes/ssew-md.md)]和<xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A>属性设置为`true`，你必须提供中的值<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性。 默认情况下，<xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A>属性是`true`。 如果将值赋给<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性，你还必须包括所有的 identity 列在查询中返回的属性列表。  
  
 如果<xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A>属性设置为`true`，数据绑定控件可以传递到一个排序表达式<xref:System.Web.UI.WebControls.LinqDataSource>控件在运行时。 <xref:System.Web.UI.WebControls.LinqDataSource>控件将应用从数据绑定控件的排序表达式，它将应用后<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性。 因此，根据排序表达式被返回的数据，从数据绑定控件。  
  
   
  
## Examples  
 下面的示例返回按反向字母顺序中的值为基础的数据`Category`属性。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default4.aspx#4)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default4.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OrderByParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection OrderByParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection OrderByParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderByParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OrderByParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ OrderByParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OrderByParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.OrderByParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于创建 Order By 子句的参数集合。</summary>
        <value>用于创建 Order By 子句的参数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件使用中的参数<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合以在运行时创建的 Order By 子句。 通常情况下设置<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>属性`true`时你将参数添加到<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合。 当<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>属性设置为`true`中, 每个参数<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合添加到中指定的序列中的 Order By 子句<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合。 当<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>属性是`true`，参数不需要命名为，因为它们会按顺序应用和与占位符不匹配。  
  
 如果不需要在 Order By 子句中的运行时设置一个值，不需要使用<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合。 你可以定义要使用的排序顺序中的数据的字段<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性。 例如，若要从数据库表中返回排序通过`LastName`，将其设置<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>为"LastName"不带任何参数。  
  
 你可以在设置参数<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合和匹配到中的占位符参数<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性，但这种方法具有有限的应用程序。 当你使用此方法时中的参数<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合不能表示的一个列名称。 可以将参数设置为一个值，然后将该值与属性中的值进行比较。 例如，你可以基于属性中的值是否小于该参数表示的运行时间值的数据进行排序。  
  
   
  
## Examples  
 下面的示例显示一个 <xref:System.Web.UI.WebControls.LinqDataSource> 控件，其 <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> 属性设置为 `true`。 参数包含在<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>排序基于属性的数据名用户的集合选择从<xref:System.Web.UI.WebControls.DropDownList>控件。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default8.aspx#8)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default8.aspx#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OrderGroupsBy">
      <MemberSignature Language="C#" Value="public string OrderGroupsBy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OrderGroupsBy" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy" />
      <MemberSignature Language="VB.NET" Value="Public Property OrderGroupsBy As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OrderGroupsBy { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OrderGroupsBy : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于对分组数据进行排序的字段。</summary>
        <value>一个字符串，用于创建组 Order By 子句。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你使用<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性指定数据的组的排序方式。 例如，你可通过组`CategoryID`属性和每个类别 ID 分组依据的平均值的然后排序`Price`属性。  
  
 你可以设置<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性仅在对数据进行分组时。 如果你设置<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性但没有设置<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性，<xref:System.Web.UI.WebControls.LinqDataSource>控件将引发异常。  
  
 用于对数据进行排序的属性必须是一个属性，用于对数据进行分组或分组数据的聚合函数的结果。 若要指定如何对数据进行排序，但是你可以添加一个空格和字符串"升序"、"ASC"、"降序"或"DESC"中的属性名称到<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>字符串。  
  
 你可以指定多个属性中的<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性。 使用逗号分隔每个属性。  
  
   
  
## Examples  
 下面的示例演示如何对数据进行分组使用两个属性，以及如何通过使用这些属性之一分组的数据进行排序。 名为的表中的数据`Products`按使用属性名为分组`CategoryID`和`Discontinued`。 按分组的数据进行排序`CategoryID`属性。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/vb/Default.aspx#1)]  
  
 下面的示例演示如何对数据进行分组通过使用的属性，以及如何对基于聚合函数的结果进行排序。 中的数据`Products`表分组使用`CategoryID`属性。 进行排序所基于的平均值`UnitPrice`每个组中的属性。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OrderGroupsByParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection OrderGroupsByParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection OrderGroupsByParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OrderGroupsByParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ OrderGroupsByParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OrderGroupsByParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于创建 Order Groups By 子句的参数集合。</summary>
        <value>使用创建组 Order By 子句的参数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件使用中的参数<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A>集合以在运行时创建的组 Order By 子句。  
  
 你将值添加到<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A>仅在你必须在组 Order By 子句中的运行时设置值时才收集。 你可以定义用于按使用顺序对数据的字段<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性。  
  
 你可以在设置参数<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A>集合和匹配到中的占位符参数<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性。 但是，当你使用此方法时中的参数时，才<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A>集合不能表示的一个列名称; 它们还必须表示值。 可以将参数设置为一个值，然后将该属性值进行比较。 例如，你可以基于属性中的值是否小于该参数表示的运行时间值的数据进行排序。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public string Select { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Select" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.Select" />
      <MemberSignature Language="VB.NET" Value="Public Property Select As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Select { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Select : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.Select" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置属性和计算值，它们包含在检索到的数据中。</summary>
        <value>用于创建 Select 子句的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你未设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性，<xref:System.Web.UI.WebControls.LinqDataSource>控制此数据对象中检索所有属性 （数据列）。 你使用<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性来检索此对象中的属性的子集或正在检索数据时计算新值。  
  
 指定要检索通过设置哪些属性<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性设置为你想要包括在返回的数据的属性的名称。  
  
 如果从数据对象，检索属性的子集<xref:System.Web.UI.WebControls.LinqDataSource>控件动态创建一个包含仅在指定的属性类<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 如果计算不在数据对象中的属性的属性，也会动态创建类。 在这些情况下，从查询返回的对象不是在指定类的实例<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性。 相反，你必须使用`new`中的方法<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性以指示，从查询返回一个新类。 例如，若要仅返回`FirstName`和`LastName`属性从一个对象，包含多个这些属性，请设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性`new(FirstName, LastName)`。 <xref:System.Web.UI.WebControls.LinqDataSource>控件动态创建中指定的新类`new`方法。  
  
 你可以使用`As`关键字来将别名分配给所选的值。 如果分配别名，则必须包含中的别名属性`new`方法。 将绑定到的任何数据绑定控件<xref:System.Web.UI.WebControls.LinqDataSource>控件必须由该别名引用的属性。 例如，如果你设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性`new(Region As SalesRegion, Revenue / 1000 As RevenueThousands)`，数据绑定控件可以访问两个属性，`SalesRegion`和`RevenueThousands`。  
  
 你使用`new`函数中<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性根据条件下表中列出。  
  
|选择|使用新的|示例|  
|------------|----------------|-------------|  
|单个属性。|`new` 不需要。|`Select="Category"`|  
|多个属性。|`new` 需要。|`Select="new(Cateogry, Name)"`|  
|一个或多个具有别名的属性。|`new` 需要。|`Select="new(Category As CategoryGroup)"`|  
  
 如果你想要启用自动数据修改，但你不希望显示此数据对象中的所有属性，则不要设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 相反，管理通过数据绑定控件显示。 当你使用<xref:System.Web.UI.WebControls.DetailsView>控件或<xref:System.Web.UI.WebControls.GridView>控件，你还必须设置<xref:System.Web.UI.WebControls.DetailsView.AutoGenerateRows%2A>或<xref:System.Web.UI.WebControls.GridView.AutoGenerateColumns%2A>属性`false`。 数据绑定控件中不显示任何值存储视图状态中。 它们是不变时传递给数据源执行数据更新。  
  
 在查询中的数据分组时，你可以纳入中的聚合方法<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 你可以使用以下聚合方法：  
  
-   `Count()`  
  
-   `Average(` *列* `)`  
  
-   `Sum(` *列* `)`  
  
-   `Max(` *列* `)`  
  
-   `Min(` *列* `)`  
  
-   `Where(` *条件* `)`  
  
-   `Any()`  
  
-   `All(` *条件* `)`  
  
 有关详细信息，请参阅[NIB: LinqDataSource Web 服务器控件概述](http://msdn.microsoft.com/library/104cfc3f-7385-47d3-8a51-830dfa791136)和[How to： 分组和聚合数据使用 LinqDataSource 控件](http://msdn.microsoft.com/library/b922cf69-251f-4158-b405-ea960993a1af)。  
  
 在您对数据进行分组，你可以纳入`Key`和`It`，它们动态创建中的属性，<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 `Key`属性是指中或多个用于对数据进行分组的属性的值。 例如，如果通过名为的属性组`Category`、`Key`属性将包含在每个唯一值`Category`属性。 `It`属性指的数据分组中的单个记录的集合。 可以循环访问`It`属性，以检索已经合并分组操作中的单个记录。 例如，如果通过名为的属性组`Category`、`It`属性包含所有的共享中的常见值的单个记录`Category`属性。  
  
 如果包含`It`中的关键字<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性数据进行分组时，你必须将分配的别名`It`关键字。 <xref:System.Web.UI.WebControls.LinqDataSource>控件将引发异常，如果`It`没有别名。 你可以分配的别名`Key`关键字，但这不是必需。  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性中的数据对象的属性的子集。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#10](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default10.aspx#10)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#10](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default10.aspx#10)]  
  
 下面的示例演示如何检索对数据进行分组，已使用的属性中的值，以及如何检索分组记录的平均值。 `Key`关键字包含已用于对数据进行分组的属性。 在此示例中，`Key`将包含从共享的值`ProductCategory`属性。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default3.aspx#3)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default3.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Selected">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Selected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Selected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Selected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Selected As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Selected;" />
      <MemberSignature Language="F#" Value="member this.Selected : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.Selected : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>数据检索操作完成后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理<xref:System.Web.UI.WebControls.LinqDataSource.Selected>事件捕获从数据检索操作的任何异常或检索操作完成之后检查数据对象。 该对象可用于从<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>传递给事件处理程序的对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Selecting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt; Selecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt; Selecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Selecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Selecting As EventHandler(Of LinqDataSourceSelectEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceSelectEventArgs ^&gt; ^ Selecting;" />
      <MemberSignature Language="F#" Value="member this.Selecting : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt; " Usage="member this.Selecting : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>执行数据检索操作前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件来执行以下任务：  
  
-   修改数据检索的参数。  
  
-   以编程方式生成查询。  
  
-   修改排序或分页的值。  
  
-   执行自定义排序或分页。  
  
-   取消数据检索操作。  
  
 <xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs>为此事件包含该数据检索操作的参数传递到事件处理程序的对象。 你可以修改中的参数<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件处理程序之前执行查询时，也可以创建新的结果集，并指定给<xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A>属性。  
  
 你是否能够实现自定义的排序或为此事件可能会受到绑定到控件处理程序中的分页<xref:System.Web.UI.WebControls.LinqDataSource>。 例如，当列标题的<xref:System.Web.UI.WebControls.GridView>单击控件，控件将执行自动排序，这可能会的替代任何订单，所以建立在事件处理程序。  
  
 如果在事件处理程序中引发异常<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件，你必须处理该事件处理程序中的异常。 此异常不会传递到事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Selected>事件 (通过<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>对象)。 <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性包含仅后引发的异常<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件。  
  
   
  
## Examples  
 下面的示例演示的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件。 该处理程序创建从 Web 页中的字符串值的数组中检索值的查询。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/cs/Default3.aspx.cs#3)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/vb/Default3.aspx.vb#3)]  
  
 下面的示例演示如何分配<xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A>表示存储的过程的方法中返回的对象的属性。  
  
```vb  
Protected Sub LinqDataSource_Selecting(ByVal sender As Object, _  
        ByVal e As LinqDataSourceSelectEventArgs)  
    Dim exampleContext As ExampleDataContext = New ExampleDataContext()  
    e.Result = exampleContext.GetRegisteredCustomers()  
End Sub  
```  
  
```csharp  
protected void LinqDataSource_Selecting(object sender,   
        LinqDataSourceSelectEventArgs e)  
{  
    ExampleDataContext exampleContext = new ExampleDataContext();  
    e.Result = exampleContext.GetRegisteredCustomers();  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection SelectParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection SelectParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.SelectParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ SelectParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.SelectParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在数据检索操作过程中使用的参数的集合。</summary>
        <value>用于创建 Select 子句的参数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件使用中的参数<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>要在运行时创建 Select 子句集合。 你将参数添加到<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>时你想要在 Select 子句中使用运行时的值的集合。 例如，你可以将参数添加到<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>集合以表示用户的配置文件中的属性。 你可以然后使用该属性和值从数据源计算新值。  
  
 如果不需要在 Select 子句中的运行时设置一个值，不需要使用<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>集合。 你可以定义要检索的属性<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 例如，若要返回`FirstName`和`LastName`从数据库表中的值设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>到"FirstName、 LastName"不带任何参数。  
  
 在中设置值<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>集合，你将添加中的占位符<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>的命名参数的属性。 在 Select 子句中，作为开头的每个参数名称 @ 符号。  
  
 不能使用中的参数<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>表示属性名称的集合。 动态设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>到属性的名称的属性创建的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件和自定义<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>根据需要的属性。  
  
   
  
## Examples  
 下面的示例演示如何使用用户提供的值计算中返回的数据的值。 用户可以表示制造天数的文本框中输入一个值。 此值除以表示的天数，以制造一种产品的数据库中的一个值。 返回的值表示多少产品可以生产期间指定的天数。 用户的输入中通过选择命令包含<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>集合。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.SelectParameters#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.SelectParameters/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.SelectParameters#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.SelectParameters/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StoreOriginalValuesInViewState">
      <MemberSignature Language="C#" Value="public bool StoreOriginalValuesInViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool StoreOriginalValuesInViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState" />
      <MemberSignature Language="VB.NET" Value="Public Property StoreOriginalValuesInViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool StoreOriginalValuesInViewState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.StoreOriginalValuesInViewState : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示数据源中的数据是否存储在视图状态中，以确保数据在更新或删除之前不会由其他进程更改。</summary>
        <value>如果将值存储在视图状态中，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，当更新和删除操作已启用，<xref:System.Web.UI.WebControls.LinqDataSource>控制存储在视图状态中的所有记录的原始值。 <xref:System.Web.UI.WebControls.LinqDataSource>控制存储值的所有主键，并且所有属性不都标记为`UpdateCheck.Never`中`Column`属性。 你设置`UpdateCheck`属性`Column`属性中[!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]。  
  
 LINQ to SQL 更新或删除数据之前，它会检查针对数据源中的当前值在视图状态的值。 如果值不匹配，则数据源记录已更改。 在这种情况下，LINQ to SQL 将引发异常和不继续更新或删除操作。 有关 LINQ to SQL 的详细信息，请参阅[LINQ to SQL](http://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655)。  
  
 状态视图中存储的原始值可能会导致的页大小变得不必要地大和可以公开给恶意用户的敏感数据。 你可以禁用通过设置存储视图状态中值<xref:System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState%2A>属性`false`。 如果你这样做，则必须提供您自己的方式，以确保数据未更改。 如果你设置<xref:System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState%2A>属性`false`，原始值不会保留在数据绑定控件的视图状态。 在这种情况下，LINQ to SQL 无法验证数据的完整性。 LINQ to SQL 将引发异常，该值指示数据冲突，即使数据源中的数据实际未更改。  
  
 如果基础数据源包含更新的过程中自动更新的时间戳字段，你可以存储视图状态中的此值。 在这种情况下，实体类中的时间戳属性设置为`IsVersion=true`和所有属性都设置为`UpdateCheck.Never`。 因为每次该记录中的这些数据更改时，数据库自动更新时间戳字段，LINQ to SQL 确定从该值中，如果数据已更改。 这有助于减少视图状态的大小，并且未公开任何敏感数据。 LINQ to SQL 数据库中的时间戳值的状态将通过比较时间戳值视图中检查的数据一致性。 有关详细信息，请参阅[演练： 使用时间戳与 LinqDataSource 控件与检查数据完整性](http://msdn.microsoft.com/library/e7700162-4f05-4130-81f7-3be1361027fa)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.DynamicData.IDynamicDataSource.ContextType">
      <MemberSignature Language="C#" Value="Type System.Web.DynamicData.IDynamicDataSource.ContextType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type System.Web.DynamicData.IDynamicDataSource.ContextType" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.System#Web#DynamicData#IDynamicDataSource#ContextType" />
      <MemberSignature Language="VB.NET" Value=" Property ContextType As Type Implements IDynamicDataSource.ContextType" />
      <MemberSignature Language="C++ CLI" Value="property Type ^ System.Web.DynamicData.IDynamicDataSource.ContextType { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.WebControls.LinqDataSource.System.Web.DynamicData.IDynamicDataSource.ContextType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.ContextType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>有关此成员的说明，请参阅 <see cref="T:System.Web.DynamicData.IDynamicDataSource" />。</summary>
        <value>与类关联的类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Web.UI.WebControls.LinqDataSource> 实例强制转换为 <xref:System.Web.DynamicData.IDynamicDataSource> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.DynamicData.IDynamicDataSource.EntitySetName">
      <MemberSignature Language="C#" Value="string System.Web.DynamicData.IDynamicDataSource.EntitySetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string System.Web.DynamicData.IDynamicDataSource.EntitySetName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.System#Web#DynamicData#IDynamicDataSource#EntitySetName" />
      <MemberSignature Language="VB.NET" Value=" Property EntitySetName As String Implements IDynamicDataSource.EntitySetName" />
      <MemberSignature Language="C++ CLI" Value="property System::String ^ System.Web.DynamicData.IDynamicDataSource.EntitySetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.WebControls.LinqDataSource.System.Web.DynamicData.IDynamicDataSource.EntitySetName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EntitySetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>有关此成员的说明，请参阅 <see cref="T:System.Web.DynamicData.IDynamicDataSource" />。</summary>
        <value>实体的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Web.UI.WebControls.LinqDataSource> 实例强制转换为 <xref:System.Web.DynamicData.IDynamicDataSource> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.DynamicData.IDynamicDataSource.Exception">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.Web.DynamicData.DynamicValidatorEventArgs&gt; System.Web.DynamicData.IDynamicDataSource.Exception;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.DynamicData.DynamicValidatorEventArgs&gt; System.Web.DynamicData.IDynamicDataSource.Exception" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.System#Web#DynamicData#IDynamicDataSource#Exception" />
      <MemberSignature Language="VB.NET" Value="Custom Event Exception As EventHandler(Of DynamicValidatorEventArgs) Implements System.Web.DynamicData.IDynamicDataSource" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Web.DynamicData.IDynamicDataSource.Exception</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.DynamicData.DynamicValidatorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TableName : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.TableName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置数据上下文类中的属性或字段的名称，该数据上下文类表示一个数据集合。</summary>
        <value>包含属性（该属性包含数据集合）名称的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性的属性或表示你想要检索的数据的字段的名称。 当连接到数据库表时，属性的名称通常是表的名称相同。 当连接到内存中的数据集合时，设置<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性的属性或返回数据集合的字段的名称。  
  
 你可以将返回到任何类型的属性分配<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>检索操作的属性。 如果由属性表示的对象不实现<xref:System.Collections.IEnumerable>、<xref:System.Web.UI.WebControls.LinqDataSource>控件将自动包装该对象的实例中<xref:System.Collections.IEnumerable>对象。  
  
 若要启用自动更新、 插入或删除操作，分配给类<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性必须派生自<xref:System.Data.Linq.DataContext>和分配给属性<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性必须派生自<xref:System.Data.Linq.Table%601>。  
  
 有关如何从一个类的实例中选择数据的信息，请参阅<xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A>属性。  
  
   
  
## Examples  
 下面的示例显示了两个<xref:System.Web.UI.WebControls.LinqDataSource>控件。 在一个<xref:System.Web.UI.WebControls.LinqDataSource>控件，<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性设置为类中的属性。 该属性返回字符串的数组。 另一部分中<xref:System.Web.UI.WebControls.LinqDataSource>控件，<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性设置为表示数据库表的属性。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/Default.aspx#2)]  
  
 名为的类`ExampleDataContext`，表示数据库表中不会显示此示例。 对于此示例正常工作，必须创建此类，通过添加一个 LINQ to SQL 类命名的 Example.dbml 并拖动一个表名为拖动到的电影[!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]。 一个名为类`ExampleDataContext`一个属性名为`Movies`生成。  
  
 下面的示例显示名为的类`MovieLibrary`中引用<xref:System.Web.UI.WebControls.LinqDataSource>控件。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/App_Code/MovieLibrary.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/App_Code/MovieLibrary.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Collections.IDictionary keys, System.Collections.IDictionary values, System.Collections.IDictionary oldValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Collections.IDictionary keys, class System.Collections.IDictionary values, class System.Collections.IDictionary oldValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.Update(System.Collections.IDictionary,System.Collections.IDictionary,System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function Update (keys As IDictionary, values As IDictionary, oldValues As IDictionary) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Collections::IDictionary ^ keys, System::Collections::IDictionary ^ values, System::Collections::IDictionary ^ oldValues);" />
      <MemberSignature Language="F#" Value="member this.Update : System.Collections.IDictionary * System.Collections.IDictionary * System.Collections.IDictionary -&gt; int" Usage="linqDataSource.Update (keys, values, oldValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.IDictionary" />
        <Parameter Name="values" Type="System.Collections.IDictionary" />
        <Parameter Name="oldValues" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="keys">要更新的记录的行键值。</param>
        <param name="values">要在数据源中更新的行值。</param>
        <param name="oldValues">为检测数据冲突而计算的行值。</param>
        <summary>执行更新操作。</summary>
        <returns>受更新操作影响的记录数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常情况下，则不需要调用<xref:System.Web.UI.WebControls.LinqDataSource.Update%2A>在代码中的方法。 数据绑定控件将自动调用<xref:System.Web.UI.WebControls.LinqDataSource.Update%2A>如果用户执行操作以更新记录的方法。 显式调用<xref:System.Web.UI.WebControls.LinqDataSource.Update%2A>方法如果你想要创建你自己的过程用于更新数据。  
  
   
  
## Examples  
 下面的示例演示如何以编程方式更新数据源中的记录，用户单击按钮后。 在代码传递<xref:System.Collections.Specialized.ListDictionary>对象，其中包含的密钥值，<xref:System.Collections.Specialized.ListDictionary>对象，其中包含的原始值和<xref:System.Collections.Specialized.ListDictionary>对象，其中包含这些新值与<xref:System.Web.UI.WebControls.LinqDataSource.Update%2A>方法。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Update#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/cs/Default2.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Update#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/vb/Default3.aspx.vb#1)]  
  
 下面的示例演示上一示例的标记。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.Update#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.Update#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/vb/Default3.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Updated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Updated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Updated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Updated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Updated As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Updated;" />
      <MemberSignature Language="F#" Value="member this.Updated : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.Updated : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>完成更新操作后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理<xref:System.Web.UI.WebControls.LinqDataSource.Updated>事件以更新操作从捕获任何异常也可检查的值更新操作完成之后，输出参数。 输出参数均可用从<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>传递给事件处理程序的对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection UpdateParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection UpdateParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.UpdateParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UpdateParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ UpdateParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UpdateParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.UpdateParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 类不使用此集合。</summary>
        <value>参数的集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Updating">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt; Updating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt; Updating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Updating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Updating As EventHandler(Of LinqDataSourceUpdateEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceUpdateEventArgs ^&gt; ^ Updating;" />
      <MemberSignature Language="F#" Value="member this.Updating : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt; " Usage="member this.Updating : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>执行更新操作前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理<xref:System.Web.UI.WebControls.LinqDataSource.Updating>事件，以便验证更新，以检查数据类，若要更改的值早更新操作，或取消更新操作中的数据验证错误的对象。 <xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs>传递给事件处理程序的对象包含对原始对象和更新的对象。  
  
 如果更新操作期间发生验证错误<xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs>对象包含由数据类引发验证异常。 如果要更新的值与在数据类中，属性的类型不匹配或未通过自定义的验证检查，将发生验证错误。 中的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Updating>事件，您可以检索验证异常，并采取相应的操作。  
  
 如果在事件处理程序中引发异常<xref:System.Web.UI.WebControls.LinqDataSource.Updating>事件，你必须处理该事件处理程序中的异常。 此异常不会传递到事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Updated>事件 (通过<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>对象)。 <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性包含仅后引发的异常<xref:System.Web.UI.WebControls.LinqDataSource.Updating>事件。  
  
   
  
## Examples  
 下面的示例演示的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Updating>事件。 代码将从属性进行比较<xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs.OriginalObject%2A>属性和<xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs.NewObject%2A>属性以查看是否已更改一个值。 如果值已更改，值为<xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs.NewObject%2A>属性设置为`true`。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Updating#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Updating/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Updating#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Updating/vb/Default.aspx.vb#1)]  
  
 下面的示例演示的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Updating>检索验证异常的事件。  
  
```vb  
Protected Sub LinqDataSource_Updating(ByVal sender As Object, _  
        ByVal e As LinqDataSourceUpdateEventArgs)  
    If (e.Exception IsNot Nothing) Then  
        For Each innerException As KeyValuePair(Of String, Exception) _  
               In e.Exception.InnerExceptions  
            Label1.Text &= innerException.Key & ": " & _  
                innerException.Value.Message & "<br />"  
        Next  
        e.ExceptionHandled = True  
    End If  
End Sub  
```  
  
```csharp  
protected void LinqDataSource_Updating(object sender,   
        LinqDataSourceUpdateEventArgs e)  
{  
    if (e.Exception != null)  
    {  
        foreach (KeyValuePair<string, Exception> innerException in   
             e.Exception.InnerExceptions)  
        {  
        Label1.Text += innerException.Key + ": " +   
            innerException.Value.Message + "<br />";  
        }  
        e.ExceptionHandled = true;  
    }  
}  
```  
  
 前面的示例检索验证异常。 如果值与属性的类型不匹配，则可能引发异常。 它还可能如以下示例中的自定义检查从引发。 `OnAgeChanging`方法检查的数量`Age`属性不是负数。  
  
```csharp  
partial void  OnAgeChanging(int? value)  
{  
    if (value < 0)  
    {  
        throw new Exception("Age cannot be a negative number.");  
    }  
}  
```  
  
```vb  
Private Sub OnAgeChanging(ByVal value As System.Nullable(Of Integer))  
    If (value < 0) Then  
        Throw New Exception("Age cannot be a negative number.")  
    End If  
End Sub  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Where">
      <MemberSignature Language="C#" Value="public string Where { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Where" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.Where" />
      <MemberSignature Language="VB.NET" Value="Public Property Where As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Where { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Where : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.Where" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.Where</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定要将记录包含在检索到的数据中必须为真的条件。</summary>
        <value>用于创建 Where 子句的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你使用<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性来指定要从查询返回的记录的条件。 语法<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性是与 C# 中的 LINQ Where 子句的语法相同。  
  
 指定一个表达式，结果为布尔值，如果表达式计算结果为`true`对于给定的行，该行包含在结果集中。 表达式的列名称、 比较运算符和值进行比较，由组成，如下面的示例中所示：  
  
```  
<asp:LinqDataSource ... Where="Price > 50"...>  
```  
  
 若要指定多个链接的逻辑的表达式`AND`或`OR`运算符，你将使用`&&`作为一个逻辑 AND 运算符和`||`作为逻辑 OR 运算符，如下面的示例中所示：  
  
```  
<asp:LinqDataSource ... Where="Price > 50 && Price < 100"...>  
<asp:LinqDataSource ... Where="Price <= 50 || Price >= 100"...>  
```  
  
 如果你想要测试针对一个文字字符串值的属性，则文本的字符串值必须括在双引号内。 若要执行此操作在标记中，请将<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>子句值单引号引起来，如下面的示例中所示：  
  
```  
<asp:LinqDataSource ... Where='Category = "Sports"' ... >  
```  
  
 要测试的代码中的文本字符串值，使用适用于你为了插入双引号括起来，如下面的示例中所示正在使用的语言的转义字符：  
  
```vb  
LinqDataSource1.Where = "Category = ""Sports"""  
```  
  
```csharp  
LinqDataSource1.Where = "Category = \"Sports\"";  
```  
  
 如果你想要测试字符串是否大于或小于另一个字符串，则必须使用的方法<xref:System.String>类而不是使用`<`或`>`之间的列名称和字符串值的运算符。 下面的示例演示如何选择具有小于，小于或等于的类别值的行大于，或大于或等于"体育":  
  
```  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") < 0' ... >  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") <= 0' ... >  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") > 0' ... >  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") >= 0' ... >  
```  
  
 你还可以使用的其他方法<xref:System.String>类，如<xref:System.String.StartsWith%2A>， <xref:System.String.EndsWith%2A>，和<xref:System.String.Contains%2A>。 有关如何比较字符串的详细信息，请参阅[比较字符串](~/docs/standard/base-types/comparing.md)。 有关 Where 子句语法，请参阅[C# 运算符](http://msdn.microsoft.com/library/0301e31f-22ad-49af-ac3c-d5eae7f0ac43)和[其中子句](~/docs/csharp/language-reference/keywords/where-clause.md)。  
  
 还可以筛选基于你定义当创建 Web 页的静态值，您可以筛选在运行时计算的基于动态值。 在这种情况下，包括在一个命名的参数<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>用作一个占位符的值的属性。 然后添加具有匹配名称的参数<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合。  
  
 或者，您可以设置<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>属性`true`和定义中的参数<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合。 当<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>属性是`true`，则不需要包括中的命名的参数<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性。 相反，<xref:System.Web.UI.WebControls.LinqDataSource>控件自动生成 Where 子句中的参数从<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>属性。  
  
 有关如何对筛选器数据的详细信息，请参阅[演练： 选择和筛选数据子集具有 LinqDataSource 和 GridView 控件](http://msdn.microsoft.com/library/c1cca3e8-86e4-4e69-a29f-1c05b91f2205)。  
  
   
  
## Examples  
 下面的示例演示如何筛选从根据静态条件对查询返回的数据。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default5.aspx#5)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default5.aspx#5)]  
  
 下面的示例演示如何筛选基于由用户在运行时提供的值的数据。 在此示例中<xref:System.Web.UI.WebControls.DropDownList>控件和<xref:System.Web.UI.WebControls.GridView>页上显示控件。 当用户选择中的值之一<xref:System.Web.UI.WebControls.DropDownList>控件，<xref:System.Web.UI.WebControls.LinqDataSource>控件选择从`Products`表具有的行`UserPrice`值等于所选值。 <xref:System.Web.UI.WebControls.GridView>控件然后显示筛选后的数据。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default6.aspx#6)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default6.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WhereParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection WhereParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection WhereParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.WhereParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WhereParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ WhereParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WhereParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.WhereParameters" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.WhereParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于创建 Where 子句的参数集合。</summary>
        <value>用于创建 <see cref="P:System.Web.UI.WebControls.LinqDataSource.Where" /> 属性中 Where 子句的参数的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件使用中的参数<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合中创建 Where 子句在运行时。 你将参数添加到<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合，当你想要以编程方式将一个或多个条件设置在 Where 子句。 例如，您可能在其中搜索姓氏等于的值的记录的数据库表<xref:System.Web.UI.WebControls.TextBox>控件。 在这种情况下，你将参数添加到<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>第文本框的值的集合。  
  
 如果不需要在运行时设置一个值，在 Where 子句，则不需要使用<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合。 你可以定义的字段中检索<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性。 例如，若要从数据库表中返回其中`LastName`等于"Adams"在标记中，设置<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性`'LastName = "Adams"'`不带任何参数。  
  
 在中设置值<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合，将名称分配给每个参数并将中的占位符<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>为该参数的属性。 在 Where 子句中，在与每个参数名之前 @ 符号。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合动态创建 Where 子句。 <xref:System.Web.UI.WebControls.LinqDataSource>控制权将返回中的值的所有记录`Price`大于中的用户选择的值的列<xref:System.Web.UI.WebControls.DropDownList>控件。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default6.aspx#6)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default6.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>