<Type Name="LinqDataSource" FullName="System.Web.UI.WebControls.LinqDataSource">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7806dfca4e32e99c40ed18a7e3648eca3e1119d6" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="58875172" /></Metadata><TypeSignature Language="C#" Value="public class LinqDataSource : System.Web.UI.WebControls.ContextDataSource, System.Web.DynamicData.IDynamicDataSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit LinqDataSource extends System.Web.UI.WebControls.ContextDataSource implements class System.Web.DynamicData.IDynamicDataSource, class System.Web.UI.IDataSource" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.LinqDataSource" />
  <TypeSignature Language="VB.NET" Value="Public Class LinqDataSource&#xA;Inherits ContextDataSource&#xA;Implements IDynamicDataSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class LinqDataSource : System::Web::UI::WebControls::ContextDataSource, System::Web::DynamicData::IDynamicDataSource" />
  <TypeSignature Language="F#" Value="type LinqDataSource = class&#xA;    inherit ContextDataSource&#xA;    interface IDynamicDataSource&#xA;    interface IDataSource" />
  <AssemblyInfo>
    <AssemblyName>System.Web.Extensions</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.WebControls.ContextDataSource</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-3.5">System.Web.UI.DataSourceControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.DynamicData.IDynamicDataSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IDataSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Selecting")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("ContextTypeName")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.LinqDataSourceDesigner, System.Web.Extensions.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Drawing.ToolboxBitmap(typeof(System.Web.UI.WebControls.LinqDataSource), "LinqDataSource.bmp")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.LinqDataSourceDesigner, System.Web.Extensions.Design, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Web.Extensions, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35", System.ComponentModel.ToolboxItemFilterType.Require)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.Drawing.ToolboxBitmap(typeof(System.Web.UI.WebControls.LinqDataSource), "LinqDataSource.ico")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>支持通过标记文本在 ASP.NET 网页中使用语言集成查询 (LINQ)，以从数据对象中检索和修改数据。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本主题内容：  
  
-   [介绍](#introduction)  
  
-   [操作顺序](#order_of_operations)  
  
-   [对数据进行排序](#ordering_data)  
  
-   [数据分组](#grouping_data)  
  
-   [数据修改](#data_modifications)  
  
-   [在运行时计算值](#evaluating_value_at_run_time)  
  
-   [使用存储过程](#working_with_stored_procedures)  
  
-   [声明性语法](#declarative_syntax)  
  
<a name="introduction"></a>   
## <a name="introduction"></a>介绍  
 语言集成查询 (LINQ) 是用于定义一组启用以在任何声明性方式表示遍历、 筛选和投影操作的查询运算符的查询语法。基于 NET 的编程语言。 数据对象可以是内存中数据集合或表示数据库中的数据的对象。 可以检索或修改数据而无需编写每个操作的 SQL 命令。  
  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件可在 ASP.NET 网页中使用 LINQ，通过标记文本中设置属性。 <xref:System.Web.UI.WebControls.LinqDataSource>控件使用 LINQ to SQL 来自动生成的数据命令。 有关 LINQ to SQL 的详细信息，请参阅[LINQ to SQL](https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655)。  
  
 当从内存中的数据集合检索数据时，您将设置<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性设置为包含数据集合的类。 您设置<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性设置为属性或字段的返回数据集合。 例如，可能有一个名为类`Person`，其中包含一个名为属性`FavoriteCities`返回一个字符串值数组。 在这种情况下，设置<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性设置为`Person`并设置<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性设置为`FavoriteCities`。  
  
 在所查询的数据库，必须首先创建表示数据库及其中的表的实体类。 可以使用[!INCLUDE[vs_ordesigner_long](~/includes/vs-ordesigner-long-md.md)]或 SqlMetal.exe 实用工具来生成这些类。 然后设置<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性设置为表示数据库的类并设置<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性设置为表示数据库表的属性。  
  
<a name="order_of_operations"></a>   
## <a name="order-of-operations"></a>操作顺序  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件应用数据按以下顺序操作：  
  
1.  其中 （指定要返回的数据的记录）。  
  
2.  Order By （排序）。  
  
3.  Group By （共享的值的聚合数据记录）。  
  
4.  Order By （排序分组数据） 的组。  
  
5.  选择 （指定哪些字段或属性返回）。  
  
6.  自动排序 （按用户所选的属性排序数据记录）。  
  
7.  自动页 （检索用户已选择的数据记录的子集）。  
  
 您可以将条件添加到<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性筛选从查询返回的数据记录。 如果<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>未设置属性，<xref:System.Web.UI.WebControls.LinqDataSource>控件检索此数据对象中的每个记录。  
  
<a name="ordering_data"></a>   
## <a name="ordering-data"></a>对数据进行排序  
 您使用<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性来指定从返回的数据要作为排序依据的属性的名称。  
  
> [!NOTE]
>  当你使用<xref:System.Web.UI.WebControls.LinqDataSource>控件，其[!INCLUDE[ss2k](~/includes/ss2k-md.md)]或[!INCLUDE[ssEW](~/includes/ssew-md.md)]并且<xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A>属性设置为`true`，必须提供中的值<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性。 默认情况下<xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A>属性是`true`。 如果你将值赋给<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性，您还必须包括所有标识列在查询中返回的属性列表中。  
  
<a name="grouping_data"></a>   
## <a name="grouping-data"></a>数据分组  
 您使用<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性来指定哪些属性用于合并具有相同的值的数据记录。 当分组数据时，可以包括`Key`并`It`，它们动态创建中的属性，<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 `Key`属性是指用来对数据进行分组的一个或多个属性中的值。 例如，如果按属性名为分组`Category`，则`Key`属性将包含中的所有唯一值`Category`属性。 `It`属性是指一系列中的数据分组的单个记录。 您可以循环访问`It`属性来检索已合并，在分组操作中的单个记录。 例如，如果按属性名为分组`Category`，则`It`属性包含所有共享一个公共值中的单个记录`Category`属性。  
  
 您使用<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性来指定要使用的分组的数据进行排序的属性。 当分组数据，<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性指定分组的数据中各记录的排序方式。  
  
 默认情况下，<xref:System.Web.UI.WebControls.LinqDataSource>控件从一个数据对象中检索的所有属性的值。 您使用<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性来指定要返回如果想要使用的子集可用属性的属性。 选择操作应用之后 Where、 Order By 和 Group By 操作。 因此，如果 Select 子句中创建了别名，别名不可用在其他子句中。  
  
<a name="data_modifications"></a>   
## <a name="data-modifications"></a>数据修改  
 您可以指定是否使用启用数据修改<xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A>， <xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A>，和<xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A>属性。 修改数据的用户界面<xref:System.Web.UI.WebControls.LinqDataSource>控件通常提供通过数据绑定控件，如<xref:System.Web.UI.WebControls.DetailsView>控件。 除了设置之外<xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A>， <xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A>，或<xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A>到`true`，启用自动数据修改所需满足以下条件：  
  
-   <xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>不能将属性分配一个值。  
  
-   <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>不能将属性分配一个值。  
  
-   分配给的类<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性必须派生自<xref:System.Data.Linq.DataContext>。  
  
-   分配给属性<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性必须派生自<xref:System.Data.Linq.Table%601>。  
  
 你可以限制在两种方法中的数据绑定控件中显示的属性。 你可以设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性的子集属性，或者你可以通过添加定义的字段的数据绑定控件<xref:System.Web.UI.WebControls.DataControlField>控件。 但是，如果您设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性，这意味着，不能启用自动更新、 插入和删除操作。 如果你想要使用的可用属性的子集时启用自动数据修改，未设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 相反，此数据对象中检索的所有属性和管理通过使用数据绑定控件所显示。 当你使用<xref:System.Web.UI.WebControls.DetailsView>控件或<xref:System.Web.UI.WebControls.GridView>控件，则还必须设置<xref:System.Web.UI.WebControls.DetailsView.AutoGenerateRows%2A>或<xref:System.Web.UI.WebControls.GridView.AutoGenerateColumns%2A>属性设置为`false`。 这会阻止数据绑定控件自动包括用于编辑和删除数据的按钮。 不会显示在数据绑定控件的任何值存储在视图状态。 它们不变时传递给数据源执行数据更新。  
  
<a name="evaluating_value_at_run_time"></a>   
## <a name="evaluating-values-at-run-time"></a>在运行时计算值  
 如果需要在运行时进行排序，评估值筛选，或者对值进行分组，您可以将参数添加到<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>， <xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>， <xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A>，或<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合。  
  
 如果你想要指定默认值，您可以将参数添加到<xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A>集合。  
  
 如果你想要检查或修改值，然后执行数据操作，则可以处理<xref:System.Web.UI.WebControls.LinqDataSource.Deleting>， <xref:System.Web.UI.WebControls.LinqDataSource.Inserting>， <xref:System.Web.UI.WebControls.LinqDataSource.Selecting>，或<xref:System.Web.UI.WebControls.LinqDataSource.Updating>事件。 此外可以处理这些事件，以便取消数据操作或发生时根据用户输入的数据类中设置属性的验证错误。  
  
 若要完成数据操作后，请检查值，处理<xref:System.Web.UI.WebControls.LinqDataSource.Deleted>， <xref:System.Web.UI.WebControls.LinqDataSource.Inserted>， <xref:System.Web.UI.WebControls.LinqDataSource.Selected>，或<xref:System.Web.UI.WebControls.LinqDataSource.Updated>事件。  
  
<a name="working_with_stored_procedures"></a>   
## <a name="working-with-stored-procedures"></a>使用存储过程  
 您使用<xref:System.Web.UI.WebControls.LinqDataSource>要从存储过程检索数据，通过创建的事件处理程序控件<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件。 在事件处理程序，您在数据上下文类表示存储的过程中调用该方法并将结果设置为<xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A>属性的<xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs>对象。 如果想要启用自动更新、 插入和删除操作的数据，从方法返回的类型必须匹配在指定的类型<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性。 有关创建数据上下文方法的详细信息，请参阅[如何：创建映射到存储过程和函数的 DataContext 方法（O/R 设计器）](https://msdn.microsoft.com/library/e7ca32f1-50b3-48af-ad92-ceafd749296a)。  
  
<a name="declarative_syntax"></a>   
## <a name="declarative-syntax"></a>声明性语法  
  
```  
<asp:LinqDataSource  
    AutoGenerateOrderByClause="True|False"  
    AutoGenerateWhereClause="True|False"  
    AutoPage="True|False"  
    AutoSort="True|False"  
    ContextTypeName="string"  
    EnableDelete="True|False"  
    EnableInsert="True|False"  
    EnableTheming="True|False"  
    EnableUpdate="True|False"  
    EnableViewState="True|False"  
    GroupBy="string"  
    ID="string"  
    OnContextCreated="ContextCreated event handler"  
    OnContextCreating="ContextCreating event handler"  
    OnContextDisposing="ContextDisposing event handler"  
    OnDataBinding="DataBinding event handler"  
    OnDeleted="Deleted event handler"  
    OnDeleting="Deleting event handler"  
    OnDisposed="Disposed event handler"  
    OnInit="Init event handler"  
    OnInserted="Inserted event handler"  
    OnInserting="Inserting event handler"  
    OnLoad="Load event handler"  
    OnPreRender="PreRender event handler"  
    OnSelected="Selected event handler"  
    OnSelecting="Selecting event handler"  
    OnUnload="Unload event handler"  
    OnUpdated="Updated event handler"  
    OnUpdating="Updating event handler"  
    OrderBy="string"  
    runat="server"  
    Select="string"  
    SkinID="string"  
    StoreOriginalValuesInViewState="True|False"  
    TableName="string"  
    Visible="True|False"  
    Where="string"  
>  
        <GroupByParameters />  
        <InsertParameters />  
        <OrderByParameters />  
        <SelectParameters />  
        <WhereParameters />  
</asp:LinqDataSource>  
```  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>从一个名为的实体类中检索数据的控件`Products`。 实体类可通过使用生成[!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]或 SqlMetal.exe 实用程序。 <xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性设置为返回中具有值的记录`Price`属性大于 50。 一个<xref:System.Web.UI.WebControls.GridView>控件绑定到<xref:System.Web.UI.WebControls.LinqDataSource>控件来显示数据。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default5.aspx#5)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default5.aspx#5)]  
  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>控件，使用户能够更新、 删除和数据源中插入记录。 一个<xref:System.Web.UI.WebControls.DetailsView>控件绑定到<xref:System.Web.UI.WebControls.LinqDataSource>控件，从而使用户能够查看和修改数据。 请注意，任何 SQL 命令才能选择、 更新、 删除或插入记录。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 下面的示例演示的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>设置的数据对象的事件基于在网页中的值。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/cs/Default3.aspx.cs#3)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/vb/Default3.aspx.vb#3)]  
  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>控制，它是由两个列配置为组。 `Key`属性引用具有两个属性的对象`ProductCategory`和`Color`。 所表示的对象`It`是已重命名 （别名） `Products`。 重命名`Products`对象包含分组中各记录的集合。 每个实例将包含中的所有列`Products`表。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#1)]  
  
 下面的示例演示两个<xref:System.Web.UI.WebControls.ListView>显示从数据的控件<xref:System.Web.UI.WebControls.LinqDataSource>上一示例中的控件。 一个<xref:System.Web.UI.WebControls.ListView>控件显示分组的数据，以及其他<xref:System.Web.UI.WebControls.ListView>控件显示各个属于该组的产品名称。 嵌套的数据绑定控件<xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A>属性设置为`Products`，这是别名`It`对象。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#2)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655">LINQ to SQL</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LinqDataSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LinqDataSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoGenerateOrderByClause">
      <MemberSignature Language="C#" Value="public bool AutoGenerateOrderByClause { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoGenerateOrderByClause" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoGenerateOrderByClause As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoGenerateOrderByClause { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoGenerateOrderByClause : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件是否根据 <see cref="P:System.Web.UI.WebControls.LinqDataSource.OrderByParameters" /> 集合中的值动态创建 Order By 子句。</summary>
        <value><see langword="true" /> 如果<see cref="T:System.Web.UI.WebControls.LinqDataSource" />控件创建 Order By 子句; 否则为<see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当您将设置<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>属性设置为`true`，则<xref:System.Web.UI.WebControls.LinqDataSource>控件动态创建 Order By 子句中的值为基础的<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合。 <xref:System.Web.UI.WebControls.LinqDataSource>控制对数据进行排序的第一个参数和每个其他参数的数据，此外进行排序。 包含参数`null`或 Order By 子句中不包含空值。  
  
 未设置<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性时<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>设置为`true`，因为分析器可动态创建 Order By 子句。 <xref:System.Web.UI.WebControls.LinqDataSource>控件将引发异常，如果<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>设置为`true`和<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性分配值。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>控件，其<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>设置为`true`。 参数包含在<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>基于属性的数据命名的用户进行排序的集合选择从<xref:System.Web.UI.WebControls.DropDownList>控件。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default8.aspx#8)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default8.aspx#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoGenerateWhereClause">
      <MemberSignature Language="C#" Value="public bool AutoGenerateWhereClause { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoGenerateWhereClause" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoGenerateWhereClause As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoGenerateWhereClause { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoGenerateWhereClause : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.AutoGenerateWhereClause</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件是否基于 <see cref="P:System.Web.UI.WebControls.LinqDataSource.WhereParameters" /> 集合中定义的值来动态创建 Where 子句。</summary>
        <value>如果 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件将创建 Where 子句，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当您将设置<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>属性设置为`true`，则<xref:System.Web.UI.WebControls.LinqDataSource>控件动态创建 Where 子句中的参数从<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合。 将添加到每个参数<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合必须具有其<xref:System.Web.UI.WebControls.Parameter.Name%2A>属性设置为匹配正被查询的数据对象中的属性的值。 自动生成 Where 子句将检查是否在指定的值<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合与数据对象中的匹配属性的值相等。 如果提供多个参数，则这些参数将与逻辑`AND`操作。 包含参数`null`或空值不包含在 Where 子句。  
  
 自动生成<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>子句可以仅测试相等性和链接参数只能与`AND`操作。 未设置<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>属性设置为`true`如果您需要添加一个条件，不会测试是否相等或如果有相关联的参数`OR`操作。 可以通过设置完成这些任务<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>属性设置为`false`并添加中的占位符<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性中每个参数<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合。 在<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性，与每个占位符名称的前面加上 @ 符号。  
  
 未设置<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性时<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>属性是`true`，因为分析器可动态创建 Where 子句。 <xref:System.Web.UI.WebControls.LinqDataSource>控件将引发异常，如果<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>属性是`true`和<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性分配值。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>控件，其<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>设置为`true`。 一个<xref:System.Web.UI.WebControls.GridView>控件绑定到<xref:System.Web.UI.WebControls.LinqDataSource>控件来显示从查询返回的数据。 一个<xref:System.Web.UI.WebControls.DropDownList>控件是，它是包含三个值填充。 参数包含在<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合中的具有名称设置为`Category,`与数据对象的属性之一匹配。 其<xref:System.Web.UI.WebControls.ControlParameter.ControlID%2A>属性设置为的 ID<xref:System.Web.UI.WebControls.DropDownList>控件。 <xref:System.Web.UI.WebControls.LinqDataSource>控件将自动创建<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性设置为筛选器记录基于用户从选择的值<xref:System.Web.UI.WebControls.DropDownList>控件。 查询返回的记录其`Category`属性与用户从所选的值匹配<xref:System.Web.UI.WebControls.DropDownList>控件。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default7.aspx#7)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default7.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoPage">
      <MemberSignature Language="C#" Value="public bool AutoPage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoPage" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoPage As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoPage { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoPage : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.AutoPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件是否支持在运行时在数据的各部分之间导航。</summary>
        <value>如果用户可以对数据进行分页，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A>属性设置为`true`若要在中启用分页<xref:System.Web.UI.WebControls.LinqDataSource>控件。 若要使用户能够对数据进行分页，连接提供用于对分页的接口的数据绑定控件<xref:System.Web.UI.WebControls.LinqDataSource>控件。 当<xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A>属性设置为`true`，则<xref:System.Web.UI.WebControls.LinqDataSource>控件所检索仅足够的数据绑定控件中的一页的记录。 它使用<xref:System.Linq.Enumerable.Skip%2A>和<xref:System.Linq.Enumerable.Take%2A>方法来检索当前页的记录。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>控件，其<xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A>属性设置为`true`和一个<xref:System.Web.UI.WebControls.GridView>绑定到控件<xref:System.Web.UI.WebControls.LinqDataSource>控件。 <xref:System.Web.UI.WebControls.GridView.AllowPaging%2A>的属性<xref:System.Web.UI.WebControls.GridView>控件设置为`true`提供界面，允许用户数据进行分页。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSort">
      <MemberSignature Language="C#" Value="public bool AutoSort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSort" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.AutoSort" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoSort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoSort { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSort : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.AutoSort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件是否支持在运行时对数据进行排序。</summary>
        <value>如果用户可以对数据进行排序，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件支持两种方法用于对数据进行排序。 可以使用<xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A>属性来启用运行时排序，或者设置<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性来定义在设计时的排序。  
  
 设置<xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A>属性设置为`true`中启用排序<xref:System.Web.UI.WebControls.LinqDataSource>基于从数据绑定控件的排序表达式的控件。 数据绑定控件提供的接口，使用户能够在运行时选择要用于排序的属性。  
  
 你可以以编程方式设置通过设置返回数据的顺序<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性设置为属性或用于排序的属性。 当<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性设置为一个属性和<xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A>属性是`true`，从数据绑定控件的排序表达式中的表达式之后应用<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性。 因此，这将确定数据的最终排序。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>控件，其<xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A>属性设置为`true`和一个<xref:System.Web.UI.WebControls.GridView>绑定到控件<xref:System.Web.UI.WebControls.LinqDataSource>控件。 <xref:System.Web.UI.WebControls.GridView.AllowSorting%2A>的属性<xref:System.Web.UI.WebControls.GridView>控件设置为`true`提供界面，允许用户对数据进行排序。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextCreated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; ContextCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; ContextCreated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.ContextCreated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextCreated As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ ContextCreated;" />
      <MemberSignature Language="F#" Value="member this.ContextCreated : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.ContextCreated : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在创建上下文类型对象实例后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理<xref:System.Web.UI.WebControls.LinqDataSource.ContextCreated>事件，以便检查的上下文类型对象或检查时，创建对象时引发的异常。 检索上下文类型对象从<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A>属性的<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>与此事件相关联的对象。 检索的数据操作过程中引发的异常<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性。  
  
 上下文类型对象选择、 更新、 插入和删除操作过程中创建，并且在整个请求重复使用。  
  
 还有一次时不引发该事件。 这是以编程方式设置<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A>属性设置为对象期间<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件。 附加条件是，原始值不需要存储在视图状态或中的对象<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A>属性实现<xref:System.Data.Linq.ITable>接口。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextCreating">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt; ContextCreating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt; ContextCreating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.ContextCreating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextCreating As EventHandler(Of LinqDataSourceContextEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceContextEventArgs ^&gt; ^ ContextCreating;" />
      <MemberSignature Language="F#" Value="member this.ContextCreating : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt; " Usage="member this.ContextCreating : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceContextEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在创建上下文类型对象实例前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Web.UI.WebControls.LinqDataSource>控件创建中指定类型的实例<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性。 <xref:System.Web.UI.WebControls.LinqDataSource>控件调用要创建的对象的实例的数据上下文对象的默认构造函数。 原因可能是您必须使用非默认构造函数，或者您必须创建不同的对象中指定从<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性。 在这种情况下，必须处理<xref:System.Web.UI.WebControls.LinqDataSource.ContextCreating>事件和手动创建数据上下文对象。  
  
 选择、 更新、 插入和删除操作期间会创建上下文类型对象。  
  
 还有一次时不引发该事件。 这是以编程方式设置<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A>中的事件处理程序的对象的属性<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件。 附加条件是，原始值不需要存储在视图状态或中的对象<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Result%2A>属性实现<xref:System.Data.Linq.ITable>接口。  
  
   
  
## Examples  
 下面的示例演示如何使用期间的非默认构造函数创建的数据上下文对象<xref:System.Web.UI.WebControls.LinqDataSource.ContextCreating>事件。 该代码将分配到的对象<xref:System.Web.UI.WebControls.LinqDataSourceContextEventArgs.ObjectInstance%2A>属性。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.ContextCreating#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.ContextCreating/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.ContextCreating#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.ContextCreating/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextDisposing">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt; ContextDisposing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt; ContextDisposing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.ContextDisposing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextDisposing As EventHandler(Of LinqDataSourceDisposeEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceDisposeEventArgs ^&gt; ^ ContextDisposing;" />
      <MemberSignature Language="F#" Value="member this.ContextDisposing : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt; " Usage="member this.ContextDisposing : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDisposeEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在释放上下文类型对象前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您处理<xref:System.Web.UI.WebControls.LinqDataSource.ContextDisposing>事件以手动释放对象或执行清理该对象被销毁前的特定于该对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextTypeName">
      <MemberSignature Language="C#" Value="public override string ContextTypeName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContextTypeName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.ContextTypeName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContextTypeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContextTypeName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextTypeName : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.ContextTypeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置包含属性（其值包含要检索的数据）的类型的名称。</summary>
        <value>要从中检索数据的类的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你使用<xref:System.Web.UI.WebControls.LinqDataSource>控件从内存中数据集合或数据库检索数据，则必须指定两个属性。 第一个是表示数据源的数据上下文类。 第二个是中包含的数据的数据上下文类的属性。 您设置<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性设置为数据上下文类的名称设<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性设置为包含数据的数据集合。  
  
 例如，当从数据库检索数据，设置<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性设置为表示数据库的类的名称。 此外设置<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性设置为表示数据库中的表的属性。 若要从数据库中生成类，使用[!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]或 SqlMetal.exe 实用工具来自动生成这些类。  
  
 当从内存中的数据集合 （如数组） 中检索数据时，设置<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性设置为包含数组属性的类的名称。 然后设置<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性设置为用于获取数组的属性。  
  
 若要启用自动更新、 插入或删除操作通过<xref:System.Web.UI.WebControls.LinqDataSource>控制分配给的类<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性必须派生自<xref:System.Data.Linq.DataContext>。 此外，此属性分配给<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性必须派生自<xref:System.Data.Linq.Table%601>。 如果您不需要以启用自动更新、 插入，或者删除操作，则可以分配的任何类型的类名称<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性。  
  
 有关如何从一个类的实例中选择数据的信息，请参阅<xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A>属性。  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性设置为包含一个字符串数组的类。 它还演示如何将属性设置为一个类 (由生成[!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]) 表示的数据库。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/Default.aspx#2)]  
  
 名为的类`ExampleDataContext`，表示数据库表不显示在此示例中。 对于此示例正常工作，必须创建此类，通过添加一个命名的 Example.dbml 和将表名为到电影的 LINQ To SQL 类[!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]。 名为的类`ExampleDataContext`一个属性名为`Movies`生成。  
  
 下面的示例演示名为的类`MovieLibrary`中引用<xref:System.Web.UI.WebControls.LinqDataSource>控件。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/App_Code/MovieLibrary.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/App_Code/MovieLibrary.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655">LINQ to SQL</related>
      </Docs>
    </Member>
    <Member MemberName="CreateQueryableView">
      <MemberSignature Language="C#" Value="protected override System.Web.UI.WebControls.QueryableDataSourceView CreateQueryableView ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.WebControls.QueryableDataSourceView CreateQueryableView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.CreateQueryableView" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateQueryableView () As QueryableDataSourceView" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::WebControls::QueryableDataSourceView ^ CreateQueryableView();" />
      <MemberSignature Language="F#" Value="override this.CreateQueryableView : unit -&gt; System.Web.UI.WebControls.QueryableDataSourceView" Usage="linqDataSource.CreateQueryableView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.QueryableDataSourceView</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回可查询的视图。</summary>
        <returns>可查询的视图。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateView">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.LinqDataSourceView CreateView ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.LinqDataSourceView CreateView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.CreateView" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateView () As LinqDataSourceView" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::LinqDataSourceView ^ CreateView();" />
      <MemberSignature Language="F#" Value="abstract member CreateView : unit -&gt; System.Web.UI.WebControls.LinqDataSourceView&#xA;override this.CreateView : unit -&gt; System.Web.UI.WebControls.LinqDataSourceView" Usage="linqDataSource.CreateView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.LinqDataSourceView</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建与此控件相关联的 <see cref="T:System.Web.UI.WebControls.LinqDataSourceView" /> 类的新实例。</summary>
        <returns>充当数据绑定控件的接口的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要提供自定义视图，可以重写此方法在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public int Delete (System.Collections.IDictionary keys, System.Collections.IDictionary oldValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Delete(class System.Collections.IDictionary keys, class System.Collections.IDictionary oldValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.Delete(System.Collections.IDictionary,System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function Delete (keys As IDictionary, oldValues As IDictionary) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Delete(System::Collections::IDictionary ^ keys, System::Collections::IDictionary ^ oldValues);" />
      <MemberSignature Language="F#" Value="member this.Delete : System.Collections.IDictionary * System.Collections.IDictionary -&gt; int" Usage="linqDataSource.Delete (keys, oldValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.IDictionary" />
        <Parameter Name="oldValues" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="keys">要删除的记录的行键值。</param>
        <param name="oldValues">为检测数据冲突而计算的行值。</param>
        <summary>执行删除操作。</summary>
        <returns>受删除操作影响的记录数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常情况下，不需要调用<xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A>从您的代码的方法。 当你使用<xref:System.Web.UI.WebControls.LinqDataSource>与数据绑定控件，数据绑定控件的控件将自动调用<xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A>方法时用户采取操作以删除一条记录。 显式调用<xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A>方法时您想要创建您自己的进程用于删除数据。 例如，可以调用<xref:System.Web.UI.WebControls.LinqDataSource.Delete%2A>方法，当你想要删除的记录时根据之外的数据绑定控件的事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Deleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.Deleted : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>完成删除操作后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理<xref:System.Web.UI.WebControls.LinqDataSource.Deleted>事件来捕获删除操作，从任何异常，也可后在操作完成后检查输出参数。 可以检索输出参数从<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>传递给事件处理程序对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection DeleteParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection DeleteParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.DeleteParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeleteParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ DeleteParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeleteParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.DeleteParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 类不使用此属性。</summary>
        <value>参数的集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Deleting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt; Deleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt; Deleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Deleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleting As EventHandler(Of LinqDataSourceDeleteEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceDeleteEventArgs ^&gt; ^ Deleting;" />
      <MemberSignature Language="F#" Value="member this.Deleting : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt; " Usage="member this.Deleting : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>执行删除操作前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理<xref:System.Web.UI.WebControls.LinqDataSource.Deleting>事件，以便验证要删除，以检查数据类，以更改前删除操作，值还是取消删除操作中的数据验证错误的对象。 <xref:System.Web.UI.WebControls.LinqDataSource>控制将传递<xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs>向事件处理程序对象<xref:System.Web.UI.WebControls.LinqDataSource.Deleting>事件。 <xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs>对象包含的数据将被删除并使您可以取消删除操作。 如果数据类将引发<xref:System.Web.UI.WebControls.LinqDataSourceValidationException>异常，<xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs>对象包含在该异常<xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs.Exception%2A>属性。  
  
 如果事件处理程序中引发异常<xref:System.Web.UI.WebControls.LinqDataSource.Deleting>事件，必须处理该事件处理程序中的异常。 此异常不会传递到的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Deleted>事件 (通过<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性的<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>对象)。 <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性包含后引发的异常<xref:System.Web.UI.WebControls.LinqDataSource.Deleting>事件。  
  
   
  
## Examples  
 下面的示例演示的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Deleting>事件。 该代码取消删除操作中的属性上基于<xref:System.Web.UI.WebControls.LinqDataSourceDeleteEventArgs.OriginalObject%2A>属性和值从 Web 页。 在示例中，当`OnSale`属性设置为`true`，则用户必须选择<xref:System.Web.UI.WebControls.CheckBox>控件，以确认应删除的记录。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Deleting#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Deleting/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Deleting#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Deleting/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableDelete">
      <MemberSignature Language="C#" Value="public bool EnableDelete { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableDelete" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableDelete" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableDelete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableDelete { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableDelete : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.EnableDelete" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EnableDelete</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否可以通过 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件删除数据记录。</summary>
        <value>如果启用了自动删除操作，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A>属性设置为`true`当你想要使用户能够删除数据记录通过<xref:System.Web.UI.WebControls.LinqDataSource>控件。 当<xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A>是`true`，则<xref:System.Web.UI.WebControls.LinqDataSource>控件使用 LINQ to SQL 来自动创建用于删除数据的命令。 必须包含一个界面，可让用户选择的记录，若要删除，如<xref:System.Web.UI.WebControls.DetailsView>控件。  
  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件不支持自动删除操作时<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性或<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性设置。 在这种情况下，<xref:System.Web.UI.WebControls.LinqDataSource>控件将引发异常，如果尝试删除操作。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>具有控件<xref:System.Web.UI.WebControls.LinqDataSource.EnableDelete%2A>设置为`true`。 一个<xref:System.Web.UI.WebControls.DetailsView>控件显示的数据并创建允许用户删除数据记录的按钮。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655">LINQ to SQL</related>
      </Docs>
    </Member>
    <Member MemberName="EnableInsert">
      <MemberSignature Language="C#" Value="public bool EnableInsert { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableInsert" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableInsert" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableInsert As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableInsert { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableInsert : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.EnableInsert" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EnableInsert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否可以通过 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件插入数据记录。</summary>
        <value>如果启用了自动插入操作，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A>属性设置为`true`当你想要使用户能够插入新数据记录通过<xref:System.Web.UI.WebControls.LinqDataSource>控件。 当<xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A>是`true`，则<xref:System.Web.UI.WebControls.LinqDataSource>控件使用 LINQ to SQL 来自动创建用于插入数据的命令。 必须包含一个界面，可让用户插入新记录，例如<xref:System.Web.UI.WebControls.DetailsView>控件。  
  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件不支持自动插入操作时<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性或<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性设置。 在这种情况下，<xref:System.Web.UI.WebControls.LinqDataSource>控件将引发异常，如果尝试插入操作。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>具有控件<xref:System.Web.UI.WebControls.LinqDataSource.EnableInsert%2A>设置为`true`。 一个<xref:System.Web.UI.WebControls.DetailsView>控件显示的数据并显示一个按钮，切换要插入模式下，用户可以通过创建并保存新记录的控件。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655">LINQ to SQL</related>
      </Docs>
    </Member>
    <Member MemberName="EnableObjectTracking">
      <MemberSignature Language="C#" Value="public bool EnableObjectTracking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableObjectTracking" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableObjectTracking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableObjectTracking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableObjectTracking : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否跟踪对数据上下文对象所做的更改。</summary>
        <value>如果跟踪数据上下文对象的更改，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking%2A>从 LINQ 到 SQL 数据上下文对象中选择数据时，才使用属性。  
  
 当你与只读数据交互时，设置<xref:System.Web.UI.WebControls.LinqDataSource.EnableObjectTracking%2A>属性设置为`false`提高性能，因为数据不缓存以确定是否已更改。 但是，它还将禁用延迟的执行查询。 此属性必须设置为`true`如果想要使用延迟的执行查询。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.Linq.DataContext.ObjectTrackingEnabled" />
      </Docs>
    </Member>
    <Member MemberName="EnableUpdate">
      <MemberSignature Language="C#" Value="public bool EnableUpdate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableUpdate" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.EnableUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableUpdate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableUpdate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableUpdate : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.EnableUpdate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EnableUpdate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否可以通过 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件更新数据记录。</summary>
        <value>如果启用了自动更新操作，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A>属性设置为`true`当你想要使用户能够通过使用更新的数据记录<xref:System.Web.UI.WebControls.LinqDataSource>控件。 当<xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A>是`true`，则<xref:System.Web.UI.WebControls.LinqDataSource>控件使用 LINQ to SQL 会自动创建的命令更新的数据。 必须包含一个界面，可让用户更新一个记录，例如<xref:System.Web.UI.WebControls.DetailsView>控件。  
  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件不支持自动更新操作时<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性或<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性设置。 在这种情况下，<xref:System.Web.UI.WebControls.LinqDataSource>控件将引发异常，如果尝试更新操作。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>具有控件<xref:System.Web.UI.WebControls.LinqDataSource.EnableUpdate%2A>设置为`true`。 一个<xref:System.Web.UI.WebControls.DetailsView>控件显示的数据并创建一个按钮，则允许用户更新数据记录。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetView">
      <MemberSignature Language="C#" Value="protected override System.Web.UI.DataSourceView GetView (string viewName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.DataSourceView GetView(string viewName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.GetView(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetView (viewName As String) As DataSourceView" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::DataSourceView ^ GetView(System::String ^ viewName);" />
      <MemberSignature Language="F#" Value="override this.GetView : string -&gt; System.Web.UI.DataSourceView" Usage="linqDataSource.GetView viewName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IDataSource.GetView(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.DataSourceView</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="viewName" Type="System.String" Index="0" FrameworkAlternate="netframework-3.5" />
      </Parameters>
      <Docs>
        <param name="viewName">要检索的视图名称，必须是“DefaultView”。</param>
        <summary>返回与 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 对象关联的数据源视图。</summary>
        <returns>与 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 对象关联的数据源视图。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<xref:System.Web.UI.WebControls.LinqDataSource>控件支持只有一个数据源视图。 <xref:System.Web.UI.WebControls.LinqDataSourceView>对象具有"DefaultView"的默认名称。 <xref:System.Web.UI.WebControls.LinqDataSourceView>对象定义数据源控件的功能，从基础数据库中检索数据并执行操作，如排序、 insert、 delete 和 update。

]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><p>viewName 为 null（Visual Basic 中为 Nothing）或除“DefaultView”以外的名称。</p></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100)">LinqDataSource Web 服务器控件概述</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178359(v=vs.110)">ASP.NET 数据访问概述</related>
      </Docs>
    </Member>
    <Member MemberName="GetViewNames">
      <MemberSignature Language="C#" Value="protected override System.Collections.ICollection GetViewNames ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Collections.ICollection GetViewNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.GetViewNames" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetViewNames () As ICollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Collections::ICollection ^ GetViewNames();" />
      <MemberSignature Language="F#" Value="override this.GetViewNames : unit -&gt; System.Collections.ICollection" Usage="linqDataSource.GetViewNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IDataSource.GetViewNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回名称的集合，这些名称表示与 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件关联的视图对象的列表。</summary>
        <returns>具有一个包含名称“DefaultView”的元素的集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<xref:System.Web.UI.WebControls.LinqDataSource>控件只支持一个视图名为其基础数据`DefaultView`。 `GetViewNames`方法因此返回仅包含一个元素，其中包含此视图名称的集合。

]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100)">LinqDataSource Web 服务器控件概述</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178359(v=vs.110)">ASP.NET 数据访问概述</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy">
      <MemberSignature Language="C#" Value="public string GroupBy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string GroupBy" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.GroupBy" />
      <MemberSignature Language="VB.NET" Value="Public Property GroupBy As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ GroupBy { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.GroupBy : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.GroupBy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定用于对检索到的数据进行分组的属性。</summary>
        <value>一个字符串，用于创建 Group By 子句。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您使用<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性来指定哪些属性用于合并具有相同的值的数据记录。 例如，如果您设置<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性设置为`Name`，在查询中所有具有相同的记录`Name`作为单个合并记录返回属性值。  
  
 可以将分配到多个属性<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性中的所有属性通过`new`函数，并使用逗号分隔每个属性。 例如，若要按属性分组`Name`，然后`Category`，请设置<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性设置为`new(Name, Category)`。  
  
 用于分组的值的属性中返回生成的属性名为通过`Key`。 您包括`Key`中的属性<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性来检索已分组的值。 可以设置`Key`属性设置为使用别名`As`关键字，但您不需要使用别名。 例如，你可能会设置<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性设置为一个名为属性`Category`。 可以检索中的合并的值`Category`通过设置属性<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性设置为`new(Key As ProductCategory)`。  
  
 可以通过包括访问分组中的单个记录`It`中的属性<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 `It`属性包含的记录共享中的分组属性的值的集合。 您可以循环访问`It`属性来检索单个记录。  
  
 <xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性通常用于聚合方法。 可以使用以下聚合方法：  
  
-   `Count()`  
  
-   `Average(` *列* `)`  
  
-   `Sum(` *列* `)`  
  
-   `Max(` *列* `)`  
  
-   `Min(` *列* `)`  
  
-   `Where(` *条件* `)`  
  
-   `Any()`  
  
-   `All(` *条件* `)`  
  
 有关详细信息，请参阅 [NIB：LinqDataSource Web 服务器控件概述](https://msdn.microsoft.com/library/104cfc3f-7385-47d3-8a51-830dfa791136)和[如何：分组和聚合数据使用 LinqDataSource 控件](https://msdn.microsoft.com/library/b922cf69-251f-4158-b405-ea960993a1af)。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>由一个名为属性组返回的数据的控件`Category`。 它返回共享的值，并计算分组记录的平均价格。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default3.aspx#3)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default3.aspx#3)]  
  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>控制，它是由两个列配置为组。 `Key`属性引用具有两个属性的对象`ProductCategory`和`Color`。 所表示的对象`It`重命名`Products`。 重命名`Products`对象包含分组中各记录的集合，每个实例包含从 Products 表的所有列。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#1)]  
  
 下面的示例演示两个<xref:System.Web.UI.WebControls.ListView>控件用于显示来自数据<xref:System.Web.UI.WebControls.LinqDataSource>上一示例中的控件。 一个<xref:System.Web.UI.WebControls.ListView>控件显示分组的数据和其他<xref:System.Web.UI.WebControls.ListView>控件显示各个属于该组的产品名称。 嵌套的数据绑定控件<xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A>属性设置为`Products`，这是别名`It`对象。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.GroupBy#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.GroupBy/vb/Default.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupByParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection GroupByParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection GroupByParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.GroupByParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GroupByParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ GroupByParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GroupByParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.GroupByParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于创建 Group By 子句的参数集合。</summary>
        <value>用于创建 Group By 子句的参数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件使用中的参数<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>集合在运行时创建 Group By 子句。 通常不会使用<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>对数据进行分组的集合。 相反，可以使用<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性。 您使用<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>必须在运行时设置集合仅当 Group By 子句中的值，该值不是属性名称。 例如，使用<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>是否基于对数据进行分组的集合`LastName`数据记录中的属性值等于由用户提供的值。  
  
 如果你想对数据进行分组的属性并且不需要在运行时设置该属性，则可以定义中的分组属性<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性。 例如，若要从数据库表中返回按分组`LastName`，请将<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>为"LastName"不带任何参数。 如果你想对动态数据进行分组的属性，创建的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件和自定义<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性根据需要。  
  
 不能将属性的名称分配中的参数的值作为<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>集合。 您将参数添加到<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>集合时想要添加到条件<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>必须在运行时设置的属性。  
  
 若要设置中的值<xref:System.Web.UI.WebControls.LinqDataSource.GroupByParameters%2A>集合中，为每个参数指定一个名称，然后添加中的占位符<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性中的为该命名参数。 在 Group By 子句中，前面加上每个参数名称后的加符号 @。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public int Insert (System.Collections.IDictionary values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Insert(class System.Collections.IDictionary values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.Insert(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (values As IDictionary) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Insert(System::Collections::IDictionary ^ values);" />
      <MemberSignature Language="F#" Value="member this.Insert : System.Collections.IDictionary -&gt; int" Usage="linqDataSource.Insert values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="values">要插入到数据源的行值。</param>
        <summary>执行插入操作。</summary>
        <returns>受插入操作影响的行数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常情况下，不需要调用<xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A>从您的代码的方法。 数据绑定控件将自动调用<xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A>方法时用户采取操作以插入新记录。 显式调用<xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A>方法时您想要创建您自己的进程插入数据。  
  
   
  
## Examples  
 下面的示例演示如何以编程方式在数据源中插入新记录，用户单击鼠标按钮后。 代码将传递<xref:System.Collections.Specialized.ListDictionary>对象，其中包含默认值为<xref:System.Web.UI.WebControls.LinqDataSource.Insert%2A>方法。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Insert#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/cs/Default2.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/vb/Default2.aspx.vb#1)]  
  
 下面的示例显示了针对上一示例的标记。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.Insert#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.Insert#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Insert/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Inserted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Inserted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Inserted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Inserted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Inserted As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Inserted;" />
      <MemberSignature Language="F#" Value="member this.Inserted : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.Inserted : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>完成插入操作后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理<xref:System.Web.UI.WebControls.LinqDataSource.Inserted>事件来捕获任何异常从插入操作，也可在插入操作完成后检查的值。 您可以检索通过新的值<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>传递给事件处理程序对象。 例如，可以使用<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>要检索 identity 属性生成新的数据记录的数据库的对象。  
  
   
  
## Examples  
 下面的示例演示如何创建事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Inserted>检查的异常，并检索新记录的标识属性的事件。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSourceStatusEventArgs#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceStatusEventArgs/cs/Default.aspx#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSourceStatusEventArgs#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceStatusEventArgs/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Inserting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt; Inserting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt; Inserting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Inserting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Inserting As EventHandler(Of LinqDataSourceInsertEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceInsertEventArgs ^&gt; ^ Inserting;" />
      <MemberSignature Language="F#" Value="member this.Inserting : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt; " Usage="member this.Inserting : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceInsertEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>执行插入操作前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理<xref:System.Web.UI.WebControls.LinqDataSource.Inserting>事件，以便验证要插入、 检查数据类，以更改在插入操作中前, 一个值或取消插入操作中的数据验证错误的对象。 <xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs>对象传递给事件处理程序中，此事件包含要插入到数据源中的新对象。  
  
 如果在插入操作时，发生验证错误<xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs>对象包含的数据类引发验证异常。 如果要插入的值与数据类中属性的类型不匹配或未通过自定义验证检查，将发生验证错误。 中的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Inserting>事件，可以检索验证异常并采取相应的措施。  
  
 如果事件处理程序中引发异常<xref:System.Web.UI.WebControls.LinqDataSource.Inserting>事件，必须处理该事件处理程序中的异常。 此异常不会传递到的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Inserted>事件 (通过<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性的<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>对象)。 <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性包含后引发的异常<xref:System.Web.UI.WebControls.LinqDataSource.Inserting>事件。  
  
   
  
## Examples  
 下面的示例演示的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Inserting>修改数据之前插入操作的事件。 中的对象<xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs.NewObject%2A>属性强制转换为一个名为类型`Product`。 `DateModified`属性的`Product`对象设置为当前日期和时间。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Inserting#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Inserting/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Inserting#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Inserting/vb/Default.aspx.vb#1)]  
  
 下面的示例演示的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Inserting>检索验证异常的事件。  
  
```vb  
Protected Sub LinqDataSource_Inserting(ByVal sender As Object, _  
        ByVal e As LinqDataSourceInsertEventArgs)  
    If (e.Exception IsNot Nothing) Then  
        For Each innerException As KeyValuePair(Of String, Exception) _  
               In e.Exception.InnerExceptions  
            Label1.Text &= innerException.Key & ": " & _  
                innerException.Value.Message & "<br />"  
        Next  
        e.ExceptionHandled = True  
    End If  
End Sub  
```  
  
```csharp  
protected void LinqDataSource_Inserting(object sender,   
        LinqDataSourceInsertEventArgs e)  
{  
    if (e.Exception != null)  
    {  
        foreach (KeyValuePair<string, Exception> innerException in   
             e.Exception.InnerExceptions)  
        {  
        Label1.Text += innerException.Key + ": " +   
            innerException.Value.Message + "<br />";  
        }  
        e.ExceptionHandled = true;  
    }  
}  
```  
  
 前面的示例检索验证异常。 如果值与属性类型不匹配，则可能会引发异常。 它还可能如以下示例中的自定义检查从引发。 `OnAgeChanging`方法检查的数量`Age`属性不是负数。  
  
```csharp  
partial void  OnAgeChanging(int? value)  
{  
    if (value < 0)  
    {  
        throw new Exception("Age cannot be a negative number.");  
    }  
}  
```  
  
```vb  
Private Sub OnAgeChanging(ByVal value As System.Nullable(Of Integer))  
    If (value < 0) Then  
        Throw New Exception("Age cannot be a negative number.")  
    End If  
End Sub  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection InsertParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection InsertParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.InsertParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InsertParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ InsertParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InsertParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.InsertParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在插入操作过程中使用的参数的集合。</summary>
        <value>在插入操作过程中使用的参数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常将所需的插入操作的值传递给<xref:System.Web.UI.WebControls.LinqDataSource>由数据绑定控件的控件。 插入参数时想要提供默认值或定义是否为空将值转换为指定`null`。 无需为每个值将插入，仅对用户不会提供一个值时必须处理的值提供参数。  
  
 中提供的值<xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A>集合仅用于数据源中定义的但未绑定数据控件中的字段。 例如，假设数据库表具有列名称、 地址和邮政编码，分别名为但<xref:System.Web.UI.WebControls.ListView>绑定到表的控件只绑定到的名称和地址字段。 中的值<xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A>集合将仅用于邮政编码字段。 它们将不会使用名称和地址字段。 即使这些字段中输入任何值，这是如此。 如果数据中的所有字段的数据绑定控件自动生成字段源，从没有值<xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A>将使用集合。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Web.UI.WebControls.LinqDataSource>具有一个参数，用于提供默认值在控件<xref:System.Web.UI.WebControls.LinqDataSource.InsertParameters%2A>集合。 如果用户未提供的值`Category`属性，由参数提供的默认值保存在数据库中。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#9](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default9.aspx#9)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#9](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default9.aspx#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadViewState">
      <MemberSignature Language="C#" Value="protected override void LoadViewState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void LoadViewState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.LoadViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub LoadViewState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void LoadViewState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="override this.LoadViewState : obj -&gt; unit" Usage="linqDataSource.LoadViewState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" Index="0" FrameworkAlternate="netframework-3.5" />
      </Parameters>
      <Docs>
        <param name="savedState">一个对象，它表示 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件的状态。</param>
        <summary>加载必须保持的 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件中的值的状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
`LoadViewState`方法用于加载以前保存的视图状态的<xref:System.Web.UI.WebControls.LinqDataSource>控件。

]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100)">LinqDataSource Web 服务器控件概述</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178359(v=vs.110)">ASP.NET 数据访问概述</related>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="linqDataSource.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件数据。</param>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 对象。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnUnload : EventArgs -&gt; unit" Usage="linqDataSource.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" /> 对象。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.Unload" /> 事件。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OrderBy">
      <MemberSignature Language="C#" Value="public string OrderBy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OrderBy" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderBy" />
      <MemberSignature Language="VB.NET" Value="Public Property OrderBy As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OrderBy { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OrderBy : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.OrderBy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定用于对检索到的数据进行排序的字段。</summary>
        <value>一个字符串，用于创建 Order By 子句。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您使用<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性来指定要用于排序的返回数据中的哪些属性。 数据进行排序的属性必须存在于原始数据源，但它不需要将其纳入<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 可以添加一个空格和`Ascending`， `ASC`， `Descending`，或`DESC`中的属性<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>以便指定如何返回有序的数据的字符串。  
  
 你可以提供多个属性中的<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>通过使用逗号分隔每个属性的属性。 例如，若要按属性名为`LastName`并`FirstName`，将<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性设置为"LastName，FirstName"。  
  
> [!NOTE]
>  当你使用<xref:System.Web.UI.WebControls.LinqDataSource>控件，其[!INCLUDE[ss2k](~/includes/ss2k-md.md)]或[!INCLUDE[ssEW](~/includes/ssew-md.md)]并且<xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A>属性设置为`true`，必须提供中的值<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性。 默认情况下<xref:System.Web.UI.WebControls.LinqDataSource.AutoPage%2A>属性是`true`。 如果你将值赋给<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性，您还必须包括所有标识列在查询中返回的属性列表中。  
  
 如果<xref:System.Web.UI.WebControls.LinqDataSource.AutoSort%2A>属性设置为`true`，为数据绑定控件可以将传递到排序表达式<xref:System.Web.UI.WebControls.LinqDataSource>控件在运行时。 <xref:System.Web.UI.WebControls.LinqDataSource>控制将应用从数据绑定控件的排序表达式应用之后<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性。 因此，根据排序表达式被返回的数据，从数据绑定控件。  
  
   
  
## Examples  
 下面的示例返回按反向字母顺序中的值为基础的数据`Category`属性。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default4.aspx#4)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default4.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OrderByParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection OrderByParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection OrderByParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderByParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OrderByParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ OrderByParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OrderByParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.OrderByParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于创建 Order By 子句的参数集合。</summary>
        <value>使用用于创建 Order By 子句的参数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件使用中的参数<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合在运行时创建 Order By 子句。 通常设置<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>属性设置为`true`添加到参数时<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合。 当<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>属性设置为`true`，在每个参数<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合添加到 Order By 子句中指定的顺序<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合。 当<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A>属性是`true`，参数无需命名为，因为它们会按顺序应用并与占位符不匹配。  
  
 如果不需要在 Order By 子句中的运行时设置一个值，无需使用<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合。 可以定义要用于排序中的数据的字段<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性。 例如，若要从数据库表中返回按排序`LastName`，请将<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>为"LastName"不带任何参数。  
  
 可以在中设置参数<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合中的占位符的参数搭配<xref:System.Web.UI.WebControls.LinqDataSource.OrderBy%2A>属性，但这种方法具有有限的应用程序。 当使用此方法时中的参数<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>集合不能表示的列名称。 可以将参数设置为一个值，然后将该值与属性中的值进行比较。 例如，可以按基于属性中的值是小于参数表示的运行时间值对数据进行排序。  
  
   
  
## Examples  
 下面的示例显示一个 <xref:System.Web.UI.WebControls.LinqDataSource> 控件，其 <xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateOrderByClause%2A> 属性设置为 `true`。 参数包含在<xref:System.Web.UI.WebControls.LinqDataSource.OrderByParameters%2A>基于属性的数据命名的用户进行排序的集合选择从<xref:System.Web.UI.WebControls.DropDownList>控件。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default8.aspx#8)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#8](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default8.aspx#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OrderGroupsBy">
      <MemberSignature Language="C#" Value="public string OrderGroupsBy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OrderGroupsBy" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy" />
      <MemberSignature Language="VB.NET" Value="Public Property OrderGroupsBy As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OrderGroupsBy { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OrderGroupsBy : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于对分组数据进行排序的字段。</summary>
        <value>一个字符串，用于创建 Order Groups By 子句。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您使用<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性指定的数据组的排序方式。 例如，可以按分组`CategoryID`属性和每个类别 ID 分组依据的平均值然后排序`Price`属性。  
  
 可以设置<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性仅当对数据进行分组。 如果您设置<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性但没有设置<xref:System.Web.UI.WebControls.LinqDataSource.GroupBy%2A>属性，<xref:System.Web.UI.WebControls.LinqDataSource>控件将引发异常。  
  
 用于对数据进行排序的属性，必须使用对数据进行分组的属性，或者对分组数据的聚合函数的结果。 若要指定对数据进行排序，但是您可以添加一个空格和"升序"、"ASC"、"降序"或"DESC"的字符串中的属性名称到<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>字符串。  
  
 可以指定多个属性中的<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性。 通过使用逗号分隔每个属性。  
  
   
  
## Examples  
 下面的示例演示如何通过使用两个属性，对数据进行分组以及如何对分组的数据进行排序通过使用这些属性之一。 名为的表中的数据`Products`通过使用名为的属性分组`CategoryID`和`Discontinued`。 分组的数据进行排序`CategoryID`属性。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/vb/Default.aspx#1)]  
  
 下面的示例演示如何通过使用属性，对数据进行分组以及如何基于一个聚合函数的结果进行排序。 将数据从`Products`通过使用分组表`CategoryID`属性。 进行排序所基于的平均值`UnitPrice`每个组中的属性。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy/vb/Default2.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OrderGroupsByParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection OrderGroupsByParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection OrderGroupsByParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OrderGroupsByParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ OrderGroupsByParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OrderGroupsByParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于创建 Order Groups By 子句的参数集合。</summary>
        <value>用于创建 Order Groups By 子句的参数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件使用中的参数<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A>集合在运行时创建 Order Groups By 子句。  
  
 添加值<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A>仅当必须在运行时在 Order Groups By 子句中设置值的集合。 可以定义用于按使用顺序对数据的字段<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性。  
  
 可以在中设置参数<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A>集合中的占位符的参数搭配<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsBy%2A>属性。 但是，如果使用此方法时中的参数<xref:System.Web.UI.WebControls.LinqDataSource.OrderGroupsByParameters%2A>集合不能表示的列名称; 它们必须代表的值。 可以将参数设置为一个值，然后到属性的值进行比较。 例如，可以按基于属性中的值是小于参数表示的运行时间值对数据进行排序。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveViewState">
      <MemberSignature Language="C#" Value="protected override object SaveViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance object SaveViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.SaveViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function SaveViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Object ^ SaveViewState();" />
      <MemberSignature Language="F#" Value="override this.SaveViewState : unit -&gt; obj" Usage="linqDataSource.SaveViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>保存 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件的当前视图状态。</summary>
        <returns>一个包含 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件的已保存状态的对象。</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100)">LinqDataSource Web 服务器控件概述</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178359(v=vs.110)">ASP.NET 数据访问概述</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public string Select { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Select" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.Select" />
      <MemberSignature Language="VB.NET" Value="Public Property Select As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Select { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Select : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.Select" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置属性和计算值，它们包含在检索到的数据中。</summary>
        <value>用于创建 Select 子句的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果未设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性，<xref:System.Web.UI.WebControls.LinqDataSource>控制此数据对象中检索所有属性 （数据列）。 您使用<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性，以便从对象检索属性的子集，或计算新值时要检索的数据。  
  
 指定要检索的设置的属性<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性设置为你想要在返回的数据中包含的属性的名称。  
  
 如果此数据对象，检索的属性子集<xref:System.Web.UI.WebControls.LinqDataSource>控件动态创建一个包含属性中指定的类<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 如果计算不是在数据对象中的属性的属性，也是动态创建的类。 在这些情况下，从查询返回的对象不是实例中指定的类<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性。 相反，必须使用`new`中的方法<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性以指示，从查询返回一个新类。 例如，若要仅返回`FirstName`并`LastName`属性从一个对象，包含多个这些属性，请设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性设置为`new(FirstName, LastName)`。 <xref:System.Web.UI.WebControls.LinqDataSource>控件将动态创建中指定的新类`new`方法。  
  
 可以使用`As`关键字来将别名分配给所选值。 如果将分配一个别名，则必须包括中的别名属性`new`方法。 将绑定到的任何数据绑定控件<xref:System.Web.UI.WebControls.LinqDataSource>控件必须由该别名引用的属性。 例如，如果您设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性设置为`new(Region As SalesRegion, Revenue / 1000 As RevenueThousands)`，数据绑定控件可以访问两个属性`SalesRegion`和`RevenueThousands`。  
  
 您使用`new`函数，在<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性根据条件下表中列出。  
  
|选择|使用新的|示例|  
|------------|----------------|-------------|  
|单个属性。|`new` 不需要。|`Select="Category"`|  
|多个属性。|`new` 所需。|`Select="new(Category, Name)"`|  
|一个或多个具有别名的属性。|`new` 所需。|`Select="new(Category As CategoryGroup)"`|  
  
 如果你想要启用自动数据修改，但不是希望显示此数据对象中的所有属性，则不要设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 相反，管理通过数据绑定控件显示。 当你使用<xref:System.Web.UI.WebControls.DetailsView>控件或<xref:System.Web.UI.WebControls.GridView>控件，则还必须设置<xref:System.Web.UI.WebControls.DetailsView.AutoGenerateRows%2A>或<xref:System.Web.UI.WebControls.GridView.AutoGenerateColumns%2A>属性设置为`false`。 不会显示在数据绑定控件的任何值存储在视图状态。 它们不变时传递给数据源执行数据更新。  
  
 当您在查询中的数据进行分组时，可以包含在聚合方法<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 可以使用以下聚合方法：  
  
-   `Count()`  
  
-   `Average(` *列* `)`  
  
-   `Sum(` *列* `)`  
  
-   `Max(` *列* `)`  
  
-   `Min(` *列* `)`  
  
-   `Where(` *条件* `)`  
  
-   `Any()`  
  
-   `All(` *条件* `)`  
  
 有关详细信息，请参阅 [NIB：LinqDataSource Web 服务器控件概述](https://msdn.microsoft.com/library/104cfc3f-7385-47d3-8a51-830dfa791136)和[如何：分组和聚合数据使用 LinqDataSource 控件](https://msdn.microsoft.com/library/b922cf69-251f-4158-b405-ea960993a1af)。  
  
 当分组数据时，可以包括`Key`并`It`，它们动态创建中的属性，<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 `Key`属性是指用来对数据进行分组的一个或多个属性中的值。 例如，如果按属性名为分组`Category`，则`Key`属性将包含在每个唯一值`Category`属性。 `It`属性是指一系列中的数据分组的单个记录。 您可以循环访问`It`属性来检索已合并，在分组操作中的单个记录。 例如，如果按属性名为分组`Category`，则`It`属性包含所有共享一个公共值中的单个记录`Category`属性。  
  
 如果包括`It`中的关键字<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性数据进行分组时，你必须将分配的别名`It`关键字。 <xref:System.Web.UI.WebControls.LinqDataSource>控件将引发异常，如果`It`没有别名。 可以分配的别名`Key`关键字，但这不是必需。  
  
   
  
## Examples  
 下面的示例演示如何设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性设置为在数据对象中的属性的子集。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#10](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default10.aspx#10)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#10](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default10.aspx#10)]  
  
 下面的示例演示如何检索值的属性中已使用对数据进行分组，以及如何检索分组记录的平均值。 `Key`关键字包含已用于对数据进行分组的属性。 在此示例中，`Key`将包含共享的值从`ProductCategory`属性。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default3.aspx#3)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default3.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Selected">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Selected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Selected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Selected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Selected As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Selected;" />
      <MemberSignature Language="F#" Value="member this.Selected : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.Selected : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>数据检索操作完成后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理<xref:System.Web.UI.WebControls.LinqDataSource.Selected>事件以从数据检索操作捕获任何异常也可检索操作完成后检查数据对象。 该对象可用于从<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>传递给事件处理程序对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Selecting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt; Selecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt; Selecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Selecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Selecting As EventHandler(Of LinqDataSourceSelectEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceSelectEventArgs ^&gt; ^ Selecting;" />
      <MemberSignature Language="F#" Value="member this.Selecting : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt; " Usage="member this.Selecting : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceSelectEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>执行数据检索操作前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件，以执行以下任务：  
  
-   修改的数据检索的参数。  
  
-   以编程方式生成查询。  
  
-   修改排序或分页的值。  
  
-   执行自定义排序或分页。  
  
-   取消数据检索操作。  
  
 <xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs>为此事件包含数据检索操作的参数传递到事件处理程序的对象。 您可以修改在参数<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件处理程序之前执行查询，也可以创建新的结果集并将其分配给<xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A>属性。  
  
 您是否能够实现自定义排序或用于绑定到的控件可能会受限于此事件处理程序中的分页<xref:System.Web.UI.WebControls.LinqDataSource>。 例如，如果列标题的<xref:System.Web.UI.WebControls.GridView>单击控件时，该控件将执行自动排序，这可能会重写任何订单，所以建立在事件处理程序。  
  
 如果事件处理程序中引发异常<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件，必须处理该事件处理程序中的异常。 此异常不会传递到的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Selected>事件 (通过<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性的<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>对象)。 <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性包含后引发的异常<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件。  
  
   
  
## Examples  
 下面的示例演示的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件。 该处理程序创建从 Web 页中的字符串值的数组中检索值的查询。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/cs/Default3.aspx.cs#3)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSourceSelectEventArgs#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSourceSelectEventArgs/vb/Default3.aspx.vb#3)]  
  
 下面的示例演示如何分配<xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A>表示存储的过程的方法中返回的对象的属性。  
  
```vb  
Protected Sub LinqDataSource_Selecting(ByVal sender As Object, _  
        ByVal e As LinqDataSourceSelectEventArgs)  
    Dim exampleContext As ExampleDataContext = New ExampleDataContext()  
    e.Result = exampleContext.GetRegisteredCustomers()  
End Sub  
```  
  
```csharp  
protected void LinqDataSource_Selecting(object sender,   
        LinqDataSourceSelectEventArgs e)  
{  
    ExampleDataContext exampleContext = new ExampleDataContext();  
    e.Result = exampleContext.GetRegisteredCustomers();  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection SelectParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection SelectParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.SelectParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ SelectParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.SelectParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在数据检索操作过程中使用的参数的集合。</summary>
        <value>用于创建 Select 子句的参数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件使用中的参数<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>集合在运行时创建 Select 子句。 您将参数添加到<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>时想要在 Select 子句中使用运行时的值的集合。 例如，您可以将参数添加到<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>集合来表示用户的配置文件中的属性。 你可以然后使用该属性和值从数据源来计算新值。  
  
 如果不需要在 Select 子句中的运行时设置一个值，无需使用<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>集合。 可以定义要在中检索的属性<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性。 例如，若要返回`FirstName`并`LastName`从数据库表中的值设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>为"FirstName，LastName"不带任何参数。  
  
 若要设置中的值<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>集合，您可以添加中的占位符<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性的命名参数。 在 Select 子句中的前面加上每个参数名称后的加符号 @。  
  
 不能使用中的参数<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>集合来表示属性名称。 若要动态设置<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性设置为属性的名称创建的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Selecting>事件和自定义<xref:System.Web.UI.WebControls.LinqDataSource.Select%2A>属性根据需要。  
  
   
  
## Examples  
 下面的示例演示如何使用一个用户提供的值来计算的值中返回的数据。 表示生产天数在文本框中，用户可以输入一个值。 此值除以表示天数，以制造一种产品的数据库中的值。 返回的值指示可在指定天数期间生产的多少产品。 用户输入的内容包含在通过 Select 命令<xref:System.Web.UI.WebControls.LinqDataSource.SelectParameters%2A>集合。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.SelectParameters#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.SelectParameters/cs/Default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.SelectParameters#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.SelectParameters/vb/Default.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StoreOriginalValuesInViewState">
      <MemberSignature Language="C#" Value="public bool StoreOriginalValuesInViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool StoreOriginalValuesInViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState" />
      <MemberSignature Language="VB.NET" Value="Public Property StoreOriginalValuesInViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool StoreOriginalValuesInViewState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.StoreOriginalValuesInViewState : bool with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示数据源中的数据是否存储在视图状态中，以确保数据在更新或删除之前不会由其他进程更改。</summary>
        <value>如果将值存储在视图状态中，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，当更新和删除操作已启用<xref:System.Web.UI.WebControls.LinqDataSource>控制存储在视图状态中的所有记录的原始值。 <xref:System.Web.UI.WebControls.LinqDataSource>控件将存储的所有主键的值，并且所有属性未都标有`UpdateCheck.Never`中`Column`属性。 您设置`UpdateCheck`的属性`Column`属性中[!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]。  
  
 LINQ to SQL 更新或删除数据之前，它会检查针对数据源中的当前值在视图状态的值。 如果值不匹配，数据源记录已更改。 在这种情况下，LINQ to SQL 将引发异常并且不会不继续更新或删除操作。 有关 LINQ to SQL 的详细信息，请参阅[LINQ to SQL](https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655)。  
  
 状态视图中存储的原始值可能会导致的页大小变得不必要的大型和可以公开恶意用户的敏感数据。 您可以禁用通过设置存储视图状态中的值<xref:System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState%2A>属性设置为`false`。 如果执行此操作，则必须提供您自己的方式来确保数据未更改。 如果您设置<xref:System.Web.UI.WebControls.LinqDataSource.StoreOriginalValuesInViewState%2A>属性设置为`false`，原始值不会保留在数据绑定控件的视图状态。 在这种情况下，LINQ to SQL 无法验证数据的完整性。 LINQ to SQL 将引发异常，指示数据冲突，即使不实际更改数据源中的数据。  
  
 如果基础数据源包含自动更新在更新过程的时间戳字段，您可以仅将该值存储在视图状态中。 在这种情况下，实体类中的时间戳属性设置为`IsVersion=true`和所有属性都设置为`UpdateCheck.Never`。 因为在每次该记录中的数据更改时，数据库会自动更新时间戳字段，LINQ to SQL 确定从该值中，如果数据已更改。 这有助于减少的视图状态大小，未公开任何敏感数据。 LINQ to SQL 数据库中时间戳值的状态将通过比较时间戳值在视图中检查的数据一致性。 有关详细信息，请参见[演练：使用时间戳与 LinqDataSource 控件，以检查数据完整性](https://msdn.microsoft.com/library/e7700162-4f05-4130-81f7-3be1361027fa)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655">LINQ to SQL</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.DynamicData.IDynamicDataSource.ContextType">
      <MemberSignature Language="C#" Value="Type System.Web.DynamicData.IDynamicDataSource.ContextType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type System.Web.DynamicData.IDynamicDataSource.ContextType" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.System#Web#DynamicData#IDynamicDataSource#ContextType" />
      <MemberSignature Language="VB.NET" Value=" Property ContextType As Type Implements IDynamicDataSource.ContextType" />
      <MemberSignature Language="C++ CLI" Value="property Type ^ System::Web::DynamicData::IDynamicDataSource::ContextType { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Web.DynamicData.IDynamicDataSource.ContextType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.ContextType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>有关此成员的说明，请参见 <see cref="T:System.Web.DynamicData.IDynamicDataSource" />。</summary>
        <value>与类关联的类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Web.UI.WebControls.LinqDataSource> 实例强制转换为 <xref:System.Web.DynamicData.IDynamicDataSource> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.DynamicData.IDynamicDataSource.EntitySetName">
      <MemberSignature Language="C#" Value="string System.Web.DynamicData.IDynamicDataSource.EntitySetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string System.Web.DynamicData.IDynamicDataSource.EntitySetName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.System#Web#DynamicData#IDynamicDataSource#EntitySetName" />
      <MemberSignature Language="VB.NET" Value=" Property EntitySetName As String Implements IDynamicDataSource.EntitySetName" />
      <MemberSignature Language="C++ CLI" Value="property System::String ^ System::Web::DynamicData::IDynamicDataSource::EntitySetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Web.DynamicData.IDynamicDataSource.EntitySetName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.EntitySetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>有关此成员的说明，请参见 <see cref="T:System.Web.DynamicData.IDynamicDataSource" />。</summary>
        <value>实体的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Web.UI.WebControls.LinqDataSource> 实例强制转换为 <xref:System.Web.DynamicData.IDynamicDataSource> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.DynamicData.IDynamicDataSource.Exception">
      <MemberSignature Language="C#" Value="event EventHandler&lt;System.Web.DynamicData.DynamicValidatorEventArgs&gt; System.Web.DynamicData.IDynamicDataSource.Exception;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.DynamicData.DynamicValidatorEventArgs&gt; System.Web.DynamicData.IDynamicDataSource.Exception" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.System#Web#DynamicData#IDynamicDataSource#Exception" />
      <MemberSignature Language="VB.NET" Value="Custom Event Exception As EventHandler(Of DynamicValidatorEventArgs) Implements System.Web.DynamicData.IDynamicDataSource" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Web.DynamicData.IDynamicDataSource.Exception</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.DynamicData.DynamicValidatorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>有关此成员的说明，请参见 <see cref="T:System.Web.DynamicData.IDynamicDataSource" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Web.UI.WebControls.LinqDataSource> 实例强制转换为 <xref:System.Web.DynamicData.IDynamicDataSource> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TableName : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.TableName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置数据上下文类中的属性或字段的名称，该数据上下文类表示一个数据集合。</summary>
        <value>包含属性（该属性包含数据集合）名称的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性设置为表示要检索的数据的字段的属性的名称。 当连接到数据库表时，属性的名称通常是表的相同的名称。 当连接到内存中的数据集合时，设置<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性设置为属性或字段返回的数据集合的名称。  
  
 您可以将返回到任何类型的属性分配<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>检索操作的属性。 如果由属性表示的对象不实现<xref:System.Collections.IEnumerable>，则<xref:System.Web.UI.WebControls.LinqDataSource>控件将自动将对象包装的实例中<xref:System.Collections.IEnumerable>对象。  
  
 若要启用自动更新、 插入或删除操作，分配给类<xref:System.Web.UI.WebControls.LinqDataSource.ContextTypeName%2A>属性必须派生自<xref:System.Data.Linq.DataContext>和分配给属性<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>必须派生自属性<xref:System.Data.Linq.Table%601>。  
  
 有关如何从一个类的实例中选择数据的信息，请参阅<xref:System.Web.UI.WebControls.LinqDataSourceSelectEventArgs.Result%2A>属性。  
  
   
  
## Examples  
 下面的示例演示两个<xref:System.Web.UI.WebControls.LinqDataSource>控件。 在一个<xref:System.Web.UI.WebControls.LinqDataSource>控件，<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性设置为类中的属性。 该属性返回一个字符串数组。 在另<xref:System.Web.UI.WebControls.LinqDataSource>控件，<xref:System.Web.UI.WebControls.LinqDataSource.TableName%2A>属性设置为该属性表示数据库表。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/Default.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/Default.aspx#2)]  
  
 名为的类`ExampleDataContext`，表示数据库表不显示在此示例中。 对于此示例正常工作，必须创建此类，通过添加 LINQ to SQL 类命名的 Example.dbml 和将表名为到电影[!INCLUDE[vs_ordesigner_short](~/includes/vs-ordesigner-short-md.md)]。 名为的类`ExampleDataContext`一个属性名为`Movies`生成。  
  
 下面的示例演示名为的类`MovieLibrary`中引用<xref:System.Web.UI.WebControls.LinqDataSource>控件。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/cs/App_Code/MovieLibrary.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Overview/vb/App_Code/MovieLibrary.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberSignature Language="F#" Value="override this.TrackViewState : unit -&gt; unit" Usage="linqDataSource.TrackViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>跟踪对 <see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 控件的视图状态的更改，以便可将这些更改存储在该控件的 <see cref="T:System.Web.UI.StateBag" /> 对象中。</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100)">LinqDataSource Web 服务器控件概述</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178359(v=vs.110)">ASP.NET 数据访问概述</related>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Collections.IDictionary keys, System.Collections.IDictionary values, System.Collections.IDictionary oldValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Update(class System.Collections.IDictionary keys, class System.Collections.IDictionary values, class System.Collections.IDictionary oldValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.LinqDataSource.Update(System.Collections.IDictionary,System.Collections.IDictionary,System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function Update (keys As IDictionary, values As IDictionary, oldValues As IDictionary) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Collections::IDictionary ^ keys, System::Collections::IDictionary ^ values, System::Collections::IDictionary ^ oldValues);" />
      <MemberSignature Language="F#" Value="member this.Update : System.Collections.IDictionary * System.Collections.IDictionary * System.Collections.IDictionary -&gt; int" Usage="linqDataSource.Update (keys, values, oldValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.IDictionary" />
        <Parameter Name="values" Type="System.Collections.IDictionary" />
        <Parameter Name="oldValues" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="keys">要更新的记录的行键值。</param>
        <param name="values">要在数据源中更新的行值。</param>
        <param name="oldValues">为检测数据冲突而计算的行值。</param>
        <summary>执行更新操作。</summary>
        <returns>受更新操作影响的记录数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常情况下，不需要调用<xref:System.Web.UI.WebControls.LinqDataSource.Update%2A>从您的代码的方法。 数据绑定控件将自动调用<xref:System.Web.UI.WebControls.LinqDataSource.Update%2A>方法时用户执行操作来更新的记录。 显式调用<xref:System.Web.UI.WebControls.LinqDataSource.Update%2A>方法时您想要创建您自己的进程用于更新数据。  
  
   
  
## Examples  
 下面的示例演示如何以编程方式更新数据源中的记录，用户单击鼠标按钮后。 代码将传递<xref:System.Collections.Specialized.ListDictionary>对象，其中包含密钥值，<xref:System.Collections.Specialized.ListDictionary>对象，其中包含的原始值和一个<xref:System.Collections.Specialized.ListDictionary>对象，其中包含新值<xref:System.Web.UI.WebControls.LinqDataSource.Update%2A>方法。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Update#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/cs/Default2.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Update#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/vb/Default3.aspx.vb#1)]  
  
 下面的示例显示了针对上一示例的标记。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource.Update#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/cs/Default2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource.Update#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Update/vb/Default3.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Updated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Updated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; Updated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Updated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Updated As EventHandler(Of LinqDataSourceStatusEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceStatusEventArgs ^&gt; ^ Updated;" />
      <MemberSignature Language="F#" Value="member this.Updated : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " Usage="member this.Updated : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceStatusEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>完成更新操作后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理<xref:System.Web.UI.WebControls.LinqDataSource.Updated>后更新操作已完成的事件来捕获任何异常从更新操作，或若要检查的值输出参数。 输出参数中有<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>传递给事件处理程序对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection UpdateParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection UpdateParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.UpdateParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UpdateParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ UpdateParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UpdateParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.UpdateParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.UI.WebControls.LinqDataSource" /> 类不使用此集合。</summary>
        <value>参数的集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Updating">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt; Updating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt; Updating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.LinqDataSource.Updating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Updating As EventHandler(Of LinqDataSourceUpdateEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Web::UI::WebControls::LinqDataSourceUpdateEventArgs ^&gt; ^ Updating;" />
      <MemberSignature Language="F#" Value="member this.Updating : EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt; " Usage="member this.Updating : System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>执行更新操作前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理<xref:System.Web.UI.WebControls.LinqDataSource.Updating>事件，以便验证要更新，以检查数据类，若要更改执行更新操作前, 一个值，或取消更新操作中的数据验证错误的对象。 <xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs>对象传递给事件处理程序包含原始对象和已更新的对象。  
  
 如果在更新操作时，发生验证错误<xref:System.Web.UI.WebControls.LinqDataSourceInsertEventArgs>对象包含的数据类引发验证异常。 如果要更新的值与数据类中属性的类型不匹配或未通过自定义验证检查，将发生验证错误。 中的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Updating>事件，可以检索验证异常并采取相应的措施。  
  
 如果事件处理程序中引发异常<xref:System.Web.UI.WebControls.LinqDataSource.Updating>事件，必须处理该事件处理程序中的异常。 此异常不会传递到的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Updated>事件 (通过<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性的<xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs>对象)。 <xref:System.Web.UI.WebControls.LinqDataSourceStatusEventArgs.Exception%2A>属性包含后引发的异常<xref:System.Web.UI.WebControls.LinqDataSource.Updating>事件。  
  
   
  
## Examples  
 下面的示例演示的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Updating>事件。 该代码将从属性进行比较<xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs.OriginalObject%2A>属性和<xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs.NewObject%2A>属性以查看是否已更改一个值。 如果值已更改，值为<xref:System.Web.UI.WebControls.LinqDataSourceUpdateEventArgs.NewObject%2A>属性设置为`true`。  
  
 [!code-csharp[System.Web.UI.WebControls.LinqDataSource.Updating#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Updating/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.UI.WebControls.LinqDataSource.Updating#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource.Updating/vb/Default.aspx.vb#1)]  
  
 下面的示例演示的事件处理程序<xref:System.Web.UI.WebControls.LinqDataSource.Updating>检索验证异常的事件。  
  
```vb  
Protected Sub LinqDataSource_Updating(ByVal sender As Object, _  
        ByVal e As LinqDataSourceUpdateEventArgs)  
    If (e.Exception IsNot Nothing) Then  
        For Each innerException As KeyValuePair(Of String, Exception) _  
               In e.Exception.InnerExceptions  
            Label1.Text &= innerException.Key & ": " & _  
                innerException.Value.Message & "<br />"  
        Next  
        e.ExceptionHandled = True  
    End If  
End Sub  
```  
  
```csharp  
protected void LinqDataSource_Updating(object sender,   
        LinqDataSourceUpdateEventArgs e)  
{  
    if (e.Exception != null)  
    {  
        foreach (KeyValuePair<string, Exception> innerException in   
             e.Exception.InnerExceptions)  
        {  
        Label1.Text += innerException.Key + ": " +   
            innerException.Value.Message + "<br />";  
        }  
        e.ExceptionHandled = true;  
    }  
}  
```  
  
 前面的示例检索验证异常。 如果值与属性类型不匹配，则可能会引发异常。 它还可能如以下示例中的自定义检查从引发。 `OnAgeChanging`方法检查的数量`Age`属性不是负数。  
  
```csharp  
partial void  OnAgeChanging(int? value)  
{  
    if (value < 0)  
    {  
        throw new Exception("Age cannot be a negative number.");  
    }  
}  
```  
  
```vb  
Private Sub OnAgeChanging(ByVal value As System.Nullable(Of Integer))  
    If (value < 0) Then  
        Throw New Exception("Age cannot be a negative number.")  
    End If  
End Sub  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Where">
      <MemberSignature Language="C#" Value="public string Where { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Where" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.Where" />
      <MemberSignature Language="VB.NET" Value="Public Property Where As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Where { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Where : string with get, set" Usage="System.Web.UI.WebControls.LinqDataSource.Where" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.Where</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指定要将记录包含在检索到的数据中必须为真的条件。</summary>
        <value>用于创建 Where 子句的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您使用<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性来指定要从查询返回的记录的条件。 语法<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性是 C# 中的 LINQ Where 子句的语法相同。  
  
 指定的表达式的结果为布尔值，如果该表达式的计算结果为`true`对于给定的行，在结果集中包括的行。 表达式的列名称、 比较运算符和值进行比较，由组成，如下面的示例中所示：  
  
```  
<asp:LinqDataSource ... Where="Price > 50"...>  
```  
  
 若要指定多个表达式的逻辑链接`AND`或`OR`运算符，您将使用`&&`作为逻辑 AND 运算符和`||`作为逻辑 OR 运算符，如下面的示例中所示：  
  
```  
<asp:LinqDataSource ... Where="Price > 50 && Price < 100"...>  
<asp:LinqDataSource ... Where="Price <= 50 || Price >= 100"...>  
```  
  
 如果你想要测试针对一个文本字符串值的属性，则文本字符串值必须括在双引号。 若要在标记中执行此操作，请将<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>子句值在单引号内，如下面的示例中所示：  
  
```  
<asp:LinqDataSource ... Where='Category = "Sports"' ... >  
```  
  
 若要测试对代码中的文本字符串值，请使用适合于您使用为了插入双引号引起来，如下面的示例中所示的语言的转义符：  
  
```vb  
LinqDataSource1.Where = "Category = ""Sports"""  
```  
  
```csharp  
LinqDataSource1.Where = "Category = \"Sports\"";  
```  
  
 如果你想要测试字符串是否大于或小于另一个字符串，则必须使用的方法<xref:System.String>类而不是使用`<`或`>`之间的列名称和字符串值的运算符。 下面的示例显示如何选择具有小于，小于或等于的类别值的行大于，或大于或等于"体育":  
  
```  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") < 0' ... >  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") <= 0' ... >  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") > 0' ... >  
<asp:LinqDataSource ... Where='Category.CompareTo("Sports") >= 0' ... >  
```  
  
 此外可以使用的其他方法<xref:System.String>类，如<xref:System.String.StartsWith%2A>， <xref:System.String.EndsWith%2A>，和<xref:System.String.Contains%2A>。 有关如何比较字符串的详细信息，请参阅[比较字符串](~/docs/standard/base-types/comparing.md)。 详细了解 Where 子句语法，请参阅[C# 运算符](https://msdn.microsoft.com/library/0301e31f-22ad-49af-ac3c-d5eae7f0ac43)和[其中子句](~/docs/csharp/language-reference/keywords/where-clause.md)。  
  
 还可以筛选基于静态值，定义创建 Web 页时，可以根据在运行时计算的动态值进行筛选。 在这种情况下，包含在一个命名的参数<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>充当占位符的值的属性。 然后添加具有匹配名称的参数，<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合。  
  
 或者，可以设置<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>属性设置为`true`定义中的参数和<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合。 当<xref:System.Web.UI.WebControls.LinqDataSource.AutoGenerateWhereClause%2A>属性是`true`，无需包括中的命名的参数<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性。 相反，<xref:System.Web.UI.WebControls.LinqDataSource>控件自动生成 Where 子句中的参数从<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>属性。  
  
 有关如何筛选数据的详细信息，请参阅[演练：选择和筛选 LinqDataSource 和 GridView 控件的数据子集](https://msdn.microsoft.com/library/c1cca3e8-86e4-4e69-a29f-1c05b91f2205)。  
  
   
  
## Examples  
 下面的示例演示如何从基于静态条件的查询返回的数据进行筛选。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default5.aspx#5)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default5.aspx#5)]  
  
 下面的示例演示如何基于用户在运行时提供的值对数据进行筛选。 在此示例中<xref:System.Web.UI.WebControls.DropDownList>控件和一个<xref:System.Web.UI.WebControls.GridView>页上显示控件。 当用户选择中的值之一<xref:System.Web.UI.WebControls.DropDownList>控件，<xref:System.Web.UI.WebControls.LinqDataSource>从控件中选择`Products`表具有的行`UserPrice`值等于所选的值。 <xref:System.Web.UI.WebControls.GridView>控件然后显示经过筛选的数据。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default6.aspx#6)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default6.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WhereParameters">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.ParameterCollection WhereParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.ParameterCollection WhereParameters" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.LinqDataSource.WhereParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WhereParameters As ParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::ParameterCollection ^ WhereParameters { System::Web::UI::WebControls::ParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WhereParameters : System.Web.UI.WebControls.ParameterCollection" Usage="System.Web.UI.WebControls.LinqDataSource.WhereParameters" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.DynamicData.IDynamicDataSource.WhereParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Data")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.ParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于创建 Where 子句的参数集合。</summary>
        <value>用于创建 <see cref="P:System.Web.UI.WebControls.LinqDataSource.Where" /> 属性中 Where 子句的参数的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.LinqDataSource>控件使用中的参数<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合创建 Where 子句在运行时。 您将参数添加到<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合时想要以编程方式将设置一个或多个条件在 Where 子句。 例如，可能会搜索数据库表中的记录的值相等的最后一个名称与<xref:System.Web.UI.WebControls.TextBox>控件。 在这种情况下，您将参数添加到<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>文本框值的集合。  
  
 如果不需要在运行时设置一个值，在 Where 子句中，您无需使用<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合。 可以定义要在中检索的字段<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性。 例如，若要从数据库表中返回其中`LastName`等于"Adams"在标记中，设置<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性设置为`'LastName = "Adams"'`不带任何参数。  
  
 若要设置中的值<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合中，为每个参数指定一个名称，然后添加中的占位符<xref:System.Web.UI.WebControls.LinqDataSource.Where%2A>属性中的为该参数。 在 Where 子句中，与每个参数名称的前面加上 @ 符号。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Web.UI.WebControls.LinqDataSource.WhereParameters%2A>集合动态创建 Where 子句。 <xref:System.Web.UI.WebControls.LinqDataSource>控制返回中的值的所有记录`Price`列中的用户选择的值大于<xref:System.Web.UI.WebControls.DropDownList>控件。  
  
 [!code-aspx-csharp[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/cs/Default6.aspx#6)]
 [!code-aspx-vb[System.Web.UI.WebControls.LinqDataSource_Simple#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.WebControls.LinqDataSource_Simple/vb/Default6.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>