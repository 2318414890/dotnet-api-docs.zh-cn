<Type Name="FtpWebRequest" FullName="System.Net.FtpWebRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ca33a4d1d4a9e9bd64b9f4b993c8badf60f916ae" /><Meta Name="ms.sourcegitcommit" Value="b0551d7828f015124aca601dbb64bd913cc5067d" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="12/13/2018" /><Meta Name="ms.locfileid" Value="53333360" /></Metadata><TypeSignature Language="C#" Value="public sealed class FtpWebRequest : System.Net.WebRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FtpWebRequest extends System.Net.WebRequest" />
  <TypeSignature Language="DocId" Value="T:System.Net.FtpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FtpWebRequest&#xA;Inherits WebRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class FtpWebRequest sealed : System::Net::WebRequest" />
  <TypeSignature Language="F#" Value="type FtpWebRequest = class&#xA;    inherit WebRequest" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>实现文件传输协议 (FTP) 客户端。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
>  我们不建议你使用`FtpWebRequest`类的新的开发。 有关详细信息和替代方案`FtpWebRequest`，请参阅[不应使用 WebRequest](https://github.com/dotnet/platform-compat/blob/master/docs/DE0003.md) GitHub 上。

 若要获取的实例<xref:System.Net.FtpWebRequest>，使用<xref:System.Net.WebRequest.Create%2A>方法。 此外可以使用<xref:System.Net.WebClient>类来上传和下载信息从 FTP 服务器。 使用任一种方法，当您指定使用 FTP 方案的网络资源 (例如， `"ftp://contoso.com"`)<xref:System.Net.FtpWebRequest>类提供了能够以编程方式与 FTP 服务器进行交互。  
  
 该 URI 可以是相对值还是绝对值。 如果 URI 是窗体`"ftp://contoso.com/%2fpath"`(%2f 是转义字符 /)，然后 URI 是绝对的当前目录是`/path`。 如果，但是，URI 是窗体`"ftp://contoso.com/path"`，.NET Framework 首次登录到 FTP 服务器 (通过使用用户名和密码设置<xref:System.Net.FtpWebRequest.Credentials%2A>属性)，则当前目录设置为`<UserLoginDirectory>/path`。  
  
 必须具有有效的用户名和密码对服务器或服务器必须允许匿名登录。 可以指定用于通过设置连接到服务器的凭据<xref:System.Net.FtpWebRequest.Credentials%2A>属性也可以将它们包含在<xref:System.Uri.UserInfo%2A>URI 部分传递给<xref:System.Net.WebRequest.Create%2A>方法。 如果包括<xref:System.Uri.UserInfo%2A>URI 中的信息<xref:System.Net.FtpWebRequest.Credentials%2A>属性设置为指定的用户名和密码信息与新的网络凭据。  
  
> [!CAUTION]
>  除非<xref:System.Net.FtpWebRequest.EnableSsl%2A>属性是`true`，所有数据和命令，其中包括你的用户名和密码信息，向服务器都发送以明文形式。 监视网络流量的任何人都可以查看你的凭据，并将其用于连接到服务器。 如果要连接到 FTP 服务器要求凭据，并支持安全套接字层 (SSL)，则应设置<xref:System.Net.FtpWebRequest.EnableSsl%2A>到`true`。  
  
 您必须具有<xref:System.Net.WebPermission>来访问 FTP 资源; 否则为<xref:System.Security.SecurityException>引发异常。  
  
 指定要通过设置发送到服务器的 FTP 命令<xref:System.Net.FtpWebRequest.Method%2A>属性中定义的值<xref:System.Net.WebRequestMethods.Ftp>结构。 若要传输的文本数据，更改<xref:System.Net.FtpWebRequest.UseBinary%2A>属性从其默认值 (`true`) 到`false`。 有关详细信息和限制，请参阅<xref:System.Net.FtpWebRequest.Method%2A>。  
  
 使用时<xref:System.Net.FtpWebRequest>对象以将文件上载到服务器，必须将文件内容写入到请求流获取通过调用<xref:System.Net.FtpWebRequest.GetRequestStream%2A>方法或其异步对应<xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>和<xref:System.Net.FtpWebRequest.EndGetRequestStream%2A>方法。 必须写入到流，并在发送请求之前关闭流。  
  
 请求被发送到服务器，通过调用<xref:System.Net.FtpWebRequest.GetResponse%2A>方法或其异步对应<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>和<xref:System.Net.FtpWebRequest.EndGetResponse%2A>方法。 完成请求的操作后，<xref:System.Net.FtpWebResponse>返回对象。 <xref:System.Net.FtpWebResponse>对象提供相应的操作和从服务器下载的任何数据的状态。  
  
 可以设置超时值以读取或写入到服务器通过使用<xref:System.Net.FtpWebRequest.ReadWriteTimeout%2A>属性。 如果超过超时期限时，调用方法将引发<xref:System.Net.WebException>与<xref:System.Net.WebExceptionStatus>设置为<xref:System.Net.WebExceptionStatus.Timeout>。  
  
 当从 FTP 服务器下载文件，如果命令成功，所请求的文件的内容中提供了响应对象的流。 可以通过调用访问此流<xref:System.Net.FtpWebResponse.GetResponseStream%2A>方法。 有关详情，请参阅<xref:System.Net.FtpWebResponse>。  
  
 如果<xref:System.Net.FtpWebRequest.Proxy%2A>属性设置，或者直接或在配置文件中，与 FTP 服务器之间的通信都通过指定的代理。 如果指定的代理是 HTTP 代理，则仅<xref:System.Net.WebRequestMethods.Ftp.DownloadFile>， <xref:System.Net.WebRequestMethods.Ftp.ListDirectory>，和<xref:System.Net.WebRequestMethods.Ftp.ListDirectoryDetails>支持命令。  
  
 仅下载二进制内容缓存;也就是说，使用接收的内容<xref:System.Net.WebRequestMethods.Ftp.DownloadFile>命令<xref:System.Net.FtpWebRequest.UseBinary%2A>属性设置为`true`。  
  
 多个<xref:System.Net.FtpWebRequest>s 重用现有连接，在可能的情况。  
  
 有关 FTP 协议的详细信息，请参阅[RFC 959:文件传输协议](https://www.ietf.org/rfc/rfc959.txt)。  
  
   
  
## Examples  
 下面的代码示例演示如何从 FTP 服务器中删除文件。  
  
 [!code-cpp[NCLFtpClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#4)]
 [!code-csharp[NCLFtpClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#4)]  
  
 下面的代码示例演示如何通过使用从 FTP 服务器下载文件<xref:System.Net.WebClient>类。  
  
 [!code-cpp[NCLFtpClient#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#5)]
 [!code-csharp[NCLFtpClient#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#5)]  
  
 下面的代码示例演示如何使用异步操作将文件上传到 FTP 服务器。  
  
 [!code-cpp[NCLFtpAsync#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpAsync/CPP/async.cpp#1)]
 [!code-csharp[NCLFtpAsync#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpAsync/CS/async.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">用于访问引用此请求的资源。 关联枚举：<see cref="F:System.Net.NetworkAccess.Connect" />。</permission>
    <altmember cref="T:System.Net.FtpWebResponse" />
    <altmember cref="T:System.Net.FtpStatusCode" />
    <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
    <altmember cref="T:System.Net.WebRequest" />
    <altmember cref="T:System.Net.WebResponse" />
    <altmember cref="T:System.Net.WebClient" />
  </Docs>
  <Members>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="ftpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>终止异步 FTP 操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果没有正在进行中的操作，此方法没有任何影响。 如果文件传输过程中，此方法将终止传输。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例演示用户如何可以终止异步上传到服务器的文件从本地目录。  
  
 [!code-cpp[NCLFtpClient#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#10)]
 [!code-csharp[NCLFtpClient#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="ftpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义对象，其中包含操作的相关信息。 操作完成时，此对象传递给 <paramref name="callback" /> 委托。</param>
        <summary>开始以异步方式打开请求的内容流以便写入。</summary>
        <returns><see cref="T:System.IAsyncResult" /> 实例，指示操作的状态。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须通过调用完成的异步操作<xref:System.Net.FtpWebRequest.EndGetRequestStream%2A>方法。 通常情况下，<xref:System.Net.FtpWebRequest.EndGetRequestStream%2A>由所引用的方法调用`callback`。 若要确定操作的状态，请检查属性<xref:System.IAsyncResult>此方法返回的对象。  
  
 此方法不会阻止等待流时。 若要阻止，请调用<xref:System.Net.FtpWebRequest.GetRequestStream%2A>来替代此方法。  
  
 有关使用异步编程模型的详细信息，请参阅[Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何开始异步操作以获取请求的流。 此代码示例是为提供一个更大示例的一部分<xref:System.Net.FtpWebRequest>类概述。  
  
 [!code-cpp[NCLFtpAsync#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpAsync/CPP/async.cpp#4)]
 [!code-csharp[NCLFtpAsync#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpAsync/CS/async.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此前对此方法或 <see cref="M:System.Net.FtpWebRequest.GetRequestStream" /> 的调用尚未完成。</exception>
        <exception cref="T:System.Net.WebException">未能建立到 FTP 服务器的连接。</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.FtpWebRequest.Method" /> 属性没有设置为 <see cref="F:System.Net.WebRequestMethods.Ftp.UploadFile" />。</exception>
        <block subset="none" type="usage"><para>此方法将生成网络流量。</para></block>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="ftpWebRequest.BeginGetResponse (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义对象，其中包含操作的相关信息。 操作完成时，此对象传递给 <paramref name="callback" /> 委托。</param>
        <summary>开始以异步方式向 FTP 服务器发送请求并从 FTP 服务器接收响应。</summary>
        <returns><see cref="T:System.IAsyncResult" /> 实例，指示操作的状态。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须通过调用完成的异步操作<xref:System.Net.FtpWebRequest.EndGetResponse%2A>方法。 通常情况下，<xref:System.Net.FtpWebRequest.EndGetResponse%2A>由所引用的方法调用`callback`。 若要确定操作的状态，请检查属性<xref:System.IAsyncResult>返回对象<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>方法。  
  
 如果<xref:System.Net.FtpWebRequest.Proxy%2A>属性设置，或者直接或在配置文件中，与 FTP 服务器之间的通信都通过指定的代理。  
  
 <xref:System.Net.FtpWebRequest.BeginGetResponse%2A> 不会阻止等待来自服务器的响应时。 若要阻止，请调用<xref:System.Net.FtpWebRequest.GetResponse%2A>方法来代替<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>。  
  
 有关使用异步编程模型的详细信息，请参阅[Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
 当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  如果<xref:System.Net.WebException>是引发，使用<xref:System.Net.WebException.Response%2A>和<xref:System.Net.WebException.Status%2A>异常来确定来自服务器的响应的属性。  
  
   
  
## Examples  
 下面的代码示例演示结束异步操作以获取请求的流，然后开始获取响应的请求。 此代码示例是为提供一个更大示例的一部分<xref:System.Net.FtpWebRequest>类概述。  
  
 [!code-cpp[NCLFtpAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpAsync/CPP/async.cpp#5)]
 [!code-csharp[NCLFtpAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpAsync/CS/async.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已经为此实例调用了 <see cref="M:System.Net.FtpWebRequest.GetResponse" /> 或 <see cref="M:System.Net.FtpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />。</exception>
        <block subset="none" type="usage"><para>此方法将生成网络流量。</para></block>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.FtpWebRequest.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于建立到 FTP 服务器的加密连接的证书。</summary>
        <value>包含客户端证书的 <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 客户端证书用于在初始的 SSL 连接协商过程对客户端进行身份验证。 有关详情，请参阅<xref:System.Net.FtpWebRequest.EnableSsl%2A>。  
  
> [!NOTE]
>  .NET Framework 缓存 SSL 会话，因为它们创建并尝试尽可能重用缓存的会话的新请求。 在尝试以重复使用的 SSL 会话时，.NET Framework 使用的第一个元素<xref:System.Net.HttpWebRequest.ClientCertificates%2A>（如果没有一个），或尝试重复使用匿名会话，如果<xref:System.Net.HttpWebRequest.ClientCertificates%2A>为空。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">为集运算指定的值为 <see langword="null" />。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.FtpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置连接组的名称，该连接组包含用于发送当前请求的服务点。</summary>
        <value>包含连接组名称的 <see cref="T:System.String" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 连接组将与一个特定的连接或连接的一组相关联请求的集。 仅当在请求凭据相同，并且该请求指定的连接组名称在相同的应用程序域中，发出请求才可以重用的连接组中的连接。 如果请求未指定连接组名称，可以使用与请求的服务器不是与连接组相关联的任何现有连接。 当凭据都不相同时，现有连接已关闭，并且新的请求必须重新进行身份验证。  
  
 使用连接组可以提高性能，因为这允许所有用户要重用与用户的凭据进行身份验证连接请求。  
  
 更改<xref:System.Net.FtpWebRequest.ConnectionGroupName%2A>属性后调用<xref:System.Net.FtpWebRequest.GetRequestStream%2A>， <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.FtpWebRequest.GetResponse%2A>，或<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>方法使<xref:System.InvalidOperationException>异常。  
  
   
  
## Examples  
 下面的代码示例检索此属性的值。  
  
 [!code-cpp[NCLFtpClient#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#16)]
 [!code-csharp[NCLFtpClient#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
        <related type="Article" href="~/docs/framework/network-programming/managing-connections.md">管理连接</related>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.FtpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置被 <see cref="T:System.Net.FtpWebRequest" /> 类忽略的值。</summary>
        <value>应忽略的 <see cref="T:System.Int64" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.ContentLength%2A>属性仅用于使用的其他实现的兼容性<xref:System.Net.WebRequest>和<xref:System.Net.WebResponse>类。 若要使用没有理由<xref:System.Net.FtpWebRequest.ContentLength%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentOffset">
      <MemberSignature Language="C#" Value="public long ContentOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentOffset" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ContentOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentOffset As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ContentOffset { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentOffset : int64 with get, set" Usage="System.Net.FtpWebRequest.ContentOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置请求所下载的文件的字节偏移量。</summary>
        <value>指定文件偏移量（以字节为单位）的 <see cref="T:System.Int64" /> 实例。 默认值为 0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.Net.FtpWebRequest.ContentOffset%2A>属性从 FTP 服务器下载文件时。 此偏移量指示标记要下载的数据的开始位置的服务器的文件中的位置。 偏移量指定为从该文件; 开始的字节数第一个字节的偏移量为零。  
  
 设置<xref:System.Net.FtpWebRequest.ContentOffset%2A>会导致<xref:System.Net.FtpWebRequest>发送重新启动 (`REST`) 命令到服务器。 如果将数据上载到服务器，大多数 FTP 服务器实现会忽略此命令。  
  
 更改<xref:System.Net.FtpWebRequest.ContentOffset%2A>后调用<xref:System.Net.FtpWebRequest.GetRequestStream%2A>， <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.FtpWebRequest.GetResponse%2A>，或<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>方法使<xref:System.InvalidOperationException>异常。  
  
   
  
## Examples  
 下面的代码示例演示从一台服务器并将下载的数据追加到本地文件的下载文件的一部分。  
  
 [!code-cpp[NclFtpClient#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#7)]
 [!code-csharp[NclFtpClient#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为该属性指定的值小于 0。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.FtpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>总是引发 <see cref="T:System.NotSupportedException" />。</summary>
        <value>总是引发 <see cref="T:System.NotSupportedException" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.ContentType%2A>属性仅用于使用的其他实现的兼容性<xref:System.Net.WebRequest>和<xref:System.Net.WebResponse>类。 若要使用没有理由<xref:System.Net.FtpWebRequest.ContentType%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">FTP 不支持内容类型信息。</exception>
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.FtpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于与 FTP 服务器通信的凭据。</summary>
        <value><see cref="T:System.Net.ICredentials" /> 实例；如果还未设置该属性，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不需要使用匿名登录进行连接时指定的凭据。 必须设置<xref:System.Net.FtpWebRequest.Credentials%2A>属性使用的凭据类型<xref:System.Net.NetworkCredential>; 这可确保，可以读取并发送到服务器的用户名和密码。  
  
> [!CAUTION]
>  凭据信息并未加密时传输到服务器，除非<xref:System.Net.FtpWebRequest.EnableSsl%2A>属性设置为`true`。  
  
 更改<xref:System.Net.FtpWebRequest.Credentials%2A>后调用<xref:System.Net.FtpWebRequest.GetRequestStream%2A>， <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.FtpWebRequest.GetResponse%2A>，或<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>方法使<xref:System.InvalidOperationException>异常。  
  
   
  
## Examples  
 下面的代码示例检索此属性的值，并使用它来显示用户名。  
  
 [!code-cpp[NCLFtpClient#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#14)]
 [!code-csharp[NCLFtpClient#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">为集运算指定的值为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">为 Set 操作指定了 <see cref="T:System.Net.ICredentials" /> 以外的 <see cref="T:System.Net.NetworkCredential" /> 类型。</exception>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.FtpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>定义所有 FTP 请求的默认缓存策略。</summary>
        <value><see cref="T:System.Net.Cache.RequestCachePolicy" />，定义 FTP 请求的缓存策略。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有使用接收的内容<xref:System.Net.WebRequestMethods.Ftp.DownloadFile>缓存命令。  
  
 下表描述了 FTP 缓存策略的效果<xref:System.Net.FtpWebRequest>。  
  
|策略|效果|  
|------------|------------|  
|<xref:System.Net.Cache.RequestCacheLevel.Default>|如果资源是最新、 内容长度是准确的并且存在过期、 修改和内容长度属性将，返回缓存的资源。|  
|<xref:System.Net.Cache.RequestCacheLevel.BypassCache>|从服务器返回的资源。|  
|<xref:System.Net.Cache.RequestCacheLevel.CacheOnly>|如果内容长度存在并且匹配的项大小;，返回缓存的资源否则，将引发<xref:System.Net.WebException>。|  
|<xref:System.Net.Cache.RequestCacheLevel.CacheIfAvailable>|如果提供了内容的长度，并且与匹配项的大小;，返回缓存的资源否则为该资源从服务器下载，并返回到调用方。|  
|<xref:System.Net.Cache.RequestCacheLevel.Revalidate>|如果缓存资源的时间戳是与服务器; 上的资源的时间戳相同，则返回缓存的资源否则为资源是从服务器下载，存储在缓存中，并返回给调用方。|  
|<xref:System.Net.Cache.RequestCacheLevel.Reload>|从服务器下载资源、 将其存储在缓存中，并返回给调用方的资源。|  
|<xref:System.Net.Cache.RequestCacheLevel.NoCacheNoStore>|如果缓存的资源存在，将删除它。 资源从服务器下载，并返回到调用方。|  
  
> [!NOTE]
>  设置<xref:System.Net.FtpWebRequest.DefaultCachePolicy%2A>重写任何配置设置。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">调用方尝试将此属性设置为 <see langword="null" />。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/0eb0c5cb-dd97-484d-8614-785e88877abb">defaultFtpCachePolicy （网络设置）</related>
      </Docs>
    </Member>
    <Member MemberName="EnableSsl">
      <MemberSignature Language="C#" Value="public bool EnableSsl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableSsl" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.EnableSsl" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableSsl As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableSsl { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableSsl : bool with get, set" Usage="System.Net.FtpWebRequest.EnableSsl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Boolean" />，它指定是否使用 SSL 连接。</summary>
        <value>如果控制和数据传输是加密的，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  除非<xref:System.Net.FtpWebRequest.EnableSsl%2A>属性是`true`，所有数据和命令，其中包括你的用户名和密码信息，向服务器都发送以明文形式。 监视网络流量的任何人都可以查看你的凭据，并将其用于连接到服务器。 如果要连接到 FTP 服务器要求凭据，并支持 SSL，则应设置<xref:System.Net.FtpWebRequest.EnableSsl%2A>到`true`。  
  
 `"AUTH TLS"`命令发送到服务器以请求的加密的会话。 如果服务器无法识别此命令，则会收到<xref:System.Net.WebException>异常。  
  
   
  
## Examples  
 下面的代码示例使用加密的连接以下载的目录列表从 FTP 服务器。  
  
 [!code-cpp[NCLFtpClient#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#8)]
 [!code-csharp[NCLFtpClient#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">到 FTP 服务器的连接已经建立。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="ftpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">在操作开始时返回的 <see cref="T:System.IAsyncResult" /> 对象。</param>
        <summary>结束由 <see cref="M:System.Net.FtpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 启动的挂起的异步操作。</summary>
        <returns>与此实例关联的可写 <see cref="T:System.IO.Stream" /> 实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果该操作未完成，<xref:System.Net.FtpWebRequest.EndGetRequestStream%2A>方法进行阻止，直到操作完成。 若要确定操作是否已完成，请检查<xref:System.IAsyncResult.IsCompleted%2A>属性之前调用<xref:System.Net.FtpWebRequest.EndGetRequestStream%2A>。  
  
 除了"异常"中所示的异常<xref:System.Net.FtpWebRequest.EndGetRequestStream%2A>重新打开以进行写入的流时引发的异常引发。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何结束异步操作以获取请求的流。 此代码示例是为提供一个更大示例的一部分<xref:System.Net.FtpWebRequest>类概述。  
  
 [!code-cpp[NCLFtpAsync#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpAsync/CPP/async.cpp#5)]
 [!code-csharp[NCLFtpAsync#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpAsync/CS/async.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">未能通过调用 <see cref="M:System.Net.FtpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 获取 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">已为 <paramref name="asyncResult" /> 标识的操作调用了此方法。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="ftpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">在操作开始时返回的 <see cref="T:System.IAsyncResult" />。</param>
        <summary>结束由 <see cref="M:System.Net.FtpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 启动的挂起的异步操作。</summary>
        <returns>包含一个 <see cref="T:System.Net.FtpWebResponse" /> 实例的 <see cref="T:System.Net.WebResponse" /> 引用。 此对象包含 FTP 服务器对请求的响应。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果该操作未完成时<xref:System.Net.FtpWebRequest.EndGetResponse%2A>调用方法时，<xref:System.Net.FtpWebRequest.EndGetResponse%2A>阻止，直到操作完成。 若要阻止阻塞，请检查<xref:System.IAsyncResult.IsCompleted%2A>属性之前调用<xref:System.Net.FtpWebRequest.EndGetResponse%2A>。  
  
 除了"异常"中所示的异常<xref:System.Net.FtpWebRequest.EndGetResponse%2A>重新引发与服务器通信时引发的异常。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何结束异步操作以获得响应。 此代码示例是为提供一个更大示例的一部分<xref:System.Net.FtpWebRequest>类概述。  
  
 [!code-cpp[NCLFtpAsync#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpAsync/CPP/async.cpp#6)]
 [!code-csharp[NCLFtpAsync#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpAsync/CS/async.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">未能通过调用 <see cref="M:System.Net.FtpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> 获取 <paramref name="asyncResult" />。</exception>
        <exception cref="T:System.InvalidOperationException">已为 <paramref name="asyncResult" /> 标识的操作调用了此方法。</exception>
        <exception cref="T:System.Net.WebException">使用 HTTP 代理时出错。</exception>
        <block subset="none" type="usage"><para>此方法将生成网络流量。</para></block>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
        <altmember cref="M:System.Net.FtpWebRequest.GetResponse" />
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="ftpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索用于向 FTP 服务器上载数据的流。</summary>
        <returns>可写 <see cref="T:System.IO.Stream" /> 实例，用于存储要由当前请求发送到服务器的数据。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置请求属性之前调用<xref:System.Net.FtpWebRequest.GetRequestStream%2A>方法。 将数据写入流之后, 您必须关闭在发送请求之前的流。  
  
 如果没有设置<xref:System.Net.FtpWebRequest.Method%2A>属性设置为<xref:System.Net.WebRequestMethods.Ftp.UploadFile>或<xref:System.Net.WebRequestMethods.Ftp.AppendFile>，不能获取的流。  
  
 <xref:System.Net.FtpWebRequest.GetRequestStream%2A> 在等待流时阻止。 若要防止此情况，调用<xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>方法来代替<xref:System.Net.FtpWebRequest.GetRequestStream%2A>。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何将文件复制到请求的数据流并将请求发送到服务器，以将数据上传并将其追加到文件。  
  
 [!code-cpp[NCLFtpClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#3)]
 [!code-csharp[NCLFtpClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.FtpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> 已被调用并且尚未完成。  
  
\- 或 - 
HTTP 代理被启用，而您尝试使用 FTP 命令而非 <see cref="F:System.Net.WebRequestMethods.Ftp.DownloadFile" />、<see cref="F:System.Net.WebRequestMethods.Ftp.ListDirectory" /> 或 <see cref="F:System.Net.WebRequestMethods.Ftp.ListDirectoryDetails" />。</exception>
        <exception cref="T:System.Net.WebException">未能建立到 FTP 服务器的连接。</exception>
        <exception cref="T:System.Net.ProtocolViolationException"><see cref="P:System.Net.FtpWebRequest.Method" /> 属性未设置为 <see cref="F:System.Net.WebRequestMethods.Ftp.UploadFile" /> 或 <see cref="F:System.Net.WebRequestMethods.Ftp.AppendFile" />。</exception>
        <block subset="none" type="usage"><para>此方法将生成网络流量。</para></block>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.FtpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="ftpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 FTP 服务器响应。</summary>
        <returns>包含一个 <see cref="T:System.Net.FtpWebResponse" /> 实例的 <see cref="T:System.Net.WebResponse" /> 引用。 此对象包含 FTP 服务器对请求的响应。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要访问特定于 FTP 的属性，必须强制转换<xref:System.Net.WebResponse>到此方法返回的对象<xref:System.Net.FtpWebResponse>。  
  
 <xref:System.Net.FtpWebRequest.GetResponse%2A> 控制连接建立，并且还可以创建数据连接。 <xref:System.Net.FtpWebRequest.GetResponse%2A> 阻止，直到收到响应。 若要防止此情况，您可以通过执行此操作以异步方式调用<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>并<xref:System.Net.FtpWebRequest.EndGetResponse%2A>方法来代替<xref:System.Net.FtpWebRequest.GetResponse%2A>。  
  
 如果<xref:System.Net.FtpWebRequest.Proxy%2A>属性设置，或者直接或在配置文件中，与 FTP 服务器之间的通信都通过代理服务器。  
  
 如果<xref:System.Net.WebException>是引发，使用<xref:System.Net.WebException.Response%2A>和<xref:System.Net.WebException.Status%2A>异常来确定来自服务器的响应的属性。  
  
 当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  多次调用<xref:System.Net.FtpWebRequest.GetResponse%2A>返回相同的响应对象中; 请求不重新颁发。  
  
   
  
## Examples  
 下面的代码示例演示如何将文件复制到请求的数据流并发送请求以将数据追加到一个文件服务器。 此示例调用<xref:System.Net.FtpWebRequest.GetResponse%2A>发送请求并阻止，直到服务器返回的响应。  
  
 [!code-cpp[NCLFtpClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#3)]
 [!code-csharp[NCLFtpClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已经为此实例调用了 <see cref="M:System.Net.FtpWebRequest.GetResponse" /> 或 <see cref="M:System.Net.FtpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />。  
  
\- 或 - 
HTTP 代理被启用，而您尝试使用 FTP 命令而非 <see cref="F:System.Net.WebRequestMethods.Ftp.DownloadFile" />、<see cref="F:System.Net.WebRequestMethods.Ftp.ListDirectory" /> 或 <see cref="F:System.Net.WebRequestMethods.Ftp.ListDirectoryDetails" />。</exception>
        <exception cref="T:System.Net.WebException"><see cref="P:System.Net.FtpWebRequest.EnableSsl" /> 设置为 <see langword="true" />，但服务器不支持此功能。  
  
\- 或 - 
<see cref="P:System.Net.FtpWebRequest.Timeout" /> 已指定，且已超时。</exception>
        <block subset="none" type="usage"><para>此方法将生成网络流量。</para></block>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.FtpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取空 <see cref="T:System.Net.WebHeaderCollection" /> 对象。</summary>
        <value>一个空 <see cref="T:System.Net.WebHeaderCollection" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.Headers%2A>属性仅用于使用的其他实现的兼容性<xref:System.Net.WebRequest>和<xref:System.Net.WebResponse>类。 若要使用没有理由<xref:System.Net.FtpWebRequest.Headers%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.FtpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("We don't support KeepAlive = true")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个 <see cref="T:System.Boolean" /> 值，该值指定在请求完成之后是否关闭到 FTP 服务器的控制连接。</summary>
        <value>如果不应销毁到服务器的连接，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Net.FtpWebRequest.KeepAlive%2A>属性设置为`false`，在调用时控制连接已关闭<xref:System.Net.FtpWebResponse.Close%2A>方法。  
  
 更改<xref:System.Net.FtpWebRequest.KeepAlive%2A>后调用<xref:System.Net.FtpWebRequest.GetRequestStream%2A>， <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.FtpWebRequest.GetResponse%2A>，或<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>方法使<xref:System.InvalidOperationException>异常。  
  
   
  
## Examples  
 下面的代码示例检索并显示为指定的属性值<xref:System.Net.FtpWebRequest>对象。  
  
 [!code-cpp[NCLFtpClient#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#15)]
 [!code-csharp[NCLFtpClient#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.FtpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要发送到 FTP 服务器的命令。</summary>
        <value><see cref="T:System.String" /> 值，包含要发送到服务器的 FTP 命令。 默认值为 <see cref="F:System.Net.WebRequestMethods.Ftp.DownloadFile" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.Method%2A>属性确定哪个命令发送到服务器。 您设置<xref:System.Net.FtpWebRequest.Method%2A>使用的公共字段成员中定义的字符串<xref:System.Net.WebRequestMethods.Ftp>类。 请注意，在中定义的字符串<xref:System.Net.WebRequestMethods.Ftp>类是唯一支持的选项<xref:System.Net.FtpWebRequest.Method%2A>属性。 设置<xref:System.Net.FtpWebRequest.Method%2A>属性设置为任何其他值将导致<xref:System.ArgumentException>异常。  
  
 设置时<xref:System.Net.FtpWebRequest.Method%2A>到<xref:System.Net.WebRequestMethods.Ftp.UploadFile>，则必须在调用之前进行<xref:System.Net.FtpWebRequest.GetRequestStream%2A>方法。 在正确的顺序会导致调用这些成员失败<xref:System.Net.ProtocolViolationException>尝试获取请求流时出现异常。  
  
 为提供的凭据<xref:System.Net.FtpWebRequest>对象必须有权执行指定的方法。 如果没有，则 FTP 命令将失败。  
  
 若要确定是成功还是失败的命令，检查<xref:System.Net.FtpWebResponse.StatusCode%2A>和<xref:System.Net.FtpWebResponse.StatusDescription%2A>属性。  
  
   
  
## Examples  
 下面的代码示例将此属性设置为<xref:System.Net.WebRequestMethods.Ftp.DeleteFile>。  
  
 [!code-cpp[NCLFtpClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#4)]
 [!code-csharp[NCLFtpClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
        <exception cref="T:System.ArgumentException">此方法无效。  
  
\- 或 - 
不支持此方法。  
  
\- 或 - 
指定了多个方法。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.FtpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>总是引发 <see cref="T:System.NotSupportedException" />。</summary>
        <value>总是引发 <see cref="T:System.NotSupportedException" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.PreAuthenticate%2A>属性仅用于使用的其他实现的兼容性<xref:System.Net.WebRequest>和<xref:System.Net.WebResponse>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">FTP 不支持预身份验证。</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.FtpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于与 FTP 服务器通信的代理。</summary>
        <value>负责与 FTP 服务器通信的 <see cref="T:System.Net.IWebProxy" /> 实例。 在.NET Core，其值是<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

### <a name="on-net-framework"></a>.NET Framework 上

 <xref:System.Net.FtpWebRequest.Proxy%2A>属性标识<xref:System.Net.IWebProxy>与 FTP 服务器进行通信的实例。 代理的设置是由系统使用的配置文件和 Internet Explorer 本地网络设置。 若要指定应使用任何代理，请设置<xref:System.Net.FtpWebRequest.Proxy%2A>返回的代理实例到<xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType>方法。 有关自动代理检测的详细信息，请参阅[自动代理检测](~/docs/framework/network-programming/automatic-proxy-detection.md)。  
  
 必须设置<xref:System.Net.FtpWebRequest.Proxy%2A>之前将数据写入到请求的流或获取响应。 更改<xref:System.Net.FtpWebRequest.Proxy%2A>后调用<xref:System.Net.FtpWebRequest.GetRequestStream%2A>， <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.FtpWebRequest.GetResponse%2A>，或<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>方法使<xref:System.InvalidOperationException>异常。  
  
 <xref:System.Net.FtpWebRequest>类支持 HTTP 和 ISA 防火墙客户端代理。  
  
 如果指定的代理是 HTTP 代理，则仅<xref:System.Net.WebRequestMethods.Ftp.DownloadFile>， <xref:System.Net.WebRequestMethods.Ftp.ListDirectory>，和<xref:System.Net.WebRequestMethods.Ftp.ListDirectoryDetails>支持命令。  
  
### <a name="on-net-core"></a>.NET Core 上   

`FtpWebRequest.Proxy`不支持属性。 将属性设置不起作用。 获取属性值返回`null`。 


## Examples  
 下面的代码示例显示了此属性的值。  
  
 [!code-cpp[NCLFtpClient#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#16)]
 [!code-csharp[NCLFtpClient#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">此属性不能设置为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
        <altmember cref="T:System.Net.WebProxy" />
        <altmember cref="T:System.Net.GlobalProxySelection" />
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.FtpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置写入或读取流时的超时。</summary>
        <value>读取或写入超时之前的毫秒数。默认值为 300,000 毫秒（5 分钟）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.ReadWriteTimeout%2A>写入到返回的流时使用<xref:System.Net.FtpWebRequest.GetRequestStream%2A>方法或在读取返回的流<xref:System.Net.FtpWebResponse.GetResponseStream%2A>方法。  
  
 具体而言，<xref:System.Net.FtpWebRequest.ReadWriteTimeout%2A>属性控制的超时<xref:System.IO.Stream.Read%2A>方法，用于读取返回的流<xref:System.Net.FtpWebResponse.GetResponseStream%2A>方法，并为<xref:System.IO.Stream.Write%2A>方法，用于写入到流返回的<xref:System.Net.FtpWebRequest.GetRequestStream%2A>方法。 如果超过超时期限时，调用方法将引发<xref:System.Net.WebException>与<xref:System.Net.WebExceptionStatus>设置为<xref:System.Net.WebExceptionStatus.Timeout>。  
  
 若要指定要等待的时间完成请求的时间量，请使用<xref:System.Net.FtpWebRequest.Timeout%2A>属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已发送请求。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">为 Set 操作指定的值小于或等于零，并且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RenameTo">
      <MemberSignature Language="C#" Value="public string RenameTo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RenameTo" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.RenameTo" />
      <MemberSignature Language="VB.NET" Value="Public Property RenameTo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RenameTo { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RenameTo : string with get, set" Usage="System.Net.FtpWebRequest.RenameTo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置重命名文件的新名称。</summary>
        <value>重命名文件的新名称。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">为 Set 操作指定的值为 <see langword="null" /> 或是空字符串。</exception>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.FtpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例所请求的 URI。</summary>
        <value><see cref="T:System.Uri" /> 实例，标识使用文件传输协议访问的资源。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.Net.FtpWebRequest.RequestUri%2A>属性是 URI 时指定<xref:System.Net.WebRequest.Create%2A>调用方法来获取此实例。  
  
   
  
## Examples  
 下面的代码示例显示了此属性的值。  
  
 [!code-cpp[NCLFtpClient#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#14)]
 [!code-csharp[NCLFtpClient#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.FtpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于连接 FTP 服务器的 <see cref="T:System.Net.ServicePoint" /> 对象。</summary>
        <value>可用于自定义连接行为的 <see cref="T:System.Net.ServicePoint" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果没有<xref:System.Net.ServicePoint>对象存在，则创建一个用于 FTP 服务器。 若要设置的最大可以为 FTP 服务器打开的连接数，设置<xref:System.Net.ServicePoint.ConnectionLimit%2A>属性的<xref:System.Net.ServicePoint>此属性返回的实例。  
  
   
  
## Examples  
 下面的代码示例从请求中检索服务点和最大连接数设置为 1。  
  
 [!code-cpp[NCLFtpClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#1)]
 [!code-csharp[NCLFtpClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.FtpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置等待请求的毫秒数。</summary>
        <value>一个 <see cref="T:System.Int32" /> 值，包含请求超时前等待的毫秒数。默认值为 <see cref="F:System.Threading.Timeout.Infinite" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要指定无限值，设置<xref:System.Net.FtpWebRequest.Timeout%2A>属性设置为<xref:System.Threading.Timeout.Infinite>(-1)。 这是默认值。  
  
 <xref:System.Net.FtpWebRequest.Timeout%2A> 是与发出同步请求的毫秒数<xref:System.Net.FtpWebRequest.GetResponse%2A>方法等待响应，<xref:System.Net.FtpWebRequest.GetRequestStream%2A>方法等待流。 如果资源不会响应在超时期内，请求将引发<xref:System.Net.WebException>与<xref:System.Net.WebException.Status%2A>属性设置为<xref:System.Net.WebExceptionStatus.Timeout>。  
  
 更改<xref:System.Net.FtpWebRequest.Timeout%2A>后调用<xref:System.Net.FtpWebRequest.GetRequestStream%2A>， <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.FtpWebRequest.GetResponse%2A>，或<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>方法使<xref:System.InvalidOperationException>异常。  
  
 域名系统 (DNS) 查询可能需要最多 15 秒钟才能返回或超时时间。如果你的请求包含需要解析的主机名，并设置<xref:System.Net.FtpWebRequest.Timeout%2A>的值不超过 15 秒，可能需要花费 15 秒或更长时间才<xref:System.Net.WebException>引发来指示你的请求超时。  
  
   
  
## Examples  
 下面的代码示例设置此属性。  
  
 [!code-cpp[NCLFtpClient#23](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#23)]
 [!code-csharp[NCLFtpClient#23](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的值是小于零，且不是 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="UseBinary">
      <MemberSignature Language="C#" Value="public bool UseBinary { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseBinary" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.UseBinary" />
      <MemberSignature Language="VB.NET" Value="Public Property UseBinary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseBinary { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseBinary : bool with get, set" Usage="System.Net.FtpWebRequest.UseBinary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个 <see cref="T:System.Boolean" /> 值，该值指定文件传输的数据类型。</summary>
        <value><see langword="true" />，指示服务器要传输的是二进制数据；<see langword="false" />，指示数据为文本。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要发送二进制数据，例如图像，将此属性设置为`true`。 如果要发送文本，将属性设置为`false`。 指定`true`会导致<xref:System.Net.FtpWebRequest>发送`"TYPE I"`命令到服务器。 指定`false`会导致<xref:System.Net.FtpWebRequest>发送`"Type A"`命令到服务器。 FTP 服务器可以忽略这些命令。  
  
 更改<xref:System.Net.FtpWebRequest.UseBinary%2A>后调用<xref:System.Net.FtpWebRequest.GetRequestStream%2A>， <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.FtpWebRequest.GetResponse%2A>，或<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>方法使<xref:System.InvalidOperationException>异常。  
  
   
  
## Examples  
 下面的代码示例检索并显示为指定的属性值<xref:System.Net.FtpWebRequest>对象。  
  
 [!code-cpp[NCLFtpClient#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#15)]
 [!code-csharp[NCLFtpClient#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.FtpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>总是引发 <see cref="T:System.NotSupportedException" />。</summary>
        <value>总是引发 <see cref="T:System.NotSupportedException" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.FtpWebRequest.UseDefaultCredentials%2A>属性仅用于使用的其他实现的兼容性<xref:System.Net.WebRequest>和<xref:System.Net.WebResponse>类。 若要使用没有理由<xref:System.Net.FtpWebRequest.UseDefaultCredentials%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">FTP 不支持默认凭据。</exception>
      </Docs>
    </Member>
    <Member MemberName="UsePassive">
      <MemberSignature Language="C#" Value="public bool UsePassive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UsePassive" />
      <MemberSignature Language="DocId" Value="P:System.Net.FtpWebRequest.UsePassive" />
      <MemberSignature Language="VB.NET" Value="Public Property UsePassive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UsePassive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UsePassive : bool with get, set" Usage="System.Net.FtpWebRequest.UsePassive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置客户端应用程序的数据传输过程的行为。</summary>
        <value>如果客户端应用程序的数据传输过程侦听数据端口上的连接，则为 <see langword="false" />；如果客户端应在数据端口上启动连接，则为 <see langword="true" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.Net.FtpWebRequest.UsePassive%2A>属性设置为`true`将发送"`PASV"`命令到服务器。 此命令请求服务器以侦听数据端口和等待连接，而不是启动一个在收到传输命令时。  
  
 有关使用指定的行为的说明<xref:System.Net.FtpWebRequest.UsePassive%2A>，请参阅[RFC 959:"文件传输协议"，第 3.2 节："建立数据连接"和 4.1.2 部分："转换参数的命令"](https://www.ietf.org/rfc/rfc959.txt)。  
  
 更改<xref:System.Net.FtpWebRequest.UsePassive%2A>后调用<xref:System.Net.FtpWebRequest.GetRequestStream%2A>， <xref:System.Net.FtpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.FtpWebRequest.GetResponse%2A>，或<xref:System.Net.FtpWebRequest.BeginGetResponse%2A>方法使<xref:System.InvalidOperationException>异常。  
  
 如果<xref:System.Net.FtpWebRequest.UsePassive%2A>设置为`true`、 FTP 服务器可能不会发送该文件的大小和下载进度始终为零。 如果<xref:System.Net.FtpWebRequest.UsePassive%2A>设置为`false`，防火墙可引发警报，并阻止文件下载。  
  
   
  
## Examples  
 下面的代码示例检索并显示为指定的属性值<xref:System.Net.FtpWebRequest>对象。  
  
 [!code-cpp[NCLFtpClient#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLFtpClient/CPP/ftptests.cpp#6)]
 [!code-csharp[NCLFtpClient#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLFtpClient/CS/ftptests.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">对于一个已在进行的请求为此属性指定了一个新值。</exception>
        <altmember cref="T:System.Net.FtpWebResponse" />
        <altmember cref="T:System.Net.FtpStatusCode" />
        <altmember cref="T:System.Net.WebRequestMethods.Ftp" />
        <altmember cref="T:System.Net.WebRequest" />
        <altmember cref="T:System.Net.WebResponse" />
        <altmember cref="T:System.Net.WebClient" />
      </Docs>
    </Member>
  </Members>
</Type>