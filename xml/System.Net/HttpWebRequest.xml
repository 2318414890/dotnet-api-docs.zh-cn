<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="758c8926acd455a9a955170a29f8a407e6816dae" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36472999" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpWebRequest&#xA;Inherits WebRequest&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpWebRequest : System::Net::WebRequest, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HttpWebRequest = class&#xA;    inherit WebRequest&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Provides an HTTP-specific implementation of the <see cref="T:System.Net.WebRequest" /> class.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest>类提供支持的属性和方法定义中<xref:System.Net.WebRequest>和其他属性和方法，使用户能够直接与使用 HTTP 的服务器进行交互。  
  
 不要使用<xref:System.Net.HttpWebRequest.%23ctor%2A>构造函数。 使用<xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>方法初始化新<xref:System.Net.HttpWebRequest>对象。 如果方案的统一资源标识符 (URI) 是`http://`或`https://`，<xref:System.Net.WebRequest.Create%2A>返回<xref:System.Net.HttpWebRequest>对象。  
  
 <xref:System.Net.HttpWebRequest.GetResponse%2A>方法中指定的资源向发出同步请求<xref:System.Net.HttpWebRequest.RequestUri%2A>属性并返回<xref:System.Net.HttpWebResponse>包含响应对象。 可以使用返回的流收到的响应数据<xref:System.Net.HttpWebResponse.GetResponseStream%2A>。 如果响应对象或响应流已关闭，则将作废剩余数据。 将耗尽剩余的数据和关闭响应对象或流，如果具备以下条件时，将重新用于后续请求套接字： 它是保持活动状态或管线传输请求，只有少量的数据需要接收，或在小时间间隔内收到剩余数据。 如果所述条件的任何保存或超出消耗时间，将关闭套接字。 对于保持活动状态或管道连接，我们强烈建议应用程序之前 EOF 读取流。 这可确保将重新用于后续请求导致更好的性能和更少的资源使用套接字。  
  
 当你想要将数据发送到资源，<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法返回<xref:System.IO.Stream>要用来发送数据对象。 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>和<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法提供对发送数据流异步访问。  
  
 客户端身份验证与<xref:System.Net.HttpWebRequest>，客户端证书必须安装在我的当前用户的证书存储。  
  
 <xref:System.Net.HttpWebRequest>类将引发<xref:System.Net.WebException>中发生错误时访问资源时。 <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType>属性包含<xref:System.Net.WebExceptionStatus>值，该值指示错误的来源。 当<xref:System.Net.WebException.Status%2A?displayProperty=nameWithType>是<xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>、<xref:System.Net.WebException.Response%2A>属性包含<xref:System.Net.HttpWebResponse>收到来自资源。  
  
 <xref:System.Net.HttpWebRequest> 公开常见 HTTP 标头值作为属性发送到 Internet 资源，由方法，或设置由系统;下表包含的完整列表。 你可以在设置其他标头<xref:System.Net.HttpWebRequest.Headers%2A>属性作为名称/值对。 请注意服务器和缓存可能更改或在请求过程中添加标头。  
  
 下表列出了通过属性或方法或系统设置的 HTTP 标头。  
  
|Header|通过设置|  
|------------|------------|  
|接受|通过设置<xref:System.Net.HttpWebRequest.Accept%2A>属性。|  
|连接|通过设置<xref:System.Net.HttpWebRequest.Connection%2A>属性，<xref:System.Net.HttpWebRequest.KeepAlive%2A>属性。|  
|内容长度|通过设置<xref:System.Net.HttpWebRequest.ContentLength%2A>属性。|  
|Content-Type|通过设置<xref:System.Net.HttpWebRequest.ContentType%2A>属性。|  
|预期|通过设置<xref:System.Net.HttpWebRequest.Expect%2A>属性。|  
|日期|系统设置的当前日期。|  
|Host|系统设置的当前主机信息。|  
|如果-修改-自|通过设置<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>属性。|  
|范围|通过设置<xref:System.Net.HttpWebRequest.AddRange%2A>方法。|  
|引用站点|通过设置<xref:System.Net.HttpWebRequest.Referer%2A>属性。|  
|传输编码|通过设置<xref:System.Net.HttpWebRequest.TransferEncoding%2A>属性 (<xref:System.Net.HttpWebRequest.SendChunked%2A>属性必须为`true`)。|  
|用户代理|通过设置<xref:System.Net.HttpWebRequest.UserAgent%2A>属性。|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest> 自动注册。 不需要调用<xref:System.Net.WebRequest.RegisterPrefix%2A>方法注册<xref:System.Net.HttpWebRequest?displayProperty=nameWithType>之前使用 Uri 开头`http://`或`https://`。  
  
 使用默认代理，可以指定本地计算机或应用程序配置文件。 如果<xref:System.Net.HttpWebRequest.Proxy%2A>指定属性，然后从的代理设置<xref:System.Net.HttpWebRequest.Proxy%2A>属性重写的本地计算机或应用程序配置文件和<xref:System.Net.HttpWebRequest>实例将使用指定的代理设置。 如果在配置文件中不指定任何代理和<xref:System.Net.HttpWebRequest.Proxy%2A>属性未指定，<xref:System.Net.HttpWebRequest>类使用从 Internet 资源管理器继承在本地计算机上的代理设置。 如果没有在 Internet Explorer 代理设置，请直接向服务器发送请求。  
  
 <xref:System.Net.HttpWebRequest>类使用继承从 Internet 资源管理器以不同的方式不是直接通过 Internet Explorer 分析跳过列表的通配符字符分析的代理跳过列表。 例如，<xref:System.Net.HttpWebRequest>类将正则表达式的分析的"nt *"Internet Explorer 中的跳过列表"nt。 $"。 这不同于 Internet Explorer 的本机行为。 因此的 URL"`http://intxxxxx`"将跳过代理使用<xref:System.Net.HttpWebRequest>类，但将不使用代理使用 Internet Explorer。  
  
> [!NOTE]
>  框架缓存 SSL 会话，因为它们创建，并尝试尽可能重用为新请求，缓存的会话。 当尝试重复使用的 SSL 会话，框架将使用的第一个元素<xref:System.Net.HttpWebRequest.ClientCertificates%2A>（如果没有一个），或尝试重用匿名会话，如果<xref:System.Net.HttpWebRequest.ClientCertificates%2A>为空。  
  
> [!NOTE]
>  出于安全原因，默认情况下 cookie 处于禁用状态。 如果你想要使用 cookie，使用<xref:System.Net.HttpWebRequest.CookieContainer%2A>属性来启用 cookie。  
  
 .NET Framework 4.6 包括一个新的安全功能，将阻止不安全的密码和哈希算法的连接。 默认情况下，使用 TLS/SSL 通过例如 HttpClient、 HttpWebRequest、 FTPClient、 SmtpClient、 SslStream 等的 Api 和面向.NET Framework 4.6 的应用程序获得更安全行为。  
  
 开发人员可能想要选择退出此行为以便保持其现有 SSL3 服务或 TLS 带 RC4 服务与互操作性。 [这篇文章](https://support.microsoft.com/kb/3069494)说明如何修改你的代码，以便禁用新的行为。  
  
   
  
## Examples  
 下面的代码示例创建<xref:System.Net.HttpWebRequest>uri http://www.contoso.com/。  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">若要访问请求的 URI 或请求重定向到任何 URI。 关联的枚举： <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpWebRequest" /> class. These constructors are obsolete; see the Remarks section for details.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

同时<xref:System.Net.HttpWebRequest>构造函数已过时，且不应使用。 调用<xref:System.Net.WebRequest.CreateHttp%2A?displayProperty=nameWithType>方法初始化新<xref:System.Net.HttpWebRequest>对象。     
  
      ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpWebRequest" /> class. This constructor is obsolete.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpWebRequest(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : Uri -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest uri" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HttpWebRequest(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="new System.Net.HttpWebRequest : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Net.HttpWebRequest" Usage="new System.Net.HttpWebRequest (serializationInfo, streamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the new <see cref="T:System.Net.HttpWebRequest" /> object.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> object that contains the source and destination of the serialized stream associated with the new <see cref="T:System.Net.HttpWebRequest" /> object.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.HttpWebRequest" /> class from the specified instances of the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> and <see cref="T:System.Runtime.Serialization.StreamingContext" /> classes. This constructor is obsolete.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用序列化时，必须在完全信任模式下运行应用程序。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">无限制地访问网络资源。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="httpWebRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancels a request to an Internet resource.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Abort%2A>方法取消对资源的请求。 取消请求后，调用<xref:System.Net.HttpWebRequest.GetResponse%2A>， <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>， <xref:System.Net.HttpWebRequest.EndGetResponse%2A>， <xref:System.Net.HttpWebRequest.GetRequestStream%2A>， <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>，或<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法使<xref:System.Net.WebException>与<xref:System.Net.WebException.Status%2A>属性设置为<xref:System.Net.WebExceptionStatus.RequestCanceled>。  
  
 <xref:System.Net.HttpWebRequest.Abort%2A>方法将同步执行到指定的回调<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>或<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法如果<xref:System.Net.HttpWebRequest.Abort%2A>这些操作中的未完成时调用方法。 这会导致潜在死锁问题。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[网络跟踪](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804)。  
  
   
  
## Examples  
 在异步请求的情况下它是客户端应用程序，来实现其自己的超时机制的责任。 下面的代码示例演示如何执行此操作。  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Property Accept As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Accept { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Accept : string with get, set" Usage="System.Net.HttpWebRequest.Accept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Accept" /> HTTP header.</summary>
        <value>
          <see langword="Accept" /> HTTP 标头的值。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要清除`Accept`设置 HTTP 标头，<xref:System.Net.HttpWebRequest.Accept%2A>属性`null`。  
  
> [!NOTE]
>  此属性的值存储在<xref:System.Net.WebHeaderCollection>。 如果设置了 WebHeaderCollection，则该属性值将丢失。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.Accept%2A>属性。  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds a range header to the request.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因为所有 HTTP 实体在 HTTP 消息中都表示为字节的序列，字节范围的概念是对任何 HTTP 实体有意义。 但是，并非所有客户端和服务器需要支持字节范围操作。  
  
 在请求的范围标头允许客户端请求它仅想要在 HTTP 实体接收指定的字节范围的某些部分。 支持范围标头请求时，不需要执行服务器。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a byte range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法向请求添加字节范围标头。  
  
 如果`range`为正、`range`参数指定范围的起始点。 服务器应开始发送数据从`range`到末尾的 HTTP 实体中的数据指定的参数。  
  
 如果`range`为负，`range`参数指定范围的结束点。 服务器应该开始将数据发送到的 HTTP 实体数据的开始从`range`指定参数。  
  
 因为所有 HTTP 实体在 HTTP 消息中都表示为字节的序列，字节范围的概念是对任何 HTTP 实体有意义。 但是，并非所有客户端和服务器需要支持字节范围操作。  
  
 在请求的范围标头允许客户端请求它仅想要在 HTTP 实体接收指定的字节范围的某些部分。 支持范围标头请求时，不需要执行服务器。  
  
 在请求服务器发送前 100 个字节 （从开头到字节位置 99） 将如下所示的 HTTP 协议请求的范围标头示例：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 对于此示例，`range`参数应为-99。  
  
 HTTP 服务器指示范围标头包含 Accept-ranges 标头的支持。 支持字节范围的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 如果 Accept-ranges 标头未收到来自服务器的响应的标头中，服务器不支持范围标头。 不支持范围，但识别 Accept-ranges 标头的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 仅与整个请求相关联的 HTTP 标头时从范围请求中收到响应，可以分析和通过上的属性使可用<xref:System.Net.HttpWebResponse>类。 在响应中返回与每个范围关联的标头。  
  
   
  
## Examples  
 下面的代码示例向请求添加范围标头。  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 -&gt; unit" Usage="httpWebRequest.AddRange range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a byte range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法向请求添加字节范围标头。  
  
 如果`range`为正、`range`参数指定范围的起始点。 服务器应开始发送数据从`range`到末尾的 HTTP 实体中的数据指定的参数。  
  
 如果`range`为负，`range`参数指定范围的结束点。 服务器应该开始将数据发送到的 HTTP 实体数据的开始从`range`指定参数。  
  
 因为所有 HTTP 实体在 HTTP 消息中都表示为字节的序列，字节范围的概念是对任何 HTTP 实体有意义。 但是，并非所有客户端和服务器需要支持字节范围操作。  
  
 在请求的范围标头允许客户端请求它仅想要在 HTTP 实体接收指定的字节范围的某些部分。 支持范围标头请求时，不需要执行服务器。  
  
 在请求服务器发送前 100 个字节 （从开头到字节位置 99） 将如下所示的 HTTP 协议请求的范围标头示例：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 对于此示例，`range`参数应为-99。  
  
 HTTP 服务器指示范围标头包含 Accept-ranges 标头的支持。 支持字节范围的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 如果 Accept-ranges 标头未收到来自服务器的响应的标头中，服务器不支持范围标头。 不支持范围，但识别 Accept-ranges 标头的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 仅与整个请求相关联的 HTTP 标头时从范围请求中收到响应，可以分析和通过上的属性使可用<xref:System.Net.HttpWebResponse>类。 在响应中返回与每个范围关联的标头。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int * int -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a byte range header to the request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法向请求添加字节范围标头。  
  
 因为所有 HTTP 实体在 HTTP 消息中都表示为字节的序列，字节范围的概念是对任何 HTTP 实体有意义。 但是，并非所有客户端和服务器需要支持字节范围操作。  
  
 在请求的范围标头允许客户端请求它仅想要在 HTTP 实体接收指定的字节范围的某些部分。 支持范围标头请求时，不需要执行服务器。  
  
 下面是在 HTTP 协议请求将请求前 100 个字节的范围标头的示例会：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 对于此示例，`from`参数将被指定为 0 和`to`参数将被指定为 99。 范围说明符被自动设置为"bytes"中，此方法。  
  
 HTTP 服务器指示范围标头包含 Accept-ranges 标头的支持。 支持字节范围的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 如果 Accept-ranges 标头未收到来自服务器的响应的标头中，服务器不支持范围标头。 不支持范围，但识别 Accept-ranges 标头的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 仅与整个请求相关联的 HTTP 标头时从范围请求中收到响应，可以分析和通过上的属性使可用<xref:System.Net.HttpWebResponse>类。 在响应中返回与每个范围关联的标头。  
  
   
  
## Examples  
 下面的代码示例向请求添加范围标头。  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a byte range header to the request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法向请求添加字节范围标头。  
  
 因为所有 HTTP 实体在 HTTP 消息中都表示为字节的序列，字节范围的概念是对任何 HTTP 实体有意义。 但是，并非所有客户端和服务器需要支持字节范围操作。  
  
 在请求的范围标头允许客户端请求它仅想要在 HTTP 实体接收指定的字节范围的某些部分。 支持范围标头请求时，不需要执行服务器。  
  
 下面是在 HTTP 协议请求将请求前 100 个字节的范围标头的示例会：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 对于此示例，`from`参数将被指定为 0 和`to`参数将被指定为 99。 范围说明符被自动设置为"bytes"中，此方法。  
  
 HTTP 服务器指示范围标头包含 Accept-ranges 标头的支持。 支持字节范围的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 如果 Accept-ranges 标头未收到来自服务器的响应的标头中，服务器不支持范围标头。 不支持范围，但识别 Accept-ranges 标头的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 仅与整个请求相关联的 HTTP 标头时从范围请求中收到响应，可以分析和通过上的属性使可用<xref:System.Net.HttpWebResponse>类。 在响应中返回与每个范围关联的标头。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a Range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法向请求添加范围标头。  
  
 如果`range`为正、`range`参数指定范围的起始点。 服务器应开始发送数据从`range`到末尾的 HTTP 实体中的数据指定的参数。  
  
 如果`range`为负，`range`参数指定范围的结束点。 服务器应该开始将数据发送到的 HTTP 实体数据的开始从`range`指定参数。  
  
 因为所有 HTTP 实体在 HTTP 消息中都表示为字节的序列，字节范围的概念是对任何 HTTP 实体有意义。 但是，并非所有客户端和服务器需要支持字节范围操作。  
  
 在请求的范围标头允许客户端请求它仅想要在 HTTP 实体接收指定的字节范围的某些部分。 支持范围标头请求时，不需要执行服务器。  
  
 `rangeSpecifier`参数将通常被指定为"bytes"，因为这是识别的大多数 HTTP 服务器的唯一范围说明符。 设置`rangeSpecifier`到另一个字符串参数的字节数 （由 IETF RFC 2616 中定义的字节范围说明符） 以外的自定义范围说明符允许支持。  
  
 下面是在 HTTP 协议请求将请求前 100 个字节的范围标头的示例会：  
  
 `Range: bytes=-99\r\n\r\n`  
  
 对于此示例，`rangeSpecifier`参数将被指定为"bytes"和`range`参数应为-99。  
  
 HTTP 服务器指示范围标头包含在响应中的 Accept-ranges 标头的支持。 支持字节范围的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 如果 Accept-ranges 标头未收到来自服务器的响应的标头中，服务器不支持范围标头。 不支持范围，但识别 Accept-ranges 标头的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 仅与整个请求相关联的 HTTP 标头时从范围请求中收到响应，可以分析和通过上的属性使可用<xref:System.Net.HttpWebResponse>类。 在响应中返回与每个范围关联的标头。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, range As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long range);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, range)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="range">The starting or ending point of the range.</param>
        <summary>Adds a Range header to a request for a specific range from the beginning or end of the requested data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法向请求添加范围标头。  
  
 如果`range`为正、`range`参数指定范围的起始点。 服务器应开始发送数据从`range`到末尾的 HTTP 实体中的数据指定的参数。  
  
 如果`range`为负，`range`参数指定范围的结束点。 服务器应该开始将数据发送到的 HTTP 实体数据的开始从`range`指定参数。  
  
 因为所有 HTTP 实体在 HTTP 消息中都表示为字节的序列，字节范围的概念是对任何 HTTP 实体有意义。 但是，并非所有客户端和服务器需要支持字节范围操作。  
  
 在请求的范围标头允许客户端请求它仅想要在 HTTP 实体接收指定的字节范围的某些部分。 支持范围标头请求时，不需要执行服务器。  
  
 `rangeSpecifier`参数将通常被指定为"bytes"，因为这是识别的大多数 HTTP 服务器的唯一范围说明符。 设置`rangeSpecifier`到另一个字符串参数的字节数 （由 IETF RFC 2616 中定义的字节范围说明符） 以外的自定义范围说明符允许支持。  
  
 下面是在 HTTP 协议请求将请求前 100 个字节的范围标头的示例会：  
  
 `Range: bytes=-99\r\n\r\n`  
  
 对于此示例，`rangeSpecifier`参数将被指定为"bytes"和`range`参数应为-99。  
  
 HTTP 服务器指示范围标头包含在响应中的 Accept-ranges 标头的支持。 支持字节范围的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 如果 Accept-ranges 标头未收到来自服务器的响应的标头中，服务器不支持范围标头。 不支持范围，但识别 Accept-ranges 标头的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 仅与整个请求相关联的 HTTP 标头时从范围请求中收到响应，可以分析和通过上的属性使可用<xref:System.Net.HttpWebResponse>类。 在响应中返回与每个范围关联的标头。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Integer, to As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, int from, int to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int * int -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a range header to a request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法向请求添加范围标头。  
  
 因为所有 HTTP 实体在 HTTP 消息中都表示为字节的序列，字节范围的概念是对任何 HTTP 实体有意义。 但是，并非所有客户端和服务器需要支持字节范围操作。  
  
 在请求的范围标头允许客户端请求它仅想要在 HTTP 实体接收指定的字节范围的某些部分。 支持范围标头请求时，不需要执行服务器。  
  
 `rangeSpecifier`参数将通常被指定为"bytes"，因为这是识别的大多数 HTTP 服务器的唯一范围说明符。 设置`rangeSpecifier`到另一个字符串参数的字节数 （由 IETF RFC 2616 中定义的字节范围说明符） 以外的自定义范围说明符允许支持。  
  
 下面是在 HTTP 协议请求将请求前 100 个字节的范围标头的示例会：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 对于此示例，`rangeSpecifier`参数将被指定为"bytes"`from`参数应为 0，和`to`参数应为 99。  
  
 HTTP 服务器指示范围标头包含在响应中的 Accept-ranges 标头的支持。 支持字节范围的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 标头中指定的字符串是将中通过指定范围说明符`rangeSpecifier`为此方法的参数。  
  
 如果 Accept-ranges 标头未收到来自服务器的响应的标头中，服务器不支持范围标头。 不支持范围，但识别 Accept-ranges 标头的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 仅与整个请求相关联的 HTTP 标头时从范围请求中收到响应，可以分析和通过上的属性使可用<xref:System.Net.HttpWebResponse>类。 在响应中返回与每个范围关联的标头。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (rangeSpecifier As String, from As Long, to As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::String ^ rangeSpecifier, long from, long to);" />
      <MemberSignature Language="F#" Value="member this.AddRange : string * int64 * int64 -&gt; unit" Usage="httpWebRequest.AddRange (rangeSpecifier, from, to)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">The description of the range.</param>
        <param name="from">The position at which to start sending data.</param>
        <param name="to">The position at which to stop sending data.</param>
        <summary>Adds a range header to a request for a specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType>方法向请求添加范围标头。  
  
 因为所有 HTTP 实体在 HTTP 消息中都表示为字节的序列，字节范围的概念是对任何 HTTP 实体有意义。 但是，并非所有客户端和服务器需要支持字节范围操作。  
  
 在请求的范围标头允许客户端请求它仅想要在 HTTP 实体接收指定的字节范围的某些部分。 支持范围标头请求时，不需要执行服务器。  
  
 `rangeSpecifier`参数将通常被指定为"bytes"，因为这是识别的大多数 HTTP 服务器的唯一范围说明符。 设置`rangeSpecifier`到另一个字符串参数的字节数 （由 IETF RFC 2616 中定义的字节范围说明符） 以外的自定义范围说明符允许支持。  
  
 下面是在 HTTP 协议请求将请求前 100 个字节的范围标头的示例会：  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 对于此示例，`rangeSpecifier`参数将被指定为"bytes"`from`参数应为 0，和`to`参数应为 99。  
  
 HTTP 服务器指示范围标头包含在响应中的 Accept-ranges 标头的支持。 支持字节范围的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Accept-ranges 标头中指定的字符串是将中通过指定范围说明符`rangeSpecifier`为此方法的参数。  
  
 如果 Accept-ranges 标头未收到来自服务器的响应的标头中，服务器不支持范围标头。 不支持范围，但识别 Accept-ranges 标头的服务器的 Accept-ranges 标头的示例将如下所示：  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 仅与整个请求相关联的 HTTP 标头时从范围请求中收到响应，可以分析和通过上的属性使可用<xref:System.Net.HttpWebResponse>类。 在响应中返回与每个范围关联的标头。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> is greater than <paramref name="to" />  -or-  <paramref name="from" /> or <paramref name="to" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> is invalid.</exception>
        <exception cref="T:System.InvalidOperationException">The range header could not be added.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Address As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Address { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Address : Uri" Usage="System.Net.HttpWebRequest.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the Uniform Resource Identifier (URI) of the Internet resource that actually responds to the request.</summary>
        <value>标识实际对请求作出响应的 Internet 资源的 <see cref="T:System.Uri" />。 默认值是供 <see cref="M:System.Net.WebRequest.Create(System.String)" /> 方法用来初始化请求的 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Address%2A>在请求期间发生的任何重定向完成后，将属性设置为该 URI。  
  
 原始请求的 URI 就会保留在<xref:System.Net.HttpWebRequest.RequestUri%2A>属性。  
  
   
  
## Examples  
 下面的代码示例检查以查看是否<xref:System.Net.HttpWebRequest>对象`req`已重定向到其他位置来完成请求，并将的值设置`hasChanged`变量`true`如果请求已重定向; 否则为`hasChanged`设置为`false`。  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowAutoRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowAutoRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAutoRedirect : bool with get, set" Usage="System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the request should follow redirection responses.</summary>
        <value>如果请求应自动遵循来自 Internet 资源的重定向响应，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>到`true`如果你想要自动遵循到新位置的资源的 HTTP 重定向标头的请求。 通过设置最大数量的重定向按照<xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A>属性。  
  
 如果<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>设置为`false`，所有响应包含 HTTP 状态代码 300 从 399 都返回到应用程序。  
  
 在自动重定向时被清除的 Authorization 标头和<xref:System.Net.HttpWebRequest>会自动尝试对重定向的位置重新进行身份验证。 在实践中，这意味着应用程序无法将自定义身份验证信息打包在 Authorization 标头，如果它是可能会遇到重定向。 相反，应用程序必须实现并注册一个自定义身份验证模块。 <xref:System.Net.AuthenticationManager?displayProperty=nameWithType>和相关的类用于实现自定义身份验证模块。 <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType>方法注册自定义身份验证模块。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>属性，以允许跟随重定向响应的请求。  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowReadStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowReadStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowReadStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to buffer the received from the Internet resource.</summary>
        <value>如果为 <see langword="true" />，则启用对从 Internet 资源接收的数据进行缓冲处理；如果为 <see langword="false" />，则禁用缓冲处理。 默认值为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowWriteStreamBuffering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowWriteStreamBuffering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowWriteStreamBuffering : bool with get, set" Usage="System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to buffer the data sent to the Internet resource.</summary>
        <value>如果为 <see langword="true" />，则允许对发送到 Internet 资源的数据进行缓冲处理；如果为 <see langword="false" />，则禁用缓冲处理。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A>是`true`，以便随时可重新发送发生重定向或身份验证请求，在内存中缓冲的数据。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A>属性来禁用数据缓冲。  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>设置<see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />到<see langword="true" />上载大型数据集，因为数据缓冲区可能会使用所有可用内存时可能会导致性能问题。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticDecompression As DecompressionMethods" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::DecompressionMethods AutomaticDecompression { System::Net::DecompressionMethods get(); void set(System::Net::DecompressionMethods value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticDecompression : System.Net.DecompressionMethods with get, set" Usage="System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the type of decompression that is used.</summary>
        <value>A<see cref="T:System.Net.DecompressionMethods" />对象，该值指示使用的解压缩类型。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">The object's current state does not allow this property to be set.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetRequestStream (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetRequestStream(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetRequestStream : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetRequestStream (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">The state object for this request.</param>
        <summary>Begins an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous request.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法会启动对用于将数据发送以流的异步请求<xref:System.Net.HttpWebRequest>。 异步回调方法使用<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法以返回实际的流。  
  
 <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法需要完成 （DNS 解析、 代理检测和 TCP 套接字连接，例如），此方法才会异步某些同步安装程序任务。 因此，此方法应永远不会调用用户界面 (UI) 线程上因为它可能需要相当长的时间 （最多几分钟时间，具体取决于网络设置） 以完成初始同步安装程序任务，然后异常引发错误或该方法成功。  
  
 若要了解有关线程池的详细信息，请参阅[托管线程池](~/docs/standard/threading/the-managed-thread-pool.md)。  
  
> [!NOTE]
>  你的应用程序不能混合使用的特定请求的同步和异步方法。 如果调用<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法，则必须使用<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法来检索响应。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法来执行对流实例的异步请求。  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">The <see cref="P:System.Net.HttpWebRequest.Method" /> property is GET or HEAD.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.</exception>
        <exception cref="T:System.InvalidOperationException">The stream is being used by a previous call to <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.  -or-  The thread pool is running out of threads.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, requests that write data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.</exception>
        <exception cref="T:System.ObjectDisposedException">In a .NET Compact Framework application, a request stream with zero content length was not obtained and closed correctly. For more information about handling zero content length requests, see [Network Programming in the .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginGetResponse (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginGetResponse(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginGetResponse : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpWebRequest.BeginGetResponse (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate</param>
        <param name="state">The state object for this request.</param>
        <summary>Begins an asynchronous request to an Internet resource.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous request for a response.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法从 Internet 资源会启动对响应的异步请求。 异步回调方法使用<xref:System.Net.HttpWebRequest.EndGetResponse%2A>方法返回的实际<xref:System.Net.WebResponse>。  
  
 A<xref:System.Net.ProtocolViolationException>时设置的属性，在某些情况下引发<xref:System.Net.HttpWebRequest>类是冲突。 如果应用程序设置，则会发生此异常<xref:System.Net.HttpWebRequest.ContentLength%2A>属性和<xref:System.Net.HttpWebRequest.SendChunked%2A>属性`true`，然后将发送 HTTP GET 请求。 如果应用程序尝试向发送分块请求到的服务器，仅支持 HTTP 1.0 协议，这不支持，则会发生此异常。 如果应用程序尝试发送数据而无需设置，则会发生此异常<xref:System.Net.HttpWebRequest.ContentLength%2A>属性或<xref:System.Net.HttpWebRequest.SendChunked%2A>是`false`禁用缓冲和 keepalive 连接上 (<xref:System.Net.HttpWebRequest.KeepAlive%2A>属性是`true`)`.`  
  
 如果<xref:System.Net.WebException>是引发，使用<xref:System.Net.WebException.Response%2A>和<xref:System.Net.WebException.Status%2A>异常来确定来自服务器的响应的属性。  
  
 <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法需要完成 （DNS 解析、 代理检测和 TCP 套接字连接，例如），此方法才会异步某些同步安装程序任务。 因此，此方法应永远不会调用用户界面 (UI) 线程上因为它可能需要相当长的时间 （最多几分钟时间，具体取决于网络设置） 以完成初始同步安装程序任务，然后异常引发错误或该方法成功。  
  
 若要了解有关线程池的详细信息，请参阅[ &#91; \<topic://cpconthreadpooling >&#93;](http://msdn.microsoft.com/library/2be05b06-a42e-4c9d-a739-96c21d673927)。  
  
> [!NOTE]
>  你的应用程序不能混合使用的特定请求的同步和异步方法。 如果调用<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法，则必须使用<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法来检索响应。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[ &#91; \<topic://conUsingNetworkTracing >&#93;](http://msdn.microsoft.com/library/e993b7c3-087f-45d8-9c02-9dded936d804)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法来执行对 Internet 资源的异步请求。  
  
> [!NOTE]
>  在异步请求的情况下它是客户端应用程序，来实现其自己的超时机制的责任。 下面的代码示例演示如何执行此操作。  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The stream is already in use by a previous call to <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.  -or-  The thread pool is running out of threads.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> is GET or HEAD, and either <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater than zero or <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="true" />.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, and either <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" /> and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.  -or-  The <see cref="T:System.Net.HttpWebRequest" /> has an entity body but the <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method is called without calling the <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" /> method.  -or-  The <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater than zero, but the application does not write all of the promised data.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); void set(System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection with get, set" Usage="System.Net.HttpWebRequest.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the collection of security certificates that are associated with this request.</summary>
        <value>
          <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" />包含与此请求关联的安全证书。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序可以将证书添加到集合，但可能没有访问权限。 若要使用集合中包含的证书，该应用程序必须具有相同的访问权限，在颁发证书的实体。  
  
> [!NOTE]
>  框架缓存 SSL 会话，因为它们创建，并尝试尽可能重用为新请求，缓存的会话。 当尝试重复使用的 SSL 会话，框架将使用的第一个元素<xref:System.Net.HttpWebRequest.ClientCertificates%2A>（如果没有一个），或尝试重用匿名会话，如果<xref:System.Net.HttpWebRequest.ClientCertificates%2A>为空。  
  
> [!NOTE]
>  出于性能原因，不应添加到客户端证书<xref:System.Net.HttpWebRequest>除非你知道该服务器将要求提供。  
>   
>  有关代码示例演示如何枚举客户端证书存储中的证书，请参阅<xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value specified for a set operation is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberSignature Language="VB.NET" Value="Public Property Connection As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Connection { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Connection : string with get, set" Usage="System.Net.HttpWebRequest.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Connection" /> HTTP header.</summary>
        <value>
          <see langword="Connection" /> HTTP 标头的值。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请求将发送<xref:System.Net.HttpWebRequest.Connection%2A>到 Internet 资源作为属性`Connection`HTTP 标头。 如果值<xref:System.Net.HttpWebRequest.KeepAlive%2A>属性是`true`，"保持活动状态"的值追加到末尾`Connection`标头。  
  
 若要清除`Connection`设置 HTTP 标头，<xref:System.Net.HttpWebRequest.Connection%2A>属性`null`。  
  
 更改<xref:System.Net.HttpWebRequest.Connection%2A>属性后已通过调用启动请求<xref:System.Net.HttpWebRequest.GetRequestStream%2A>， <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.HttpWebRequest.GetResponse%2A>，或<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法抛出异常<xref:System.InvalidOperationException>。  
  
> [!NOTE]
>  此属性的值存储在<xref:System.Net.WebHeaderCollection>。 如果设置了 WebHeaderCollection，则该属性值将丢失。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.Connection%2A>属性来设置连接 HTTP 标头的值。  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value of <see cref="P:System.Net.HttpWebRequest.Connection" /> is set to Keep-alive or Close.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ConnectionGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ConnectionGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionGroupName : string with get, set" Usage="System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the connection group for the request.</summary>
        <value>该请求的连接组的名称。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A>属性使您能够将请求与连接组相关联。 当你的应用程序为不同的用户，例如从数据库服务器中检索客户信息的网站向一个服务器发出请求时，这非常有用。  
  
   
  
## Examples  
 下面的代码示例演示如何使用用户信息以便形成一个连接组，前提假定变量`username`， `password`，和`domain`调用此代码之前已设置应用程序。  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>每个连接组创建其他连接的服务器。这可能会导致超出设置的连接数<see cref="P:System.Net.ServicePoint.ConnectionLimit" />属性为该服务器。</para>
        </block>
        <altmember cref="P:System.Net.Configuration.ConnectionManagementElement.MaxConnection" />
        <altmember cref="P:System.Net.WebRequest.ConnectionGroupName" />
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long ContentLength { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int64 with get, set" Usage="System.Net.HttpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see langword="Content-length" /> HTTP header.</summary>
        <value>要发送到 Internet 资源的数据的字节数。 默认值为 -1，该值指示尚未设置该属性，并且没有要发送的请求数据。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentLength%2A>属性包含的值将作为发送`Content-length`与请求的 HTTP 标头。  
  
 非-1 中的任何值<xref:System.Net.HttpWebRequest.ContentLength%2A>属性指示，请求将数据上载和上载数据的方法允许要在设置<xref:System.Net.HttpWebRequest.Method%2A>属性。  
  
 后<xref:System.Net.HttpWebRequest.ContentLength%2A>属性设置为一个值，字节数必须将写入到通过调用返回的请求流<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法或二者<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>和<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法。  
  
> [!NOTE]
>  此属性的值存储在<xref:System.Net.WebHeaderCollection>。 如果设置了 WebHeaderCollection，则该属性值将丢失。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.ContentLength%2A>属性设置为发布的字符串的长度。  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The new <see cref="P:System.Net.HttpWebRequest.ContentLength" /> value is less than 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Net.HttpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Content-type" /> HTTP header.</summary>
        <value>
          <see langword="Content-type" /> HTTP 标头的值。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContentType%2A>属性包含请求的媒体类型。 分配给值<xref:System.Net.HttpWebRequest.ContentType%2A>属性替换任何现有内容，当请求发送`Content-type`HTTP 标头。  
  
 若要清除`Content-type`设置 HTTP 标头，<xref:System.Net.HttpWebRequest.ContentType%2A>属性`null`。  
  
> [!NOTE]
>  此属性的值存储在<xref:System.Net.WebHeaderCollection>。 如果<xref:System.Net.WebHeaderCollection>设置，该属性值将丢失。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.ContentType%2A>属性。  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueDelegate As HttpContinueDelegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::HttpContinueDelegate ^ ContinueDelegate { System::Net::HttpContinueDelegate ^ get(); void set(System::Net::HttpContinueDelegate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueDelegate : System.Net.HttpContinueDelegate with get, set" Usage="System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the delegate method called when an HTTP 100-continue response is received from the Internet resource.</summary>
        <value>实现回调方法的委托，该方法在从 Internet 资源返回 HTTP Continue 响应时执行。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ContinueDelegate%2A>属性指定当客户端接收到一个 100 时要调用的回调方法-继续响应。  
  
 当<xref:System.Net.HttpWebRequest.ContinueDelegate%2A>属性设置，则客户端调用委托每当协议的类型的响应<xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType>(100) 接收。 这是你希望客户端以显示从 Internet 资源接收的数据的状态的情况下很有用。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContinueTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a timeout, in milliseconds, to wait until the 100-Continue is received from the server.</summary>
        <value>在接收到 100-Continue 之前要等待的超时（以毫秒为单位）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 100-继续在超时到期时，可以发送的实体正文之前收到响应。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CookieContainer As CookieContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::CookieContainer ^ CookieContainer { System::Net::CookieContainer ^ get(); void set(System::Net::CookieContainer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieContainer : System.Net.CookieContainer with get, set" Usage="System.Net.HttpWebRequest.CookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the cookies associated with the request.</summary>
        <value>包含与此请求关联的 Cookie 的 <see cref="T:System.Net.CookieContainer" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A>属性提供的实例<xref:System.Net.CookieContainer>类，其中包含与此请求关联的 cookie。  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A> 是`null`默认情况下。 你必须分配<xref:System.Net.CookieContainer>有中返回的 cookie 的属性的对象<xref:System.Net.HttpWebResponse.Cookies%2A>属性<xref:System.Net.HttpWebResponse>返回<xref:System.Net.HttpWebRequest.GetResponse%2A>方法。  
  
> [!NOTE]
>  出于安全原因，默认情况下 cookie 处于禁用状态。 如果你想要使用 cookie，使用<xref:System.Net.HttpWebRequest.CookieContainer%2A>属性来启用 cookie。  
  
   
  
## Examples  
 下面的代码示例将请求发送到 URL，并显示在响应中返回的 cookie。  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.CookieContainer" />
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Credentials As ICredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::ICredentials ^ Credentials { System::Net::ICredentials ^ get(); void set(System::Net::ICredentials ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.Net.ICredentials with get, set" Usage="System.Net.HttpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets authentication information for the request.</summary>
        <value>包含与该请求关联的身份验证凭据的 <see cref="T:System.Net.ICredentials" />。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Credentials%2A>属性包含身份验证信息以标识请求的创建者。 <xref:System.Net.HttpWebRequest.Credentials%2A>属性可以是<xref:System.Net.NetworkCredential>，而在哪些情况下，用户、 密码和域信息中包含<xref:System.Net.NetworkCredential>对象用于进行身份验证请求，也可以是<xref:System.Net.CredentialCache>，在这种情况下统一资源请求标识符 (URI) 用于确定要用于对请求进行身份验证用户、 密码和域信息。  
  
 在大多数客户端方案，应使用<xref:System.Net.CredentialCache.DefaultCredentials%2A>属性，其中包含当前登录用户的凭据。 若要执行此操作，将设置<xref:System.Net.WebClient.UseDefaultCredentials%2A>属性`true`而不是设置此属性。  
  
 如果<xref:System.Net.HttpWebRequest>类正在使用在中间层应用程序，如 ASP.NET 应用程序中的凭据<xref:System.Net.CredentialCache.DefaultCredentials%2A>属性属于运行 ASP 页面 （服务器端凭据） 的帐户。 通常情况下，将此属性设置为客户端的名义发出的请求的凭据。  
  
> [!NOTE]
>  无法使用 NTLM 身份验证方案，模拟其他用户。 必须专门配置 Kerberos 以支持模拟。  
  
 若要限制 HttpWebRequest 对一个或多个身份验证方法，请使用<xref:System.Net.CredentialCache>类并将你的凭据绑定到一个或多个身份验证方案  
  
 支持的身份验证方案包括摘要式、 协商、 Kerberos、 NTLM 和 Basic。  
  
 出于安全原因，自动遵循重定向时，你想要包含在中的重定向将凭据存储<xref:System.Net.CredentialCache>并将其分配给此属性。 此属性将自动设置为`null`在重定向，如果它包含除<xref:System.Net.CredentialCache>。 具有此属性的值自动设置为`null`在这些情况下防止凭据被发送到任何非预期目标。
  
## Examples  
 下面的代码示例设置请求的凭据。  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberSignature Language="VB.NET" Value="Public Property Date As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Date { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.Date : DateTime with get, set" Usage="System.Net.HttpWebRequest.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or set the <see langword="Date" /> HTTP header value to use in an HTTP request.</summary>
        <value>HTTP 请求中的 Date 标头值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果日期标头`null`，则返回值将设置为<xref:System.DateTime.MinValue?displayProperty=nameWithType>。  
  
 <xref:System.Net.HttpWebRequest.Date%2A>属性是一种标准<xref:System.DateTime?displayProperty=nameWithType>对象，并可以包含<xref:System.DateTimeKind?displayProperty=nameWithType>字段<xref:System.DateTimeKind.Local?displayProperty=nameWithType>， <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>，或<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 使用时，可以设置任何类型的时间<xref:System.Net.HttpWebRequest.Date%2A>属性。 如果<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>进行设置或检索，<xref:System.Net.HttpWebRequest.Date%2A>属性被假定为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>（当地时间）。  
  
 中的类<xref:System.Net>命名空间始终将其写出<xref:System.Net.HttpWebRequest.Date%2A>是在使用格林威治标准时间 (Utc) 格式的标准窗体中的传输期间在网络上的属性。  
  
 如果<xref:System.Net.HttpWebRequest.Date%2A>属性设置为<xref:System.DateTime.MinValue?displayProperty=nameWithType>，则`Date`HTTP 标头删除从<xref:System.Net.HttpWebRequest.Headers%2A>属性和<xref:System.Net.WebHeaderCollection>。  
  
 如果<xref:System.Net.HttpWebRequest.Date%2A>属性是<xref:System.DateTime.MinValue?displayProperty=nameWithType>，这指示`Date`HTTP 标头未包含在<xref:System.Net.HttpWebRequest.Headers%2A>属性和<xref:System.Net.WebHeaderCollection>。  
  
> [!NOTE]
>  此属性的值存储在<xref:System.Net.WebHeaderCollection>。 如果设置了 WebHeaderCollection，则该属性值将丢失。  
  
 如果<xref:System.Net.HttpWebRequest.Date%2A>设置和尝试发送<xref:System.Net.HttpWebRequest>没有正文，则<xref:System.Net.ProtocolViolationException?displayProperty=nameWithType>将引发<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>， <xref:System.Net.HttpWebRequest.GetResponse%2A>，和<xref:System.Net.HttpWebRequest.EndGetResponse%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultCachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::Cache::RequestCachePolicy ^ DefaultCachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default cache policy for this request.</summary>
        <value>一个 <see cref="T:System.Net.Cache.HttpRequestCachePolicy" />，它指定当没有其他策略适用时对此请求有效的缓存策略。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置此属性注册为 HTTP 和 HTTPS 方案指定的策略。 如果此请求使用此策略：  
  
 没有任何<xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType>为此请求指定的属性。  
  
 \- 或 -  
  
 不适用到统一资源标识符 (URI) 的缓存策略用于创建此请求指定文件的计算机和应用程序配置。  
  
 缓存策略将确定是否可以从缓存而不是将请求发送到的资源主机计算机获取请求的资源。  
  
 如果资源的响应流是检索，并且读取到流末尾，资源的副本是仅添加到缓存。 因此相同的资源的另一个请求可以使用缓存的副本，具体取决于此请求的缓存策略级别。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">无限制地访问网络资源。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Net.Cache.RequestCachePolicy" />
        <altmember cref="T:System.Net.Cache.HttpRequestCacheLevel" />
        <altmember cref="T:System.Net.Cache.RequestCacheLevel" />
        <altmember cref="P:System.Net.WebRequest.CachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumErrorResponseLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumErrorResponseLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumErrorResponseLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default maximum length of an HTTP error response.</summary>
        <value>HTTP 错误响应的默认最大长度。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is less than 0 and is not equal to -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultMaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int DefaultMaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default for the <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" /> property.</summary>
        <value>接收的响应标头的默认最大长度，以 KB（1024 字节）为单位。 默认配置文件将此值设置为 64 KB。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 响应状态行以及作为 HTTP 协议的一部分接收任何额外的控制字符，接收到响应标头的长度。 值为-1 表示没有限制收到; 对响应标头值为 0 表示将所有请求将都失败。  
  
 也可以在配置文件中更改此值。 此属性的影响可以通过设置重写<xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A>实例上的属性<xref:System.Net.HttpWebRequest>类。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is not equal to -1 and is less than zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ends an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetRequestStream (asyncResult As IAsyncResult) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending request for a stream.</param>
        <summary>Ends an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法完成对已由启动的流的异步请求<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法。 后<xref:System.IO.Stream>返回对象，因此可以将数据与<xref:System.Net.HttpWebRequest>使用<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>方法。  
  
> [!NOTE]
>  必须设置的值<xref:System.Net.HttpWebRequest.ContentLength%2A>数据写入流之前的属性。  
  
> [!CAUTION]
>  必须调用<xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>方法来关闭的流并释放重用的连接。 未关闭的流将导致你的应用程序耗尽连接。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法来结束对流实例的异步请求。  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">The request did not complete, and no stream is available.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by the current instance from a call to <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called previously using <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  An error occurred while processing the request.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; context) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef context As TransportContext) As Stream" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetRequestStream (asyncResult As IAsyncResult, ByRef transportContext As TransportContext) As Stream" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ EndGetRequestStream(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::TransportContext ^ % transportContext);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.EndGetRequestStream : IAsyncResult *  -&gt; System.IO.Stream" Usage="httpWebRequest.EndGetRequestStream (asyncResult, transportContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" />
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="transportContext" Type="System.Net.TransportContext&amp;" RefType="out" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending request for a stream.</param>
        <param name="context">To be added.</param>
        <param name="transportContext">To be added.</param>
        <summary>Ends an asynchronous request for a <see cref="T:System.IO.Stream" /> object to use to write data and outputs the <see cref="T:System.Net.TransportContext" /> associated with the stream.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A>方法完成对已由启动的流的异步请求<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法和输出<xref:System.Net.TransportContext>与流关联。 后<xref:System.IO.Stream>返回对象，因此可以将数据与<xref:System.Net.HttpWebRequest>使用<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>方法。  
  
 某些具有扩展保护使用集成的 Windows 身份验证应用程序可能需要能够查询使用的传输层<xref:System.Net.HttpWebRequest>以检索从基础 TLS 通道的通道绑定令牌 (CBT)。 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法提供此信息对其具有请求正文的 HTTP 方法的访问 (`POST`和`PUT`请求)。 这仅需要如果应用程序实现其自己的身份验证，并需要访问 CBT。  
  
> [!NOTE]
>  如果应用程序需要设置的值<xref:System.Net.HttpWebRequest.ContentLength%2A>属性，则这必须在检索流，并向其中写入数据之前的情况下完成。  
  
> [!CAUTION]
>  必须调用<xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>方法来关闭的流并释放重用的连接。 未关闭的流将导致你的应用程序耗尽连接。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by the current instance from a call to <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called previously using <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.IO.IOException">The request did not complete, and no stream is available.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  An error occurred while processing the request.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndGetResponse (asyncResult As IAsyncResult) As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ EndGetResponse(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndGetResponse : IAsyncResult -&gt; System.Net.WebResponse" Usage="httpWebRequest.EndGetResponse asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The pending request for a response.</param>
        <summary>Ends an asynchronous request to an Internet resource.</summary>
        <returns>A <see cref="T:System.Net.WebResponse" /> that contains the response from the Internet resource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.EndGetResponse%2A>方法完成已由调用启动对 Internet 资源的异步请求<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法。  
  
> [!CAUTION]
>  必须调用<xref:System.Net.HttpWebResponse.Close%2A>方法来关闭的流并释放连接。 如果不这样做可能会导致你的应用程序耗尽连接。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.EndGetResponse%2A>方法来结束对 Internet 资源的异步请求。  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called previously using <paramref name="asyncResult." />  -or-  The <see cref="P:System.Net.HttpWebRequest.ContentLength" /> property is greater than 0 but the data has not been written to the request stream.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  An error occurred while processing the request.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> was not returned by the current instance from a call to <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberSignature Language="VB.NET" Value="Public Property Expect As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Expect { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Expect : string with get, set" Usage="System.Net.HttpWebRequest.Expect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Expect" /> HTTP header.</summary>
        <value>内容<see langword="Expect" />HTTP 标头。 默认值为 <see langword="null" />。  
  
 <block subset="none" type="note"><para> 此属性的值存储在<see cref="T:System.Net.WebHeaderCollection" />。如果了 webheadercollection，则属性值将丢失。  </para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="Expect" /> is set to a string that contains "100-continue" as a substring.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="httpWebRequest.GetObjectData (serializationInfo, streamingContext)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> that specifies the destination for this serialization.</param>
        <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data required to serialize the target object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中包含的任何对象<xref:System.Runtime.Serialization.SerializationInfo>会自动跟踪和序列化格式化程序。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a <see cref="T:System.IO.Stream" /> object to use to write request data.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetRequestStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::IO::Stream ^ GetRequestStream();" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream : unit -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a <see cref="T:System.IO.Stream" /> object to use to write request data.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法返回的流用于将数据发送以<xref:System.Net.HttpWebRequest>。 后<xref:System.IO.Stream>返回对象，因此可以将数据与<xref:System.Net.HttpWebRequest>使用<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>方法。  
  
 如果应用程序需要设置的值<xref:System.Net.HttpWebRequest.ContentLength%2A>属性，则这必须检索流之前的情况下完成。  
  
 必须调用<xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>方法来关闭的流并释放重用的连接。 未关闭的流将导致你的应用程序耗尽连接。  
  
> [!NOTE]
>  你的应用程序不能混合使用的特定请求的同步和异步方法。 如果调用<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法，则必须使用<xref:System.Net.HttpWebRequest.GetResponse%2A>方法来检索响应。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法返回的流实例。  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">The <see cref="P:System.Net.HttpWebRequest.Method" /> property is GET or HEAD.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method is called more than once.  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, requests that write data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  The time-out period for the request expired.  -or-  An error occurred while processing the request.</exception>
        <exception cref="T:System.ObjectDisposedException">In a .NET Compact Framework application, a request stream with zero content length was not obtained and closed correctly. For more information about handling zero content length requests, see [Network Programming in the .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRequestStream (ByRef context As TransportContext) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetRequestStream([Runtime::InteropServices::Out] System::Net::TransportContext ^ % context);" />
      <MemberSignature Language="F#" Value="override this.GetRequestStream :  -&gt; System.IO.Stream" Usage="httpWebRequest.GetRequestStream context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context">The <see cref="T:System.Net.TransportContext" /> for the <see cref="T:System.IO.Stream" />.</param>
        <summary>Gets a <see cref="T:System.IO.Stream" /> object to use to write request data and outputs the <see cref="T:System.Net.TransportContext" /> associated with the stream.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法返回的流用于将数据发送以<xref:System.Net.HttpWebRequest>并输出<xref:System.Net.TransportContext>与流关联。 后<xref:System.IO.Stream>返回对象，因此可以将数据与<xref:System.Net.HttpWebRequest>使用<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>方法。  
  
 某些具有扩展保护使用集成的 Windows 身份验证应用程序可能需要能够查询使用的传输层<xref:System.Net.HttpWebRequest>以检索从基础 TLS 通道的通道绑定令牌 (CBT)。 <xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法提供此信息对其具有请求正文的 HTTP 方法的访问 (`POST`和`PUT`请求)。 这仅需要如果应用程序实现其自己的身份验证，并需要访问 CBT。  
  
 如果应用程序需要设置的值<xref:System.Net.HttpWebRequest.ContentLength%2A>属性，则这必须检索流之前的情况下完成。  
  
 必须调用<xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>方法来关闭的流并释放重用的连接。 未关闭的流将导致你的应用程序耗尽连接。  
  
> [!NOTE]
>  你的应用程序不能混合使用的特定请求的同步和异步方法。 如果调用<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法，则必须使用<xref:System.Net.HttpWebRequest.GetResponse%2A>方法来检索响应。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">The <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method was unable to obtain the <see cref="T:System.IO.Stream" />.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method is called more than once.  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, requests that write data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">The <see cref="P:System.Net.HttpWebRequest.Method" /> property is GET or HEAD.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  The time-out period for the request expired.  -or-  An error occurred while processing the request.</exception>
        <altmember cref="T:System.Net.TransportContext" />
        <altmember cref="M:System.Net.TransportContext.GetChannelBinding(System.Security.Authentication.ExtendedProtection.ChannelBindingKind)" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" />
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetResponse () As WebResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Net::WebResponse ^ GetResponse();" />
      <MemberSignature Language="F#" Value="override this.GetResponse : unit -&gt; System.Net.WebResponse" Usage="httpWebRequest.GetResponse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a response from an Internet resource.</summary>
        <returns>A <see cref="T:System.Net.WebResponse" /> that contains the response from the Internet resource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.GetResponse%2A>方法返回<xref:System.Net.WebResponse>对象，其中包含来自 Internet 资源的响应。 实际的实例，则返回<xref:System.Net.HttpWebResponse>，和可以强制转换为该类以访问 HTTP 特定属性。  
  
 A<xref:System.Net.ProtocolViolationException>时设置的属性，在某些情况下引发<xref:System.Net.HttpWebRequest>类是冲突。 如果应用程序设置，则会发生此异常<xref:System.Net.HttpWebRequest.ContentLength%2A>属性和<xref:System.Net.HttpWebRequest.SendChunked%2A>属性`true`，然后将发送 HTTP GET 请求。 如果应用程序尝试向发送分块请求到的服务器，仅支持 HTTP 1.0 协议，这不支持，则会发生此异常。 如果应用程序尝试发送数据而无需设置，则会发生此异常<xref:System.Net.HttpWebRequest.ContentLength%2A>属性或<xref:System.Net.HttpWebRequest.SendChunked%2A>是`false`禁用缓冲和 keepalive 连接上 (<xref:System.Net.HttpWebRequest.KeepAlive%2A>属性是`true`)`.`  
  
> [!CAUTION]
>  必须调用<xref:System.Net.HttpWebResponse.Close%2A>方法来关闭的流并释放连接。 如果不这样做可能会导致你的应用程序耗尽连接。  
  
 使用 POST 方法时，必须获取请求流、 将数据发布，写入和关闭的流。 此方法将一直阻塞等待内容发布;如果没有超时设置，并且不提供内容，调用的线程块无限期。  
  
> [!NOTE]
>  多次调用<xref:System.Net.HttpWebRequest.GetResponse%2A>返回相同的响应对象; 请求不重新颁发。  
  
> [!NOTE]
>  你的应用程序不能混合使用的特定请求的同步和异步方法。 如果调用<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法，则必须使用<xref:System.Net.HttpWebRequest.GetResponse%2A>方法来检索响应。  
  
> [!NOTE]
>  如果<xref:System.Net.WebException>是引发，使用<xref:System.Net.WebException.Response%2A>和<xref:System.Net.WebException.Status%2A>异常来确定来自服务器的响应的属性。  
  
> [!NOTE]
>  当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  出于安全原因，默认情况下 cookie 处于禁用状态。 如果你想要使用 cookie，使用<xref:System.Net.HttpWebRequest.CookieContainer%2A>属性来启用 cookie。  
  
   
  
## Examples  
 下面的代码示例获取请求的响应。  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The stream is already in use by a previous call to <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.  -or-  <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to a value and <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> is GET or HEAD, and either <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater or equal to zero or <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="true" />.  -or-  <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> is <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> is <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />, and <see cref="P:System.Net.HttpWebRequest.Method" /> is POST or PUT.  -or-  The <see cref="T:System.Net.HttpWebRequest" /> has an entity body but the <see cref="M:System.Net.HttpWebRequest.GetResponse" /> method is called without calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> method.  -or-  The <see cref="P:System.Net.HttpWebRequest.ContentLength" /> is greater than zero, but the application does not write all of the promised data.</exception>
        <exception cref="T:System.NotSupportedException">The request cache validator indicated that the response for this request can be served from the cache; however, this request includes data to be sent to the server. Requests that send data must not use the cache. This exception can occur if you are using a custom cache validator that is incorrectly implemented.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> was previously called.  -or-  The time-out period for the request expired.  -or-  An error occurred while processing the request.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HaveResponse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HaveResponse { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HaveResponse : bool" Usage="System.Net.HttpWebRequest.HaveResponse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether a response has been received from an Internet resource.</summary>
        <value>如果接收到了响应，则为 <see langword="true" />，否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例检查<xref:System.Net.HttpWebRequest.HaveResponse%2A>属性来确定是否已从 Internet 资源接收响应。  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Headers As WebHeaderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::WebHeaderCollection ^ Headers { System::Net::WebHeaderCollection ^ get(); void set(System::Net::WebHeaderCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Net.WebHeaderCollection with get, set" Usage="System.Net.HttpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies a collection of the name/value pairs that make up the HTTP headers.</summary>
        <value>包含构成 HTTP 请求标头的名称/值对的 <see cref="T:System.Net.WebHeaderCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Headers%2A>集合包含与请求关联的协议标头。 下表列出了 HTTP 标头未存储在<xref:System.Net.HttpWebRequest.Headers%2A>集合但系统设置的或者设置的属性或方法。  
  
|Header|通过设置|  
|------------|------------|  
|接受|通过设置<xref:System.Net.HttpWebRequest.Accept%2A>属性。|  
|连接|通过设置<xref:System.Net.HttpWebRequest.Connection%2A>属性和<xref:System.Net.HttpWebRequest.KeepAlive%2A>属性。|  
|内容长度|通过设置<xref:System.Net.HttpWebRequest.ContentLength%2A>属性。|  
|Content-Type|通过设置<xref:System.Net.HttpWebRequest.ContentType%2A>属性。|  
|预期|通过设置<xref:System.Net.HttpWebRequest.Expect%2A>属性。|  
|日期|通过设置<xref:System.Net.HttpWebRequest.Date%2A>属性。|  
|Host|通过设置<xref:System.Net.HttpWebRequest.Host%2A>属性。|  
|如果-修改-自|通过设置<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>属性。|  
|范围|通过设置<xref:System.Net.HttpWebRequest.AddRange%2A>方法。|  
|引用站点|通过设置<xref:System.Net.HttpWebRequest.Referer%2A>属性。|  
|传输编码|通过设置<xref:System.Net.HttpWebRequest.TransferEncoding%2A>属性 (<xref:System.Net.HttpWebRequest.SendChunked%2A>属性必须为 true)。|  
|用户代理|通过设置<xref:System.Net.HttpWebRequest.UserAgent%2A>属性。|  
  
 <xref:System.Net.WebHeaderCollection.Add%2A>方法抛出异常<xref:System.ArgumentException>如果你尝试设置这些受保护的标头之一。  
  
 更改<xref:System.Net.HttpWebRequest.Headers%2A>属性后已通过调用启动请求<xref:System.Net.HttpWebRequest.GetRequestStream%2A>， <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.HttpWebRequest.GetResponse%2A>，或<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法抛出异常<xref:System.InvalidOperationException>。  
  
 不应假定，标头值将保持不变，因为 Web 服务器和缓存可能更改或添加到 Web 请求的标头。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.Headers%2A>属性可打印到控制台的 HTTP 标头名称/值对。  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberSignature Language="VB.NET" Value="Public Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : string with get, set" Usage="System.Net.HttpWebRequest.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or set the Host header value to use in an HTTP request independent from the request URI.</summary>
        <value>HTTP 请求中的 Host 标头值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Host%2A>属性可以用于设置要在 HTTP 请求中独立于请求 URI 中使用的标头值的主机。 <xref:System.Net.HttpWebRequest.Host%2A>属性可以包含主机名和一个可选端口号。 主机标头不包含端口信息意味着的默认端口为请求的服务 （端口 80 HTTP URL，例如）。  
  
 指定主机和端口的格式必须遵循 14.23 小节中的发布的 IETF RFC2616 规则。 满足这些要求的示例，指定的端口 8080 是以下值以查找<xref:System.Net.HttpWebRequest.Host%2A>属性：  
  
 `www.contoso.com:8080`  
  
 使用<xref:System.Net.HttpWebRequest.Host%2A>属性来显式指定的自定义主机标头值还会影响缓存的区域、 cookie 和身份验证。 在应用程序特定的 URI 前缀提供凭据，该应用程序将需要确保使用包含的值的 Host 标头，而不是在 URI 中的目标服务器的 URI。 缓存资源时所使用的密钥使用的主机头值，而不是请求 URI。 Cookie 存储在<xref:System.Net.CookieContainer>和服务器的域名进行逻辑分组。 如果应用程序将指定主机标头，此值将用作域。  
  
 如果<xref:System.Net.HttpWebRequest.Host%2A>未设置属性，则要在 HTTP 请求中使用的主机标头值基于请求 URI。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The Host header cannot be set to <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The Host header cannot be set to an invalid value.</exception>
        <exception cref="T:System.InvalidOperationException">The Host header cannot be set after the <see cref="T:System.Net.HttpWebRequest" /> has already started to be sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberSignature Language="VB.NET" Value="Public Property IfModifiedSince As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime IfModifiedSince { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.IfModifiedSince : DateTime with get, set" Usage="System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="If-Modified-Since" /> HTTP header.</summary>
        <value>A<see cref="T:System.DateTime" />包含的内容<see langword="If-Modified-Since" />HTTP 标头。 默认值是当前日期和时间。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.IfModifiedSince%2A>属性是一种标准<xref:System.DateTime?displayProperty=nameWithType>对象，并可以包含<xref:System.DateTimeKind?displayProperty=nameWithType>字段<xref:System.DateTimeKind.Local?displayProperty=nameWithType>， <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>，或<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>。 使用时，可以设置任何类型的时间<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>属性。 如果<xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>进行设置或检索，<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>属性被假定为<xref:System.DateTimeKind.Local?displayProperty=nameWithType>（当地时间）。  
  
 中的类<xref:System.Net>命名空间始终将其写出<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>是在使用格林威治标准时间 (Utc) 格式的标准窗体中的传输期间在网络上的属性。  
  
 如果<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>属性设置为<xref:System.DateTime.MinValue?displayProperty=nameWithType>，则`If-Modified-Since`HTTP 标头删除从<xref:System.Net.HttpWebRequest.Headers%2A>属性和<xref:System.Net.WebHeaderCollection>。  
  
 如果<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>属性是<xref:System.DateTime.MinValue?displayProperty=nameWithType>，这指示`If-Modified-Since`HTTP 标头未包含在<xref:System.Net.HttpWebRequest.Headers%2A>属性和<xref:System.Net.WebHeaderCollection>。  
  
> [!NOTE]
>  此属性的值存储在<xref:System.Net.WebHeaderCollection>。 如果设置了 WebHeaderCollection，则该属性值将丢失。  
  
   
  
## Examples  
 下面的代码示例检查<xref:System.Net.HttpWebRequest.IfModifiedSince%2A>属性。  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Net.HttpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to make a persistent connection to the Internet resource.</summary>
        <value>
          <see langword="true" /> 如果对 Internet 资源的请求应包含<see langword="Connection" />包含值的 HTTP 标头保持活动状态; 否则为<see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将此属性设置为`true`发送`Connection`保持活动状态的值的 HTTP 标头。 应用程序使用<xref:System.Net.HttpWebRequest.KeepAlive%2A>指示永久连接的首选项。 当<xref:System.Net.HttpWebRequest.KeepAlive%2A>属性是`true`，应用程序建立持久连接到支持这些服务器。  
  
> [!NOTE]
>  使用 HTTP/1.1，保持活动状态时，在默认情况下。 设置<xref:System.Net.HttpWebRequest.KeepAlive%2A>到`false`可能会导致发送`Connection: Close`到服务器的标头。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.KeepAlive%2A>属性`false`以免建立与 Internet 资源的持久连接。  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumAutomaticRedirections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumAutomaticRedirections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumAutomaticRedirections : int with get, set" Usage="System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum number of redirects that the request follows.</summary>
        <value>请求将跟随的重定向响应的最大数目。 默认值为 50。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A>属性设置的最大的请求时应遵循的重定向<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>属性是`true`。  
  
   
  
## Examples  
 下面的代码示例设置此属性的值。  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value is set to 0 or less.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaximumResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumResponseHeadersLength : int with get, set" Usage="System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum allowed length of the response headers.</summary>
        <value>响应标头的长度，以 KB（1024 字节）为单位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 响应标头的长度包括响应状态行和作为 HTTP 协议的一部分接收任何额外的控制字符。 值为-1 表示响应标头; 没有限制值为 0 表示将所有请求将都失败。  
  
 如果<xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A>属性未显式设置，则它默认为的值<xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A>属性。  
  
 如果收到响应标头的长度超出的值<xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A>属性，<xref:System.Net.HttpWebRequest.EndGetResponse%2A>或<xref:System.Net.HttpWebRequest.GetResponse%2A>方法都会引发<xref:System.Net.WebException>与<xref:System.Net.WebException.Status%2A>属性设置为<xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>。  
  
   
  
## Examples  
 下面的代码示例设置此属性的值。  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The property is set after the request has already been submitted.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is less than 0 and is not equal to -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberSignature Language="VB.NET" Value="Public Property MediaType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MediaType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MediaType : string with get, set" Usage="System.Net.HttpWebRequest.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the media type of the request.</summary>
        <value>请求的媒体类型。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.Net.HttpWebRequest.MediaType%2A>属性将影响<xref:System.Net.HttpWebResponse.CharacterSet%2A>属性。 当你将设置<xref:System.Net.HttpWebRequest.MediaType%2A>从响应中返回的字符集的列表中在请求中，选择相应的媒体类型`Content-type`HTTP 标头。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Method As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Method { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Method : string with get, set" Usage="System.Net.HttpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the method for the request.</summary>
        <value>用于联系 Internet 资源的请求方法。 默认值为 GET。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Method%2A>属性可以设置为任何 HTTP 1.1 协议谓词： GET、 HEAD、 POST、 PUT、 删除，跟踪或选项。  
  
 如果<xref:System.Net.HttpWebRequest.ContentLength%2A>属性设置为任何值，而-1<xref:System.Net.HttpWebRequest.Method%2A>属性必须设置为将数据上载的协议属性。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.Method%2A>属性设置为 POST。  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No method is supplied.  -or-  The method string contains invalid characters.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberSignature Language="VB.NET" Value="Public Property Pipelined As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Pipelined { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Pipelined : bool with get, set" Usage="System.Net.HttpWebRequest.Pipelined" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to pipeline the request to the Internet resource.</summary>
        <value>如果通过管线传输请求，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序使用<xref:System.Net.HttpWebRequest.Pipelined%2A>属性，指示管道连接的首选项。 当<xref:System.Net.HttpWebRequest.Pipelined%2A>是`true`，应用程序进行管道的连接到支持这些服务器。  
  
 管道的连接进行时，才<xref:System.Net.HttpWebRequest.KeepAlive%2A>属性也为`true`。  
  
   
  
## Examples  
 下面的代码示例将的值打印<xref:System.Net.HttpWebRequest.Pipelined%2A>到控制台的属性。  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property PreAuthenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool PreAuthenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreAuthenticate : bool with get, set" Usage="System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to send an Authorization header with the request.</summary>
        <value>
          <see langword="true" /> 发送 HTTP 授权标头与请求后发生身份验证;否则为<see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对特定的客户端请求后<xref:System.Uri>成功通过身份验证，如果<xref:System.Net.HttpWebRequest.PreAuthenticate%2A>是`true`和提供凭据的、 Authorization 标头与每个请求发送到任何<xref:System.Uri>匹配特定<xref:System.Uri>直到最后一个正斜杠。 因此，如果客户端请求成功地验证到特定<xref:System.Uri>包含以下：  
  
 `http://www.contoso.com/firstpath/`  
  
 然后预身份验证的授权标头与每个请求发送到以下任一<xref:System.Uri>实例：  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 但是，授权标头不会发送与请求到以下任一<xref:System.Uri>实例：  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 如果客户端请求到特定<xref:System.Uri>是不成功通过身份验证，请求使用标准身份验证过程。  
  
 第一个请求，除了<xref:System.Net.WebRequest.PreAuthenticate%2A>属性指示是否将发送到的后续请求的身份验证信息<xref:System.Uri>匹配特定<xref:System.Uri>而无需等待将在最后一个正斜杠由服务器面临的挑战。  
  
 客户端和服务器之间以下对话框说明了此属性的效果。 该对话框假设基本身份验证正在使用中。  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> 是`false`:  
  
 客户端： GET someUrl  
  
 服务器： 401 Www-authenticate Basic  
  
 获取与授权标头的客户端：  
  
 服务器： 200 确定  
  
 客户端： GET someUrl  
  
 服务器： 401 Www-authenticate Basic  
  
 获取与授权标头的客户端：  
  
 服务器： 200 确定  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> 是`true`:  
  
 客户端： GET someUrl  
  
 服务器： 401 Www-authenticate Basic  
  
 获取与授权标头的客户端：  
  
 服务器： 200 确定  
  
 客户端： 获取 someUrl 与授权标头  
  
 如果身份验证方案不支持预身份验证，则忽略此属性的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolVersion : Version with get, set" Usage="System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the version of HTTP to use for the request.</summary>
        <value>用于请求的 HTTP 版本。 默认值为 <see cref="F:System.Net.HttpVersion.Version11" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest>类支持版本 1.0 和 1.1 版 HTTP。 设置<xref:System.Net.HttpWebRequest.ProtocolVersion%2A>与另一个版本将引发异常。  
  
> [!NOTE]
>  若要设置当前请求的 HTTP 版本，使用<xref:System.Net.HttpVersion.Version10>和<xref:System.Net.HttpVersion.Version11>字段<xref:System.Net.HttpVersion>类。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.ProtocolVersion%2A>属性。  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The HTTP version is set to a value other than 1.0 or 1.1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Proxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Net::IWebProxy ^ Proxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Proxy : System.Net.IWebProxy with get, set" Usage="System.Net.HttpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets proxy information for the request.</summary>
        <value>
          <see cref="T:System.Net.IWebProxy" />用于代理请求的对象。 默认值通过调用设置<see cref="P:System.Net.GlobalProxySelection.Select" />属性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Proxy%2A>属性标识<xref:System.Net.WebProxy>要用来处理对 Internet 资源的请求对象。 若要指定应使用无代理，设置<xref:System.Net.HttpWebRequest.Proxy%2A>属性返回的代理实例<xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType>方法。  
  
 使用默认代理，可以指定本地计算机或应用程序配置文件。 如果<xref:System.Net.HttpWebRequest.Proxy%2A>指定属性，然后从的代理设置<xref:System.Net.HttpWebRequest.Proxy%2A>属性重写的本地计算机或应用程序配置文件和<xref:System.Net.HttpWebRequest>实例将使用指定的代理设置。 如果在配置文件中不指定任何代理和<xref:System.Net.HttpWebRequest.Proxy%2A>属性未指定，<xref:System.Net.HttpWebRequest>类使用从 Internet 资源管理器继承在本地计算机上的代理设置。 如果没有在 Internet Explorer 代理设置，请直接向服务器发送请求。  
  
 <xref:System.Net.HttpWebRequest>类解析包含通配符字符的代理跳过列表继承从 Internet 资源管理器相同跳过列表分析直接通过 Internet Explorer。 例如，<xref:System.Net.HttpWebRequest>类将正则表达式的分析的"nt *"Internet Explorer 中的跳过列表"nt。\*"。 因此的 URL"`http://nt.com`"将跳过代理使用<xref:System.Net.HttpWebRequest>类并使用 Internet Explorer。  
  
 <xref:System.Net.HttpWebRequest>类支持本地代理绕过。 类会将目标是本地如果满足以下任何条件视为：  
  
-   目标包含一个简单的名称 （在 URL 中没有句点）。  
  
-   目标包含环回地址 (<xref:System.Net.IPAddress.Loopback>或<xref:System.Net.IPAddress.IPv6Loopback>) 或目标包含<xref:System.Net.IPAddress>分配给本地计算机。  
  
-   目标的域后缀匹配本地计算机的域后缀 (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>)。  
  
 更改<xref:System.Net.HttpWebRequest.Proxy%2A>属性后已通过调用启动请求<xref:System.Net.HttpWebRequest.GetRequestStream%2A>， <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.HttpWebRequest.GetResponse%2A>，或<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法抛出异常<xref:System.InvalidOperationException>。 有关代理元素信息请参阅[ \&lt; defaultProxy\&gt;元素 （网络设置）](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md)。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpWebRequest.Proxy%2A>方法以获取关于请求的代理信息。  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.HttpWebRequest.Proxy" /> is set to <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have permission for the requested operation.</exception>
        <permission cref="T:System.Net.WebPermission">要获取或设置<see cref="P:System.Net.HttpWebRequest.Proxy" />属性。 关联的枚举： <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a time-out in milliseconds when writing to or reading from a stream.</summary>
        <value>在写入超时或读取超时之前的毫秒数。默认值为 300,000 毫秒（5 分钟）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>写入到返回的流时使用属性<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法或从返回的流读取<xref:System.Net.HttpWebResponse.GetResponseStream%2A>方法。  
  
 具体而言，<xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>属性控制的超时时间<xref:System.IO.Stream.Read%2A>方法，用于读取返回的流<xref:System.Net.HttpWebResponse.GetResponseStream%2A>方法，以及<xref:System.IO.Stream.Write%2A>方法，用于向返回的流写入<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法。  
  
 若要指定要等待的时间完成请求的时间量，请使用<xref:System.Net.HttpWebRequest.Timeout%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何设置 <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> 属性。  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has already been sent.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is less than or equal to zero and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /></exception>
        <altmember cref="P:System.Net.HttpWebRequest.Timeout" />
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberSignature Language="VB.NET" Value="Public Property Referer As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Referer { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Referer : string with get, set" Usage="System.Net.HttpWebRequest.Referer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Referer" /> HTTP header.</summary>
        <value>
          <see langword="Referer" /> HTTP 标头的值。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A>属性是`true`、<xref:System.Net.HttpWebRequest.Referer%2A>请求重定向到另一个站点时自动设置属性。  
  
 若要清除`Referer`设置 HTTP 标头，<xref:System.Net.HttpWebRequest.Referer%2A>属性`null`。  
  
> [!NOTE]
>  此属性的值存储在<xref:System.Net.WebHeaderCollection>。 如果设置了 WebHeaderCollection，则该属性值将丢失。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.Referer%2A>属性。  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RequestUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Uri ^ RequestUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestUri : Uri" Usage="System.Net.HttpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the original Uniform Resource Identifier (URI) of the request.</summary>
        <value>A <see cref="T:System.Uri" /> ，其中包含传递到 Internet 资源的 URI<see cref="M:System.Net.WebRequest.Create(System.String)" />方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri>对象传递给<xref:System.Net.HttpWebRequest>通过调用<xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>。  
  
 跟随重定向标头不会更改<xref:System.Net.HttpWebRequest.RequestUri%2A>属性。 若要获取实际响应此请求的 URI，请检查<xref:System.Net.HttpWebRequest.Address%2A>属性。  
  
   
  
## Examples  
 下面的代码示例检查以查看是否<xref:System.Net.HttpWebRequest>对象`req`已重定向到其他位置来完成请求，并将的值设置`hasChanged`变量`true`如果请求重定向; 否则为`hasChanged`设置为`false`。  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberSignature Language="VB.NET" Value="Public Property SendChunked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SendChunked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SendChunked : bool with get, set" Usage="System.Net.HttpWebRequest.SendChunked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to send data in segments to the Internet resource.</summary>
        <value>
          <see langword="true" /> 若要将数据发送到段; 中的 Internet 资源否则为<see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Net.HttpWebRequest.SendChunked%2A>是`true`，请求将数据发送到段中的 Internet 资源。 Internet 资源必须支持接收分块的数据。  
  
 更改<xref:System.Net.HttpWebRequest.SendChunked%2A>属性后已通过调用启动请求<xref:System.Net.HttpWebRequest.GetRequestStream%2A>， <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>， <xref:System.Net.HttpWebRequest.GetResponse%2A>，或<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法抛出异常<xref:System.InvalidOperationException>。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.SendChunked%2A>属性`true`，以便可以将数据发送到 Internet 资源的段中。  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The request has been started by calling the <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" />, or <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> method.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a callback function to validate the server certificate.</summary>
        <value>用于验证服务器证书的回调函数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认值是不设置任何回调函数和<xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A>属性是`null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServicePoint As ServicePoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::ServicePoint ^ ServicePoint { System::Net::ServicePoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServicePoint : System.Net.ServicePoint" Usage="System.Net.HttpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the service point to use for the request.</summary>
        <value>A<see cref="T:System.Net.ServicePoint" />表示到 Internet 资源的网络连接。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType>属性可以是不同于<xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType>如果请求重定向。  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsCookieContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsCookieContainer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsCookieContainer : bool" Usage="System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the request provides support for a <see cref="T:System.Net.CookieContainer" />.</summary>
        <value>
          <see langword="true" /> 如果请求提供了对支持<see cref="T:System.Net.CookieContainer" />; 否则为<see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data.</param>
        <param name="streamingContext">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> that specifies the destination for this serialization.</param>
        <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data needed to serialize the target object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中包含的任何对象<xref:System.Runtime.Serialization.SerializationInfo>会自动跟踪和序列化格式化程序。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Timeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Timeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : int with get, set" Usage="System.Net.HttpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the time-out value in milliseconds for the <see cref="M:System.Net.HttpWebRequest.GetResponse" /> and <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> methods.</summary>
        <value>请求超时前等待的毫秒数。默认值是 100,000 毫秒（100 秒）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A> 是的使用进行后续的同步请求的毫秒数<xref:System.Net.HttpWebRequest.GetResponse%2A>方法等待响应，与<xref:System.Net.HttpWebRequest.GetRequestStream%2A>方法等待流。 <xref:System.Net.HttpWebRequest.Timeout%2A>不单独对适用于整个请求和响应，<xref:System.Net.HttpWebRequest.GetRequestStream%2A>和<xref:System.Net.HttpWebRequest.GetResponse%2A>方法调用。 如果在超时期间内未返回该资源，请求将引发<xref:System.Net.WebException>与<xref:System.Net.WebException.Status%2A>属性设置为<xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>。  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A>属性必须之前设置<xref:System.Net.HttpWebRequest.GetRequestStream%2A>或<xref:System.Net.HttpWebRequest.GetResponse%2A>调用方法。 更改<xref:System.Net.HttpWebRequest.Timeout%2A>属性在调用<xref:System.Net.HttpWebRequest.GetRequestStream%2A>或<xref:System.Net.HttpWebRequest.GetResponse%2A>方法不起作用  
  
 <xref:System.Net.HttpWebRequest.Timeout%2A>属性不起使用发出异步请求<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>或<xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>方法。  
  
> [!CAUTION]
>  在异步请求的情况下客户端应用程序实现其自己的超时机制。 请参阅中的示例<xref:System.Net.HttpWebRequest.BeginGetResponse%2A>方法。  
  
 若要指定的时间等待读取或写入操作超时，请使用<xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A>属性。  
  
 域名系统 (DNS) 查询可能需要最多为 15 秒为单位返回或超时。如果你的请求包含需要解析的主机名，并设置<xref:System.Net.FileWebRequest.Timeout%2A>为值小于 15 秒，可能需要 15 秒或更之前<xref:System.Net.WebException>引发来指示你的请求超时。  
  
   
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.Timeout%2A>属性<xref:System.Net.HttpWebRequest>对象。  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified is less than zero and is not <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransferEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransferEncoding : string with get, set" Usage="System.Net.HttpWebRequest.TransferEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="Transfer-encoding" /> HTTP header.</summary>
        <value>
          <see langword="Transfer-encoding" /> HTTP 标头的值。 默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在设置前<xref:System.Net.HttpWebRequest.TransferEncoding%2A>属性，必须首先设置<xref:System.Net.HttpWebRequest.SendChunked%2A>属性`true`。 清除<xref:System.Net.HttpWebRequest.TransferEncoding%2A>通过将它设置为`null`的值不起<xref:System.Net.HttpWebRequest.SendChunked%2A>。  
  
 分配给值<xref:System.Net.HttpWebRequest.TransferEncoding%2A>属性替换任何现有内容。  
  
> [!NOTE]
>  此属性的值存储在<xref:System.Net.WebHeaderCollection>。 如果设置了 WebHeaderCollection，则该属性值将丢失。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set when <see cref="P:System.Net.HttpWebRequest.SendChunked" /> is <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> is set to the value "Chunked".</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to allow high-speed NTLM-authenticated connection sharing.</summary>
        <value>
          <see langword="true" /> 表示使经过身份验证的连接保持打开状态;否则为<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的默认值是`false`，这将导致当前连接的请求完成后关闭。 每次发出新请求时，你的应用程序必须经过身份验证序列。  
  
 如果此属性设置为`true`，执行身份验证后，用于检索响应的连接保持打开状态。 在这种情况下，其他请求具有此属性设置为`true`可以使用该连接而无需重新进行身份验证。 换而言之，如果用户 A，连接已经过身份验证，用户 B 可能会重新使用 A 的连接;根据用户 a。 的凭据实现用户 B 的请求  
  
> [!CAUTION]
>  因为它是可能的应用程序不经过身份验证中使用连接，你必须在确定是否有任何管理漏洞在你的系统时将此属性设置为`true`。 如果你的应用程序将请求发送多个用户 （模拟多个用户帐户），并依赖于要保护的资源的身份验证，执行未设置此属性为`true`除非你使用连接组，如下所述。  
  
 你可能想要考虑启用此机制，如果你出现了性能问题，在使用集成 Windows 身份验证的 Web 服务器上运行你的应用程序。  
  
 启用此设置将使系统面临安全风险。 如果你设置<xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A>属性`true`一定要采取以下预防措施：  
  
-   使用<xref:System.Net.HttpWebRequest.ConnectionGroupName%2A>属性来管理不同的用户的连接。 这通过未经身份验证的应用程序来避免可能出现的连接的使用。 例如，用户 A 应该不同于用户 B 的唯一连接组名称这提供了一层隔离每个用户帐户。  
  
-   在受保护的环境，以帮助避免可能的连接攻击中运行你的应用程序。  
  
 若要控制后端服务器，或者你可能考虑关闭身份验证持久性。 这将提高性能一定程度上，但它是更安全。 有关详细信息，搜索在 MSDN 库中的 AuthPersistence [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library)。  
  
> [!NOTE]
>  如果这两个<xref:System.Net.WebRequest.PreAuthenticate%2A>和<xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A>设置为`true`，每个请求发送来自不安全的池，但具有一个 Authorization 标头使用的连接。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">具有不受限制的 Web 访问权限需要设置此属性。</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property UseDefaultCredentials As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool UseDefaultCredentials { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDefaultCredentials : bool with get, set" Usage="System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a <see cref="T:System.Boolean" /> value that controls whether default credentials are sent with requests.</summary>
        <value>如果使用默认凭据，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将此属性设置为`true`时发出的此请求<xref:System.Net.HttpWebRequest>对象，如果请求服务器进行身份验证应使用当前登录用户的凭据。 对于客户端应用程序，这是在大多数情况下所需的行为。 对于中间层应用程序，例如 ASP.NET 应用程序，而不是使用此属性，通常会设置<xref:System.Net.HttpWebRequest.Credentials%2A>到客户端的名义发出的请求的凭据的属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">You attempted to set this property after the request was sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string with get, set" Usage="System.Net.HttpWebRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the <see langword="User-agent" /> HTTP header.</summary>
        <value>
          <see langword="User-agent" /> HTTP 标头的值。 默认值为 <see langword="null" />。  
  
 <block subset="none" type="note"><para> 此属性的值存储在<see cref="T:System.Net.WebHeaderCollection" />。如果了 webheadercollection，则属性值将丢失。  </para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例设置<xref:System.Net.HttpWebRequest.UserAgent%2A>属性。  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>