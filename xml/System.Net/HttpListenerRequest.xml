<Type Name="HttpListenerRequest" FullName="System.Net.HttpListenerRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="76dca6c03fa9c47eb67a205952892b5fbc50e8a0" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33683765" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpListenerRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpListenerRequest extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpListenerRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpListenerRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpListenerRequest sealed" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net.HttpListener</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>描述传入 <see cref="T:System.Net.HttpListener" /> 对象的 HTTP 请求。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当客户端发出一个请求到统一资源标识符 (URI) 由<xref:System.Net.HttpListener>对象，<xref:System.Net.HttpListener>提供<xref:System.Net.HttpListenerContext>对象，其中包含有关发件人、 请求和发送到客户端的响应信息。 <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=nameWithType>属性返回<xref:System.Net.HttpListenerRequest>描述的请求的对象。  
  
 <xref:System.Net.HttpListenerRequest>对象包含有关请求，如请求的信息<xref:System.Net.HttpListenerRequest.HttpMethod%2A>字符串，<xref:System.Net.HttpListenerRequest.UserAgent%2A>字符串，并请求的正文数据 (请参阅<xref:System.Net.HttpListenerRequest.InputStream%2A>属性)。  
  
 若要答复请求，你必须获取关联的响应使用<xref:System.Net.HttpListenerContext.Response%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何接收并响应<xref:System.Net.HttpListenerRequest>。  
  
 [!code-csharp[Net_Listener_Basic#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.HttpListener" />
    <altmember cref="T:System.Net.HttpListenerContext" />
    <altmember cref="T:System.Net.HttpListenerResponse" />
  </Docs>
  <Members>
    <Member MemberName="AcceptTypes">
      <MemberSignature Language="C#" Value="public string[] AcceptTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AcceptTypes" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.AcceptTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AcceptTypes As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AcceptTypes { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取客户端接受的 MIME 类型。</summary>
        <value>一个 <see cref="T:System.String" /> 数组，该数组包含在请求的 <see langword="Accept" /> 标头中指定的类型名称；如果客户端请求不包括 <see langword="null" /> 标头，则为 <see langword="Accept" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Accept`标头是一个空格分隔的多用途 Internet 邮件扩展 (MIME) 类型名称的字符串 (例如， `image/jpeg`)，指示客户端是准备好接受并处理在响应中的 MIME 类型。 `*/*`条目指示客户端接受任何 MIME 类型。 有关的详细说明`Accept`标头，请参阅 RFC 2616，可用在[ https://www.rfc-editor.org ](https://www.rfc-editor.org/)。  
  
 请求标头的完整列表，请参阅<xref:System.Net.HttpRequestHeader>枚举。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此属性。  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="BeginGetClientCertificate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginGetClientCertificate (AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginGetClientCertificate(class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.BeginGetClientCertificate(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginGetClientCertificate (requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginGetClientCertificate(AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="requestCallback">一个 <see cref="T:System.AsyncCallback" /> 委托，它引用操作完成时要调用的方法。</param>
        <param name="state">一个用户定义对象，其中包含操作的相关信息。 操作完成后，此对象会被传递给回叫委托。</param>
        <summary>开始对客户端的 X.509 v.3 证书的异步请求。</summary>
        <returns>指示操作的状态的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificateError">
      <MemberSignature Language="C#" Value="public int ClientCertificateError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ClientCertificateError" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ClientCertificateError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificateError As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ClientCertificateError { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个错误代码，该代码标识的问题涉及客户端提供的 <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" />。</summary>
        <value>包含 Windows 错误代码的 <see cref="T:System.Int32" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性包含返回通过安全通道 (Schannel) 安全支持提供程序接口 (SSPI)，用于验证的证书的 Windows 错误代码。 有关 Schannel 的 SSPI 支持的详细信息，请参阅"创建安全连接使用 Schannel"中的安全文档[ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library)。  
  
   
  
## Examples  
 下面的代码示例检查此属性以确定请求是否包含有效的客户端证书。  
  
 [!code-csharp[NCLListener#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLListener/CS/sample.cs#3)]
 [!code-vb[NCLListener#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLListener/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尚未通过调用 <see cref="M:System.Net.HttpListenerRequest.BeginGetClientCertificate(System.AsyncCallback,System.Object)" /> 或 <see cref="M:System.Net.HttpListenerRequest.GetClientCertificate" /> 方法初始化客户端证书  
  
 - 或 -  
  
 操作仍在进行中。</exception>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可用于随请求发送的数据的内容编码</summary>
        <value>一个 <see cref="T:System.Text.Encoding" /> 对象，适于 <see cref="P:System.Net.HttpListenerRequest.InputStream" /> 属性中的数据使用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding>对象可以用于将字节序列转换为字符集 （代码页） 和为字节序列的字符。 此属性使用的字符集的值从`Content-Type`标头来确定编码。 如果该信息不可用，此属性返回<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Net.HttpListenerRequest.ContentEncoding%2A>属性。  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ContentLength64">
      <MemberSignature Language="C#" Value="public long ContentLength64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength64" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ContentLength64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentLength64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long ContentLength64 { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含在请求中的正文数据的长度。</summary>
        <value>请求的 <see langword="Content-Length" /> 标头中的值。 如果内容长度未知，则此值为 -1。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Content-Length`标头提出请求附带的正文数据的长度，以字节为单位。  
  
 请求标头的完整列表，请参阅<xref:System.Net.HttpRequestHeader>枚举。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Net.HttpListenerRequest.ContentLength64%2A>时处理的正文数据的属性。  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含在请求中的正文数据的 MIME 类型。</summary>
        <value>
          <see cref="T:System.String" />，包含请求的 <see langword="Content-Type" /> 标头的文本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果客户端在请求中包括的正文数据，它声明中的正文数据的多用途 Internet 邮件扩展 (MIME) 类型`Content-Type`标头。 例如，从 Web 窗体使用返回的数据的默认 MIME 类型`POST`方法是`application/x-www-form-urlencoded`。  
  
 请求标头的完整列表，请参阅<xref:System.Net.HttpRequestHeader>枚举和 RFC 2616，可用在[ https://www.rfc-editor.org ](https://www.rfc-editor.org/)。  
  
 <xref:System.Net.HttpListenerRequest.ContentType%2A>为 null 时没有`Content-Type`请求标头中的。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此属性。  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Net.CookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As CookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::CookieCollection ^ Cookies { System::Net::CookieCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取随请求发送的 Cookie。</summary>
        <value>
          <see cref="T:System.Net.CookieCollection" /> 包含伴随请求的 Cookie。 如果请求不包含 Cookie，则此属性返回空集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cookie 是从存储在本地 （客户端） 计算机的 Web 服务器的名称/值文本数据。  
  
   
  
## Examples  
 下面的代码示例显示与请求一起发送的 cookie 的值。  
  
 [!code-csharp[Net_Listener_Basic#18](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#18)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="EndGetClientCertificate">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509Certificate2 EndGetClientCertificate (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.Cryptography.X509Certificates.X509Certificate2 EndGetClientCertificate(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.EndGetClientCertificate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndGetClientCertificate (asyncResult As IAsyncResult) As X509Certificate2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::Cryptography::X509Certificates::X509Certificate2 ^ EndGetClientCertificate(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate2</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">证书的挂起请求。</param>
        <summary>结束对客户端的 X.509 v.3 证书的异步请求。</summary>
        <returns>操作启动时返回的 <see cref="T:System.IAsyncResult" /> 对象。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          未通过调用 <see cref="M:System.Net.HttpListenerRequest.BeginGetClientCertificate(System.AsyncCallback,System.Object)" /><paramref name="e." /> 获取 <paramref name="asyncResult" /></exception>
        <exception cref="T:System.InvalidOperationException">已为 <paramref name="asyncResult" /> 标识的操作调用了此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetClientCertificate">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509Certificate2 GetClientCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.Cryptography.X509Certificates.X509Certificate2 GetClientCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.GetClientCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Function GetClientCertificate () As X509Certificate2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::Cryptography::X509Certificates::X509Certificate2 ^ GetClientCertificate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate2</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索客户端的 X.509 v.3 证书。</summary>
        <returns>一个 <see cref="N:System.Security.Cryptography.X509Certificates" /> 对象，其中包含客户端的 X.509 v.3 证书。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法阻止，直至检索的证书。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">对此方法的一个调用（以检索客户端的 X.509 v.3 证书）正在进行，因此无法进行对此方法的另一个调用。</exception>
        <altmember cref="N:System.Security.Cryptography.X509Certificates" />
      </Docs>
    </Member>
    <Member MemberName="GetClientCertificateAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Security.Cryptography.X509Certificates.X509Certificate2&gt; GetClientCertificateAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Security.Cryptography.X509Certificates.X509Certificate2&gt; GetClientCertificateAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpListenerRequest.GetClientCertificateAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function GetClientCertificateAsync () As Task(Of X509Certificate2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Security::Cryptography::X509Certificates::X509Certificate2 ^&gt; ^ GetClientCertificateAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Security.Cryptography.X509Certificates.X509Certificate2&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以异步操作检索客户端的 X.509 v.3 证书。</summary>
        <returns>返回 <see cref="T:System.Threading.Tasks.Task`1" />。  
  
 表示异步操作的任务对象。 任务对象上的 <see cref="P:System.Threading.Tasks.Task`1.Result" /> 属性返回包含客户端的 X.509 v.3 证书的 <see cref="N:System.Security.Cryptography.X509Certificates" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不会阻止此操作。 返回<xref:System.Threading.Tasks.Task%601>对象都完成时检索的证书。  
  
 如果此方法的调用来检索客户端的 X.509 v.3 证书正在进行，无法建立到此方法的另一次调用。  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Security.Cryptography.X509Certificates" />
      </Docs>
    </Member>
    <Member MemberName="HasEntityBody">
      <MemberSignature Language="C#" Value="public bool HasEntityBody { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasEntityBody" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.HasEntityBody" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasEntityBody As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasEntityBody { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Boolean" /> 值，该值指示请求是否有关联的正文数据。</summary>
        <value>
          如果请求有关联的正文数据，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将数据发送到服务器使用的请求`POST`方法，例如，应具有实体主体。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此属性。  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在请求中发送的标头名称/值对的集合。</summary>
        <value>
          <see cref="T:System.Net.WebHeaderCollection" /> 包含的 HTTP 标头包括在请求中。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请求标头包含元数据信息。 例如，标头可以包含客户端与服务器的资源的统一资源标识符 (URI)，由客户端，以及可接受的 MIME 响应正文中的数据的类型的用户代理的标识。  
  
 请求标头的完整列表，请参阅<xref:System.Net.HttpRequestHeader>枚举。  
  
   
  
## Examples  
 下面的代码示例显示中的所有信息给定<xref:System.Net.WebHeaderCollection>对象。  
  
 [!code-csharp[Net_Listener_Basic#21](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#21)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="HttpMethod">
      <MemberSignature Language="C#" Value="public string HttpMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HttpMethod" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.HttpMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpMethod As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ HttpMethod { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取由客户端指定的 HTTP 方法。</summary>
        <value>
          <see cref="T:System.String" /> 包含的方法用于请求中。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTTP 方法通常是 GET 或 POST，具体取决于客户端所需的操作。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此属性。  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="InputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream InputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream InputStream" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.InputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ InputStream { System::IO::Stream ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含由客户端发送的正文数据的流。</summary>
        <value>一个可读的 <see cref="T:System.IO.Stream" /> 对象，该对象包含客户端在请求正文中发送的字节。 如果没有随请求发送任何数据，则此属性返回 <see cref="F:System.IO.Stream.Null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果客户端将数据传输 (例如，使用 HTTP`POST`方法)，此方法返回的流包含的数据。  
  
> [!NOTE]
>  关闭请求不会关闭此属性返回的流。 当你不再需要该流时，你应通过调用关闭它<xref:System.IO.Stream.Close%2A>方法。  
  
   
  
## Examples  
 下面的代码示例演示了如何使用此属性读取与请求一起发送的数据。  
  
 [!code-csharp[Net_Listener_Basic#16](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#16)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>当你在应用程序中启用网络跟踪后，此成员将输出跟踪信息。 有关详细信息，请参阅[在.NET Framework 中进行网络跟踪](~/docs/framework/network-programming/network-tracing.md)。</para>
        </block>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAuthenticated { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Always returns false")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Boolean" /> 值，该值指示发送此请求的客户端是否经过身份验证。</summary>
        <value>
          如果客户端已经过身份验证，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你的应用程序请求客户端身份验证使用<xref:System.Net.HttpListener.AuthenticationSchemes%2A>或<xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A>属性。  
  
 你的应用程序不会收到<xref:System.Net.HttpListenerContext>来自不成功身份验证的客户端请求。  
  
   
  
## Examples  
 下面的代码示例显示的值<xref:System.Net.HttpListenerRequest.IsAuthenticated%2A>属性。  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsLocal">
      <MemberSignature Language="C#" Value="public bool IsLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocal" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLocal { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Boolean" /> 值，该值指示该请求是否来自本地计算机。</summary>
        <value>
          如果发出请求的计算机就是提供该请求的 <see cref="T:System.Net.HttpListener" /> 对象所在的计算机，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序可以使用此属性以执行特殊处理的请求时从本地计算机。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Net.HttpListenerRequest.IsLocal%2A>属性。  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsSecureConnection">
      <MemberSignature Language="C#" Value="public bool IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSecureConnection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecureConnection { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Boolean" /> 值，该值指示用来发送请求的 TCP 连接是否使用安全套接字层 (SSL) 协议。</summary>
        <value>
          如果 TCP 连接使用的是 SSL，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要请求的安全连接，客户端请求使用<xref:System.Uri.UriSchemeHttps>而不是<xref:System.Uri.UriSchemeHttp>。 如果不使用 SSL 建立的连接，客户端接收<xref:System.Net.WebException>，它提供有关错误的信息。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Net.HttpListenerRequest.IsSecureConnection%2A>属性。  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Boolean" /> 值，该值指示 TCP 连接是否为 WebSocket 请求。</summary>
        <value>返回 <see cref="T:System.Boolean" />。  
  
 如果 TCP 连接是 WebSocket 请求，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 <see cref="T:System.Boolean" /> 值，该值指示客户端是否请求持久性连接。</summary>
        <value>
          如果连接应保持打开状态，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 HTTP 客户端和服务器预计在短时间内多次交换数据，持续性连接可允许客户以避免需要打开和关闭每个消息的 TCP 连接的开销，从而加快其通信。 对于使用 HTTP/1.1 的客户端，此属性的默认值是`true`。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此属性。  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.IPEndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IPEndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As IPEndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::IPEndPoint ^ LocalEndPoint { System::Net::IPEndPoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPEndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取请求定向到的服务器 IP 地址和端口号。</summary>
        <value>
          <see cref="T:System.Net.IPEndPoint" /> 表示请求被发送到的 IP 地址。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你想要对基于解决这些问题的方法的请求作出响应，此属性很有用。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此属性。  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ProtocolVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ ProtocolVersion { Version ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取请求客户端使用的 HTTP 版本。</summary>
        <value>
          <see cref="T:System.Version" /> 用于标识 HTTP 的客户端版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在文档中指定不同的 HTTP 版本的功能[ https://www.rfc-editor.org ](https://www.rfc-editor.org/)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此属性。  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="QueryString">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection QueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection QueryString" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.QueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property QueryString As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ QueryString { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含在请求中的查询字符串。</summary>
        <value>一个 <see cref="T:System.Collections.Specialized.NameValueCollection" /> 对象，其中包含的查询数据包括在请求 <see cref="P:System.Net.HttpListenerRequest.Url" /> 中。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 URL 中，查询信息用问号 （？） 分隔的路径信息。 名称/值对之间用等号 （=） 分隔。 若要访问作为单个字符串的查询数据，获取<xref:System.Uri.Query%2A>属性值从<xref:System.Uri>返回对象<xref:System.Net.HttpListenerRequest.Url%2A>。  
  
> [!NOTE]
>  查询缺少等号 (示例： [ http://www.contoso.com/query.htm?Name ](http://www.contoso.com/query.htm?Name) ) 添加到`null`中的键<xref:System.Collections.Specialized.NameValueCollection>。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Net.HttpListenerRequest.QueryString%2A>属性。  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="RawUrl">
      <MemberSignature Language="C#" Value="public string RawUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RawUrl" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.RawUrl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RawUrl { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取客户端请求的 URL 信息（不包括主机和端口）。</summary>
        <value>
          <see cref="T:System.String" /> 包含此请求的原始 URL。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 原始 URL 定义为以下的域信息的 URL 的一部分。 URL 字符串中`http://www.contoso.com/articles/recent.aspx`，原始的 URL 是`/articles/recent.aspx`。 如果存在，原始的 URL 包括查询字符串。  
  
 若要获取的主机和端口的信息，请使用<xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Net.HttpListenerRequest.RawUrl%2A>属性。  
  
 [!code-csharp[Net_Listener_Basic#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.IPEndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IPEndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As IPEndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::IPEndPoint ^ RemoteEndPoint { System::Net::IPEndPoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IPEndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取发出请求的客户端 IP 地址和端口号。</summary>
        <value>
          <see cref="T:System.Net.IPEndPoint" /> 表示发出请求的 IP 地址和端口号。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何使用此属性。  
  
 [!code-csharp[Net_Listener_Basic#17](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="RequestTraceIdentifier">
      <MemberSignature Language="C#" Value="public Guid RequestTraceIdentifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid RequestTraceIdentifier" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.RequestTraceIdentifier" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RequestTraceIdentifier As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid RequestTraceIdentifier { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Always returns Guid.Empty")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取传入 HTTP 请求的请求标识符。</summary>
        <value>
          <see cref="T:System.Guid" /> 对象，其中包含 HTTP 请求的标识符。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取客户端通过请求发送的服务提供程序名称 (SPN)。</summary>
        <value>一个 <see cref="T:System.String" />，它包含客户端通过请求发送的 SPN。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序可以使用<xref:System.Net.HttpListenerRequest.ServiceName%2A>属性以执行自定义服务提供名称 (SPN) 验证。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="P:System.Net.HttpListenerRequest.TransportContext" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="TransportContext">
      <MemberSignature Language="C#" Value="public System.Net.TransportContext TransportContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.TransportContext TransportContext" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.TransportContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransportContext As TransportContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::TransportContext ^ TransportContext { System::Net::TransportContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.TransportContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取客户端请求的 <see cref="T:System.Net.TransportContext" />。</summary>
        <value>客户端请求的 <see cref="T:System.Net.TransportContext" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.TransportContext>属性可以用于检索的通道绑定令牌 (CBT)<xref:System.Net.HttpListenerRequest>发送其中已使用 HTTPS。  
  
 应用程序可以使用<xref:System.Net.TransportContext>属性来执行自定义身份验证使用调用到本机 Win32 [AcceptSecurityContext](http://go.microsoft.com/fwlink/?LinkId=147021)函数。  
  
 如果应用程序尝试从此检索的通道绑定令牌 (CBT)<xref:System.Net.HttpListenerRequest.TransportContext%2A>属性使用<xref:System.Net.TransportContext.GetChannelBinding%2A>方法和<xref:System.Security.Authentication.ExtendedProtection.ChannelBindingKind>不<xref:System.Security.Authentication.ExtendedProtection.ChannelBindingKind.Endpoint>，则<xref:System.Net.HttpListenerRequest>将引发<xref:System.NotSupportedException>。 <xref:System.Net.HttpListenerRequest>重写<xref:System.Net.TransportContext.GetChannelBinding%2A>使用内部实现的方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.HttpListener.DefaultServiceNames" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionPolicy" />
        <altmember cref="P:System.Net.HttpListener.ExtendedProtectionSelectorDelegate" />
        <altmember cref="T:System.Net.HttpListener.ExtendedProtectionSelector" />
        <altmember cref="P:System.Net.HttpListenerRequest.ServiceName" />
        <altmember cref="N:System.Security.Authentication.ExtendedProtection" />
        <altmember cref="T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取客户端请求的 <see cref="T:System.Uri" /> 对象。</summary>
        <value>一个 <see cref="T:System.Uri" /> 对象，用于标识客户端请求的资源。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpListenerRequest.Url%2A>属性允许您获取中提供的所有信息<xref:System.Uri>对象。 如果你需要知道仅 URI 请求的原始文本，请考虑使用<xref:System.Net.HttpListenerRequest.RawUrl%2A>属性改为。  
  
 <xref:System.Net.HttpListenerRequest.Url%2A>属性为 null 如果<xref:System.Uri>从客户端无法分析。  
  
 <xref:System.Net.Configuration.HttpListenerElement.UnescapeRequestUrl%2A>属性指示如果<xref:System.Net.HttpListener>而不是转换后的 URI 其中百分比编码的任何值都会转换，并执行其他任何规范化步骤使用原始的未转义的 URI。  
  
 当<xref:System.Net.HttpListener>实例收到的请求通过`http.sys`服务，它创建提供的 URI 字符串的实例`http.sys`，并将数据公开为<xref:System.Net.HttpListenerRequest.Url%2A?displayProperty=nameWithType>属性。  
  
 `http.sys`服务公开两个请求 URI 字符串：  
  
-   原始 URI  
  
-   转换后的 URI  
  
 原始 URI 是<xref:System.Uri?displayProperty=nameWithType>HTTP 请求的请求行中提供：  
  
 `GET /path/`  
  
 `Host: www.contoso.com`  
  
 通过提供的原始 URI`http.sys`上述，请求为"/ 路径 /"。 这表示在通过网络发送后面的 HTTP 谓词的字符串。  
  
 `http.sys`服务从使用 HTTP 请求行中提供的 URI 的请求中提供的信息创建一个转换后的 URI 和要确定源服务器请求的主机标头应转发到。 这是通过比较中使用一组的已注册的 URI 前缀请求的信息。 为了能够将这些值进行比较，需要进行一些规范化到请求。 对于上面的转换后的 URI 的示例将为，如下所示：  
  
 `http://www.contoso.com/path/`  
  
 `http.sys`服务结合<xref:System.Uri.Host%2A?displayProperty=nameWithType>属性值和请求行来创建转换后的 URI 中的字符串。 此外，`http.sys`和<xref:System.Uri?displayProperty=nameWithType>类还执行以下操作：  
  
-   取消转义所有百分比编码值。  
  
-   将转换百分比编码为 utf-16 字符表示形式的非 ASCII 字符。 请注意，以及 Unicode 字符 （Unicode 编码使用 %uxxxx 格式） 支持 utf-8 和 ANSI/DBCS 字符。  
  
-   执行其他规范化步骤，如路径压缩。  
  
 请求不包含有关用于百分比编码值的编码的任何信息，因为它可能不能以确定正确的编码只是通过分析百分比编码值。  
  
 因此`http.sys`提供用于修改进程的两个注册表项：  
  
|注册表项|默认值|描述|  
|------------------|-------------------|-----------------|  
|EnableNonUTF8|1|如果为零，`http.sys`接受仅 UTF 8 编码的 Url。<br /><br /> 如果非零，`http.sys`还接受在请求中的 ANSI 编码或 DBCS 编码的 Url。|  
|FavorUTF8|1|如果非零，`http.sys`始终尝试解码 URL 为 utf-8 首先; 如果转换失败和 EnableNonUTF8 为非零，Http.sys 然后尝试对其进行解码为 ANSI 或 DBCS。<br /><br /> 如果为零 （和 EnableNonUTF8 为非零），`http.sys`尝试对其进行解码为 ANSI 或 DBCS; 如果该操作不成功，它会尝试 utf-8 转换。|  
  
 当<xref:System.Net.HttpListener>收到请求时，它使用转换后的 URI 从`http.sys`作为输入到<xref:System.Net.HttpListenerRequest.Url%2A>属性。  
  
 没有需要在 Uri 中支持除了字符和数字的字符。 一个示例是下面的 URI，用于检索客户的客户信息数字"1/3812":  
  
 `http://www.contoso.com/Customer('1%2F3812')/`  
  
 请注意 Uri (%2f) 中的百分号编码斜杠。 因为在这种情况下包含斜杠字符表示数据而不是路径分隔符，这是必需的。  
  
 将字符串传递给 Uri 构造函数将导致以下 URI:  
  
 `http://www.contoso.com/Customer('1/3812')/`  
  
 将路径拆分为其段将导致以下元素：  
  
 `Customer('1`  
  
 `3812')`  
  
 这不是请求的发送方的意图。  
  
 如果<xref:System.Net.Configuration.HttpListenerElement.UnescapeRequestUrl%2A>属性设置为 false，则当<xref:System.Net.HttpListener>收到请求时，它使用的原始 URI 而不是转换后 URI`http.sys`作为输入到<xref:System.Net.HttpListenerRequest.Url%2A>属性。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Net.HttpListenerRequest.Url%2A>属性。  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Configuration.HttpListenerElement" />
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UrlReferrer">
      <MemberSignature Language="C#" Value="public Uri UrlReferrer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UrlReferrer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UrlReferrer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UrlReferrer As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ UrlReferrer { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取将使客户端与服务器相关的资源的统一资源标识符 (URI)。</summary>
        <value>
          <see cref="T:System.Uri" /> 对象，包含请求的 <see cref="F:System.Net.HttpRequestHeader.Referer" /> 标头的文本；如果请求中不包含标头，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果客户端具有遵循到请求的 URI 的超链接，可能包含其请求`Referrer`标识包含该超链接的资源的 URI 的标头。  
  
 客户端可以伪造，或选择不存在<xref:System.Net.HttpRequestHeader.Referer>标头。 因此，虽然<xref:System.Net.HttpListenerRequest.UrlReferrer%2A>属性可用于标识 Web 流量的基本趋势; 你不应使用它作为授权方案的一部分来控制对数据的访问。  
  
 请求标头的完整列表，请参阅<xref:System.Net.HttpRequestHeader>枚举。  
  
 <xref:System.Net.HttpListenerRequest.UrlReferrer%2A>为 null 时没有`Referrer`请求标头中的时，或者当`Referrer`标头在请求中存在但不会分析为有效<xref:System.Uri>。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此属性。  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取客户端提供的用户代理。</summary>
        <value>一个 <see cref="T:System.String" /> 对象，其中包含请求的 <see langword="User-Agent" /> 标头的文本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `User-Agent`标头通常包含标识用于生成请求的软件的名称和版本数的文本。  
  
 请求标头的完整列表，请参阅<xref:System.Net.HttpRequestHeader>枚举。  
  
 <xref:System.Net.HttpListenerRequest.UserAgent%2A>为 null 时没有`User-Agent`请求标头中的。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此属性。  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserHostAddress">
      <MemberSignature Language="C#" Value="public string UserHostAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostAddress" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserHostAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostAddress { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取请求定向到的服务器 IP 地址和端口号。</summary>
        <value>包含主机地址信息的 <see cref="T:System.String" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的信息也是可用在<xref:System.Net.HttpListenerRequest.LocalEndPoint%2A>属性值。  
  
   
  
## Examples  
 下面的代码示例显示此属性的值。  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserHostName">
      <MemberSignature Language="C#" Value="public string UserHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserHostName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取由客户端指定的 DNS 名称和端口号（如果提供了端口号）。</summary>
        <value>一个 <see cref="T:System.String" /> 值，其中包含请求的 <see langword="Host" /> 标头的文本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Host`标头包含请求的服务器主机名和端口号，如果指定，分号分隔 (例如， `www.contoso.com:8080`)。  
  
 你可以使用此属性返回不同的响应，具体取决于请求中指定的主机名。  
  
 请求标头的完整列表，请参阅<xref:System.Net.HttpRequestHeader>枚举。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此属性。  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
    <Member MemberName="UserLanguages">
      <MemberSignature Language="C#" Value="public string[] UserLanguages { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] UserLanguages" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpListenerRequest.UserLanguages" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserLanguages As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ UserLanguages { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.HttpListener</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取响应的首选自然语言。</summary>
        <value>
          <see cref="T:System.String" /> 数组，包含请求的 <see cref="F:System.Net.HttpRequestHeader.AcceptLanguage" /> 标头中指定的语言；如果客户端请求不包含 <see cref="F:System.Net.HttpRequestHeader.AcceptLanguage" /> 标头，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关的详细说明`Accept-Language`标头，请参阅 RFC 2616 部分 14.4，可用在[ https://www.rfc-editor.org ](https://www.rfc-editor.org/)。  
  
 请求标头的完整列表，请参阅<xref:System.Net.HttpRequestHeader>枚举。  
  
   
  
## Examples  
 下面的代码示例显示从请求的语言`Accept-Language`标头。  
  
 [!code-csharp[Net_Listener_Basic#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Net_Listener_Basic/CS/test.cs#15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.HttpListener" />
        <altmember cref="T:System.Net.HttpListenerContext" />
        <altmember cref="T:System.Net.HttpListenerResponse" />
      </Docs>
    </Member>
  </Members>
</Type>