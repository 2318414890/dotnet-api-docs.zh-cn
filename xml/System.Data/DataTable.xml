<Type Name="DataTable" FullName="System.Data.DataTable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ae2d2ca49781b6fbea2101bb4f63426c09bee1b1" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33685185" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataTable extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTable" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTable&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTable : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("RowChanging")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("TableName")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataTableSchema")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示内存中数据的一个表。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable>是 ADO.NET 库中的中央对象。 其他对象使用<xref:System.Data.DataTable>包括<xref:System.Data.DataSet>和<xref:System.Data.DataView>。  
  
 在访问时<xref:System.Data.DataTable>对象，请注意，它们是有条件地区分大小写。 例如，如果一个<xref:System.Data.DataTable>名为"mydatatable"和另一个名为"Mydatatable"，用于搜索表中的一个的字符串将被视为区分大小写。 但是，如果"mydatatable"存在，并且"Mydatatable"不，搜索字符串将被视为区分。 A<xref:System.Data.DataSet>可以包含两个<xref:System.Data.DataTable>具有相同的对象<xref:System.Data.DataTable.TableName%2A>属性值但是具有不同<xref:System.Data.DataTable.Namespace%2A>属性值。 有关使用<xref:System.Data.DataTable>对象，请参阅[创建数据表](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md)。  
  
 如果要创建<xref:System.Data.DataTable>以编程方式，你首先必须通过添加定义其架构<xref:System.Data.DataColumn>对象添加到<xref:System.Data.DataColumnCollection>(通过访问<xref:System.Data.DataTable.Columns%2A>属性)。 有关添加详细信息<xref:System.Data.DataColumn>对象，请参阅[向数据表添加列](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md)。  
  
 若要将行添加到<xref:System.Data.DataTable>，必须首先使用<xref:System.Data.DataTable.NewRow%2A>方法以返回一个新<xref:System.Data.DataRow>对象。 <xref:System.Data.DataTable.NewRow%2A>方法返回的架构行<xref:System.Data.DataTable>，因为它由表的定义<xref:System.Data.DataColumnCollection>。 行的最大数目<xref:System.Data.DataTable>可以存储是 16777216。 有关详细信息，请参阅[向数据表添加数据](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md)。  
  
 <xref:System.Data.DataTable>还包含一套<xref:System.Data.Constraint>可以用于确保数据完整性的对象。 有关详细信息，请参阅[数据表约束](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md)。  
  
 有许多<xref:System.Data.DataTable>可以用于确定当对表进行更改的事件。 其中包括 <xref:System.Data.DataTable.RowChanged>、<xref:System.Data.DataTable.RowChanging>、<xref:System.Data.DataTable.RowDeleting> 和 <xref:System.Data.DataTable.RowDeleted>。 有关可与事件的详细信息<xref:System.Data.DataTable>，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
 实例时<xref:System.Data.DataTable>创建后，某些的读/写属性设置为初始值。 有关这些值的列表，请参阅<xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType>构造函数主题。  
  
> [!NOTE]
>  <xref:System.Data.DataSet>和<xref:System.Data.DataTable>对象继承自<xref:System.ComponentModel.MarshalByValueComponent>，并且支持<xref:System.Runtime.Serialization.ISerializable>.NET Framework 远程处理的接口。 这些是唯一可用于.NET Framework 远程处理的 ADO.NET 对象。  
  
   
  
## Examples  
 下面的示例创建两个<xref:System.Data.DataTable>对象和一个<xref:System.Data.DataRelation>对象，并将添加到的新对象<xref:System.Data.DataSet>。 表将显示在<xref:System.Windows.Forms.DataGridView>控件。  
  
 [!code-csharp[Classic WebData DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable Example/VB/source.vb#1)]  
  
 此示例演示如何使用特定的架构定义手动创建 DataTable：  
  
-   创建多个 DataTable 并定义初始列。  
  
-   创建表约束。  
  
-   插入值并显示表。  
  
-   创建表达式列并显示表。  
  
 此代码示例的 C# 和 Visual Basic 项目可以位于[开发人员代码示例](https://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914)。  
  
 [!code-csharp[Classic WebData DataTable Example2#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/classic webdata datatable example2/cs/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example2#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/classic webdata datatable example2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是安全的多线程读取操作。 你必须同步任何写入操作。</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Data.DataTable" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>在不使用参数的情况下初始化 <see cref="T:System.Data.DataTable" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 构造函数设置的所有属性的初始值<xref:System.Data.DataTable>对象。 下表显示的属性和其默认值。 实例时<xref:System.Data.DataTable>创建以下读/写属性设置为初始值。  
  
|Property|默认值|  
|--------------|-------------------|  
|**CaseSensitive**|与父项相同<xref:System.Data.DataSet>，如果它属于一个。 否则为 `false`。|  
|**DisplayExpression**|空字符串 ("")|  
|**区域设置**|与父项相同<xref:System.Data.DataSet>对象的<xref:System.Globalization.CultureInfo>(返回<xref:System.Data.DataSet.Locale%2A>属性); 如果存在没有父级，默认值是当前系统<xref:System.Globalization.CultureInfo>。|  
|**MinimumCapacity**|50 行。|  
  
 你可以更改任何通过单独属性调用这些属性的值。  
  
   
  
## Examples  
 下面的示例创建一个新<xref:System.Data.DataTable>与<xref:System.Data.DataColumn>和<xref:System.Data.DataRow>，并将其显示在<xref:System.Windows.Forms.DataGridView>控件。  
  
 [!code-csharp[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">要向表提供的名称。 如果 tableName 为 <see langword="null" /> 或空字符串，则添加到 <see cref="T:System.Data.DataTableCollection" /> 时会提供默认名称<c></c>。</param>
        <summary>使用指定的表名初始化 <see cref="T:System.Data.DataTable" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建<xref:System.Data.DataTable>和将其显示在<xref:System.Windows.Forms.DataGridView>控件。  
  
 [!code-csharp[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataTable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataTable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">序列化或反序列化对象所需的数据。</param>
        <param name="context">给定序列化流的源和目标。</param>
        <summary>使用 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 和 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 初始化 <see cref="T:System.Data.DataTable" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现的<xref:System.Data.DataTable>构造函数，才能使用<xref:System.Runtime.Serialization.ISerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName, string tableNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName, string tableNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String, tableNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName, System::String ^ tableNamespace);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
        <Parameter Name="tableNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">要向表提供的名称。 如果 tableName 为 <see langword="null" /> 或空字符串，则添加到 <see cref="T:System.Data.DataTableCollection" /> 时会提供默认名称<c></c>。</param>
        <param name="tableNamespace">
          <see langword="DataTable" /> 中所存储数据的 XML 表示形式的命名空间。</param>
        <summary>使用指定的表名和命名空间初始化 <see cref="T:System.Data.DataTable" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>提交自上次调用 <see cref="M:System.Data.DataTable.AcceptChanges" /> 以来对该表进行的所有更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Data.DataTable.AcceptChanges%2A>调用时，任何<xref:System.Data.DataRow>仍处于编辑模式的对象已成功结束其编辑。 <xref:System.Data.DataRowState>也会更改： 所有`Added`和`Modified`行都变为`Unchanged`，和`Deleted`已删除的行。  
  
 <xref:System.Data.DataTable.AcceptChanges%2A>方法通常称为上<xref:System.Data.DataTable>你尝试更新后<xref:System.Data.DataSet>使用<xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下面的示例测试有错误的每个表。 如果表中的错误可以协调 （通过将其传递到未定义的函数），<xref:System.Data.DataTable.AcceptChanges%2A>调用; 否则为<xref:System.Data.DataTable.RejectChanges%2A>调用。  
  
 [!code-csharp[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>开始初始化在窗体上使用或由另一个组件使用的 <see cref="T:System.Data.DataTable" />。 初始化发生在运行时。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio.NET 设计环境使用此方法来启动窗体上使用或由另一个组件的组件的初始化。 <xref:System.Data.DataTable.EndInit%2A>方法初始化已结束。 使用<xref:System.Data.DataTable.BeginInit%2A>和<xref:System.Data.DataTable.EndInit%2A>方法阻止控件完全初始化之前使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadData">
      <MemberSignature Language="C#" Value="public void BeginLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoadData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>加载数据时，关闭通知、索引维护和约束。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.BeginLoadData%2A>结合<xref:System.Data.DataTable.LoadDataRow%2A>和<xref:System.Data.DataTable.EndLoadData%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示表中的字符串比较是否区分大小写。</summary>
        <value>
          如果比较区分大小写，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值被设置为父级 <see cref="T:System.Data.DataSet" /> 对象的 <see cref="P:System.Data.DataSet.CaseSensitive" /> 属性；当 <see cref="T:System.Data.DataTable" /> 的创建独立于 <see cref="T:System.Data.DataSet" /> 时设置为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.CaseSensitive%2A>属性会影响中排序、 搜索和筛选的字符串比较。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Data.DataTable.Select%2A>方法两次<xref:System.Data.DataTable>。 第一次，<xref:System.Data.DataTable.CaseSensitive%2A>属性设置为`false`，则第二个`true`。  
  
 [!code-csharp[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Select" />
      </Docs>
    </Member>
    <Member MemberName="ChildRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ChildRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ChildRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ChildRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChildRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ChildRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 <see cref="T:System.Data.DataTable" /> 的子关系的集合。</summary>
        <value>一个 <see cref="T:System.Data.DataRelationCollection" />，包含该表的子关系。 如果 <see cref="T:System.Data.DataRelation" /> 对象不存在，将返回空集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Data.DataRelation>定义两个表之间的关系。 通常情况下，通过单个字段包含相同的数据链接两个表。 例如，其中包含地址数据的表可能具有单个字段，其中包含表示国家/地区代码。 包含国家/地区的数据的第二个表将具有单个字段包含标识国家/地区代码和它将此代码会插入到第一个表中的对应字段。 A <xref:System.Data.DataRelation>，然后，包含至少四部分信息: (1) 的第一个表名称、 中的第一个表 （2） 的列名称、 第二个表，（3） 的名称和第二个表中 （4） 的列名称。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Data.DataTable.ChildRelations%2A>属性以返回每个子<xref:System.Data.DataRelation>中<xref:System.Data.DataTable>。 每个关系中的参数作为用<xref:System.Data.DataRow.GetChildRows%2A>方法<xref:System.Data.DataRow>返回行的数组。 然后打印的行中的每个列的值。  
  
 [!code-csharp[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ParentRelations" />
        <altmember cref="M:System.Data.DataRow.GetParentRows(System.String)" />
        <altmember cref="M:System.Data.DataRow.GetChildRows(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除所有数据的 <see cref="T:System.Data.DataTable" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将删除所有表中的所有行。 如果表具有将导致子行孤立任何强制执行的子关系，则会生成异常。  
  
 如果<xref:System.Data.DataSet>绑定到<xref:System.Xml.XmlDataDocument>，则调用<xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType>或<xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType>引发<xref:System.NotSupportedException>。 若要避免这种情况下，遍历每个表，一次移除每一行。 当你使用<xref:System.Data.DataTable.NewRow%2A>若要创建新行，行必须处理你在调用之前<xref:System.Data.DataTable.Clear%2A>。  
  
   
  
## Examples  
 下面的示例将清除所有数据的表。  
  
 [!code-csharp[Classic WebData DataTable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataTable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataTable ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>克隆 <see cref="T:System.Data.DataTable" /> 的结构，包括所有 <see cref="T:System.Data.DataTable" /> 架构和约束。</summary>
        <returns>新的 <see cref="T:System.Data.DataTable" />，与当前 <see cref="T:System.Data.DataTable" /> 具有相同架构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果派生的这些类，克隆也将是相同的派生类。  
  
 克隆可创建具有与原始 <xref:System.Data.DataTable> 相同的结构的新 <xref:System.Data.DataTable>，但不复制任何数据（新 <xref:System.Data.DataTable> 将不会包含任何 `DataRows`）。 若要同时将结构和数据复制到新 <xref:System.Data.DataTable> 中，请使用 <xref:System.Data.DataTable.Copy%2A>。  
  
   
  
## Examples  
 以下示例演示如何在执行 DataTable.Clone 后更新目标表的结构和约束。 ClonedDataTable 类将返回目标表并包括所有更新事件。 克隆后，源表中的结构更改不会反映到目标表中。 具体而言，此示例将：  
  
-   更新源表中的列更改。  
  
-   更新源表中的 UniqueConstraint 更改。  
  
-   更新源表中的 ForeignKeyConstraint 更改。  
  
 此代码示例的 C# 和 Visual Basic 项目可以位于[开发人员代码示例](https://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable)。  
  
```csharp  
using System;  
using System.Linq;  
using System.Data;  
using System.ComponentModel;  
  
class Program {  
   static void Main(string[] args) {  
      DataTable courses = NewCourseDataTable();  
      Console.WriteLine("This is the source table:");  
      WriteDataTable(courses);  
  
      ClonedDataTable clonedResult = new ClonedDataTable(courses);  
      DataTable clonedCourses = clonedResult.DestinationTable;  
      Console.WriteLine("This is the destination table:");  
      WriteDataTable(clonedCourses);  
  
      // Add the events of updating column collection into the source table.  
      clonedResult.UpdateAddedColumn();  
      clonedResult.UpdateDeletedColumn();  
      // Add a DataColumn in source table.  
      DataColumn columnCreidts = new DataColumn("Credits", typeof(Int32));  
      courses.Columns.Add(columnCreidts);  
      Console.WriteLine("After add a column in source table, it's the result in the destination:");  
      WriteDataTable(clonedCourses);  
  
      // Add the event of updating UniqueConstraint into the source table.  
      clonedResult.UpdateUniqueConstraint();  
  
      // Add the unique constraint in source table.  
      UniqueConstraint uniqueConstraint = new UniqueConstraint(courses.Columns["CourseId"]);  
      courses.Constraints.Add(uniqueConstraint);  
  
      Console.WriteLine(@"If we add the unique constraint in source table and then insert the duplicate   
rows into the destination table, we will get the following error:");  
      InsertDuplicateData(clonedCourses);  
      Console.WriteLine();  
  
      // Add the event of updating ForeignKeyConstraint into the source table.  
      clonedResult.UpdateForeignKeyConstraint();  
  
      // Add the ForeignKeyConstraint into the source table.  
      DataTable deparments = NewDeparmentDataTable();  
      DataSet dataset = new DataSet();  
  
      dataset.Tables.Add(courses);  
      dataset.Tables.Add(clonedCourses);  
      dataset.Tables.Add(deparments);  
  
      ForeignKeyConstraint foreignKey = new ForeignKeyConstraint(deparments.Columns["DepartmentId"], courses.Columns["DepartmentId"]);  
      courses.Constraints.Add(foreignKey);  
  
      Console.WriteLine(@"If we add the foreign key constraint in source table and then insert a row   
without the parent  into the destination table, we will get the following error:");  
      InsertNoParentRow(clonedCourses);  
      Console.WriteLine();  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   static private DataTable NewCourseDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("CourseId", typeof(String)),  
                                      new DataColumn("CourseName",typeof(String)),                                        
                                      new DataColumn("DepartmentId", typeof(Int32))  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add("C1045", "Calculus", 7);  
      newTable.Rows.Add("C1061", "Physics", 1);  
      newTable.Rows.Add("C2021", "Composition", 2);  
      newTable.Rows.Add("C2042", "Literature", 2);  
  
      return newTable;  
   }  
  
   static private DataTable NewDeparmentDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("DepartmentId", typeof(Int32)),  
                                      new DataColumn("Name",typeof(String)),  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add(1, "Engineering");  
      newTable.Rows.Add(2, "English");  
      newTable.Rows.Add(4, "Economics");  
      newTable.Rows.Add(7, "Mathematics");  
  
      return newTable;  
   }  
  
   static private void WriteDataTable(DataTable table) {  
      if (table == null)  
         return;  
  
      foreach (DataColumn column in table.Columns) {  
         Console.Write("{0,-15}", column.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         for (int i = 0; i < table.Columns.Count; i++)  
            Console.Write("{0,-15}", row[i].ToString());  
         Console.WriteLine();  
      }  
  
      Console.WriteLine();  
   }  
  
   static private void InsertDuplicateData(DataTable table) {  
      try {  
         table.Rows.Add("C1045", "Calculus", 7);  
         table.Rows.Add("C1045", "Calculus", 7);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
  
   private static void InsertNoParentRow(DataTable table) {  
      try {  
         table.Rows.Add("C1061", "Physics", 11);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
}  
  
public class ClonedDataTable {  
   private DataTable sourceTable;  
   private DataTable destinationTable;  
  
   public ClonedDataTable(DataTable source) {  
      sourceTable = source;  
      // set the cloned result  
      destinationTable = sourceTable.Clone();  
   }  
  
   public void UpdateAddedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnAdded);  
   }  
  
   public void UpdateDeletedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnDeleted);  
   }  
  
   public void UpdateUniqueConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(UniqueConstraint_Changed);  
   }  
  
   public void UpdateForeignKeyConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(ForeignKeyConstraint_Changed);  
   }  
  
   // After the source table adds a column, the method will add the same column in the destination table.  
   void ColumnAdded(object sender, System.ComponentModel.CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null) {  
            DataColumn newColumn = new DataColumn(column.ColumnName, column.DataType, column.Expression, column.ColumnMapping);  
  
            if (!destinationTable.Columns.Contains(newColumn.ColumnName))  
               destinationTable.Columns.Add(newColumn);  
         }  
      }  
   }  
  
   // After the source table deletes a column, the method will delete the same column in the destination table.  
   void ColumnDeleted(object sender, CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Remove) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null)  
            if (destinationTable.Columns.Contains(column.ColumnName))  
               destinationTable.Columns.Remove(column.ColumnName);  
      }  
   }  
  
   // After the source table changes the UniqueConstraint, this method changes the same UniqueConstraint in destination table.        
   void UniqueConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      UniqueConstraint constraint = e.Element as UniqueConstraint;  
  
      if (constraint == null)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         Boolean isPrimaryKey = constraint.IsPrimaryKey;  
  
         // Get the columns used in new constraint from the destiantion table.  
         for (Int32 i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         UniqueConstraint newConstraint = new UniqueConstraint(constraintName, columns, isPrimaryKey);  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // After the source table changes the ForeignKeyConstraint, this method changes    
   // the same ForeignKeyConstraint in the destination table.  
   void ForeignKeyConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      ForeignKeyConstraint constraint = e.Element as ForeignKeyConstraint;  
  
      if (constraint == null)  
         return;  
  
      // If the source and destination are not in the same DataSet, don't change the ForeignKeyConstraint.  
      if (sourceTable.DataSet != destinationTable.DataSet)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         DataColumn[] parentColumns = constraint.RelatedColumns;  
  
         // Get the columns used in new constraint from the destination table.  
         for (int i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constraintName, parentColumns, columns);  
         newConstraint.AcceptRejectRule = constraint.AcceptRejectRule;  
         newConstraint.DeleteRule = constraint.DeleteRule;  
         newConstraint.UpdateRule = constraint.UpdateRule;  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // return the destination table.  
   public DataTable DestinationTable {  
      get { return destinationTable; }  
   }  
}  
```  
  
 此示例演示如何更改 DataTable 中的数据和更新数据源。  
  
 首先，创建一个数据库：  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 现在可编译并运行此示例。 [如何修改 DataTable 和更新到数据源中的数据](https://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4)具有此示例的 Visual Basic 和 C# 项目。  
  
```csharp  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
   string MySchoolConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True";  
  
      // Get Data  
      String selectString =  
       @"Select [CourseID],[Year],[Title],[Credits],[DepartmentID] From [dbo].[Course];  
               Select [DepartmentID],[Name],[Budget],[StartDate],[Administrator] From [dbo].[Department] ";  
  
      DataSet dataSet = new DataSet();  
      DataTable course = dataSet.Tables.Add("Course");  
      DataTable department = dataSet.Tables.Add("Department");  
  
      Console.WriteLine("Get data from database:");  
      GetDataTables(MySchoolConnectionString, selectString, dataSet, course, department);  
      Console.WriteLine();  
  
      // Use DataTable Edits to edit the data  
      String updateString =  
              @"Update [dbo].[Course] Set [Credits]=@Credits Where [CourseID]=@CourseID;";  
  
      course.ColumnChanged += OnColumnChanged;  
  
      // Set the Credits of first row is negative value, and set the Credits of second row is plus.  
      ChangeCredits(course, course.Rows[0], -1);  
      ChangeCredits(course, course.Rows[1], 11);  
  
      UpdateDataTables(MySchoolConnectionString, updateString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"),  
          new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits"));  
      Console.WriteLine("Only the Credits of second row is changed.");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      // Delete and Remove from DataTable  
      // Create the foreign key constraint, and set the DeleteRule with Cascade.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      String deleteString = @"Delete From [dbo].[Course] Where [CourseID]=@CourseID;";  
  
      department.Rows[0].Delete();  
      Console.WriteLine("If One row in Department table is deleted, the related rows in Course table will also be deleted.");  
      Console.WriteLine("Department DataTable:");  
      ShowDataTable(department);  
      Console.WriteLine();  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
      // Update the delete operation  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
      Console.WriteLine("After delete operation:");  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      course.Rows.RemoveAt(0);  
      Console.WriteLine("Now we remove one row from Course:");  
      ShowDataTable(course);  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
   }  
  
   // Use SqlDataAdapter to get data.  
   private static void GetDataTables(String connectionString, String selectString,  
       DataSet dataSet, params DataTable[] tables) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.SelectCommand = new SqlCommand(selectString);  
         adapter.SelectCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Fill(0, 0, tables);  
  
         foreach (DataTable table in dataSet.Tables) {  
            Console.WriteLine("Data in {0}:", table.TableName);  
            ShowDataTable(table);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use SqlDataAdapter to update the updata operation.  
   private static void UpdateDataTables(String connectionString, String updateString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.UpdateCommand = new SqlCommand(updateString);  
         adapter.UpdateCommand.Parameters.AddRange(parameters);  
         adapter.UpdateCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use SqlDataAdapter to update delete operation.  
   private static void DeleteDataTables(String connectionString, String deleteString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.DeleteCommand = new SqlCommand(deleteString);  
         adapter.DeleteCommand.Parameters.AddRange(parameters);  
         adapter.DeleteCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use DataTable Edits to modify the data.  
   private static void ChangeCredits(DataTable table, DataRow row, Int32 credits) {  
      row.BeginEdit();  
      Console.WriteLine("We change row {0}", table.Rows.IndexOf(row));  
      row["Credits"] = credits;  
      row.EndEdit();  
   }  
  
   // The method will be invoked when the value in DataTable is changed.  
   private static void OnColumnChanged(Object sender, DataColumnChangeEventArgs args) {  
      Int32 credits = 0;  
      // If Credits is changed and the value is negative, we'll cancel the edit.  
      if ((args.Column.ColumnName == "Credits") &&  
          (!Int32.TryParse(args.ProposedValue.ToString(), out credits) || credits < 0)) {  
         Console.WriteLine("The value of Credits is invalid. Edit canceled.");  
         args.Row.CancelEdit();  
      }  
   }  
  
   // Display the column and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "RowState");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               else  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col]);  
               else  
                  Console.Write("{0,-14}", row[col]);  
            }  
         }  
         Console.WriteLine("{0,-14}", row.RowState);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Copy" />
      </Docs>
    </Member>
    <Member MemberName="ColumnChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanged As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>更改 <see cref="T:System.Data.DataRow" /> 中指定的 <see cref="T:System.Data.DataColumn" /> 值之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataColumnChangeEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ColumnChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanging As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>更改 <see cref="T:System.Data.DataRow" /> 中指定的 <see cref="T:System.Data.DataColumn" /> 值时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Columns">
      <MemberSignature Language="C#" Value="public System.Data.DataColumnCollection Columns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumnCollection Columns" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Columns" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Columns As DataColumnCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataColumnCollection ^ Columns { System::Data::DataColumnCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取属于该表的列的集合。</summary>
        <value>一个 <see cref="T:System.Data.DataColumnCollection" />，包含该表的 <see cref="T:System.Data.DataColumn" /> 对象的集合。 如果 <see cref="T:System.Data.DataColumn" /> 对象不存在，将返回空集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataColumnCollection>通过定义每个列的数据类型确定的表架构。  
  
   
  
## Examples  
 下面的示例输出中表使用的每一行的每个值<xref:System.Data.DataTable.Columns%2A>属性。  
  
 [!code-csharp[Classic WebData DataTable.Columns Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Columns Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compute">
      <MemberSignature Language="C#" Value="public object Compute (string expression, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Compute(string expression, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Compute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compute (expression As String, filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Compute(System::String ^ expression, System::String ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">要计算的表达式。</param>
        <param name="filter">用于限制表达式中计算的行的筛选器。</param>
        <summary>计算用来传递筛选条件的当前行上的给定表达式。</summary>
        <returns>将 <see cref="T:System.Object" /> 设置为计算结果。 如果该表达式计算结果为 null，则返回值为 <see cref="F:System.DBNull.Value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `expression`参数需要聚合函数。 例如，下面是一个合法的表达式：  
  
 `Count(Quantity)`  
  
 但是，此表达式不是：  
  
 `Sum (Quantity * UnitPrice)`  
  
 如果必须执行两个或多个列上的操作，则应创建<xref:System.Data.DataColumn>，将其<xref:System.Data.DataColumn.Expression%2A>到适当的表达式，并使用在生成的列的聚合表达式中的属性。 在这种情况下，给定<xref:System.Data.DataColumn>具有名称"总"，与<xref:System.Data.DataColumn.Expression%2A>属性设置为此：  
  
 `"Quantity * UnitPrice"`  
  
 表达式参数<xref:System.Data.DataTable.Compute%2A>方法将为此：  
  
 `Sum(total)`  
  
 第二个参数， `filter`，确定在表达式中使用哪些行。 例如，如果表包含一个名为"colDate"的日期列，则无法限制使用以下表达式的行：  
  
 `colDate > 1/1/99 AND colDate < 17/1/99`  
  
 有关创建这两个参数的表达式的规则，请参阅<xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType>属性。  
  
   
  
## Examples  
 下面的示例针对名"总计"，为其标识号为五位销售人员的列的值求和。  
  
 [!code-csharp[Classic WebData DataTable.Compute Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Compute Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public System.Data.ConstraintCollection Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ConstraintCollection Constraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Constraints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Constraints As ConstraintCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ConstraintCollection ^ Constraints { System::Data::ConstraintCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConstraintCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取由该表维护的约束的集合。</summary>
        <value>一个 <see cref="T:System.Data.ConstraintCollection" />，包含该表的 <see cref="T:System.Data.Constraint" /> 对象的集合。 如果 <see cref="T:System.Data.Constraint" /> 对象不存在，将返回空集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Data.ForeignKeyConstraint>限制时删除或更新列 （或列） 中的值执行的操作。 此类约束旨在与主键列一起使用。 在父/子关系中两个表之间，从父表中删除值可能会影响子行在通过以下方式之一。  
  
-   也可以是行的子删除 （级联操作）。  
  
-   中子 （或多个列） 的值可以设置为 null 值。  
  
-   中子 （或多个列） 的值可以设置为默认值。  
  
-   可以生成异常。  
  
 A<xref:System.Data.UniqueConstraint>尝试在一个主键到非唯一的值中设置一个值时将变为活动状态。  
  
   
  
## Examples  
 下面的示例添加<xref:System.Data.ForeignKeyConstraint>到约束的集合。  
  
 [!code-csharp[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataTable Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ Copy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>复制该 <see cref="T:System.Data.DataTable" /> 的结构和数据。</summary>
        <returns>新的 <see cref="T:System.Data.DataTable" />，具有与该 <see cref="T:System.Data.DataTable" /> 相同的结构（表架构和约束）和数据。  
  
 如果已派生这些类，则副本也是相同的派生类。  
  
 <see cref="M:System.Data.DataTable.Copy" /> 创建一个新 <see cref="T:System.Data.DataTable" />，后者与原始 <see cref="T:System.Data.DataTable" /> 具有相同的结构和数据。 要将结构复制到新的 <see cref="T:System.Data.DataTable" />，而不是复制到数据，请使用 <see cref="M:System.Data.DataTable.Clone" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例使用<xref:System.Data.DataTable.Copy%2A>方法来创建一份原始<xref:System.Data.DataTable>。 如果从父文件夹继承的命名空间名称不会保留<xref:System.Data.DataTable>或<xref:System.Data.DataSet>。  
  
 [!code-csharp[Classic WebData DataTable.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataView.ToTable" />
        <altmember cref="M:System.Data.DataTable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回与此 <see cref="T:System.Data.DataTable" /> 内的数据对应的 <see cref="T:System.Data.DataTableReader" />。</summary>
        <returns>
          <see cref="T:System.Data.DataTableReader" /> 包含一个对应于源 <see cref="T:System.Data.DataTable" /> 实例的结果集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下控制台应用程序创建一个 <xref:System.Data.DataTable> 实例。 该示例然后将填充<xref:System.Data.DataTable>给过程调用<xref:System.Data.DataTable.CreateDataReader%2A>方法，它循环访问结果中包含<xref:System.Data.DataTableReader>。  
  
 [!code-csharp[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/VB/source.vb#1)]  
  
 该示例在控制台窗口中显示以下输出：  
  
 `1 Mary`  
  
 `2 Andy`  
  
 `3 Peter`  
  
 `4 Russ`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.CreateDataReader" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateInstance () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ CreateInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建 <see cref="T:System.Data.DataTable" /> 的新实例。</summary>
        <returns>新表达式。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此表所属的 <see cref="T:System.Data.DataSet" />。</summary>
        <value>此表所属的 <see cref="T:System.Data.DataSet" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果控件数据绑定到<xref:System.Data.DataTable>，并且表属于<xref:System.Data.DataSet>，可获取指向<xref:System.Data.DataSet>通过此属性。  
  
   
  
## Examples  
 下面的示例返回父<xref:System.Data.DataSet>通过给定表的<xref:System.Data.DataTable.DataSet%2A>属性。  
  
 [!code-csharp[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultView">
      <MemberSignature Language="C#" Value="public System.Data.DataView DefaultView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataView DefaultView" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DefaultView" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultView As DataView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataView ^ DefaultView { System::Data::DataView ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可能包含筛选视图或游标位置的表的自定义视图。</summary>
        <value>与 <see cref="T:System.Data.DataView" /> 关联的 <see cref="T:System.Data.DataTable" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.DefaultView%2A>属性返回<xref:System.Data.DataView>可用于排序、 筛选和搜索<xref:System.Data.DataTable>。  
  
   
  
## Examples  
 下面的示例设置的一个属性<xref:System.Data.DataTable>对象的<xref:System.Data.DataView>通过<xref:System.Data.DataTable.DefaultView%2A>属性。 该示例还演示的绑定<xref:System.Windows.Forms.DataGridView>控制转移到<xref:System.Data.DataTable>名为"供应商"包括一个名为"CompanyName"。  
  
 [!code-csharp[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayExpression">
      <MemberSignature Language="C#" Value="public string DisplayExpression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayExpression" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DisplayExpression" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayExpression As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayExpression { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个表达式，该表达式返回的值用于在用户界面中表示此表。 <see langword="DisplayExpression" /> 属性用于在用户界面中显示此表名。</summary>
        <value>显示字符串。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Data.DataColumn.Expression" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>结束在窗体上使用或由另一个组件使用的 <see cref="T:System.Data.DataTable" /> 的初始化。 初始化发生在运行时。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio.NET 设计环境使用此方法来结束的窗体上使用或由另一个组件的组件初始化。 <xref:System.Data.DataTable.BeginInit%2A>方法开始初始化。 使用<xref:System.Data.DataTable.BeginInit%2A>和<xref:System.Data.DataTable.EndInit%2A>方法阻止控件完全初始化之前使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLoadData">
      <MemberSignature Language="C#" Value="public void EndLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>加载数据后，打开通知、索引维护和约束。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.EndLoadData%2A>结合<xref:System.Data.DataTable.LoadDataRow%2A>和<xref:System.Data.DataTable.BeginLoadData%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取自定义用户信息的集合。</summary>
        <value>包含自定义用户信息的 <see cref="T:System.Data.PropertyCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.ExtendedProperties%2A>向其添加自定义信息<xref:System.Data.DataTable>。 使用添加信息`Add`方法。 检索信息，`Item`方法。  
  
 扩展的属性的类型必须为<xref:System.String>。 并不属于 String 类型的属性不会保留时<xref:System.Data.DataTable>以 XML 形式写入。  
  
   
  
## Examples  
 下面的示例将添加到一个时间戳值<xref:System.Data.DataTable>通过<xref:System.Data.DataTable.ExtendedProperties%2A>属性。  
  
 [!code-csharp[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="fInitInProgress">
      <MemberSignature Language="C#" Value="protected internal bool fInitInProgress;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly bool fInitInProgress" />
      <MemberSignature Language="DocId" Value="F:System.Data.DataTable.fInitInProgress" />
      <MemberSignature Language="VB.NET" Value="Protected Friend fInitInProgress As Boolean " />
      <MemberSignature Language="C++ CLI" Value="protected public: bool fInitInProgress;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检查是否正在进行初始化。 初始化发生在运行时。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取 <see cref="T:System.Data.DataTable" /> 的副本，该副本包含自上次加载以来或自调用 <see cref="M:System.Data.DataTable.AcceptChanges" /> 以来的所有更改。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取 <see cref="T:System.Data.DataTable" /> 的副本，该副本包含自加载以来或自上次调用 <see cref="M:System.Data.DataTable.AcceptChanges" /> 以来进行的所有更改。</summary>
        <returns>此 <see cref="T:System.Data.DataTable" /> 中的更改的副本，如果未发现更改，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 创建一个新<xref:System.Data.DataSet>包含原始中的所有行的副本<xref:System.Data.DataSet>中具有挂起更改。 关系约束可能会导致其他未更改的行添加到新<xref:System.Data.DataSet>如果未更改的行包含对应于已更改的行中的外键的主键。 该方法返回`null`(`Nothing`在 Visual Basic 中) 中是否存在任何行原始<xref:System.Data.DataSet>与挂起的更改。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">
          <see cref="T:System.Data.DataRowState" /> 值之一。</param>
        <summary>获取由 <see cref="T:System.Data.DataRowState" /> 筛选的 <see cref="T:System.Data.DataTable" /> 的副本，该副本包含上次加载以来或调用 <see cref="M:System.Data.DataTable.AcceptChanges" /> 以来进行的所有更改。</summary>
        <returns>
          <see cref="T:System.Data.DataTable" /> 的筛选副本，可以对该副本执行操作，之后可以使用 <see cref="T:System.Data.DataTable" /> 将其合并回 <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />。 如果未找到所需 <see cref="T:System.Data.DataRowState" /> 的行，则该方法返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.GetChanges%2A>方法用于生成第二个<xref:System.Data.DataTable>引入到原始的只包含的更改的对象。 使用`rowStates`自变量以指定新的对象应包含的更改的类型。  
  
 关系约束可能会导致不变的父行要包含。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataTableSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataTableSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataTableSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">一个 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 实例。</param>
        <summary>该方法返回一个包含 Web Services 描述语言 (WSDL) 的 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 实例，该语言描述了用于 Web 服务的 <see cref="T:System.Data.DataTable" />。</summary>
        <returns>
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 实例。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetErrors">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] GetErrors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] GetErrors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetErrors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetErrors () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ GetErrors();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取包含错误的 <see cref="T:System.Data.DataRow" /> 对象数组。</summary>
        <returns>包含错误的 <see cref="T:System.Data.DataRow" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回具有 <xref:System.Data.DataRow> 集的 <xref:System.Data.DataRow.RowError%2A> 对象的列表。 例如，错误可能会导致在调用时<xref:System.Data.Common.DataAdapter.Update%2A>与<xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>设置为**true**。 不要对 <xref:System.Data.DataTable.AcceptChanges%2A> 调用 <xref:System.Data.DataTable>，直到您解决所有错误并重新提交 <xref:System.Data.DataSet> 以供更新。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Data.DataTable.GetErrors%2A>方法返回的数组<xref:System.Data.DataRow>具有错误的对象。  
  
 [!code-csharp[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.HasErrors" />
        <altmember cref="P:System.Data.DataRow.RowError" />
        <altmember cref="M:System.Data.DataRow.SetColumnError(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">一个 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象，包含与 <see cref="T:System.Data.DataTable" /> 关联的序列化数据。</param>
        <param name="context">一个 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 对象，包含与 <see cref="T:System.Data.DataTable" /> 关联的序列化流的源和目标。</param>
        <summary>使用序列化 <see cref="T:System.Data.DataTable" /> 时所需的数据填充序列化信息对象。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> 参数为 null 引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRowType">
      <MemberSignature Language="C#" Value="protected virtual Type GetRowType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetRowType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetRowType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRowType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetRowType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取行类型。</summary>
        <returns>返回 <see cref="T:System.Data.DataRow" /> 的类型。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetSchema" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchema () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchema();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />。</summary>
        <returns>一个 <see cref="T:System.Xml.Schema.XmlSchema" />，描述由 <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> 方法生成并由 <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> 方法使用的对象的 XML 表示形式。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示该表所属的 <see cref="T:System.Data.DataSet" /> 的任何表的任何行中是否有错误。</summary>
        <value>
          如果有错误，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户在数据中包含一组工作<xref:System.Data.DataTable>，如果更改会导致某些验证失败，可以将标记每个更改与错误的更改。 你可以将标记整个<xref:System.Data.DataRow>与错误消息使用<xref:System.Data.DataRow.RowError%2A>属性。 此外可以在每个列具有的行上设置错误<xref:System.Data.DataRow.SetColumnError%2A>方法。  
  
 更新数据源之前， <xref:System.Data.DataSet>，建议你首先调用<xref:System.Data.DataSet.GetChanges%2A>方法在目标上的<xref:System.Data.DataSet>。 该方法将产生<xref:System.Data.DataSet>包含仅与原始所做的更改。 在发送之前<xref:System.Data.DataSet>到更新的数据源，请检查<xref:System.Data.DataTable.HasErrors%2A>的每个表以查看任何错误是否已附加到的行或行中的列的属性。  
  
 协调的每个错误之后, 清除的错误<xref:System.Data.DataRow.ClearErrors%2A>方法`DataRow`。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Data.DataTable.HasErrors%2A>属性检查表是否包含错误。  
  
 [!code-csharp[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.GetErrors" />
      </Docs>
    </Member>
    <Member MemberName="ImportRow">
      <MemberSignature Language="C#" Value="public void ImportRow (System.Data.DataRow row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ImportRow(class System.Data.DataRow row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ImportRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ImportRow (row As DataRow)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ImportRow(System::Data::DataRow ^ row);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="row">要导入的 <see cref="T:System.Data.DataRow" />。</param>
        <summary>将 <see cref="T:System.Data.DataRow" /> 复制到 <see cref="T:System.Data.DataTable" /> 中，保留任何属性设置以及初始值和当前值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用<xref:System.Data.DataTable.NewRow%2A>将行添加到表使用现有的表架构，但使用的行，默认值并设置<xref:System.Data.DataRowState>到`Detached`。 调用<xref:System.Data.DataTable.ImportRow%2A>保留现有<xref:System.Data.DataRowState>以及行中的其他值。 如果`DataRow`传递当参数处于 detached 状态时，它将被忽略，但不会引发异常。  
  
 新行将添加到数据表的末尾。  
  
 如果新行与它不会添加到数据表约束冲突。  
  
 你可以获取具有 DataTable.Rows.Find 以及 DataTable.Rows.IndexOf 的新行的索引。 有关更多信息，请参见<xref:System.Data.DataRowCollection>和<xref:System.Data.DataTable.Rows%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>初始化 <see cref="T:System.Data.DataTable" /> 后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详情，请参阅<xref:System.Data.DataTable.IsInitialized%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否已初始化 <see cref="T:System.Data.DataTable" />。</summary>
        <value>
          <see langword="true" /> 表明组件已完成初始化；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的状态<xref:System.Data.DataTable>时它正在构造，例如 Visual Studio。 <xref:System.Data.DataTable.BeginInit%2A>方法将其设置为`false`和<xref:System.Data.DataTable.EndInit%2A>方法将其设置为`true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>通过所提供的 <see cref="T:System.Data.IDataReader" />，用某个数据源的值填充 <see cref="T:System.Data.DataTable" />。 如果 <see langword="DataTable" /> 已经包含行，则从数据源传入的数据与现有行合并。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load`方法可在几种常见情况，都围绕着从指定的数据源获取数据并将其添加到当前的数据容器 (在这种情况下， `DataTable`)。 以下方案说明的标准用法`DataTable`、 描述其更新和合并行为。  
  
 A`DataTable`同步或更新与单个主数据源。 `DataTable`跟踪更改，以实现与主数据源同步。 此外，`DataTable`可以接受来自一个或多个辅助数据源的增量数据。 `DataTable`不负责跟踪更改，以便允许与辅助数据源同步。  
  
 提供这些两个假设数据源，用户很可能需要的以下行为之一：  
  
-   初始化`DataTable`从主数据源。 在此方案中，用户想要初始化一个空`DataTable`与主数据源中的值。 更高版本，用户想要将更改传播回主数据源。  
  
-   保留更改，并从主数据源重新同步。 在此方案中，用户想要采用`DataTable`填充在前面的方案和执行增量同步使用主数据源，保留中所做修改`DataTable`。  
  
-   增量数据馈送从辅助数据源。 在此方案中，用户想从一个或多个辅助数据源的更改，并将合并这些将更改传播回主数据源。  
  
 `Load`方法使所有这些方案成为可能。 所有但一个作为参数的重载此方法允许您指定的负载选项参数，指示如何中的现有行<xref:System.Data.DataTable>结合正在加载的行。 （不允许你指定的行为的重载使用默认加载选项。）下表描述了由提供的三个负载选项<xref:System.Data.LoadOption>枚举。 每种情况下，说明该值传入数据中的行的主键值匹配的现有行的主键时，指示的行为。  
  
|加载选项|描述|  
|-----------------|-----------------|  
|`PreserveChanges`（默认值）|使用传入的行的值更新行的原始版本。|  
|`OverwriteChanges`|使用传入的行的值更新行的当前和原始版本。|  
|`Upsert`|使用传入的行的值更新行的当前版本。|  
  
 一般情况下，`PreserveChanges`和`OverwriteChanges`选项适用于用户需要将同步的情形`DataSet`及其更改与主数据源。 `Upsert`选项可帮助聚合来自一个或多个辅助数据源的更改。  
  
   
  
## Examples  
 下面的示例演示了一些调用所涉及的问题<xref:System.Data.DataTable.Load%2A>方法。 首先，该示例侧重于架构问题，包括从加载推断架构<xref:System.Data.IDataReader>，然后处理不兼容的架构和架构具有列缺失或其他列。 然后，该示例着重于数据问题，包括处理各种的加载选项。  
  
> [!NOTE]
>  此示例演示如何使用的重载版本之一`Load`。 有关可能会提供其他示例，请参阅各个重载主题。  
  
 [!code-csharp[DataWorks DataTableLoad#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.Load" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (reader As IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">提供结果集的 <see cref="T:System.Data.IDataReader" />。</param>
        <summary>通过所提供的 <see cref="T:System.Data.IDataReader" />，用某个数据源的值填充 <see cref="T:System.Data.DataTable" />。 如果 <see cref="T:System.Data.DataTable" /> 已经包含行，则从数据源传入的数据与现有行合并。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A>方法使用的第一个结果集加载<xref:System.Data.IDataReader>，并成功完成后，将读取器的位置设置为下一个结果集，如果有的话。 转换数据时，`Load`方法使用相同的转换规则<xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType>方法。  
  
 <xref:System.Data.DataTable.Load%2A>方法必须考虑三个特定问题时加载的数据从<xref:System.Data.IDataReader>实例： 架构、 数据和事件的操作。 使用架构时,<xref:System.Data.DataTable.Load%2A>方法可能会遇到条件下表中所述。 架构操作发生的所有导入的结果集，甚至那些不包含任何数据。  
  
|条件|行为|  
|---------------|--------------|  
|<xref:System.Data.DataTable>没有架构。|<xref:System.Data.DataTable.Load%2A>方法推理基于来自导入的结果集架构<xref:System.Data.IDataReader>。|  
|<xref:System.Data.DataTable>拥有的架构，但它与加载的架构不兼容。|<xref:System.Data.DataTable.Load%2A>方法引发异常对应于试图将数据加载到不兼容的架构时发生的特定错误。|  
|架构是兼容，但加载的结果集架构包含中不存在的列<xref:System.Data.DataTable>。|<xref:System.Data.DataTable.Load%2A>方法将添加的额外列`DataTable`的架构。 该方法将引发异常，如果对应中的列<xref:System.Data.DataTable>和加载的结果集不兼容的值。 该方法还会从结果集中为所有添加的列检索约束信息。 仅当除外 Primary Key 约束的情况下，使用此约束信息当前<xref:System.Data.DataTable>不包含在启动时加载操作的任何列。|  
|架构是兼容，但加载的结果集架构包含较少的列比`DataTable`。|如果缺少列已定义的默认值或列的数据类型可以为 null，<xref:System.Data.DataTable.Load%2A>方法允许要添加的行替换为默认值或`null`缺少的列的值。 如果没有默认值或`null`可以使用，则`Load`方法引发异常。 如果已不提供任何特定的默认值，`Load`方法使用`null`默示的默认值的值。|  
  
 在考虑的行为之前`Load`方法根据数据操作，请考虑，每个行内<xref:System.Data.DataTable>维护的当前值和每个列的原始值。 这些值可能相同，或如果后填充发生了更改的行中的数据可能不同`DataTable`。  有关详细信息，请参阅[行状态和行版本](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)。  
  
 此版本的`Load`方法会尝试保留的每一行，保持不变的原始值中的当前值。 (如果你想更好地控制传入数据的行为，请参阅<xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType>。)如果现有行和传入行将包含相应的主键值，则使用其当前的行状态值处理行，否则它将被视为新行。  
  
 在事件操作方面<xref:System.Data.DataTable.RowChanging>事件发生之前更改每个行，与<xref:System.Data.DataTable.RowChanged>事件发生在每个行已更改之后。 在每个情况下，<xref:System.Data.DataRowChangeEventArgs.Action%2A>属性<xref:System.Data.DataRowChangeEventArgs>传递给事件处理程序的实例包含有关与事件关联的特定操作的信息。 此操作的值取决于行之前加载操作的状态。 在每个情况下，这两个事件发生，且操作为每个相同。 操作可以应用于当前或原始版本的每一行，或两者，具体取决于当前的行状态。  
  
 下表显示了行为`Load`方法。 最终 （标记为"（不提供）"） 的行所说明的行为传入不匹配任何现有行的行。 此表中的每个单元格连同描述行中的字段的当前和原始值<xref:System.Data.DataRowState>后的值为`Load`方法已完成。 在这种情况下，该方法不允许你以指示加载选项，并使用默认值， `PreserveChanges`。  
  
|现有 DataRowState|之后的值`Load`方法和事件操作|  
|---------------------------|--------------------------------------------------|  
|已添加|当前 =\<现有 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改原始值|  
|修改时间|当前 =\<现有 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改原始值|  
|Deleted|当前 =\<不可用 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<删除 ><br /><br /> 行操作 = 更改原始值|  
|Unchanged|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|  
|（不提供）|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|  
  
 中的值<xref:System.Data.DataColumn>可以如约束通过使用属性<xref:System.Data.DataColumn.ReadOnly%2A>和<xref:System.Data.DataColumn.AutoIncrement%2A>。 `Load`方法可处理此类列与列的属性定义的行为一致的方式。 上的只读的约束<xref:System.Data.DataColumn>仅适用于在内存中发生更改。 `Load`方法的覆盖的只读的列的值，如果需要。  
  
 若要确定哪个版本的用于比较的传入行具有的当前行的主键字段`Load`方法使用行中的主键值的原始版本，如果它存在。 否则为`Load`方法使用当前版本的主键字段。  
  
   
  
## Examples  
 下面的示例演示了一些调用所涉及的问题<xref:System.Data.DataTable.Load%2A>方法。 首先，该示例侧重于架构问题，包括从加载推断架构<xref:System.Data.IDataReader>，然后处理不兼容的架构和架构具有列缺失或其他列。 该示例然后调用`Load`方法，显示的数据之前和之后加载操作。  
  
 [!code-csharp[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="reader">提供一个或多个结果集的 <see cref="T:System.Data.IDataReader" />。</param>
        <param name="loadOption">
          <see cref="T:System.Data.LoadOption" /> 枚举的值，指示 <see cref="T:System.Data.DataTable" /> 中已有的行如何与共享相同主键的传入行合并。</param>
        <summary>通过所提供的 <see cref="T:System.Data.IDataReader" />，用某个数据源的值填充 <see cref="T:System.Data.DataTable" />。 如果 <see langword="DataTable" /> 已包含行，则从数据源传入的数据根据 <paramref name="loadOption" /> 参数的值与现有行合并。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load`方法使用的第一个结果集加载<xref:System.Data.IDataReader>，并成功完成后，将读取器的位置设置为下一个结果集，如果有的话。 转换数据时，`Load`方法使用相同的转换规则<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法。  
  
 `Load`方法必须考虑三个特定问题时加载的数据从<xref:System.Data.IDataReader>实例： 架构、 数据和事件的操作。 使用架构时,`Load`方法可能会遇到条件下表中所述。 架构操作发生的所有导入的结果集，甚至那些不包含任何数据。  
  
|条件|行为|  
|---------------|--------------|  
|<xref:System.Data.DataTable>没有架构。|`Load`方法推理基于来自导入的结果集架构<xref:System.Data.IDataReader>。|  
|<xref:System.Data.DataTable>拥有的架构，但它与加载的架构不兼容。|`Load`方法引发异常对应于试图将数据加载到不兼容的架构时发生的特定错误。|  
|架构是兼容，但加载的结果集架构包含在中不存在的列`DataTable`。|`Load`方法将添加的额外列`DataTable`的架构。 该方法将引发异常，如果对应中的列<xref:System.Data.DataTable>和加载的结果集不兼容的值。 该方法还会从结果集中为所有添加的列检索约束信息。 仅当除外 Primary Key 约束的情况下，使用此约束信息当前<xref:System.Data.DataTable>不包含在启动时加载操作的任何列。|  
|架构是兼容，但加载的结果集架构包含较少的列比`DataTable`。|如果缺少列已定义的默认值或列的数据类型可以为 null，`Load`方法允许要添加的行替换缺少的列的默认值或 null 值。 如果可以使用任何默认值或 null，则`Load`方法引发异常。 如果已不提供任何特定的默认值，`Load`方法使用隐含的默认值为 null 的值。|  
  
 在考虑的行为之前`Load`方法根据数据操作，请考虑，每个行内<xref:System.Data.DataTable>维护的当前值和每个列的原始值。 这些值可能相同，或如果后填充发生了更改的行中的数据可能不同`DataTable`。 请参阅[行状态和行版本](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)有关详细信息。  
  
 在此方法调用中，指定<xref:System.Data.LoadOption>参数影响的传入数据的处理。 Load 方法应如何处理具有相同的主键作为现有行的加载行？ 它应修改当前值和 / 或原始值？ 这些问题，和的详细信息，由控制`loadOption`参数。  
  
 如果现有行和传入行将包含相应的主键值，则使用其当前的行状态值处理行，否则它将被视为新行。  
  
 在事件操作方面<xref:System.Data.DataTable.RowChanging>事件发生之前更改每个行，与<xref:System.Data.DataTable.RowChanged>事件发生在每个行已更改之后。 在每个情况下，<xref:System.Data.DataRowChangeEventArgs.Action%2A>属性<xref:System.Data.DataRowChangeEventArgs>传递给事件处理程序的实例包含有关与事件关联的特定操作的信息。 此操作值都不同，具体取决于行之前加载操作的状态。 在每个情况下，这两个事件发生，且操作为每个相同。 操作可以应用于当前或原始版本的每一行，或两者，具体取决于当前的行状态。  
  
 下表显示负载方法调用每个时的行为`LoadOption`值，并显示如何与正在加载的行的行状态进行交互的值。 最终 （标记为"（不提供）"） 的行所说明的行为传入不匹配任何现有行的行。 此表中的每个单元格连同描述行中的字段的当前和原始值<xref:System.Data.DataRowState>后的值为`Load`方法已完成。  
  
|现有 DataRowState|Upsert|OverwriteChanges|PreserveChanges （默认行为）|  
|---------------------------|------------|----------------------|------------------------------------------|  
|已添加|当前 =\<传入 ><br /><br /> 原始 =-\<不可用 ><br /><br /> 状态 =\<添加 ><br /><br /> 行操作 = 更改|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<现有 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改原始值|  
|修改时间|当前 =\<传入 ><br /><br /> 原始 =\<现有 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<现有 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改原始值|  
eleted|（负载进行不影响删除的行）<br /><br /> 当前 =--<br /><br /> 原始 =\<现有 ><br /><br /> 状态 =\<删除 ><br /><br /> （新行添加具有下列特性）<br /><br /> 当前 =\<传入 ><br /><br /> 原始 =\<不可用 ><br /><br /> 状态 =\<添加 ><br /><br /> 行操作 = 添加|撤消删除和<br /><br /> 当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<不可用 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<删除 ><br /><br /> 行操作 = 更改原始值|  
|Unchanged|当前 =\<传入 ><br /><br /> 原始 =\<现有 ><br /><br /> 如果新值为与现有的值相同，则<br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = Nothing<br /><br /> Else<br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|  
不存在）|当前 =\<传入 ><br /><br /> 原始 =\<不可用 ><br /><br /> 状态 =\<添加 ><br /><br /> 行操作 = 添加|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|  
  
 中的值<xref:System.Data.DataColumn>可以如约束通过使用属性<xref:System.Data.DataColumn.ReadOnly%2A>和<xref:System.Data.DataColumn.AutoIncrement%2A>。 `Load`方法可处理此类列与列的属性定义的行为一致的方式。 上的只读的约束<xref:System.Data.DataColumn>仅适用于在内存中发生更改。 `Load`方法的覆盖的只读的列的值，如果需要。  
  
 在调用时指定的 OverwriteChanges 或 PreserveChanges 选项`Load`来自传入的数据进行的方法，则假定`DataTable`的主数据源和数据表跟踪更改，可以将传播所做的更改回数据源。 如果选择 Upsert 选项，则假定数据来自其中一个的辅助数据源，如由一个中间层组件，可能是由用户更改提供的数据。 在这种情况下，假设条件是从一个或多个数据源中的意图是对数据进行聚合`DataTable`，然后可能将传播回主数据源的数据。 <xref:System.Data.LoadOption>参数用于确定要使用主键比较行的特定版本。 下表提供了详细信息。  
  
|加载选项|使用主键比较 DataRow 版本|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|原始版本，如果它存在，否则为当前版本|  
|`PreserveChanges`|原始版本，如果它存在，否则为当前版本|  
|`Upsert`|当前版本，如果它存在，否则为原始版本|  
  
   
  
## Examples  
 下面的示例演示了一些调用所涉及的问题<xref:System.Data.DataTable.Load%2A>方法。 首先，该示例侧重于架构问题，包括从加载推断架构<xref:System.Data.IDataReader>，然后处理不兼容的架构和架构具有列缺失或其他列。 然后，该示例着重于数据问题，包括处理各种的加载选项。  
  
 [!code-csharp[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
      </Parameters>
      <Docs>
        <param name="reader">提供结果集的 <see cref="T:System.Data.IDataReader" />。</param>
        <param name="loadOption">
          <see cref="T:System.Data.LoadOption" /> 枚举的值，指示 <see cref="T:System.Data.DataTable" /> 中已有的行如何与共享相同主键的传入行合并。</param>
        <param name="errorHandler">加载数据时出现错误的情况下要调用的 <see cref="T:System.Data.FillErrorEventHandler" /> 委托。</param>
        <summary>通过所提供的使用错误处理委托的 <see cref="T:System.Data.IDataReader" />，用某个数据源中的值填充 <see cref="T:System.Data.DataTable" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load`方法使用的第一个结果集加载<xref:System.Data.IDataReader>，并成功完成后，将读取器的位置设置为下一个结果集，如果有的话。 转换数据时，`Load`方法使用相同的转换规则<xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType>方法。  
  
 `Load`方法必须考虑三个特定问题时加载的数据从<xref:System.Data.IDataReader>实例： 架构、 数据和事件的操作。 使用架构时,`Load`方法可能会遇到条件下表中所述。 架构操作发生的所有导入的结果集，甚至那些不包含任何数据。  
  
|条件|行为|  
|---------------|--------------|  
|<xref:System.Data.DataTable>没有架构。|`Load`方法推理基于来自导入的结果集架构<xref:System.Data.IDataReader>。|  
|<xref:System.Data.DataTable>拥有的架构，但它与加载的架构不兼容。|`Load`方法引发异常对应于试图将数据加载到不兼容的架构时发生的特定错误。|  
|架构是兼容，但加载的结果集架构包含在中不存在的列`DataTable`。|`Load`方法将添加到的额外列`DataTable`的架构。 该方法将引发异常，如果对应中的列<xref:System.Data.DataTable>和加载的结果集不兼容的值。 该方法还会从结果集中为所有添加的列检索约束信息。 仅当除外 Primary Key 约束的情况下，使用此约束信息当前<xref:System.Data.DataTable>不包含在启动时加载操作的任何列。|  
|架构是兼容，但加载的结果集架构包含较少的列比`DataTable`。|如果缺少列已定义的默认值或列的数据类型可以为 null，`Load`方法允许要添加的行替换缺少的列的默认值或 null 值。 如果可以使用任何默认值或 null，则`Load`方法引发异常。 如果已不提供任何特定的默认值，`Load`方法使用隐含的默认值为 null 的值。|  
  
 在考虑的行为之前`Load`方法根据数据操作，请考虑，每个行内<xref:System.Data.DataTable>维护的当前值和每个列的原始值。 这些值可能相同，或如果后填充发生了更改的行中的数据可能不同`DataTable`。 请参阅[行状态和行版本](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)有关详细信息。  
  
 在此方法调用中，指定<xref:System.Data.LoadOption>参数影响的传入数据的处理。 Load 方法应如何处理具有相同的主键作为现有行的加载行？ 它应修改当前值和 / 或原始值？ 这些问题，和的详细信息，由控制`loadOption`参数。  
  
 如果现有行和传入行将包含相应的主键值，则使用其当前的行状态值处理行，否则它将被视为新行。  
  
 在事件操作方面<xref:System.Data.DataTable.RowChanging>事件发生之前更改每个行，与<xref:System.Data.DataTable.RowChanged>事件发生在每个行已更改之后。 在每个情况下，<xref:System.Data.DataRowChangeEventArgs.Action%2A>属性<xref:System.Data.DataRowChangeEventArgs>传递给事件处理程序的实例包含有关与事件关联的特定操作的信息。 此操作值都不同，具体取决于行之前加载操作的状态。 在每个情况下，这两个事件发生，且操作为每个相同。 操作可以应用于当前或原始版本的每一行，或两者，具体取决于当前的行状态。  
  
 下表显示负载方法调用每个时的行为`LoadOption`值，并显示如何与正在加载的行的行状态进行交互的值。 最终 （标记为"（不提供）"） 的行所说明的行为传入不匹配任何现有行的行。 此表中的每个单元格连同描述行中的字段的当前和原始值<xref:System.Data.DataRowState>后的值为`Load`方法已完成。  
  
|现有 DataRowState|Upsert|OverwriteChanges|PreserveChanges （默认行为）|  
|---------------------------|------------|----------------------|------------------------------------------|  
|已添加|当前 =\<传入 ><br /><br /> 原始 =-\<不可用 ><br /><br /> 状态 =\<添加 ><br /><br /> 行操作 = 更改|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<现有 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改原始值|  
|修改时间|当前 =\<传入 ><br /><br /> 原始 =\<现有 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<现有 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改原始值|  
eleted|（负载进行不影响删除的行）<br /><br /> 当前 =--<br /><br /> 原始 =\<现有 ><br /><br /> 状态 =\<删除 ><br /><br /> （新行添加具有下列特性）<br /><br /> 当前 =\<传入 ><br /><br /> 原始 =\<不可用 ><br /><br /> 状态 =\<添加 ><br /><br /> 行操作 = 添加|撤消删除和<br /><br /> 当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<不可用 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<删除 ><br /><br /> 行操作 = 更改原始值|  
|Unchanged|当前 =\<传入 ><br /><br /> 原始 =\<现有 ><br /><br /> 如果新值为与现有的值相同，则<br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = Nothing<br /><br /> Else<br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|  
不存在）|当前 =\<传入 ><br /><br /> 原始 =\<不可用 ><br /><br /> 状态 =\<添加 ><br /><br /> 行操作 = 添加|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|  
  
 中的值<xref:System.Data.DataColumn>可以如约束通过使用属性<xref:System.Data.DataColumn.ReadOnly%2A>和<xref:System.Data.DataColumn.AutoIncrement%2A>。 `Load`方法可处理此类列与列的属性定义的行为一致的方式。 上的只读的约束<xref:System.Data.DataColumn>仅适用于在内存中发生更改。 `Load`方法的覆盖的只读的列的值，如果需要。  
  
 在调用时指定的 OverwriteChanges 或 PreserveChanges 选项`Load`来自传入的数据进行的方法，则假定`DataTable`的主数据源和数据表跟踪更改，可以将传播所做的更改回数据源。 如果选择 Upsert 选项，则假定数据来自其中一个的辅助数据源，如由一个中间层组件，可能是由用户更改提供的数据。 在这种情况下，假设条件是从一个或多个数据源中的意图是对数据进行聚合`DataTable`，然后可能将传播回主数据源的数据。 <xref:System.Data.LoadOption>参数用于确定要使用主键比较行的特定版本。 下表提供了详细信息。  
  
|加载选项|使用主键比较 DataRow 版本|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|原始版本，如果它存在，否则为当前版本|  
|`PreserveChanges`|原始版本，如果它存在，否则为当前版本|  
|`Upsert`|当前版本，如果它存在，否则为原始版本|  
  
 `errorHandler`参数是<xref:System.Data.FillErrorEventHandler>指将数据加载过程中发生错误时调用的过程的委托。 <xref:System.Data.FillErrorEventArgs>传递给过程的参数提供的属性，使您得以检索有关错误的发生，而当前行的数据，信息和<xref:System.Data.DataTable>填充的。 使用此委托机制，而不是更简单的 try/catch 块，可以确定该错误，处理这种情况，并继续如果愿意处理。 <xref:System.Data.FillErrorEventArgs>参数提供<xref:System.Data.FillErrorEventArgs.Continue%2A>属性： 将此属性设置为`true`以指示你已处理错误，并且希望继续进行处理。 将属性设置为`false`以指示你想要停止处理。 请注意，将属性设置为`false`导致触发要引发异常的问题的代码。  
  
   
  
## Examples  
 [!code-csharp[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadDataRow">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>查找和更新特定行。 如果找不到任何匹配行，则使用给定值创建新行。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, bool fAcceptChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, bool fAcceptChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadDataRow (values As Object(), fAcceptChanges As Boolean) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, bool fAcceptChanges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="fAcceptChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="values">用于创建新行的值数组。</param>
        <param name="fAcceptChanges">
          如果接受更改，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>查找和更新特定行。 如果找不到任何匹配行，则使用给定值创建新行。</summary>
        <returns>新的 <see cref="T:System.Data.DataRow" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.LoadDataRow%2A>方法接受的值的数组，并在主键列中查找匹配的值。  
  
 如果列具有默认值，请设置该列的默认值数组中传递 null 值。 同样，如果某一列具有其<xref:System.Data.DataColumn.AutoIncrement%2A>属性设置为 true，则要设置行自动生成的值的数组中传递 null 值。  
  
 如果`fAcceptChanges`参数是`true`或未指定，将添加新数据，然后<xref:System.Data.DataTable.AcceptChanges%2A>调用以接受中的所有更改<xref:System.Data.DataTable>; 如果参数是`false`，新添加的行标记为插入、 和到的更改现有行被标记为修改。  
  
 也可在发生异常<xref:System.Data.DataTable.ColumnChanging>或<xref:System.Data.DataTable.RowChanging>事件。 如果发生异常，则行未添加到表中。  
  
 使用<xref:System.Data.DataTable.LoadDataRow%2A>结合<xref:System.Data.DataTable.BeginLoadData%2A>和<xref:System.Data.DataTable.EndLoadData%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Data.DataTable.LoadDataRow%2A>方法来尝试查找行。 如果未不找到任何此类行，这些值用于创建新行。  
  
 [!code-csharp[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该数组大于表中的列数。</exception>
        <exception cref="T:System.InvalidCastException">值与其各自的列类型不匹配。</exception>
        <exception cref="T:System.Data.ConstraintException">添加行会使约束无效。</exception>
        <exception cref="T:System.Data.NoNullAllowedException">尝试将 null 值放到 <see cref="P:System.Data.DataColumn.AllowDBNull" /> 为 false 的列中。</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, System::Data::LoadOption loadOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="values">用于创建新行的值数组。</param>
        <param name="loadOption">用于确定数组值如何应用于现有行中的对应值。</param>
        <summary>查找和更新特定行。 如果找不到任何匹配行，则使用给定值创建新行。</summary>
        <returns>新的 <see cref="T:System.Data.DataRow" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.LoadDataRow%2A>方法接受的值的数组，并在主键列中查找匹配的值。  
  
 如果列具有默认值，请设置该列的默认值数组中传递 null 值。 同样，如果某一列具有其<xref:System.Data.DataColumn.AutoIncrement%2A>属性设置为 true，则要设置行自动生成的值的数组中传递 null 值。  
  
 值`loadOption`参数用于确定如何将数组中的值应用于现有行。 例如，如果`loadOption`设置为`OverwriteChanges`、`Original`和`Current`的每个列的值将替换中的传入行的值与`RowState`属性设置为`Unchanged`。  
  
 也可在发生异常<xref:System.Data.DataTable.ColumnChanging>或<xref:System.Data.DataTable.RowChanging>事件。 如果发生异常，则行未添加到表中。  
  
 使用<xref:System.Data.DataTable.LoadDataRow%2A>结合<xref:System.Data.DataTable.BeginLoadData%2A>和<xref:System.Data.DataTable.EndLoadData%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于比较表中字符串的区域设置信息。</summary>
        <value>一个 <see cref="T:System.Globalization.CultureInfo" />，它包含有关用户计算机区域设置的数据。 默认为 <see cref="T:System.Data.DataSet" /> 所属的 <see cref="T:System.Globalization.CultureInfo" /> 对象的 <see cref="P:System.Data.DataSet.Locale" />（由 <see cref="T:System.Data.DataTable" /> 属性返回）；如果该表不属于 <see cref="T:System.Data.DataSet" />，则默认为当前系统的 <see cref="T:System.Globalization.CultureInfo" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Globalization.CultureInfo>表示特定区域性或社区的软件首选项。  
  
 用于字符串比较时<xref:System.Globalization.CultureInfo>影响排序比较，以及进行筛选。  
  
> [!NOTE]
>  包含表达式，列中<xref:System.StringComparison.InvariantCulture>使用。 <xref:System.StringComparison.CurrentCulture>将被忽略。  
  
   
  
## Examples  
 下面的示例设置<xref:System.Globalization.CultureInfo>通过<xref:System.Data.DataTable.Locale%2A>，并输出 ISO 语言名称。  
  
 [!code-csharp[Classic WebData DataTable.Locale Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将指定的 <see cref="T:System.Data.DataTable" /> 与当前 <see cref="T:System.Data.DataTable" /> 合并。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Merge`方法用于合并两个<xref:System.Data.DataTable>有很大程度上类似的架构的对象。 合并通常用于对客户端应用程序，以将数据源的最新的更改合并到现有<xref:System.Data.DataTable>。 这允许客户端应用程序具有刷新<xref:System.Data.DataTable>使用数据源的最新的数据。  
  
 仅对原始表和表要合并，则合并操作将考虑在内。 不受影响或包含子表。 如果表具有一个或多个定义的一种关系，一部分的子表必须单独合并每个子表。  
  
   
  
## Examples  
 以下控制台应用程序演示的行为`missingSchemaAction`参数<xref:System.Data.DataTable.Merge%2A>方法。 此示例创建两个版本的同一个表，修改的第二个版本的架构。 然后，代码尝试将第二个表合并到第一个。  
  
> [!NOTE]
>  此示例演示如何使用合并的重载版本之一。 有关可能会提供其他示例，请参阅各个重载主题。  
  
 [!code-csharp[DataWorks DataTableMergeOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableMergeOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">要与当前 <see cref="T:System.Data.DataTable" /> 合并的 <see cref="T:System.Data.DataTable" />。</param>
        <summary>将指定的 <see cref="T:System.Data.DataTable" /> 与当前 <see cref="T:System.Data.DataTable" /> 合并。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Merge 方法用于合并两个<xref:System.Data.DataTable>有很大程度上类似的架构的对象。 合并通常用于对客户端应用程序，以将数据源的最新的更改合并到现有<xref:System.Data.DataTable>。 这允许客户端应用程序具有刷新<xref:System.Data.DataTable>使用数据源的最新的数据。  
  
 仅对原始表和表要合并，则合并操作将考虑在内。 不受影响或包含子表。 如果表具有一个或多个定义的一种关系，一部分的子表必须单独合并每个子表。  
  
 `Merge`方法通常称为涉及验证更改、 协调错误、 与所做的更改，更新数据源和最后刷新现有的过程的一系列末尾<xref:System.Data.DataTable>。  
  
 当执行合并时，在合并前的现有数据所做的更改会在合并操作期间，保留默认情况下。 开发人员可以修改此行为通过其他两个重载之一调用此方法，并指定为返回值为 false`preserveChanges`参数。  
  
 在客户端应用程序，它是通常有一个按钮，用户可以单击它来收集已更改的数据并将其发送回中间层组件之前对它进行验证。 在此方案中，<xref:System.Data.DataTable.GetChanges%2A>第一次调用方法。 方法将返回第二个<xref:System.Data.DataTable>优化为验证和合并。 第二个<xref:System.Data.DataTable>对象只包含<xref:System.Data.DataRow>已更改，从而导致原始的子集的对象<xref:System.Data.DataTable>。 此子集通常较小，因此可以更有效地传递回中间层组件。 然后，中间层组件使用通过存储过程的更改更新原始数据源。 然后，中间层可以发送回一个新<xref:System.Data.DataTable>，包括原始数据和数据源的最新数据 （通过再次运行原始查询），或者它可以发送回包含从数据源对其进行任何更改的子集。 （例如，如果数据源会自动创建唯一的主键值，这些值可以将传播回客户端应用程序。）在任一情况下，返回<xref:System.Data.DataTable>必须合并回客户端应用程序的原始<xref:System.Data.DataTable>与<xref:System.Data.DataTable.Merge%2A>方法。  
  
 合并新的源时<xref:System.Data.DataTable>到目标中时，任何源行与<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`，与具有相同的主键值的目标行匹配。 源行<xref:System.Data.DataRowState>值`Added`具有相同作为新的源行的主键值的新目标行匹配。  
  
   
  
## Examples  
 以下控制台应用程序创建一个简单<xref:System.Data.DataTable>然后将数据添加到表。 然后，示例创建表，将行添加到复制的副本。 最后，该示例调用<xref:System.Data.DataTable.Merge%2A>方法合并第二个表中的第一个表中的数据的数据。  
  
 [!code-csharp[DataWorks DataTable.Merge#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.Merge#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable, preserveChanges As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="table">要与当前 <see langword="DataTable" /> 合并的 <see langword="DataTable" />。</param>
        <param name="preserveChanges">
          如果保留当前 <see langword="DataTable" /> 中的更改，则为 <see langword="true" />；否则为 <see langword="false" />。<see langword="" /></param>
        <summary>将指定的 <see cref="T:System.Data.DataTable" /> 与当前 <see langword="DataTable" /> 合并，指示是否保留当前 <see langword="DataTable" /> 中的更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Merge 方法用于合并两个<xref:System.Data.DataTable>有很大程度上类似的架构的对象。 合并通常用于对客户端应用程序，以将数据源的最新的更改合并到现有<xref:System.Data.DataTable>。 这允许客户端应用程序具有刷新<xref:System.Data.DataTable>使用数据源的最新的数据。  
  
 仅对原始表和表要合并，则合并操作将考虑在内。 不受影响或包含子表。 如果表具有一个或多个定义的一种关系，一部分的子表必须单独合并每个子表。  
  
 `Merge`方法通常称为涉及验证更改、 协调错误、 与所做的更改，更新数据源和最后刷新现有的过程的一系列末尾<xref:System.Data.DataTable>。  
  
 除非开发人员指定为 false 时执行合并时，在合并前的现有数据所做的更改合并操作过程中保留`preserveChanges`参数。 如果`preserveChanges`参数设置为`true`，传入值不会覆盖现有行的当前行版本中的现有值。 如果`preserveChanges`参数设置为`false`，传入值将覆盖现有行的当前行版本中的现有值。 有关行版本的详细信息，请参阅[行状态和行版本](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)。  
  
 在客户端应用程序，它是通常有一个按钮，用户可以单击它来收集已更改的数据并将其发送回中间层组件之前对它进行验证。 在此方案中，<xref:System.Data.DataTable.GetChanges%2A>第一次调用方法。 方法将返回第二个<xref:System.Data.DataTable>优化为验证和合并。 第二个<xref:System.Data.DataTable>对象只包含<xref:System.Data.DataTable>和<xref:System.Data.DataRow>已更改，从而导致原始的子集的对象<xref:System.Data.DataTable>。 此子集是通常较小，因此此子集更有效地传递回中间层组件。 然后，中间层组件使用通过存储过程的更改更新原始数据源。 然后，中间层可以发送回一个新<xref:System.Data.DataTable>，包括原始数据和数据源的最新数据 （通过再次运行原始查询），或者它可以发送回包含从数据源对其进行任何更改的子集。 （例如，如果数据源会自动创建唯一的主键值，这些值可以将传播回客户端应用程序。）在任一情况下，返回<xref:System.Data.DataTable>必须合并回客户端应用程序的原始<xref:System.Data.DataTable>与<xref:System.Data.DataTable.Merge%2A>方法。  
  
 合并新的源时<xref:System.Data.DataTable>到目标中时，任何源行与<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`与具有相同的主键值的目标行匹配。 源行<xref:System.Data.DataRowState>值`Added`具有相同作为新的源行的主键值的新目标行匹配。  
  
   
  
## Examples  
 以下控制台应用程序创建<xref:System.Data.DataTable>包含行，修改某些这些行中的数据并尝试合并来自不同数据<xref:System.Data.DataTable>。 此示例演示为不同的行为`preserveChanges`参数。  
  
 [!code-csharp[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">要与当前 <see cref="T:System.Data.DataTable" /> 合并的 <see cref="T:System.Data.DataTable" />。</param>
        <param name="preserveChanges">
          如果保留当前 <see cref="T:System.Data.DataTable" /> 中的更改，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="missingSchemaAction">
          <see cref="T:System.Data.MissingSchemaAction" /> 值之一。</param>
        <summary>将指定的 <see cref="T:System.Data.DataTable" /> 与当前 <see langword="DataTable" /> 合并，指示是否保留更改以及如何处理当前 <see langword="DataTable" /> 中缺失的架构。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Merge`方法用于合并两个<xref:System.Data.DataTable>有很大程度上类似的架构的对象。 合并通常用于对客户端应用程序，以将数据源的最新的更改合并到现有<xref:System.Data.DataTable>。 这允许客户端应用程序具有刷新<xref:System.Data.DataTable>使用数据源的最新的数据。  
  
 仅对原始表和表要合并，则合并操作将考虑在内。 不受影响或包含子表。 如果表具有一个或多个定义的一种关系，一部分的子表必须单独合并每个子表。  
  
 `Merge`方法通常称为涉及验证更改、 协调错误、 与所做的更改，更新数据源和最后刷新现有的过程的一系列末尾<xref:System.Data.DataTable>。  
  
 除非开发人员指定为 false 时执行合并时，在合并前的现有数据所做的更改合并操作过程中保留`preserveChanges`参数。 如果`preserveChanges`参数设置为`true`，传入值不会覆盖现有行的当前行版本中的现有值。 如果`preserveChanges`参数设置为`false`，传入值将覆盖现有行的当前行版本中的现有值。 有关行版本的详细信息，请参阅[行状态和行版本](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)。  
  
 在客户端应用程序，它是通常有一个按钮，用户可以单击它来收集已更改的数据并将其发送回中间层组件之前对它进行验证。 在此方案中，<xref:System.Data.DataTable.GetChanges%2A>第一次调用方法。 方法将返回第二个<xref:System.Data.DataTable>优化为验证和合并。 第二个<xref:System.Data.DataTable>对象只包含<xref:System.Data.DataTable>和<xref:System.Data.DataRow>已更改，从而导致原始的子集的对象<xref:System.Data.DataTable>。 此子集是通常较小，因此此子集更有效地传递回中间层组件。 然后，中间层组件使用通过存储过程的更改更新原始数据源。 然后，中间层可以发送回一个新<xref:System.Data.DataTable>，包括原始数据和数据源的最新数据 （通过再次运行原始查询），或者它可以发送回包含从数据源对其进行任何更改的子集。 （例如，如果数据源会自动创建唯一的主键值，这些值可以将传播回客户端应用程序。）在任一情况下，返回<xref:System.Data.DataTable>必须合并回客户端应用程序的原始<xref:System.Data.DataTable>与<xref:System.Data.DataTable.Merge%2A>方法。  
  
 当<xref:System.Data.DataTable.Merge%2A>调用方法时，这两个架构<xref:System.Data.DataTable>对象进行比较，因为它是可能的架构可能已更改。 例如，在企业到企业方案中，新列可能已被添加到 XML 架构一个自动化过程。 如果源<xref:System.Data.DataTable>包含架构元素 (添加<xref:System.Data.DataColumn>对象) 缺少目标中，通过设置，可以将架构元素添加到目标`missingSchemaAction`参数`MissingSchemaAction.Add`。 在这种情况下，合并<xref:System.Data.DataTable>包含添加的架构和数据。  
  
 合并后的架构，则数据将合并。  
  
 合并新的源时<xref:System.Data.DataTable>到目标中时，任何源行与<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`与具有相同的主键值的目标行匹配。 源行<xref:System.Data.DataRowState>值`Added`具有相同作为新的源行的主键值的新目标行匹配。  
  
   
  
## Examples  
 以下控制台应用程序演示的行为`missingSchemaAction`参数<xref:System.Data.DataTable.Merge%2A>方法。 此示例创建两个版本的同一个表，修改的第二个版本的架构。 然后，代码尝试将第二个表合并到第一个。  
  
 [!code-csharp[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumCapacity">
      <MemberSignature Language="C#" Value="public int MinimumCapacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.MinimumCapacity" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimumCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumCapacity { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(50)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置该表最初的起始大小。</summary>
        <value>该表中行的最初起始大小。 默认值为 50。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.MinimumCapacity%2A>允许系统在读取数据之前创建一组适当的资源。 在这种情况时性能非常重要，设置此属性可优化性能。  
  
   
  
## Examples  
 下面的示例设置<xref:System.Data.DataTable.MinimumCapacity%2A>的<xref:System.Data.DataTable>。  
  
 [!code-csharp[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Data.DataTable" /> 中所存储数据的 XML 表示形式的命名空间。</summary>
        <value>
          <see cref="T:System.Data.DataTable" /> 的命名空间。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow NewRow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow NewRow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRow" />
      <MemberSignature Language="VB.NET" Value="Public Function NewRow () As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ NewRow();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建与该表具有相同架构的新 <see cref="T:System.Data.DataRow" />。</summary>
        <returns>与 <see cref="T:System.Data.DataTable" /> 具有相同架构的 <see cref="T:System.Data.DataRow" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须使用<xref:System.Data.DataTable.NewRow%2A>方法来创建新<xref:System.Data.DataRow>具有相同的架构对象<xref:System.Data.DataTable>。 在创建后<xref:System.Data.DataRow>，你可以将其添加到<xref:System.Data.DataRowCollection>，直到<xref:System.Data.DataTable>对象的<xref:System.Data.DataTable.Rows%2A>属性。 当你使用<xref:System.Data.DataTable.NewRow%2A>若要创建新行，必须将添加到或删除行从数据表然后才能调用<xref:System.Data.DataTable.Clear%2A>。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.DataTable>，添加两个<xref:System.Data.DataColumn>确定表的架构，并创建几个新的对象<xref:System.Data.DataRow>对象使用<xref:System.Data.DataTable.NewRow%2A>方法。 那些<xref:System.Data.DataRow>随后会将对象添加到<xref:System.Data.DataRowCollection>使用<xref:System.Data.DataRowCollection.Add%2A>方法。  
  
 [!code-csharp[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowArray">
      <MemberSignature Language="C#" Value="protected internal System.Data.DataRow[] NewRowArray (int size);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Data.DataRow[] NewRowArray(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowArray(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function NewRowArray (size As Integer) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ NewRowArray(int size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">描述数组大小的 <see cref="T:System.Int32" /> 值。</param>
        <summary>返回 <see cref="T:System.Data.DataRow" /> 的数组。</summary>
        <returns>新数组。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowFromBuilder">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataRow NewRowFromBuilder (System.Data.DataRowBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataRow NewRowFromBuilder(class System.Data.DataRowBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewRowFromBuilder (builder As DataRowBuilder) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataRow ^ NewRowFromBuilder(System::Data::DataRowBuilder ^ builder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Data.DataRowBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">
          <see cref="T:System.Data.DataRowBuilder" /> 对象。</param>
        <summary>从现有行创建新行。</summary>
        <returns>
          <see cref="T:System.Data.DataRow" /> 派生类。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanged (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanged(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanged (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanged(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Data.DataColumnChangeEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Data.DataTable.ColumnChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanging">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanging (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanging(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanging (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanging(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Data.DataColumnChangeEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Data.DataTable.ColumnChanging" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">包含事件数据的 <see cref="T:System.ComponentModel.PropertyChangedEventArgs" />。</param>
        <summary>引发 <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveColumn">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveColumn (System.Data.DataColumn column);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveColumn(class System.Data.DataColumn column) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveColumn (column As DataColumn)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveColumn(System::Data::DataColumn ^ column);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="column" Type="System.Data.DataColumn" />
      </Parameters>
      <Docs>
        <param name="column">正在移除的 <see cref="T:System.Data.DataColumn" />。</param>
        <summary>通知 <see cref="T:System.Data.DataTable" /> 正在移除 <see cref="T:System.Data.DataColumn" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />在派生类中，一定要调用基类的<see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanged (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanged(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanged (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanged(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Data.DataRowChangeEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Data.DataTable.RowChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanging (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanging(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanging (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanging(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Data.DataRowChangeEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Data.DataTable.RowChanging" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleted (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleted(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleted (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleted(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Data.DataRowChangeEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Data.DataTable.RowDeleted" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleting (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleting(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleting (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleting(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Data.DataRowChangeEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Data.DataTable.RowDeleting" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTableCleared">
      <MemberSignature Language="C#" Value="protected virtual void OnTableCleared (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableCleared(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableCleared (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableCleared(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Data.DataTableClearEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Data.DataTable.TableCleared" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发<xref:System.Data.DataTable.TableCleared>事件，成功之前清除所有行后立即触发<xref:System.Data.DataTable.Clear%2A>方法将返回给调用方的控件。  
  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableClearing">
      <MemberSignature Language="C#" Value="protected virtual void OnTableClearing (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableClearing(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableClearing (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableClearing(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Data.DataTableClearEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Data.DataTable.TableClearing" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发<xref:System.Data.DataTable.TableClearing>事件，在处理之前激发<xref:System.Data.DataTable.Clear%2A>操作开始。  
  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableNewRow">
      <MemberSignature Language="C#" Value="protected virtual void OnTableNewRow (System.Data.DataTableNewRowEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableNewRow(class System.Data.DataTableNewRowEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableNewRow (e As DataTableNewRowEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableNewRow(System::Data::DataTableNewRowEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableNewRowEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Data.DataTableNewRowEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Data.DataTable.TableNewRow" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发<xref:System.Data.DataTable.TableNewRow>触发后新的事件<xref:System.Data.DataRow>已经使用创建<xref:System.Data.DataTable.NewRow%2A>。  
  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ParentRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ParentRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ParentRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ParentRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该 <see cref="T:System.Data.DataTable" /> 的父关系的集合。</summary>
        <value>一个 <see cref="T:System.Data.DataRelationCollection" />，包含该表的父关系。 如果 <see cref="T:System.Data.DataRelation" /> 对象不存在，将返回空集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例使用<xref:System.Data.DataTable.ParentRelations%2A>属性以返回每个父<xref:System.Data.DataRelation>中<xref:System.Data.DataTable>。 每个关系中的参数作为用<xref:System.Data.DataRow.GetParentRows%2A>方法<xref:System.Data.DataRow>返回行的数组。 然后打印的行中的每个列的值。  
  
 [!code-csharp[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ChildRelations" />
        <altmember cref="T:System.Data.DataRelation" />
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Relations" />
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Data.DataTable" /> 中所存储数据的 XML 表示形式的命名空间。</summary>
        <value>
          <see cref="T:System.Data.DataTable" /> 的前缀。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimaryKey">
      <MemberSignature Language="C#" Value="public System.Data.DataColumn[] PrimaryKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumn[] PrimaryKey" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.PrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrimaryKey As DataColumn()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::DataColumn ^&gt; ^ PrimaryKey { cli::array &lt;System::Data::DataColumn ^&gt; ^ get(); void set(cli::array &lt;System::Data::DataColumn ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Data.PrimaryKeyTypeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumn[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用作数据表主键的列数组。</summary>
        <value>一个 <see cref="T:System.Data.DataColumn" /> 对象数组。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表的主键必须唯一标识表中的记录。 还有可能获得具有主键的两个或多个列组成的表。 在单个列不能包含足够的唯一值时，将发生这种情况。 例如，"FirstName"和"LastName"列可能包含两个列的主键。 因为主键可以由构成的多个列，<xref:System.Data.DataTable.PrimaryKey%2A>属性包含的数组<xref:System.Data.DataColumn>对象。  
  
   
  
## Examples  
 第一个示例演示如何返回有关的主键列<xref:System.Data.DataTable>中显示`DataGrid`。 第二个示例演示如何设置有关的主键列<xref:System.Data.DataTable>。  
  
 [!code-csharp[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DataException">该键是外键。</exception>
        <altmember cref="T:System.Data.DataColumn" />
        <altmember cref="P:System.Data.DataTable.PrimaryKey" />
        <altmember cref="T:System.Data.DataColumnCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 XML 架构和数据读入 <see cref="T:System.Data.DataTable" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.ReadXml%2A>方法提供方法读取只将数据或数据和架构读入<xref:System.Data.DataTable>从 XML 文档，而<xref:System.Data.DataTable.ReadXmlSchema%2A>方法读取仅的架构。 若要读取数据和架构，使用之一`ReadXML`重载，以包括`XmlReadMode`参数，并将其值设置为`ReadSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.WriteXml%2A>和<xref:System.Data.DataTable.WriteXmlSchema%2A>方法，分别。 要写入的 XML 数据，或架构和数据从`DataTable`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXml" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">从 <see cref="T:System.IO.Stream" /> 派生的对象</param>
        <summary>使用指定的 <see cref="T:System.IO.Stream" /> 将 XML 架构和数据读入 <see cref="T:System.Data.DataTable" />。</summary>
        <returns>用于读取数据的 <see cref="T:System.Data.XmlReadMode" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前<xref:System.Data.DataTable>及其子代加载从提供的数据<xref:System.IO.Stream>。 此方法的行为等同于的<xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType>仅为当前表及其子代加载方法，这在这种情况下，数据除外。  
  
 <xref:System.Data.DataTable.ReadXml%2A>方法提供方法读取只将数据或数据和架构读入<xref:System.Data.DataTable>从 XML 文档，而<xref:System.Data.DataTable.ReadXmlSchema%2A>方法读取仅的架构。  
  
 请注意，同样适用于<xref:System.Data.DataTable.WriteXml%2A>和<xref:System.Data.DataTable.WriteXmlSchema%2A>方法，分别。 要写入的 XML 数据，或架构和数据从`DataTable`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定内联架构，内联架构用于扩展现有的关系结构之前加载数据。 如果存在任何冲突 （例如，定义具有不同数据类型的同一个表中的相同列） 被引发异常。  
  
 如果不指定任何内联架构，则关系结构通过推理，如有必要，扩展根据 XML 文档的结构。 如果无法通过推断扩展架构，才能公开的所有数据，则引发异常。  
  
> [!NOTE]
>  `DataSet`不将 XML 元素关联与其对应`DataColumn`或`DataTable`合法的 XML 字符，如 ("_") 在序列化的 XML 中的转义时。 `DataSet`本身仅为 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.DataTable>包含两个列和十个行。 此示例将<xref:System.Data.DataTable>架构和数据迁移到内存流，通过调用<xref:System.Data.DataTable.WriteXml%2A>方法。 此示例将创建第二个<xref:System.Data.DataTable>和调用<xref:System.Data.DataTable.ReadXml%2A>方法以用架构和数据填充它。  
  
 [!code-csharp[DataWorks DataTable.ReadXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">将用于读取数据的 <see cref="T:System.IO.TextReader" />。</param>
        <summary>使用指定的 <see cref="T:System.IO.TextReader" /> 将 XML 架构和数据读入 <see cref="T:System.Data.DataTable" />。</summary>
        <returns>用于读取数据的 <see cref="T:System.Data.XmlReadMode" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前<xref:System.Data.DataTable>及其子代加载从提供的数据<xref:System.IO.TextReader>。 此方法的行为等同于的<xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType>仅为当前表及其子代加载方法，这在这种情况下，数据除外。  
  
 <xref:System.Data.DataTable.ReadXml%2A>方法提供方法读取只将数据或数据和架构读入<xref:System.Data.DataTable>从 XML 文档，而<xref:System.Data.DataTable.ReadXmlSchema%2A>方法读取仅的架构。  
  
 请注意，同样适用于<xref:System.Data.DataTable.WriteXml%2A>和<xref:System.Data.DataTable.WriteXmlSchema%2A>方法，分别。 要写入的 XML 数据，或架构和数据从`DataTable`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定内联架构，内联架构用于扩展现有的关系结构之前加载数据。 如果存在任何冲突 （例如，定义具有不同数据类型的同一个表中的相同列） 被引发异常。  
  
 如果不指定任何内联架构，则关系结构通过推理，如有必要，扩展根据 XML 文档的结构。 如果无法通过推断扩展架构，才能公开的所有数据，则引发异常。  
  
> [!NOTE]
>  `DataSet`不将 XML 元素关联与其对应`DataColumn`或`DataTable`合法的 XML 字符，如 ("_") 在序列化的 XML 中的转义时。 `DataSet`本身仅为 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.DataTable>包含两个列和十个行。 此示例将<xref:System.Data.DataTable>架构和数据迁移到内存流，通过调用<xref:System.Data.DataTable.WriteXml%2A>方法。 此示例将创建第二个<xref:System.Data.DataTable>和调用<xref:System.Data.DataTable.ReadXml%2A>方法以用架构和数据填充它。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">从中读取数据的文件的名称。</param>
        <summary>从指定的文件将 XML 架构和数据读入 <see cref="T:System.Data.DataTable" />。</summary>
        <returns>用于读取数据的 <see cref="T:System.Data.XmlReadMode" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前<xref:System.Data.DataTable>及其子代加载从提供名为的文件中的数据<xref:System.String>。 此方法的行为等同于的<xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType>仅为当前表及其子代加载方法，这在这种情况下，数据除外。  
  
 <xref:System.Data.DataTable.ReadXml%2A>方法提供方法读取只将数据或数据和架构读入<xref:System.Data.DataTable>从 XML 文档，而<xref:System.Data.DataTable.ReadXmlSchema%2A>方法读取仅的架构。  
  
 请注意，同样适用于<xref:System.Data.DataTable.WriteXml%2A>和<xref:System.Data.DataTable.WriteXmlSchema%2A>方法，分别。 要写入的 XML 数据，或架构和数据从`DataTable`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定内联架构，内联架构用于扩展现有的关系结构之前加载数据。 如果存在任何冲突 （例如，定义具有不同数据类型的同一个表中的相同列） 被引发异常。  
  
 如果不指定任何内联架构，则关系结构通过推理，如有必要，扩展根据 XML 文档的结构。 如果无法通过推断扩展架构，才能公开的所有数据，则引发异常。  
  
> [!NOTE]
>  `DataSet`不将 XML 元素关联与其对应`DataColumn`或`DataTable`合法的 XML 字符，如 ("_") 在序列化的 XML 中的转义时。 `DataSet`本身仅为 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。  
  
```csharp  
using System.Data;  
public class A {  
   static void Main(string[] args) {  
      DataTable tabl = new DataTable("mytable");  
      tabl.Columns.Add(new DataColumn("id", typeof(int)));  
      for (int i = 0; i < 10; i++) {  
         DataRow row = tabl.NewRow();  
         row["id"] = i;  
         tabl.Rows.Add(row);  
      }  
      tabl.WriteXml("f.xml", XmlWriteMode.WriteSchema);  
      DataTable newt = new DataTable();  
      newt.ReadXml("f.xml");  
   }  
}  
```  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.DataTable>包含两个列和十个行。 此示例将<xref:System.Data.DataTable>架构和数据写入磁盘。 此示例将创建第二个<xref:System.Data.DataTable>和调用<xref:System.Data.DataTable.ReadXml%2A>方法以用架构和数据填充它。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">将用于读取数据的 <see cref="T:System.Xml.XmlReader" />。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlReader" /> 将 XML 架构和数据读入 <see cref="T:System.Data.DataTable" />。</summary>
        <returns>用于读取数据的 <see cref="T:System.Data.XmlReadMode" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前<xref:System.Data.DataTable>及其子代加载从提供名为的文件中的数据<xref:System.Xml.XmlReader>。 此方法的行为等同于的<xref:System.Data.DataTable.ReadXml%2A>仅为当前表及其子代加载方法，这在这种情况下，数据除外。  
  
 <xref:System.Data.DataTable.ReadXml%2A>方法提供方法读取只将数据或数据和架构读入<xref:System.Data.DataTable>从 XML 文档，而<xref:System.Data.DataTable.ReadXmlSchema%2A>方法读取仅的架构。  
  
 请注意，同样适用于<xref:System.Data.DataTable.WriteXml%2A>和<xref:System.Data.DataTable.WriteXmlSchema%2A>方法，分别。 要写入的 XML 数据，或架构和数据从`DataTable`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定内联架构，内联架构用于扩展现有的关系结构之前加载数据。 如果存在任何冲突 （例如，定义具有不同数据类型的同一个表中的相同列） 被引发异常。  
  
 如果不指定任何内联架构，则关系结构通过推理，如有必要，扩展根据 XML 文档的结构。 如果无法通过推断扩展架构，才能公开的所有数据，则引发异常。  
  
> [!NOTE]
>  `DataSet`不将 XML 元素关联与其对应`DataColumn`或`DataTable`合法的 XML 字符，如 ("_") 在序列化的 XML 中的转义时。 `DataSet`本身仅为 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.DataTable>包含两个列和十个行。 此示例将<xref:System.Data.DataTable>架构和数据写入<xref:System.Xml.XmlReader>。 此示例将创建第二个<xref:System.Data.DataTable>和调用<xref:System.Data.DataTable.ReadXml%2A>方法以填充架构和数据从<xref:System.Xml.XmlReader>实例。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 XML 架构读入 <see cref="T:System.Data.DataTable" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`ReadXmlSchema`方法创建的架构<xref:System.Data.DataTable>。 架构包含表、 关系和约束定义。  
  
 若要写入到 XML 文档的架构，使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法。  
  
 XML 架构被指根据 XSD 标准。  
  
 `ReadXmlSchema`通常在调用之前调用方法<xref:System.Data.DataTable.ReadXml%2A>方法用于填充<xref:System.Data.DataTable>。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXmlSchema" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">用于读取架构的流。</param>
        <summary>使用指定的流将 XML 架构读入 <see cref="T:System.Data.DataTable" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.ReadXmlSchema%2A>方法创建的架构<xref:System.Data.DataTable>。 架构包含表、 关系和约束定义。  
  
 若要写入到 XML 文档的架构，使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法。  
  
 XML 架构被指根据 XSD 标准。  
  
 如果 msdata:DataType 和 xs:type 类型不匹配，则会发生数据损坏。 会不引发任何异常。  
  
 `ReadXmlSchema`通常在调用之前调用方法<xref:System.Data.DataTable.ReadXml%2A>方法用于填充<xref:System.Data.DataTable>。  
  
 若要创建使用 XML 架构的嵌套的关系，使用隐式的嵌套的元素。 你还可以配置要使用显式的列名称的嵌套的关系。 元素必须隐式嵌套顺序对应的数据表中使用嵌套关系。  
  
   
  
## Examples  
 以下控制台应用程序创建一个新<xref:System.Data.DataTable>，并将写入到该表的架构的<xref:System.IO.MemoryStream>。 然后，该示例创建一个新<xref:System.Data.DataTable>，并读取其架构中的已保存的 XML 架构。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">用于读取架构信息的 <see cref="T:System.IO.TextReader" />。</param>
        <summary>使用指定的 <see cref="T:System.IO.TextReader" /> 将 XML 架构读入 <see cref="T:System.Data.DataTable" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.ReadXmlSchema%2A>方法创建的架构<xref:System.Data.DataTable>。 架构包含表、 关系和约束定义。  
  
 若要写入到 XML 文档的架构，使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法。  
  
 XML 架构被指根据 XSD 标准。  
  
 如果 msdata:DataType 和 xs:type 类型不匹配，则会发生数据损坏。 会不引发任何异常。  
  
 `ReadXmlSchema`通常在调用之前调用方法<xref:System.Data.DataTable.ReadXml%2A>方法用于填充<xref:System.Data.DataTable>。  
  
 若要创建使用 XML 架构的嵌套的关系，使用隐式的嵌套的元素。 你还可以重新配置要使用显式的列名称的嵌套的关系。 元素必须隐式嵌套顺序对应的数据表中使用嵌套关系。  
  
   
  
## Examples  
 以下控制台应用程序创建一个新<xref:System.Data.DataTable>，并将写入到该表的架构的<xref:System.IO.MemoryStream>。 然后，该示例创建一个新<xref:System.Data.DataTable>和从已保存的 XML 架构，读取其架构使用<xref:System.IO.StreamReader>(其继承自<xref:System.IO.TextReader>) 作为其源。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">从中读取架构信息的文件的名称。</param>
        <summary>从指定的文件将 XML 架构读入 <see cref="T:System.Data.DataTable" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.ReadXmlSchema%2A>方法创建的架构<xref:System.Data.DataTable>。 架构包含表、 关系和约束定义。  
  
 若要写入到 XML 文档的架构，使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法。  
  
 XML 架构被指根据 XSD 标准。  
  
 如果 msdata:DataType 和 xs:type 类型不匹配，则会发生数据损坏。 会不引发任何异常。  
  
 `ReadXmlSchema`通常在调用之前调用方法<xref:System.Data.DataTable.ReadXml%2A>方法用于填充`DataTable`。  
  
 若要创建使用 XML 架构的嵌套的关系，使用隐式的嵌套的元素。 你还可以重新配置要使用显式的列名称的嵌套的关系。 元素必须隐式嵌套顺序对应的数据表中使用嵌套关系。  
  
   
  
## Examples  
 以下控制台应用程序创建一个新<xref:System.Data.DataTable>，并将该表的架构写入文件。 然后，该示例创建一个新<xref:System.Data.DataTable>而且从已保存的 XML 架构，读取其架构作为其源使用的文件。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">用于读取架构信息的 <see cref="T:System.Xml.XmlReader" />。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlReader" /> 将 XML 架构读入 <see cref="T:System.Data.DataTable" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.ReadXmlSchema%2A>方法创建的架构<xref:System.Data.DataTable>。 架构包含表、 关系和约束定义。  
  
 若要写入到 XML 文档的架构，使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法。  
  
 XML 架构被指根据 XSD 标准。  
  
 如果 msdata:DataType 和 xs:type 类型不匹配，则会发生数据损坏。 会不引发任何异常。  
  
 `ReadXmlSchema`通常在调用之前调用方法<xref:System.Data.DataTable.ReadXml%2A>方法用于填充<xref:System.Data.DataTable>。  
  
> [!NOTE]
>  创建使用 XML 架构的嵌套的关系的方法是具有隐式的嵌套的元素。 此外，将嵌套的关系可能是重新配置为使用显式的列名称。 它是必需的元素，隐式嵌套为相应的数据表中使用嵌套关系。  
  
   
  
## Examples  
 以下控制台应用程序创建一个新<xref:System.Data.DataTable>，并将写入到该表的架构的<xref:System.IO.MemoryStream>。 然后，该示例创建一个新<xref:System.Data.DataTable>和从已保存的 XML 架构，读取其架构使用<xref:System.Xml.XmlTextReader>(其继承自<xref:System.Xml.XmlReader>) 作为其源。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> 对象。</param>
        <summary>从 XML 流中读取。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RejectChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>回滚自该表加载以来或上次调用 <see cref="M:System.Data.DataTable.AcceptChanges" /> 以来对该表进行的所有更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Data.DataTable.RejectChanges%2A>调用时，任何<xref:System.Data.DataRow>是否仍处于编辑模式的对象将取消其编辑。 新行被移除。 与行<xref:System.Data.DataRowState>设置为`Modified`或`Deleted`返回回其原始状态。  
  
   
  
## Examples  
 下面的示例进行几次更改到<xref:System.Data.DataTable>，但通过调用拒绝所做的更改<xref:System.Data.DataTable.RejectChanges%2A>方法。  
  
 [!code-csharp[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置序列化格式。</summary>
        <value>指定 <see langword="Binary" /> 或 <see langword="Xml" /> 序列化的 <see cref="T:System.Data.SerializationFormat" /> 枚举。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将 <see cref="T:System.Data.DataTable" /> 重置为其初始状态。 重置将移除表的所有数据、索引、关系和列。 如果数据集包含一个数据表，则在重置该表之后，它将仍是数据集的一部分。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanged As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在成功更改 <see cref="T:System.Data.DataRow" /> 后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanging As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在更改 <see cref="T:System.Data.DataRow" /> 时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleted">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleted As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>删除表中的行后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleting">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleting As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要删除表中的行之前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rows">
      <MemberSignature Language="C#" Value="public System.Data.DataRowCollection Rows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRowCollection Rows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Rows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rows As DataRowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRowCollection ^ Rows { System::Data::DataRowCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取属于该表的行的集合。</summary>
        <value>包含 <see cref="T:System.Data.DataRowCollection" /> 对象的 <see cref="T:System.Data.DataRow" />；否则为 null 值（如果不存在任何 <see cref="T:System.Data.DataRow" /> 对象）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要创建一个新<xref:System.Data.DataRow>，必须使用<xref:System.Data.DataTable.NewRow%2A>方法以返回一个新的对象。 此类对象将自动配置为定义的架构根据<xref:System.Data.DataTable>通过其集合<xref:System.Data.DataColumn>对象。 在创建新行并设置行中的每个列的值之后, 向其中添加行<xref:System.Data.DataRowCollection>使用`Add`方法。  
  
 每个<xref:System.Data.DataRow>集合中表示表中的数据行。 若要将更改提交到行中列的值，必须调用<xref:System.Data.DataTable.AcceptChanges%2A>方法。  
  
   
  
## Examples  
 下面显示了返回并设置行的两个示例。 第一个示例使用<xref:System.Data.DataTable.Rows%2A>属性，并输出每个列的每一行的值。 第二个示例使用<xref:System.Data.DataTable>对象的<xref:System.Data.DataTable.NewRow%2A>方法来创建一个新<xref:System.Data.DataRow>与的架构对象<xref:System.Data.DataTable>。 设置行值之后, 的行被添加到<xref:System.Data.DataRowCollection>通过`Add`方法。  
  
 [!code-csharp[Classic WebData DataTable.Rows Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Rows Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.AcceptChanges" />
        <altmember cref="T:System.Data.DataRow" />
        <altmember cref="T:System.Data.DataRowCollection" />
        <altmember cref="M:System.Data.DataTable.NewRow" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取 <see cref="T:System.Data.DataRow" /> 对象数组。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select" />
      <MemberSignature Language="VB.NET" Value="Public Function Select () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取由所有 <see cref="T:System.Data.DataRow" /> 对象组成的数组。</summary>
        <returns>一个 <see cref="T:System.Data.DataRow" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确保正确的排序顺序，指定与排序条件<xref:System.Data.DataTable.Select%2A>或<xref:System.Data.DataTable.Select%2A>。  
  
   
  
## Examples  
 下面的示例返回的数组<xref:System.Data.DataRow>对象通过<xref:System.Data.DataTable.Select%2A>方法。  
  
 [!code-csharp[Classic WebData DataTable.Select Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">用于筛选行的条件。 有关如何筛选行的示例，请参阅 [DataView RowFilter 语法 [C#]](http://www.csharp-examples.net/dataview-rowfilter/)。</param>
        <summary>获取由与筛选条件匹配的所有 <see cref="T:System.Data.DataRow" /> 对象组成的数组。</summary>
        <returns>一个 <see cref="T:System.Data.DataRow" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要创建`filterExpression`自变量，使用相同的规则适用于<xref:System.Data.DataColumn>类的<xref:System.Data.DataColumn.Expression%2A>创建筛选器的属性值。  
  
 若要确保正确的排序顺序，指定与排序条件<xref:System.Data.DataTable.Select%2A>或<xref:System.Data.DataTable.Select%2A>。  
  
 如果筛选器上的列包含 null 值，它将不是结果的一部分。  
  
   
  
## Examples  
 下面的示例使用筛选器表达式返回的数组<xref:System.Data.DataRow>对象。  
  
 [!code-csharp[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">用于筛选行的条件。 有关如何筛选行的示例，请参阅 [DataView RowFilter 语法 [C#]](http://www.csharp-examples.net/dataview-rowfilter/)。</param>
        <param name="sort">指定列和排序方向的字符串。</param>
        <summary>以指定排序顺序，获取由与筛选条件匹配的所有 <see cref="T:System.Data.DataRow" /> 对象组成的数组。</summary>
        <returns>由与筛选条件匹配的 <see cref="T:System.Data.DataRow" /> 对象组成的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向窗体`filterExpression`自变量，用于创建使用相同的规则<xref:System.Data.DataColumn>类的<xref:System.Data.DataColumn.Expression%2A>属性值。 `Sort`自变量还会将相同的规则用于创建类的<xref:System.Data.DataColumn.Expression%2A>字符串。  
  
 如果筛选器上的列包含 null 值，它将不是结果的一部分。  
  
   
  
## Examples  
 下面的示例使用筛选器表达式返回的数组<xref:System.Data.DataRow>对象。  
  
 [!code-csharp[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort, System.Data.DataViewRowState recordStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort, valuetype System.Data.DataViewRowState recordStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String, recordStates As DataViewRowState) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort, System::Data::DataViewRowState recordStates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
        <Parameter Name="recordStates" Type="System.Data.DataViewRowState" />
      </Parameters>
      <Docs>
        <param name="filterExpression">用于筛选行的条件。 有关如何筛选行的示例，请参阅 [DataView RowFilter 语法 [C#]](http://www.csharp-examples.net/dataview-rowfilter/)。</param>
        <param name="sort">指定列和排序方向的字符串。</param>
        <param name="recordStates">
          <see cref="T:System.Data.DataViewRowState" /> 值之一。</param>
        <summary>以与指定状态匹配的排序顺序，获取由与筛选条件匹配的所有 <see cref="T:System.Data.DataRow" /> 对象组成的数组。</summary>
        <returns>一个 <see cref="T:System.Data.DataRow" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向窗体`filterExpression`自变量，用于创建使用相同的规则<xref:System.Data.DataColumn>类的<xref:System.Data.DataColumn.Expression%2A>属性值。 `Sort`自变量还会将相同的规则用于创建类的<xref:System.Data.DataColumn.Expression%2A>字符串。  
  
 如果筛选器上的列包含 null 值，它将不是结果的一部分。  
  
   
  
## Examples  
 下面的示例使用筛选器表达式和记录状态返回的数组<xref:System.Data.DataRow>对象。  
  
 [!code-csharp[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Data.DataTable" /> 的 <see cref="T:System.ComponentModel.ISite" />。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> 的一个 <see cref="T:System.Data.DataTable" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 站点绑定<xref:System.ComponentModel.Component>到<xref:System.ComponentModel.Container>和启用它们之间的通信，以及为要管理其组件的容器提供的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ComponentModel.IListSource.ContainsListCollection { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>有关此成员的说明，请参阅 <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />。</summary>
        <value>
          如果集合是 <see cref="T:System.Collections.IList" /> 对象集合，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Data.DataTable> 实例强制转换为 <xref:System.ComponentModel.IListSource> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.ComponentModel.IListSource.GetList" />。</summary>
        <returns>对象中可以绑定到数据源的 <see cref="T:System.Collections.IList" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Data.DataTable> 实例强制转换为 <xref:System.ComponentModel.IListSource> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />。</summary>
        <returns>一个 <see cref="T:System.Xml.Schema.XmlSchema" />，描述由 <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> 方法生成并由 <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> 方法使用的对象的 XML 表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Data.DataSet> 实例强制转换为 <xref:System.Xml.Serialization.IXmlSerializable> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">XmlReader。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Data.DataSet> 实例强制转换为 <xref:System.Xml.Serialization.IXmlSerializable> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">XmlWriter。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Data.DataSet> 实例强制转换为 <xref:System.Xml.Serialization.IXmlSerializable> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableCleared">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableCleared;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableCleared" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableCleared" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableCleared As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableCleared;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>清除 <see cref="T:System.Data.DataTable" /> 后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableCleared>成功之前清除所有行后立即激发事件<xref:System.Data.DataTable.Clear%2A>方法将返回给调用方的控件。 <xref:System.Data.DataTable.TableCleared>如果清除操作中的任何异常不激发事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableClearing">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableClearing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableClearing" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableClearing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableClearing As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableClearing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>清除 <see cref="T:System.Data.DataTable" /> 时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableClearing>处理之前激发事件<xref:System.Data.DataTable.Clear%2A>操作开始。 此事件始终会激发<xref:System.Data.DataTable.Clear%2A>调用方法时，即使表包含零行。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Data.DataTable" /> 的名称。</summary>
        <value>
          <see cref="T:System.Data.DataTable" /> 的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableName%2A>用于从父返回此表<xref:System.Data.DataSet>对象的<xref:System.Data.DataTableCollection>(返回<xref:System.Data.DataSet.Tables%2A>属性)。  
  
   
  
## Examples  
 下面的示例将打印<xref:System.Data.DataTable.TableName%2A>为集合中的每个表<xref:System.Data.DataTable>对象。  
  
 [!code-csharp[Classic WebData DataTable.TableName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.TableName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          传入 <see langword="null" /> 或空字符串 ("")，此表属于一个集合。</exception>
        <exception cref="T:System.Data.DuplicateNameException">该表属于一个集合，该集合已包含同名的表。 （比较区分大小写）。</exception>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Tables" />
      </Docs>
    </Member>
    <Member MemberName="TableNewRow">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableNewRowEventHandler TableNewRow;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableNewRowEventHandler TableNewRow" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableNewRow" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableNewRow As DataTableNewRowEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableNewRowEventHandler ^ TableNewRow;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableNewRowEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>插入新的 <see cref="T:System.Data.DataRow" /> 时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 后的激发<xref:System.Data.DataRow>已经使用创建<xref:System.Data.DataTable.NewRow%2A>。 此事件激发之前调用`NewRow`方法返回。 新<xref:System.Data.DataRow>分离实例; 不添加到集合。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取 <see cref="P:System.Data.DataTable.TableName" /> 和 <see cref="P:System.Data.DataTable.DisplayExpression" />（如果有一个用作连接字符串）。</summary>
        <returns>一个由 <see cref="P:System.Data.DataTable.TableName" /> 和 <see cref="P:System.Data.DataTable.DisplayExpression" /> 值字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 获取<xref:System.Data.DataTable.TableName%2A>和<xref:System.Data.DataTable.DisplayExpression%2A>为<xref:System.Data.DataTable>。  
  
   
  
## Examples  
 下面的示例返回<xref:System.Data.DataTable.TableName%2A>和<xref:System.Data.DataTable.DisplayExpression%2A>使用<xref:System.Data.DataTable.ToString%2A>方法。  
  
 [!code-csharp[Classic WebData DataTable.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>以 XML 形式写入 <see cref="T:System.Data.DataTable" /> 的当前内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
   
  
## Examples  
 以下控制台应用程序创建两个<xref:System.Data.DataTable>实例，将每个<xref:System.Data.DataSet>，创建<xref:System.Data.DataRelation>相关的两个表，，然后使用<xref:System.Data.DataTable.WriteXml%2A>方法写入到父表中包含的数据<xref:System.IO.TextWriter>. 设置时，此示例演示行为`writeHierarchy`到每个其值的参数。  
  
> [!NOTE]
>  此示例演示如何使用 WriteXml 的重载版本之一。 有关可能会提供其他示例，请参阅各个重载主题。  
  
 [!code-csharp[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/VB/source.vb#1)]  
  
 该示例在控制台窗口中显示以下输出：  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">要向其写入数据的流。</param>
        <summary>通过指定的 <see cref="T:System.IO.Stream" />，按 XML 形式编写 <see cref="T:System.Data.DataTable" /> 的当前内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入内容的 <see cref="T:System.IO.TextWriter" />。</param>
        <summary>通过指定的 <see cref="T:System.IO.TextWriter" />，按 XML 形式编写 <see cref="T:System.Data.DataTable" /> 的当前内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要向其写入 XML 数据的文件。</param>
        <summary>使用指定的文件以 XML 形式写入 <see cref="T:System.Data.DataTable" /> 的当前内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入内容的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <summary>通过指定的 <see cref="T:System.Xml.XmlWriter" />，按 XML 形式编写 <see cref="T:System.Data.DataTable" /> 的当前内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">要向其写入数据的流。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的内容。 如果为 <see langword="false" />（默认值），则只写入当前表的数据。</param>
        <summary>通过指定的 <see cref="T:System.IO.Stream" />，按 XML 形式编写 <see cref="T:System.Data.DataTable" /> 的当前内容。 若要保存该表及其所有子代的数据，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 通常`WriteXml`方法将写入当前表的数据。 要写入当前表和所有其后代的数据相关的表，请调用此方法的`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">要向其写入数据的流。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 值之一。</param>
        <summary>使用指定的 <see cref="T:System.Data.XmlWriteMode" /> 将 <see cref="T:System.Data.DataTable" /> 的当前数据和架构（可选）写入指定的文件。 若要写入架构，请将 <paramref name="mode" /> 参数的值设置为 <see langword="WriteSchema" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入内容的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的内容。 如果为 <see langword="false" />（默认值），则只写入当前表的数据。</param>
        <summary>通过指定的 <see cref="T:System.IO.TextWriter" />，按 XML 形式编写 <see cref="T:System.Data.DataTable" /> 的当前内容。 若要保存该表及其所有子代的数据，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 通常`WriteXml`方法将写入当前表的数据。 若要写入当前表和及其所有子代和相关的表数据，请调用与方法`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
   
  
## Examples  
 以下控制台应用程序创建两个<xref:System.Data.DataTable>实例，将每个<xref:System.Data.DataSet>，创建<xref:System.Data.DataRelation>相关的两个表，，然后使用<xref:System.Data.DataTable.WriteXml%2A>方法写入到父表中包含的数据<xref:System.IO.TextWriter>. 设置时，此示例演示行为`writeHierarchy`参数`true`。  
  
 [!code-csharp[DataWorks DataTable.WriteXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入文档的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 值之一。</param>
        <summary>使用指定的 <see cref="T:System.IO.TextWriter" /> 和 <see cref="T:System.Data.XmlWriteMode" /> 写入 <see cref="T:System.Data.DataTable" /> 的当前数据和架构（可选）。 若要写入架构，请将 <paramref name="mode" /> 参数的值设置为 <see langword="WriteSchema" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">要向其写入 XML 数据的文件。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的内容。 如果为 <see langword="false" />（默认值），则只写入当前表的数据。</param>
        <summary>使用指定的文件以 XML 形式写入 <see cref="T:System.Data.DataTable" /> 的当前内容。 若要保存该表及其所有子代的数据，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
 通常`WriteXml`方法将写入当前表的数据。 要写入当前表和所有其后代的数据相关的表，请调用此方法的`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">将向其写入数据的文件名称。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 值之一。</param>
        <summary>使用指定的文件和 <see cref="T:System.Data.XmlWriteMode" /> 写入 <see cref="T:System.Data.DataTable" /> 的当前数据和架构（可选）。 若要写入架构，请将 <paramref name="mode" /> 参数的值设置为 <see langword="WriteSchema" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入内容的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的内容。 如果为 <see langword="false" />（默认值），则只写入当前表的数据。</param>
        <summary>通过指定的 <see cref="T:System.Xml.XmlWriter" />，按 XML 形式编写 <see cref="T:System.Data.DataTable" /> 的当前内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
 通常`WriteXml`方法将写入当前表的数据。 若要写入当前表和及其所有子代和相关表的数据，调用与方法`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入文档的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 值之一。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlWriter" /> 和 <see cref="T:System.Data.XmlWriteMode" /> 写入 <see cref="T:System.Data.DataTable" /> 的当前数据和架构（可选）。 若要写入架构，请将 <paramref name="mode" /> 参数的值设置为 <see langword="WriteSchema" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">要向其写入数据的流。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 值之一。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的内容。 如果为 <see langword="false" />（默认值），则只写入当前表的数据。</param>
        <summary>使用指定的 <see cref="T:System.Data.XmlWriteMode" /> 将 <see cref="T:System.Data.DataTable" /> 的当前数据和架构（可选）写入指定的文件。 若要写入架构，请将 <paramref name="mode" /> 参数的值设置为 <see langword="WriteSchema" />。 若要保存该表及其所有子代的数据，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从`DataTable`插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一`XmlWriteMode`参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
 通常情况下，`WriteXml`方法将仅对当前表的数据保存。 `WriteXml`方法提供了编写只将数据方法或数据和架构从`DataTable`插入 XML 文档，而`WriteXmlSchema`方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一`XmlWriteMode`参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
 通常`WriteXml`方法将写入当前表的数据。 要写入当前表和所有其后代的数据相关的表，请调用此方法的`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入文档的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 值之一。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的内容。 如果为 <see langword="false" />（默认值），则只写入当前表的数据。</param>
        <summary>使用指定的 <see cref="T:System.IO.TextWriter" /> 和 <see cref="T:System.Data.XmlWriteMode" /> 写入 <see cref="T:System.Data.DataTable" /> 的当前数据和架构（可选）。 若要写入架构，请将 <paramref name="mode" /> 参数的值设置为 <see langword="WriteSchema" />。 若要保存该表及其所有子代的数据，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
 通常情况下，`WriteXml`方法将仅对当前表的数据保存。 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
 通常`WriteXml`方法将写入当前表的数据。 要写入当前表和所有其后代的数据相关的表，请调用此方法的`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
   
  
## Examples  
 以下控制台应用程序创建两个<xref:System.Data.DataTable>实例，将每个<xref:System.Data.DataSet>，创建<xref:System.Data.DataRelation>相关的两个表，，然后使用<xref:System.Data.DataTable.WriteXml%2A>方法写入到父表中包含的数据<xref:System.IO.TextWriter>. 设置时，此示例演示行为`writeHierarchy`到每个其值的参数。  
  
 [!code-csharp[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/VB/source.vb#1)]  
  
 该示例在控制台窗口中显示以下输出：  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">将向其写入数据的文件名称。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 值之一。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的内容。 如果为 <see langword="false" />（默认值），则只写入当前表的数据。</param>
        <summary>使用指定的文件和 <see cref="T:System.Data.XmlWriteMode" /> 写入 <see cref="T:System.Data.DataTable" /> 的当前数据和架构（可选）。 若要写入架构，请将 <paramref name="mode" /> 参数的值设置为 <see langword="WriteSchema" />。 若要保存该表及其所有子代的数据，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
 通常情况下，`WriteXml`方法将仅对当前表的数据保存。 如果你想要保存当前表和的架构，所有的数据<xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
 通常`WriteXml`方法将写入当前表的数据。 若要写入当前表和相关的所有子代的表数据，请调用与方法`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入文档的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 值之一。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的内容。 如果为 <see langword="false" />（默认值），则只写入当前表的数据。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlWriter" /> 和 <see cref="T:System.Data.XmlWriteMode" /> 写入 <see cref="T:System.Data.DataTable" /> 的当前数据和架构（可选）。 若要写入架构，请将 <paramref name="mode" /> 参数的值设置为 <see langword="WriteSchema" />。 若要保存该表及其所有子代的数据，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
 通常`WriteXml`方法将写入当前表的数据。 若要写入当前表和及其所有子代和相关表的数据，调用与方法`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Data.DataTable" /> 的当前数据结构以 XML 架构形式写入。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
   
  
## Examples  
 以下控制台应用程序创建两个<xref:System.Data.DataTable>实例，将每个<xref:System.Data.DataSet>，创建<xref:System.Data.DataRelation>相关的两个表，，然后使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入到父表中包含的数据<xref:System.IO.TextWriter>. 设置时，此示例演示行为`writeHierarchy`到每个其值的参数。  
  
> [!NOTE]
>  此示例演示如何使用的重载版本之一`WriteXmlSchema`有关可能可用，其他示例，请参阅各个重载主题。  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/VB/source.vb#1)]  
  
 该示例在控制台窗口中显示以下输出：  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">要向其写入 XML 架构的流。</param>
        <summary>以 XML 架构的形式将 <see cref="T:System.Data.DataTable" /> 的当前数据结构写入指定的流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入的 <see cref="T:System.IO.TextWriter" />。</param>
        <summary>使用指定的 <see cref="T:System.IO.TextWriter" /> 以 XML 架构的形式写入 <see cref="T:System.Data.DataTable" /> 的当前数据结构。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要使用的文件的名称。</param>
        <summary>以 XML 架构的形式将 <see cref="T:System.Data.DataTable" /> 的当前数据结构写入指定的文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">要使用的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlWriter" /> 以 XML 架构的形式写入 <see cref="T:System.Data.DataTable" /> 的当前数据结构。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">要向其写入 XML 架构的流。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的架构。 如果为 <see langword="false" />（默认值），则只写入当前表的架构。</param>
        <summary>以 XML 架构的形式将 <see cref="T:System.Data.DataTable" /> 的当前数据结构写入指定的流。 若要保存该表及其所有子代的架构，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 通常`WriteXmlSchema`方法将写入当前表的架构。 若要写入当前表和及其所有子代和相关表的架构，调用与方法`writeHierarchy`参数设置为`true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的架构。 如果为 <see langword="false" />（默认值），则只写入当前表的架构。</param>
        <summary>使用指定的 <see cref="T:System.IO.TextWriter" /> 以 XML 架构的形式写入 <see cref="T:System.Data.DataTable" /> 的当前数据结构。 若要保存该表及其所有子代的架构，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 通常`WriteXmlSchema`方法将写入当前表的架构。 若要写入当前表和及其所有子代和相关表的架构，调用与方法`writeHierarchy`参数设置为`true`。  
  
   
  
## Examples  
 以下控制台应用程序创建两个<xref:System.Data.DataTable>实例，将每个<xref:System.Data.DataSet>，创建<xref:System.Data.DataRelation>相关的两个表，，然后使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入到父表中包含的数据<xref:System.IO.TextWriter>. 设置时，此示例演示行为`writeHierarchy`到每个其值的参数。  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/VB/source.vb#1)]  
  
 该示例在控制台窗口中显示以下输出：  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">要使用的文件的名称。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的架构。 如果为 <see langword="false" />（默认值），则只写入当前表的架构。</param>
        <summary>以 XML 架构的形式将 <see cref="T:System.Data.DataTable" /> 的当前数据结构写入指定的文件。 若要保存该表及其所有子代的架构，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 通常`WriteXmlSchema`方法将写入当前表的架构。 若要写入当前表和及其所有子代和相关表的架构，调用与方法`writeHierarchy`参数设置为`true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入文档的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的架构。 如果为 <see langword="false" />（默认值），则只写入当前表的架构。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlWriter" /> 以 XML 架构的形式写入 <see cref="T:System.Data.DataTable" /> 的当前数据结构。 若要保存该表及其所有子代的架构，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 通常`WriteXmlSchema`方法将写入当前表的架构。 若要写入当前表和及其所有子代和相关表的架构，调用与方法`writeHierarchy`参数设置为`true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>