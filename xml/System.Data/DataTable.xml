<Type Name="DataTable" FullName="System.Data.DataTable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ebfc2930ba77d02811472dac7449a79e1eea9c8a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36679900" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataTable extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTable" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTable&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTable : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataTable = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("RowChanging")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("TableName")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataTableSchema")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents one table of in-memory data.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable>是 ADO.NET 库中的中央对象。 其他对象使用<xref:System.Data.DataTable>包括<xref:System.Data.DataSet>和<xref:System.Data.DataView>。  
  
 在访问时<xref:System.Data.DataTable>对象，请注意，它们是有条件地区分大小写。 例如，如果一个<xref:System.Data.DataTable>名为"mydatatable"和另一个名为"Mydatatable"，用于搜索表中的一个的字符串将被视为区分大小写。 但是，如果"mydatatable"存在，并且"Mydatatable"不，搜索字符串将被视为区分。 A<xref:System.Data.DataSet>可以包含两个<xref:System.Data.DataTable>具有相同的对象<xref:System.Data.DataTable.TableName%2A>属性值但是具有不同<xref:System.Data.DataTable.Namespace%2A>属性值。 有关使用<xref:System.Data.DataTable>对象，请参阅[创建数据表](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md)。  
  
 如果要创建<xref:System.Data.DataTable>以编程方式，你首先必须通过添加定义其架构<xref:System.Data.DataColumn>对象添加到<xref:System.Data.DataColumnCollection>(通过访问<xref:System.Data.DataTable.Columns%2A>属性)。 有关添加详细信息<xref:System.Data.DataColumn>对象，请参阅[向数据表添加列](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md)。  
  
 若要将行添加到<xref:System.Data.DataTable>，必须首先使用<xref:System.Data.DataTable.NewRow%2A>方法以返回一个新<xref:System.Data.DataRow>对象。 <xref:System.Data.DataTable.NewRow%2A>方法返回的架构行<xref:System.Data.DataTable>，因为它由表的定义<xref:System.Data.DataColumnCollection>。 行的最大数目<xref:System.Data.DataTable>可以存储是 16777216。 有关详细信息，请参阅[向数据表添加数据](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md)。  
  
 <xref:System.Data.DataTable>还包含一套<xref:System.Data.Constraint>可以用于确保数据完整性的对象。 有关详细信息，请参阅[数据表约束](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md)。  
  
 有许多<xref:System.Data.DataTable>可以用于确定当对表进行更改的事件。 其中包括 <xref:System.Data.DataTable.RowChanged>、<xref:System.Data.DataTable.RowChanging>、<xref:System.Data.DataTable.RowDeleting> 和 <xref:System.Data.DataTable.RowDeleted>。 有关可与事件的详细信息<xref:System.Data.DataTable>，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
 实例时<xref:System.Data.DataTable>创建后，某些的读/写属性设置为初始值。 有关这些值的列表，请参阅<xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType>构造函数主题。  
  
> [!NOTE]
>  <xref:System.Data.DataSet>和<xref:System.Data.DataTable>对象继承自<xref:System.ComponentModel.MarshalByValueComponent>，并且支持<xref:System.Runtime.Serialization.ISerializable>.NET Framework 远程处理的接口。 这些是唯一可用于.NET Framework 远程处理的 ADO.NET 对象。  
  
   
  
## Examples  
 下面的示例创建两个<xref:System.Data.DataTable>对象和一个<xref:System.Data.DataRelation>对象，并将添加到的新对象<xref:System.Data.DataSet>。 表将显示在<xref:System.Windows.Forms.DataGridView>控件。  
  
 [!code-csharp[Classic WebData DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable Example/VB/source.vb#1)]  
  
 此示例演示如何使用特定的架构定义手动创建 DataTable：  
  
-   创建多个 DataTable 并定义初始列。  
  
-   创建表约束。  
  
-   插入值并显示表。  
  
-   创建表达式列并显示表。  
  
 此代码示例的 C# 和 Visual Basic 项目可以位于[开发人员代码示例](https://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914)。  
  
 [!code-csharp[Classic WebData DataTable Example2#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/classic webdata datatable example2/cs/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example2#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/classic webdata datatable example2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是安全的多线程读取操作。 你必须同步任何写入操作。</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class with no arguments.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 构造函数设置的所有属性的初始值<xref:System.Data.DataTable>对象。 下表显示的属性和其默认值。 实例时<xref:System.Data.DataTable>创建以下读/写属性设置为初始值。  
  
|属性|默认值|  
|--------------|-------------------|  
|**CaseSensitive**|与父项相同<xref:System.Data.DataSet>，如果它属于一个。 否则为 `false`。|  
|**DisplayExpression**|空字符串 ("")|  
|**区域设置**|与父项相同<xref:System.Data.DataSet>对象的<xref:System.Globalization.CultureInfo>(返回<xref:System.Data.DataSet.Locale%2A>属性); 如果存在没有父级，默认值是当前系统<xref:System.Globalization.CultureInfo>。|  
|**MinimumCapacity**|50 行。|  
  
 你可以更改任何通过单独属性调用这些属性的值。  
  
   
  
## Examples  
 下面的示例创建一个新<xref:System.Data.DataTable>与<xref:System.Data.DataColumn>和<xref:System.Data.DataRow>，并将其显示在<xref:System.Windows.Forms.DataGridView>控件。  
  
 [!code-csharp[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable tableName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">The name to give the table. If <c>tableName</c> is <see langword="null" /> or an empty string, a default name is given when added to the <see cref="T:System.Data.DataTableCollection" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class with the specified table name.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建<xref:System.Data.DataTable>和将其显示在<xref:System.Windows.Forms.DataGridView>控件。  
  
 [!code-csharp[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataTable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataTable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">The data needed to serialize or deserialize an object.</param>
        <param name="context">The source and destination of a given serialized stream.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class with the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> and the <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现的<xref:System.Data.DataTable>构造函数，才能使用<xref:System.Runtime.Serialization.ISerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName, string tableNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName, string tableNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String, tableNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName, System::String ^ tableNamespace);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string * string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (tableName, tableNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
        <Parameter Name="tableNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">The name to give the table. If <c>tableName</c> is <see langword="null" /> or an empty string, a default name is given when added to the <see cref="T:System.Data.DataTableCollection" />.</param>
        <param name="tableNamespace">The namespace for the XML representation of the data stored in the <see langword="DataTable" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class using the specified table name and namespace.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataTable.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Commits all the changes made to this table since the last time <see cref="M:System.Data.DataTable.AcceptChanges" /> was called.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Data.DataTable.AcceptChanges%2A>调用时，任何<xref:System.Data.DataRow>仍处于编辑模式的对象已成功结束其编辑。 <xref:System.Data.DataRowState>也会更改： 所有`Added`和`Modified`行都变为`Unchanged`，和`Deleted`已删除的行。  
  
 <xref:System.Data.DataTable.AcceptChanges%2A>方法通常称为上<xref:System.Data.DataTable>你尝试更新后<xref:System.Data.DataSet>使用<xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下面的示例测试有错误的每个表。 如果表中的错误可以协调 （通过将其传递到未定义的函数），<xref:System.Data.DataTable.AcceptChanges%2A>调用; 否则为<xref:System.Data.DataTable.RejectChanges%2A>调用。  
  
 [!code-csharp[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataTable.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins the initialization of a <see cref="T:System.Data.DataTable" /> that is used on a form or used by another component. The initialization occurs at run time.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio.NET 设计环境使用此方法来启动窗体上使用或由另一个组件的组件的初始化。 <xref:System.Data.DataTable.EndInit%2A>方法初始化已结束。 使用<xref:System.Data.DataTable.BeginInit%2A>和<xref:System.Data.DataTable.EndInit%2A>方法阻止控件完全初始化之前使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadData">
      <MemberSignature Language="C#" Value="public void BeginLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoadData();" />
      <MemberSignature Language="F#" Value="member this.BeginLoadData : unit -&gt; unit" Usage="dataTable.BeginLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Turns off notifications, index maintenance, and constraints while loading data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.BeginLoadData%2A>结合<xref:System.Data.DataTable.LoadDataRow%2A>和<xref:System.Data.DataTable.EndLoadData%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataTable.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates whether string comparisons within the table are case-sensitive.</summary>
        <value>
          <see langword="true" /> 如果比较不区分大小写;否则为<see langword="false" />。 默认值设置为 parent<see cref="T:System.Data.DataSet" />对象的<see cref="P:System.Data.DataSet.CaseSensitive" />属性，或<see langword="false" />如果<see cref="T:System.Data.DataTable" />创建独立于<see cref="T:System.Data.DataSet" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.CaseSensitive%2A>属性会影响中排序、 搜索和筛选的字符串比较。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Data.DataTable.Select%2A>方法两次<xref:System.Data.DataTable>。 第一次，<xref:System.Data.DataTable.CaseSensitive%2A>属性设置为`false`，则第二个`true`。  
  
 [!code-csharp[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Select" />
      </Docs>
    </Member>
    <Member MemberName="ChildRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ChildRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ChildRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ChildRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChildRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ChildRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChildRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ChildRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of child relations for this <see cref="T:System.Data.DataTable" />.</summary>
        <value>A <see cref="T:System.Data.DataRelationCollection" /> ，包含表的子关系。 如果没有，则返回一个空集合<see cref="T:System.Data.DataRelation" />对象存在。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Data.DataRelation>定义两个表之间的关系。 通常情况下，通过单个字段包含相同的数据链接两个表。 例如，其中包含地址数据的表可能具有单个字段，其中包含表示国家/地区代码。 包含国家/地区的数据的第二个表将具有单个字段包含标识国家/地区代码和它将此代码会插入到第一个表中的对应字段。 A <xref:System.Data.DataRelation>，然后，包含至少四部分信息: (1) 的第一个表名称、 中的第一个表 （2） 的列名称、 第二个表，（3） 的名称和第二个表中 （4） 的列名称。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Data.DataTable.ChildRelations%2A>属性以返回每个子<xref:System.Data.DataRelation>中<xref:System.Data.DataTable>。 每个关系中的参数作为用<xref:System.Data.DataRow.GetChildRows%2A>方法<xref:System.Data.DataRow>返回行的数组。 然后打印的行中的每个列的值。  
  
 [!code-csharp[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ParentRelations" />
        <altmember cref="M:System.Data.DataRow.GetParentRows(System.String)" />
        <altmember cref="M:System.Data.DataRow.GetChildRows(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears the <see cref="T:System.Data.DataTable" /> of all data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将删除所有表中的所有行。 如果表具有将导致子行孤立任何强制执行的子关系，则会生成异常。  
  
 如果<xref:System.Data.DataSet>绑定到<xref:System.Xml.XmlDataDocument>，则调用<xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType>或<xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType>引发<xref:System.NotSupportedException>。 若要避免这种情况下，遍历每个表，一次移除每一行。 当你使用<xref:System.Data.DataTable.NewRow%2A>若要创建新行，行必须处理你在调用之前<xref:System.Data.DataTable.Clear%2A>。  
  
   
  
## Examples  
 下面的示例将清除所有数据的表。  
  
 [!code-csharp[Classic WebData DataTable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataTable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataTable ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataTable&#xA;override this.Clone : unit -&gt; System.Data.DataTable" Usage="dataTable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clones the structure of the <see cref="T:System.Data.DataTable" />, including all <see cref="T:System.Data.DataTable" /> schemas and constraints.</summary>
        <returns>A new <see cref="T:System.Data.DataTable" /> with the same schema as the current <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果派生的这些类，克隆也将是相同的派生类。  
  
 克隆可创建具有与原始 <xref:System.Data.DataTable> 相同的结构的新 <xref:System.Data.DataTable>，但不复制任何数据（新 <xref:System.Data.DataTable> 将不会包含任何 `DataRows`）。 若要同时将结构和数据复制到新 <xref:System.Data.DataTable> 中，请使用 <xref:System.Data.DataTable.Copy%2A>。  
  
   
  
## Examples  
 以下示例演示如何在执行 DataTable.Clone 后更新目标表的结构和约束。 ClonedDataTable 类将返回目标表并包括所有更新事件。 克隆后，源表中的结构更改不会反映到目标表中。 具体而言，此示例将：  
  
-   更新源表中的列更改。  
  
-   更新源表中的 UniqueConstraint 更改。  
  
-   更新源表中的 ForeignKeyConstraint 更改。  
  
 此代码示例的 C# 和 Visual Basic 项目可以位于[开发人员代码示例](https://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable)。  
  
```csharp  
using System;  
using System.Linq;  
using System.Data;  
using System.ComponentModel;  
  
class Program {  
   static void Main(string[] args) {  
      DataTable courses = NewCourseDataTable();  
      Console.WriteLine("This is the source table:");  
      WriteDataTable(courses);  
  
      ClonedDataTable clonedResult = new ClonedDataTable(courses);  
      DataTable clonedCourses = clonedResult.DestinationTable;  
      Console.WriteLine("This is the destination table:");  
      WriteDataTable(clonedCourses);  
  
      // Add the events of updating column collection into the source table.  
      clonedResult.UpdateAddedColumn();  
      clonedResult.UpdateDeletedColumn();  
      // Add a DataColumn in source table.  
      DataColumn columnCreidts = new DataColumn("Credits", typeof(Int32));  
      courses.Columns.Add(columnCreidts);  
      Console.WriteLine("After add a column in source table, it's the result in the destination:");  
      WriteDataTable(clonedCourses);  
  
      // Add the event of updating UniqueConstraint into the source table.  
      clonedResult.UpdateUniqueConstraint();  
  
      // Add the unique constraint in source table.  
      UniqueConstraint uniqueConstraint = new UniqueConstraint(courses.Columns["CourseId"]);  
      courses.Constraints.Add(uniqueConstraint);  
  
      Console.WriteLine(@"If we add the unique constraint in source table and then insert the duplicate   
rows into the destination table, we will get the following error:");  
      InsertDuplicateData(clonedCourses);  
      Console.WriteLine();  
  
      // Add the event of updating ForeignKeyConstraint into the source table.  
      clonedResult.UpdateForeignKeyConstraint();  
  
      // Add the ForeignKeyConstraint into the source table.  
      DataTable deparments = NewDeparmentDataTable();  
      DataSet dataset = new DataSet();  
  
      dataset.Tables.Add(courses);  
      dataset.Tables.Add(clonedCourses);  
      dataset.Tables.Add(deparments);  
  
      ForeignKeyConstraint foreignKey = new ForeignKeyConstraint(deparments.Columns["DepartmentId"], courses.Columns["DepartmentId"]);  
      courses.Constraints.Add(foreignKey);  
  
      Console.WriteLine(@"If we add the foreign key constraint in source table and then insert a row   
without the parent  into the destination table, we will get the following error:");  
      InsertNoParentRow(clonedCourses);  
      Console.WriteLine();  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   static private DataTable NewCourseDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("CourseId", typeof(String)),  
                                      new DataColumn("CourseName",typeof(String)),                                        
                                      new DataColumn("DepartmentId", typeof(Int32))  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add("C1045", "Calculus", 7);  
      newTable.Rows.Add("C1061", "Physics", 1);  
      newTable.Rows.Add("C2021", "Composition", 2);  
      newTable.Rows.Add("C2042", "Literature", 2);  
  
      return newTable;  
   }  
  
   static private DataTable NewDeparmentDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("DepartmentId", typeof(Int32)),  
                                      new DataColumn("Name",typeof(String)),  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add(1, "Engineering");  
      newTable.Rows.Add(2, "English");  
      newTable.Rows.Add(4, "Economics");  
      newTable.Rows.Add(7, "Mathematics");  
  
      return newTable;  
   }  
  
   static private void WriteDataTable(DataTable table) {  
      if (table == null)  
         return;  
  
      foreach (DataColumn column in table.Columns) {  
         Console.Write("{0,-15}", column.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         for (int i = 0; i < table.Columns.Count; i++)  
            Console.Write("{0,-15}", row[i].ToString());  
         Console.WriteLine();  
      }  
  
      Console.WriteLine();  
   }  
  
   static private void InsertDuplicateData(DataTable table) {  
      try {  
         table.Rows.Add("C1045", "Calculus", 7);  
         table.Rows.Add("C1045", "Calculus", 7);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
  
   private static void InsertNoParentRow(DataTable table) {  
      try {  
         table.Rows.Add("C1061", "Physics", 11);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
}  
  
public class ClonedDataTable {  
   private DataTable sourceTable;  
   private DataTable destinationTable;  
  
   public ClonedDataTable(DataTable source) {  
      sourceTable = source;  
      // set the cloned result  
      destinationTable = sourceTable.Clone();  
   }  
  
   public void UpdateAddedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnAdded);  
   }  
  
   public void UpdateDeletedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnDeleted);  
   }  
  
   public void UpdateUniqueConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(UniqueConstraint_Changed);  
   }  
  
   public void UpdateForeignKeyConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(ForeignKeyConstraint_Changed);  
   }  
  
   // After the source table adds a column, the method will add the same column in the destination table.  
   void ColumnAdded(object sender, System.ComponentModel.CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null) {  
            DataColumn newColumn = new DataColumn(column.ColumnName, column.DataType, column.Expression, column.ColumnMapping);  
  
            if (!destinationTable.Columns.Contains(newColumn.ColumnName))  
               destinationTable.Columns.Add(newColumn);  
         }  
      }  
   }  
  
   // After the source table deletes a column, the method will delete the same column in the destination table.  
   void ColumnDeleted(object sender, CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Remove) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null)  
            if (destinationTable.Columns.Contains(column.ColumnName))  
               destinationTable.Columns.Remove(column.ColumnName);  
      }  
   }  
  
   // After the source table changes the UniqueConstraint, this method changes the same UniqueConstraint in destination table.        
   void UniqueConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      UniqueConstraint constraint = e.Element as UniqueConstraint;  
  
      if (constraint == null)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         Boolean isPrimaryKey = constraint.IsPrimaryKey;  
  
         // Get the columns used in new constraint from the destiantion table.  
         for (Int32 i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         UniqueConstraint newConstraint = new UniqueConstraint(constraintName, columns, isPrimaryKey);  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // After the source table changes the ForeignKeyConstraint, this method changes    
   // the same ForeignKeyConstraint in the destination table.  
   void ForeignKeyConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      ForeignKeyConstraint constraint = e.Element as ForeignKeyConstraint;  
  
      if (constraint == null)  
         return;  
  
      // If the source and destination are not in the same DataSet, don't change the ForeignKeyConstraint.  
      if (sourceTable.DataSet != destinationTable.DataSet)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         DataColumn[] parentColumns = constraint.RelatedColumns;  
  
         // Get the columns used in new constraint from the destination table.  
         for (int i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constraintName, parentColumns, columns);  
         newConstraint.AcceptRejectRule = constraint.AcceptRejectRule;  
         newConstraint.DeleteRule = constraint.DeleteRule;  
         newConstraint.UpdateRule = constraint.UpdateRule;  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // return the destination table.  
   public DataTable DestinationTable {  
      get { return destinationTable; }  
   }  
}  
```  
  
 此示例演示如何更改 DataTable 中的数据和更新数据源。  
  
 首先，创建一个数据库：  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 现在可编译并运行此示例。 [如何修改 DataTable 和更新到数据源中的数据](https://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4)具有此示例的 Visual Basic 和 C# 项目。  
  
```csharp  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
   string MySchoolConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True";  
  
      // Get Data  
      String selectString =  
       @"Select [CourseID],[Year],[Title],[Credits],[DepartmentID] From [dbo].[Course];  
               Select [DepartmentID],[Name],[Budget],[StartDate],[Administrator] From [dbo].[Department] ";  
  
      DataSet dataSet = new DataSet();  
      DataTable course = dataSet.Tables.Add("Course");  
      DataTable department = dataSet.Tables.Add("Department");  
  
      Console.WriteLine("Get data from database:");  
      GetDataTables(MySchoolConnectionString, selectString, dataSet, course, department);  
      Console.WriteLine();  
  
      // Use DataTable Edits to edit the data  
      String updateString =  
              @"Update [dbo].[Course] Set [Credits]=@Credits Where [CourseID]=@CourseID;";  
  
      course.ColumnChanged += OnColumnChanged;  
  
      // Set the Credits of first row is negative value, and set the Credits of second row is plus.  
      ChangeCredits(course, course.Rows[0], -1);  
      ChangeCredits(course, course.Rows[1], 11);  
  
      UpdateDataTables(MySchoolConnectionString, updateString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"),  
          new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits"));  
      Console.WriteLine("Only the Credits of second row is changed.");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      // Delete and Remove from DataTable  
      // Create the foreign key constraint, and set the DeleteRule with Cascade.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      String deleteString = @"Delete From [dbo].[Course] Where [CourseID]=@CourseID;";  
  
      department.Rows[0].Delete();  
      Console.WriteLine("If One row in Department table is deleted, the related rows in Course table will also be deleted.");  
      Console.WriteLine("Department DataTable:");  
      ShowDataTable(department);  
      Console.WriteLine();  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
      // Update the delete operation  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
      Console.WriteLine("After delete operation:");  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      course.Rows.RemoveAt(0);  
      Console.WriteLine("Now we remove one row from Course:");  
      ShowDataTable(course);  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
   }  
  
   // Use SqlDataAdapter to get data.  
   private static void GetDataTables(String connectionString, String selectString,  
       DataSet dataSet, params DataTable[] tables) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.SelectCommand = new SqlCommand(selectString);  
         adapter.SelectCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Fill(0, 0, tables);  
  
         foreach (DataTable table in dataSet.Tables) {  
            Console.WriteLine("Data in {0}:", table.TableName);  
            ShowDataTable(table);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use SqlDataAdapter to update the updata operation.  
   private static void UpdateDataTables(String connectionString, String updateString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.UpdateCommand = new SqlCommand(updateString);  
         adapter.UpdateCommand.Parameters.AddRange(parameters);  
         adapter.UpdateCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use SqlDataAdapter to update delete operation.  
   private static void DeleteDataTables(String connectionString, String deleteString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.DeleteCommand = new SqlCommand(deleteString);  
         adapter.DeleteCommand.Parameters.AddRange(parameters);  
         adapter.DeleteCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use DataTable Edits to modify the data.  
   private static void ChangeCredits(DataTable table, DataRow row, Int32 credits) {  
      row.BeginEdit();  
      Console.WriteLine("We change row {0}", table.Rows.IndexOf(row));  
      row["Credits"] = credits;  
      row.EndEdit();  
   }  
  
   // The method will be invoked when the value in DataTable is changed.  
   private static void OnColumnChanged(Object sender, DataColumnChangeEventArgs args) {  
      Int32 credits = 0;  
      // If Credits is changed and the value is negative, we'll cancel the edit.  
      if ((args.Column.ColumnName == "Credits") &&  
          (!Int32.TryParse(args.ProposedValue.ToString(), out credits) || credits < 0)) {  
         Console.WriteLine("The value of Credits is invalid. Edit canceled.");  
         args.Row.CancelEdit();  
      }  
   }  
  
   // Display the column and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "RowState");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               else  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col]);  
               else  
                  Console.Write("{0,-14}", row[col]);  
            }  
         }  
         Console.WriteLine("{0,-14}", row.RowState);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Copy" />
      </Docs>
    </Member>
    <Member MemberName="ColumnChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanged As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanged;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after a value has been changed for the specified <see cref="T:System.Data.DataColumn" /> in a <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataColumnChangeEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ColumnChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanging As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanging;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a value is being changed for the specified <see cref="T:System.Data.DataColumn" /> in a <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Columns">
      <MemberSignature Language="C#" Value="public System.Data.DataColumnCollection Columns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumnCollection Columns" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Columns" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Columns As DataColumnCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataColumnCollection ^ Columns { System::Data::DataColumnCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Columns : System.Data.DataColumnCollection" Usage="System.Data.DataTable.Columns" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of columns that belong to this table.</summary>
        <value>A <see cref="T:System.Data.DataColumnCollection" /> ，包含的集合<see cref="T:System.Data.DataColumn" />表的对象。 如果没有，则返回一个空集合<see cref="T:System.Data.DataColumn" />对象存在。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataColumnCollection>通过定义每个列的数据类型确定的表架构。  
  
   
  
## Examples  
 下面的示例输出中表使用的每一行的每个值<xref:System.Data.DataTable.Columns%2A>属性。  
  
 [!code-csharp[Classic WebData DataTable.Columns Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Columns Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compute">
      <MemberSignature Language="C#" Value="public object Compute (string expression, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Compute(string expression, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Compute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compute (expression As String, filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Compute(System::String ^ expression, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="member this.Compute : string * string -&gt; obj" Usage="dataTable.Compute (expression, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">The expression to compute.</param>
        <param name="filter">The filter to limit the rows that evaluate in the expression.</param>
        <summary>Computes the given expression on the current rows that pass the filter criteria.</summary>
        <returns>An <see cref="T:System.Object" />, set to the result of the computation. If the expression evaluates to null, the return value will be <see cref="F:System.DBNull.Value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `expression`参数需要聚合函数。 例如，下面是一个合法的表达式：  
  
 `Count(Quantity)`  
  
 但是，此表达式不是：  
  
 `Sum (Quantity * UnitPrice)`  
  
 如果必须执行两个或多个列上的操作，则应创建<xref:System.Data.DataColumn>，将其<xref:System.Data.DataColumn.Expression%2A>到适当的表达式，并使用在生成的列的聚合表达式中的属性。 在这种情况下，给定<xref:System.Data.DataColumn>具有名称"总"，与<xref:System.Data.DataColumn.Expression%2A>属性设置为此：  
  
 `"Quantity * UnitPrice"`  
  
 表达式参数<xref:System.Data.DataTable.Compute%2A>方法将为此：  
  
 `Sum(total)`  
  
 第二个参数， `filter`，确定在表达式中使用哪些行。 例如，如果表包含一个名为"colDate"的日期列，则无法限制使用以下表达式的行：  
  
 `colDate > 1/1/99 AND colDate < 17/1/99`  
  
 有关创建这两个参数的表达式的规则，请参阅<xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType>属性。  
  
   
  
## Examples  
 下面的示例针对名"总计"，为其标识号为五位销售人员的列的值求和。  
  
 [!code-csharp[Classic WebData DataTable.Compute Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Compute Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public System.Data.ConstraintCollection Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ConstraintCollection Constraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Constraints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Constraints As ConstraintCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ConstraintCollection ^ Constraints { System::Data::ConstraintCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Constraints : System.Data.ConstraintCollection" Usage="System.Data.DataTable.Constraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConstraintCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of constraints maintained by this table.</summary>
        <value>A <see cref="T:System.Data.ConstraintCollection" /> ，包含的集合<see cref="T:System.Data.Constraint" />表的对象。 如果没有，则返回一个空集合<see cref="T:System.Data.Constraint" />对象存在。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Data.ForeignKeyConstraint>限制时删除或更新列 （或列） 中的值执行的操作。 此类约束旨在与主键列一起使用。 在父/子关系中两个表之间，从父表中删除值可能会影响子行在通过以下方式之一。  
  
-   也可以是行的子删除 （级联操作）。  
  
-   中子 （或多个列） 的值可以设置为 null 值。  
  
-   中子 （或多个列） 的值可以设置为默认值。  
  
-   可以生成异常。  
  
 A<xref:System.Data.UniqueConstraint>尝试在一个主键到非唯一的值中设置一个值时将变为活动状态。  
  
   
  
## Examples  
 下面的示例添加<xref:System.Data.ForeignKeyConstraint>到约束的集合。  
  
 [!code-csharp[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataTable Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataTable" Usage="dataTable.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copies both the structure and data for this <see cref="T:System.Data.DataTable" />.</summary>
        <returns>A new <see cref="T:System.Data.DataTable" /> with the same structure (table schemas and constraints) and data as this <see cref="T:System.Data.DataTable" />.  If these classes have been derived, the copy will also be of the same derived classes.  
  
 <see cref="M:System.Data.DataTable.Copy" /> creates a new <see cref="T:System.Data.DataTable" /> with the same structure and data as the original <see cref="T:System.Data.DataTable" />. To copy the structure to a new <see cref="T:System.Data.DataTable" />, but not the data, use <see cref="M:System.Data.DataTable.Clone" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例使用<xref:System.Data.DataTable.Copy%2A>方法来创建一份原始<xref:System.Data.DataTable>。 如果从父文件夹继承的命名空间名称不会保留<xref:System.Data.DataTable>或<xref:System.Data.DataSet>。  
  
 [!code-csharp[Classic WebData DataTable.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataView.ToTable" />
        <altmember cref="M:System.Data.DataTable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataTable.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a <see cref="T:System.Data.DataTableReader" /> corresponding to the data within this <see cref="T:System.Data.DataTable" />.</summary>
        <returns>A <see cref="T:System.Data.DataTableReader" /> containing one result set, corresponding to the source <see cref="T:System.Data.DataTable" /> instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下控制台应用程序创建一个 <xref:System.Data.DataTable> 实例。 该示例然后将填充<xref:System.Data.DataTable>给过程调用<xref:System.Data.DataTable.CreateDataReader%2A>方法，它循环访问结果中包含<xref:System.Data.DataTableReader>。  
  
 [!code-csharp[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/VB/source.vb#1)]  
  
 该示例在控制台窗口中显示以下输出：  
  
 `1 Mary`  
  
 `2 Andy`  
  
 `3 Peter`  
  
 `4 Russ`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.CreateDataReader" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateInstance () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : unit -&gt; System.Data.DataTable&#xA;override this.CreateInstance : unit -&gt; System.Data.DataTable" Usage="dataTable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new instance of <see cref="T:System.Data.DataTable" />.</summary>
        <returns>The new expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataSet : System.Data.DataSet" Usage="System.Data.DataTable.DataSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Data.DataSet" /> to which this table belongs.</summary>
        <value>
          <see cref="T:System.Data.DataSet" />该表所属。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果控件数据绑定到<xref:System.Data.DataTable>，并且表属于<xref:System.Data.DataSet>，可获取指向<xref:System.Data.DataSet>通过此属性。  
  
   
  
## Examples  
 下面的示例返回父<xref:System.Data.DataSet>通过给定表的<xref:System.Data.DataTable.DataSet%2A>属性。  
  
 [!code-csharp[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultView">
      <MemberSignature Language="C#" Value="public System.Data.DataView DefaultView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataView DefaultView" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DefaultView" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultView As DataView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataView ^ DefaultView { System::Data::DataView ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultView : System.Data.DataView" Usage="System.Data.DataTable.DefaultView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a customized view of the table that may include a filtered view, or a cursor position.</summary>
        <value>与 <see cref="T:System.Data.DataView" /> 关联的 <see cref="T:System.Data.DataTable" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.DefaultView%2A>属性返回<xref:System.Data.DataView>可用于排序、 筛选和搜索<xref:System.Data.DataTable>。  
  
   
  
## Examples  
 下面的示例设置的一个属性<xref:System.Data.DataTable>对象的<xref:System.Data.DataView>通过<xref:System.Data.DataTable.DefaultView%2A>属性。 该示例还演示的绑定<xref:System.Windows.Forms.DataGridView>控制转移到<xref:System.Data.DataTable>名为"供应商"包括一个名为"CompanyName"。  
  
 [!code-csharp[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayExpression">
      <MemberSignature Language="C#" Value="public string DisplayExpression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayExpression" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DisplayExpression" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayExpression As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayExpression { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayExpression : string with get, set" Usage="System.Data.DataTable.DisplayExpression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the expression that returns a value used to represent this table in the user interface. The <see langword="DisplayExpression" /> property lets you display the name of this table in a user interface.</summary>
        <value>显示字符串。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Data.DataColumn.Expression" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataTable.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ends the initialization of a <see cref="T:System.Data.DataTable" /> that is used on a form or used by another component. The initialization occurs at run time.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio.NET 设计环境使用此方法来结束的窗体上使用或由另一个组件的组件初始化。 <xref:System.Data.DataTable.BeginInit%2A>方法开始初始化。 使用<xref:System.Data.DataTable.BeginInit%2A>和<xref:System.Data.DataTable.EndInit%2A>方法阻止控件完全初始化之前使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLoadData">
      <MemberSignature Language="C#" Value="public void EndLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadData();" />
      <MemberSignature Language="F#" Value="member this.EndLoadData : unit -&gt; unit" Usage="dataTable.EndLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Turns on notifications, index maintenance, and constraints after loading data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.EndLoadData%2A>结合<xref:System.Data.DataTable.LoadDataRow%2A>和<xref:System.Data.DataTable.BeginLoadData%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataTable.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of customized user information.</summary>
        <value>A <see cref="T:System.Data.PropertyCollection" /> ，其中包含自定义用户信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.ExtendedProperties%2A>向其添加自定义信息<xref:System.Data.DataTable>。 使用添加信息`Add`方法。 检索信息，`Item`方法。  
  
 扩展的属性的类型必须为<xref:System.String>。 并不属于 String 类型的属性不会保留时<xref:System.Data.DataTable>以 XML 形式写入。  
  
   
  
## Examples  
 下面的示例将添加到一个时间戳值<xref:System.Data.DataTable>通过<xref:System.Data.DataTable.ExtendedProperties%2A>属性。  
  
 [!code-csharp[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="fInitInProgress">
      <MemberSignature Language="C#" Value="protected internal bool fInitInProgress;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly bool fInitInProgress" />
      <MemberSignature Language="DocId" Value="F:System.Data.DataTable.fInitInProgress" />
      <MemberSignature Language="VB.NET" Value="Protected Friend fInitInProgress As Boolean " />
      <MemberSignature Language="C++ CLI" Value="protected public: bool fInitInProgress;" />
      <MemberSignature Language="F#" Value="val mutable fInitInProgress : bool" Usage="System.Data.DataTable.fInitInProgress" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Checks whether initialization is in progress. The initialization occurs at run time.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a copy of the <see cref="T:System.Data.DataTable" /> containing all changes made to it since it was last loaded, or since <see cref="M:System.Data.DataTable.AcceptChanges" /> was called.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataTable" Usage="dataTable.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a copy of the <see cref="T:System.Data.DataTable" /> that contains all changes made to it since it was loaded or <see cref="M:System.Data.DataTable.AcceptChanges" /> was last called.</summary>
        <returns>A copy of the changes from this <see cref="T:System.Data.DataTable" />, or <see langword="null" /> if no changes are found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 创建一个新<xref:System.Data.DataSet>包含原始中的所有行的副本<xref:System.Data.DataSet>中具有挂起更改。 关系约束可能会导致其他未更改的行添加到新<xref:System.Data.DataSet>如果未更改的行包含对应于已更改的行中的外键的主键。 该方法返回`null`(`Nothing`在 Visual Basic 中) 中是否存在任何行原始<xref:System.Data.DataSet>与挂起的更改。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataTable" Usage="dataTable.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">One of the <see cref="T:System.Data.DataRowState" /> values.</param>
        <summary>Gets a copy of the <see cref="T:System.Data.DataTable" /> containing all changes made to it since it was last loaded, or since <see cref="M:System.Data.DataTable.AcceptChanges" /> was called, filtered by <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>A filtered copy of the <see cref="T:System.Data.DataTable" /> that can have actions performed on it, and later be merged back in the <see cref="T:System.Data.DataTable" /> using <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. If no rows of the desired <see cref="T:System.Data.DataRowState" /> are found, the method returns <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.GetChanges%2A>方法用于生成第二个<xref:System.Data.DataTable>引入到原始的只包含的更改的对象。 使用`rowStates`自变量以指定新的对象应包含的更改的类型。  
  
 关系约束可能会导致不变的父行要包含。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataTableSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataTableSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataTableSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataTableSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataTable.GetDataTableSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">An <see cref="T:System.Xml.Schema.XmlSchemaSet" /> instance.</param>
        <summary>This method returns an <see cref="T:System.Xml.Schema.XmlSchemaSet" /> instance containing the Web Services Description Language (WSDL) that describes the <see cref="T:System.Data.DataTable" /> for Web Services.</summary>
        <returns>The <see cref="T:System.Xml.Schema.XmlSchemaSet" /> instance.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetErrors">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] GetErrors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] GetErrors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetErrors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetErrors () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ GetErrors();" />
      <MemberSignature Language="F#" Value="member this.GetErrors : unit -&gt; System.Data.DataRow[]" Usage="dataTable.GetErrors " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets an array of <see cref="T:System.Data.DataRow" /> objects that contain errors.</summary>
        <returns>An array of <see cref="T:System.Data.DataRow" /> objects that have errors.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回具有 <xref:System.Data.DataRow> 集的 <xref:System.Data.DataRow.RowError%2A> 对象的列表。 例如，错误可能会导致在调用时<xref:System.Data.Common.DataAdapter.Update%2A>与<xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>设置为**true**。 不要对 <xref:System.Data.DataTable.AcceptChanges%2A> 调用 <xref:System.Data.DataTable>，直到您解决所有错误并重新提交 <xref:System.Data.DataSet> 以供更新。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Data.DataTable.GetErrors%2A>方法返回的数组<xref:System.Data.DataRow>具有错误的对象。  
  
 [!code-csharp[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.HasErrors" />
        <altmember cref="P:System.Data.DataRow.RowError" />
        <altmember cref="M:System.Data.DataRow.SetColumnError(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataTable.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that holds the serialized data associated with the <see cref="T:System.Data.DataTable" />.</param>
        <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> object that contains the source and destination of the serialized stream associated with the <see cref="T:System.Data.DataTable" />.</param>
        <summary>Populates a serialization information object with the data needed to serialize the <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is a null reference (<see langword="Nothing" /> in Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRowType">
      <MemberSignature Language="C#" Value="protected virtual Type GetRowType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetRowType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetRowType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRowType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetRowType();" />
      <MemberSignature Language="F#" Value="abstract member GetRowType : unit -&gt; Type&#xA;override this.GetRowType : unit -&gt; Type" Usage="dataTable.GetRowType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the row type.</summary>
        <returns>Returns the type of the <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetSchema" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchema () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchema();" />
      <MemberSignature Language="F#" Value="abstract member GetSchema : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchema : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataTable.GetSchema " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>For a description of this member, see <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>An <see cref="T:System.Xml.Schema.XmlSchema" /> that describes the XML representation of the object that is produced by the <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> method and consumed by the <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> method.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataTable.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether there are errors in any of the rows in any of the tables of the <see cref="T:System.Data.DataSet" /> to which the table belongs.</summary>
        <value>
          <see langword="true" /> 如果存在错误;否则为<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户在数据中包含一组工作<xref:System.Data.DataTable>，如果更改会导致某些验证失败，可以将标记每个更改与错误的更改。 你可以将标记整个<xref:System.Data.DataRow>与错误消息使用<xref:System.Data.DataRow.RowError%2A>属性。 此外可以在每个列具有的行上设置错误<xref:System.Data.DataRow.SetColumnError%2A>方法。  
  
 更新数据源之前， <xref:System.Data.DataSet>，建议你首先调用<xref:System.Data.DataSet.GetChanges%2A>方法在目标上的<xref:System.Data.DataSet>。 该方法将产生<xref:System.Data.DataSet>包含仅与原始所做的更改。 在发送之前<xref:System.Data.DataSet>到更新的数据源，请检查<xref:System.Data.DataTable.HasErrors%2A>的每个表以查看任何错误是否已附加到的行或行中的列的属性。  
  
 协调的每个错误之后, 清除的错误<xref:System.Data.DataRow.ClearErrors%2A>方法`DataRow`。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Data.DataTable.HasErrors%2A>属性检查表是否包含错误。  
  
 [!code-csharp[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.GetErrors" />
      </Docs>
    </Member>
    <Member MemberName="ImportRow">
      <MemberSignature Language="C#" Value="public void ImportRow (System.Data.DataRow row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ImportRow(class System.Data.DataRow row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ImportRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ImportRow (row As DataRow)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ImportRow(System::Data::DataRow ^ row);" />
      <MemberSignature Language="F#" Value="member this.ImportRow : System.Data.DataRow -&gt; unit" Usage="dataTable.ImportRow row" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="row">The <see cref="T:System.Data.DataRow" /> to be imported.</param>
        <summary>Copies a <see cref="T:System.Data.DataRow" /> into a <see cref="T:System.Data.DataTable" />, preserving any property settings, as well as original and current values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用<xref:System.Data.DataTable.NewRow%2A>将行添加到表使用现有的表架构，但使用的行，默认值并设置<xref:System.Data.DataRowState>到`Detached`。 调用<xref:System.Data.DataTable.ImportRow%2A>保留现有<xref:System.Data.DataRowState>以及行中的其他值。 如果`DataRow`传递当参数处于 detached 状态时，它将被忽略，但不会引发异常。  
  
 新行将添加到数据表的末尾。  
  
 如果新行与它不会添加到数据表约束冲突。  
  
 你可以获取具有 DataTable.Rows.Find 以及 DataTable.Rows.IndexOf 的新行的索引。 有关更多信息，请参见<xref:System.Data.DataRowCollection>和<xref:System.Data.DataTable.Rows%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after the <see cref="T:System.Data.DataTable" /> is initialized.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅<xref:System.Data.DataTable.IsInitialized%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataTable.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Data.DataTable" /> is initialized.</summary>
        <value>
          <see langword="true" /> 指示组件已完成初始化;否则为<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的状态<xref:System.Data.DataTable>时它正在构造，例如 Visual Studio。 <xref:System.Data.DataTable.BeginInit%2A>方法将其设置为`false`和<xref:System.Data.DataTable.EndInit%2A>方法将其设置为`true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fills a <see cref="T:System.Data.DataTable" /> with values from a data source using the supplied <see cref="T:System.Data.IDataReader" />. If the <see langword="DataTable" /> already contains rows, the incoming data from the data source is merged with the existing rows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load`方法可在几种常见情况，都围绕着从指定的数据源获取数据并将其添加到当前的数据容器 (在这种情况下， `DataTable`)。 以下方案说明的标准用法`DataTable`、 描述其更新和合并行为。  
  
 A`DataTable`同步或更新与单个主数据源。 `DataTable`跟踪更改，以实现与主数据源同步。 此外，`DataTable`可以接受来自一个或多个辅助数据源的增量数据。 `DataTable`不负责跟踪更改，以便允许与辅助数据源同步。  
  
 提供这些两个假设数据源，用户很可能需要的以下行为之一：  
  
-   初始化`DataTable`从主数据源。 在此方案中，用户想要初始化一个空`DataTable`与主数据源中的值。 更高版本，用户想要将更改传播回主数据源。  
  
-   保留更改，并从主数据源重新同步。 在此方案中，用户想要采用`DataTable`填充在前面的方案和执行增量同步使用主数据源，保留中所做修改`DataTable`。  
  
-   增量数据馈送从辅助数据源。 在此方案中，用户想从一个或多个辅助数据源的更改，并将合并这些将更改传播回主数据源。  
  
 `Load`方法使所有这些方案成为可能。 所有但一个作为参数的重载此方法允许您指定的负载选项参数，指示如何中的现有行<xref:System.Data.DataTable>结合正在加载的行。 （不允许你指定的行为的重载使用默认加载选项。）下表描述了由提供的三个负载选项<xref:System.Data.LoadOption>枚举。 每种情况下，说明该值传入数据中的行的主键值匹配的现有行的主键时，指示的行为。  
  
|加载选项|描述|  
|-----------------|-----------------|  
|`PreserveChanges`（默认值）|使用传入的行的值更新行的原始版本。|  
|`OverwriteChanges`|使用传入的行的值更新行的当前和原始版本。|  
|`Upsert`|使用传入的行的值更新行的当前版本。|  
  
 一般情况下，`PreserveChanges`和`OverwriteChanges`选项适用于用户需要将同步的情形`DataSet`及其更改与主数据源。 `Upsert`选项可帮助聚合来自一个或多个辅助数据源的更改。  
  
   
  
## Examples  
 下面的示例演示了一些调用所涉及的问题<xref:System.Data.DataTable.Load%2A>方法。 首先，该示例侧重于架构问题，包括从加载推断架构<xref:System.Data.IDataReader>，然后处理不兼容的架构和架构具有列缺失或其他列。 然后，该示例着重于数据问题，包括处理各种的加载选项。  
  
> [!NOTE]
>  此示例演示如何使用的重载版本之一`Load`。 有关可能会提供其他示例，请参阅各个重载主题。  
  
 [!code-csharp[DataWorks DataTableLoad#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.Load" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (reader As IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader -&gt; unit" Usage="dataTable.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">An <see cref="T:System.Data.IDataReader" /> that provides a result set.</param>
        <summary>Fills a <see cref="T:System.Data.DataTable" /> with values from a data source using the supplied <see cref="T:System.Data.IDataReader" />. If the <see cref="T:System.Data.DataTable" /> already contains rows, the incoming data from the data source is merged with the existing rows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A>方法使用的第一个结果集加载<xref:System.Data.IDataReader>，并成功完成后，将读取器的位置设置为下一个结果集，如果有的话。 转换数据时，`Load`方法使用相同的转换规则<xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType>方法。  
  
 <xref:System.Data.DataTable.Load%2A>方法必须考虑三个特定问题时加载的数据从<xref:System.Data.IDataReader>实例： 架构、 数据和事件的操作。 使用架构时,<xref:System.Data.DataTable.Load%2A>方法可能会遇到条件下表中所述。 架构操作发生的所有导入的结果集，甚至那些不包含任何数据。  
  
|条件|行为|  
|---------------|--------------|  
|<xref:System.Data.DataTable>没有架构。|<xref:System.Data.DataTable.Load%2A>方法推理基于来自导入的结果集架构<xref:System.Data.IDataReader>。|  
|<xref:System.Data.DataTable>拥有的架构，但它与加载的架构不兼容。|<xref:System.Data.DataTable.Load%2A>方法引发异常对应于试图将数据加载到不兼容的架构时发生的特定错误。|  
|架构是兼容，但加载的结果集架构包含中不存在的列<xref:System.Data.DataTable>。|<xref:System.Data.DataTable.Load%2A>方法将添加的额外列`DataTable`的架构。 该方法将引发异常，如果对应中的列<xref:System.Data.DataTable>和加载的结果集不兼容的值。 该方法还会从结果集中为所有添加的列检索约束信息。 仅当除外 Primary Key 约束的情况下，使用此约束信息当前<xref:System.Data.DataTable>不包含在启动时加载操作的任何列。|  
|架构是兼容，但加载的结果集架构包含较少的列比`DataTable`。|如果缺少列已定义的默认值或列的数据类型可以为 null，<xref:System.Data.DataTable.Load%2A>方法允许要添加的行替换为默认值或`null`缺少的列的值。 如果没有默认值或`null`可以使用，则`Load`方法引发异常。 如果已不提供任何特定的默认值，`Load`方法使用`null`默示的默认值的值。|  
  
 在考虑的行为之前`Load`方法根据数据操作，请考虑，每个行内<xref:System.Data.DataTable>维护的当前值和每个列的原始值。 这些值可能相同，或如果后填充发生了更改的行中的数据可能不同`DataTable`。  有关详细信息，请参阅[行状态和行版本](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)。  
  
 此版本的`Load`方法会尝试保留的每一行，保持不变的原始值中的当前值。 (如果你想更好地控制传入数据的行为，请参阅<xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType>。)如果现有行和传入行将包含相应的主键值，则使用其当前的行状态值处理行，否则它将被视为新行。  
  
 在事件操作方面<xref:System.Data.DataTable.RowChanging>事件发生之前更改每个行，与<xref:System.Data.DataTable.RowChanged>事件发生在每个行已更改之后。 在每个情况下，<xref:System.Data.DataRowChangeEventArgs.Action%2A>属性<xref:System.Data.DataRowChangeEventArgs>传递给事件处理程序的实例包含有关与事件关联的特定操作的信息。 此操作的值取决于行之前加载操作的状态。 在每个情况下，这两个事件发生，且操作为每个相同。 操作可以应用于当前或原始版本的每一行，或两者，具体取决于当前的行状态。  
  
 下表显示了行为`Load`方法。 最终 （标记为"（不提供）"） 的行所说明的行为传入不匹配任何现有行的行。 此表中的每个单元格连同描述行中的字段的当前和原始值<xref:System.Data.DataRowState>后的值为`Load`方法已完成。 在这种情况下，该方法不允许你以指示加载选项，并使用默认值， `PreserveChanges`。  
  
|现有 DataRowState|之后的值`Load`方法和事件操作|  
|---------------------------|--------------------------------------------------|  
|已添加|当前 =\<现有 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改原始值|  
|修改时间|当前 =\<现有 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改原始值|  
|Deleted|当前 =\<不可用 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<删除 ><br /><br /> 行操作 = 更改原始值|  
|Unchanged|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|  
|（不提供）|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|  
  
 中的值<xref:System.Data.DataColumn>可以如约束通过使用属性<xref:System.Data.DataColumn.ReadOnly%2A>和<xref:System.Data.DataColumn.AutoIncrement%2A>。 `Load`方法可处理此类列与列的属性定义的行为一致的方式。 上的只读的约束<xref:System.Data.DataColumn>仅适用于在内存中发生更改。 `Load`方法的覆盖的只读的列的值，如果需要。  
  
 若要确定哪个版本的用于比较的传入行具有的当前行的主键字段`Load`方法使用行中的主键值的原始版本，如果它存在。 否则为`Load`方法使用当前版本的主键字段。  
  
   
  
## Examples  
 下面的示例演示了一些调用所涉及的问题<xref:System.Data.DataTable.Load%2A>方法。 首先，该示例侧重于架构问题，包括从加载推断架构<xref:System.Data.IDataReader>，然后处理不兼容的架构和架构具有列缺失或其他列。 该示例然后调用`Load`方法，显示的数据之前和之后加载操作。  
  
 [!code-csharp[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption -&gt; unit" Usage="dataTable.Load (reader, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="reader">An <see cref="T:System.Data.IDataReader" /> that provides one or more result sets.</param>
        <param name="loadOption">A value from the <see cref="T:System.Data.LoadOption" /> enumeration that indicates how rows already in the <see cref="T:System.Data.DataTable" /> are combined with incoming rows that share the same primary key.</param>
        <summary>Fills a <see cref="T:System.Data.DataTable" /> with values from a data source using the supplied <see cref="T:System.Data.IDataReader" />. If the <see langword="DataTable" /> already contains rows, the incoming data from the data source is merged with the existing rows according to the value of the <paramref name="loadOption" /> parameter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load`方法使用的第一个结果集加载<xref:System.Data.IDataReader>，并成功完成后，将读取器的位置设置为下一个结果集，如果有的话。 转换数据时，`Load`方法使用相同的转换规则<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法。  
  
 `Load`方法必须考虑三个特定问题时加载的数据从<xref:System.Data.IDataReader>实例： 架构、 数据和事件的操作。 使用架构时,`Load`方法可能会遇到条件下表中所述。 架构操作发生的所有导入的结果集，甚至那些不包含任何数据。  
  
|条件|行为|  
|---------------|--------------|  
|<xref:System.Data.DataTable>没有架构。|`Load`方法推理基于来自导入的结果集架构<xref:System.Data.IDataReader>。|  
|<xref:System.Data.DataTable>拥有的架构，但它与加载的架构不兼容。|`Load`方法引发异常对应于试图将数据加载到不兼容的架构时发生的特定错误。|  
|架构是兼容，但加载的结果集架构包含在中不存在的列`DataTable`。|`Load`方法将添加的额外列`DataTable`的架构。 该方法将引发异常，如果对应中的列<xref:System.Data.DataTable>和加载的结果集不兼容的值。 该方法还会从结果集中为所有添加的列检索约束信息。 仅当除外 Primary Key 约束的情况下，使用此约束信息当前<xref:System.Data.DataTable>不包含在启动时加载操作的任何列。|  
|架构是兼容，但加载的结果集架构包含较少的列比`DataTable`。|如果缺少列已定义的默认值或列的数据类型可以为 null，`Load`方法允许要添加的行替换缺少的列的默认值或 null 值。 如果可以使用任何默认值或 null，则`Load`方法引发异常。 如果已不提供任何特定的默认值，`Load`方法使用隐含的默认值为 null 的值。|  
  
 在考虑的行为之前`Load`方法根据数据操作，请考虑，每个行内<xref:System.Data.DataTable>维护的当前值和每个列的原始值。 这些值可能相同，或如果后填充发生了更改的行中的数据可能不同`DataTable`。 请参阅[行状态和行版本](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)有关详细信息。  
  
 在此方法调用中，指定<xref:System.Data.LoadOption>参数影响的传入数据的处理。 Load 方法应如何处理具有相同的主键作为现有行的加载行？ 它应修改当前值和 / 或原始值？ 这些问题，和的详细信息，由控制`loadOption`参数。  
  
 如果现有行和传入行将包含相应的主键值，则使用其当前的行状态值处理行，否则它将被视为新行。  
  
 在事件操作方面<xref:System.Data.DataTable.RowChanging>事件发生之前更改每个行，与<xref:System.Data.DataTable.RowChanged>事件发生在每个行已更改之后。 在每个情况下，<xref:System.Data.DataRowChangeEventArgs.Action%2A>属性<xref:System.Data.DataRowChangeEventArgs>传递给事件处理程序的实例包含有关与事件关联的特定操作的信息。 此操作值都不同，具体取决于行之前加载操作的状态。 在每个情况下，这两个事件发生，且操作为每个相同。 操作可以应用于当前或原始版本的每一行，或两者，具体取决于当前的行状态。  
  
 下表显示负载方法调用每个时的行为`LoadOption`值，并显示如何与正在加载的行的行状态进行交互的值。 最终 （标记为"（不提供）"） 的行所说明的行为传入不匹配任何现有行的行。 此表中的每个单元格连同描述行中的字段的当前和原始值<xref:System.Data.DataRowState>后的值为`Load`方法已完成。  
  
|现有 DataRowState|Upsert|OverwriteChanges|PreserveChanges （默认行为）|  
|---------------------------|------------|----------------------|------------------------------------------|  
|已添加|当前 =\<传入 ><br /><br /> 原始 =-\<不可用 ><br /><br /> 状态 =\<添加 ><br /><br /> 行操作 = 更改|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<现有 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改原始值|  
|修改时间|当前 =\<传入 ><br /><br /> 原始 =\<现有 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<现有 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改原始值|  
eleted|（负载进行不影响删除的行）<br /><br /> 当前 =--<br /><br /> 原始 =\<现有 ><br /><br /> 状态 =\<删除 ><br /><br /> （新行添加具有下列特性）<br /><br /> 当前 =\<传入 ><br /><br /> 原始 =\<不可用 ><br /><br /> 状态 =\<添加 ><br /><br /> 行操作 = 添加|撤消删除和<br /><br /> 当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<不可用 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<删除 ><br /><br /> 行操作 = 更改原始值|  
|Unchanged|当前 =\<传入 ><br /><br /> 原始 =\<现有 ><br /><br /> 如果新值为与现有的值相同，则<br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = Nothing<br /><br /> Else<br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|  
不存在）|当前 =\<传入 ><br /><br /> 原始 =\<不可用 ><br /><br /> 状态 =\<添加 ><br /><br /> 行操作 = 添加|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|  
  
 中的值<xref:System.Data.DataColumn>可以如约束通过使用属性<xref:System.Data.DataColumn.ReadOnly%2A>和<xref:System.Data.DataColumn.AutoIncrement%2A>。 `Load`方法可处理此类列与列的属性定义的行为一致的方式。 上的只读的约束<xref:System.Data.DataColumn>仅适用于在内存中发生更改。 `Load`方法的覆盖的只读的列的值，如果需要。  
  
 在调用时指定的 OverwriteChanges 或 PreserveChanges 选项`Load`来自传入的数据进行的方法，则假定`DataTable`的主数据源和数据表跟踪更改，可以将传播所做的更改回数据源。 如果选择 Upsert 选项，则假定数据来自其中一个的辅助数据源，如由一个中间层组件，可能是由用户更改提供的数据。 在这种情况下，假设条件是从一个或多个数据源中的意图是对数据进行聚合`DataTable`，然后可能将传播回主数据源的数据。 <xref:System.Data.LoadOption>参数用于确定要使用主键比较行的特定版本。 下表提供了详细信息。  
  
|加载选项|使用主键比较 DataRow 版本|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|原始版本，如果它存在，否则为当前版本|  
|`PreserveChanges`|原始版本，如果它存在，否则为当前版本|  
|`Upsert`|当前版本，如果它存在，否则为原始版本|  
  
   
  
## Examples  
 下面的示例演示了一些调用所涉及的问题<xref:System.Data.DataTable.Load%2A>方法。 首先，该示例侧重于架构问题，包括从加载推断架构<xref:System.Data.IDataReader>，然后处理不兼容的架构和架构具有列缺失或其他列。 然后，该示例着重于数据问题，包括处理各种的加载选项。  
  
 [!code-csharp[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit" Usage="dataTable.Load (reader, loadOption, errorHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
      </Parameters>
      <Docs>
        <param name="reader">A <see cref="T:System.Data.IDataReader" /> that provides a result set.</param>
        <param name="loadOption">A value from the <see cref="T:System.Data.LoadOption" /> enumeration that indicates how rows already in the <see cref="T:System.Data.DataTable" /> are combined with incoming rows that share the same primary key.</param>
        <param name="errorHandler">A <see cref="T:System.Data.FillErrorEventHandler" /> delegate to call when an error occurs while loading data.</param>
        <summary>Fills a <see cref="T:System.Data.DataTable" /> with values from a data source using the supplied <see cref="T:System.Data.IDataReader" /> using an error-handling delegate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load`方法使用的第一个结果集加载<xref:System.Data.IDataReader>，并成功完成后，将读取器的位置设置为下一个结果集，如果有的话。 转换数据时，`Load`方法使用相同的转换规则<xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType>方法。  
  
 `Load`方法必须考虑三个特定问题时加载的数据从<xref:System.Data.IDataReader>实例： 架构、 数据和事件的操作。 使用架构时,`Load`方法可能会遇到条件下表中所述。 架构操作发生的所有导入的结果集，甚至那些不包含任何数据。  
  
|条件|行为|  
|---------------|--------------|  
|<xref:System.Data.DataTable>没有架构。|`Load`方法推理基于来自导入的结果集架构<xref:System.Data.IDataReader>。|  
|<xref:System.Data.DataTable>拥有的架构，但它与加载的架构不兼容。|`Load`方法引发异常对应于试图将数据加载到不兼容的架构时发生的特定错误。|  
|架构是兼容，但加载的结果集架构包含在中不存在的列`DataTable`。|`Load`方法将添加到的额外列`DataTable`的架构。 该方法将引发异常，如果对应中的列<xref:System.Data.DataTable>和加载的结果集不兼容的值。 该方法还会从结果集中为所有添加的列检索约束信息。 仅当除外 Primary Key 约束的情况下，使用此约束信息当前<xref:System.Data.DataTable>不包含在启动时加载操作的任何列。|  
|架构是兼容，但加载的结果集架构包含较少的列比`DataTable`。|如果缺少列已定义的默认值或列的数据类型可以为 null，`Load`方法允许要添加的行替换缺少的列的默认值或 null 值。 如果可以使用任何默认值或 null，则`Load`方法引发异常。 如果已不提供任何特定的默认值，`Load`方法使用隐含的默认值为 null 的值。|  
  
 在考虑的行为之前`Load`方法根据数据操作，请考虑，每个行内<xref:System.Data.DataTable>维护的当前值和每个列的原始值。 这些值可能相同，或如果后填充发生了更改的行中的数据可能不同`DataTable`。 请参阅[行状态和行版本](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)有关详细信息。  
  
 在此方法调用中，指定<xref:System.Data.LoadOption>参数影响的传入数据的处理。 Load 方法应如何处理具有相同的主键作为现有行的加载行？ 它应修改当前值和 / 或原始值？ 这些问题，和的详细信息，由控制`loadOption`参数。  
  
 如果现有行和传入行将包含相应的主键值，则使用其当前的行状态值处理行，否则它将被视为新行。  
  
 在事件操作方面<xref:System.Data.DataTable.RowChanging>事件发生之前更改每个行，与<xref:System.Data.DataTable.RowChanged>事件发生在每个行已更改之后。 在每个情况下，<xref:System.Data.DataRowChangeEventArgs.Action%2A>属性<xref:System.Data.DataRowChangeEventArgs>传递给事件处理程序的实例包含有关与事件关联的特定操作的信息。 此操作值都不同，具体取决于行之前加载操作的状态。 在每个情况下，这两个事件发生，且操作为每个相同。 操作可以应用于当前或原始版本的每一行，或两者，具体取决于当前的行状态。  
  
 下表显示负载方法调用每个时的行为`LoadOption`值，并显示如何与正在加载的行的行状态进行交互的值。 最终 （标记为"（不提供）"） 的行所说明的行为传入不匹配任何现有行的行。 此表中的每个单元格连同描述行中的字段的当前和原始值<xref:System.Data.DataRowState>后的值为`Load`方法已完成。  
  
|现有 DataRowState|Upsert|OverwriteChanges|PreserveChanges （默认行为）|  
|---------------------------|------------|----------------------|------------------------------------------|  
|已添加|当前 =\<传入 ><br /><br /> 原始 =-\<不可用 ><br /><br /> 状态 =\<添加 ><br /><br /> 行操作 = 更改|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<现有 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改原始值|  
|修改时间|当前 =\<传入 ><br /><br /> 原始 =\<现有 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<现有 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改原始值|  
eleted|（负载进行不影响删除的行）<br /><br /> 当前 =--<br /><br /> 原始 =\<现有 ><br /><br /> 状态 =\<删除 ><br /><br /> （新行添加具有下列特性）<br /><br /> 当前 =\<传入 ><br /><br /> 原始 =\<不可用 ><br /><br /> 状态 =\<添加 ><br /><br /> 行操作 = 添加|撤消删除和<br /><br /> 当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<不可用 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<删除 ><br /><br /> 行操作 = 更改原始值|  
|Unchanged|当前 =\<传入 ><br /><br /> 原始 =\<现有 ><br /><br /> 如果新值为与现有的值相同，则<br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = Nothing<br /><br /> Else<br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|  
不存在）|当前 =\<传入 ><br /><br /> 原始 =\<不可用 ><br /><br /> 状态 =\<添加 ><br /><br /> 行操作 = 添加|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<不变 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|  
  
 中的值<xref:System.Data.DataColumn>可以如约束通过使用属性<xref:System.Data.DataColumn.ReadOnly%2A>和<xref:System.Data.DataColumn.AutoIncrement%2A>。 `Load`方法可处理此类列与列的属性定义的行为一致的方式。 上的只读的约束<xref:System.Data.DataColumn>仅适用于在内存中发生更改。 `Load`方法的覆盖的只读的列的值，如果需要。  
  
 在调用时指定的 OverwriteChanges 或 PreserveChanges 选项`Load`来自传入的数据进行的方法，则假定`DataTable`的主数据源和数据表跟踪更改，可以将传播所做的更改回数据源。 如果选择 Upsert 选项，则假定数据来自其中一个的辅助数据源，如由一个中间层组件，可能是由用户更改提供的数据。 在这种情况下，假设条件是从一个或多个数据源中的意图是对数据进行聚合`DataTable`，然后可能将传播回主数据源的数据。 <xref:System.Data.LoadOption>参数用于确定要使用主键比较行的特定版本。 下表提供了详细信息。  
  
|加载选项|使用主键比较 DataRow 版本|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|原始版本，如果它存在，否则为当前版本|  
|`PreserveChanges`|原始版本，如果它存在，否则为当前版本|  
|`Upsert`|当前版本，如果它存在，否则为原始版本|  
  
 `errorHandler`参数是<xref:System.Data.FillErrorEventHandler>指将数据加载过程中发生错误时调用的过程的委托。 <xref:System.Data.FillErrorEventArgs>传递给过程的参数提供的属性，使您得以检索有关错误的发生，而当前行的数据，信息和<xref:System.Data.DataTable>填充的。 使用此委托机制，而不是更简单的 try/catch 块，可以确定该错误，处理这种情况，并继续如果愿意处理。 <xref:System.Data.FillErrorEventArgs>参数提供<xref:System.Data.FillErrorEventArgs.Continue%2A>属性： 将此属性设置为`true`以指示你已处理错误，并且希望继续进行处理。 将属性设置为`false`以指示你想要停止处理。 请注意，将属性设置为`false`导致触发要引发异常的问题的代码。  
  
   
  
## Examples  
 [!code-csharp[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadDataRow">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Finds and updates a specific row. If no matching row is found, a new row is created using the given values.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, bool fAcceptChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, bool fAcceptChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadDataRow (values As Object(), fAcceptChanges As Boolean) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, bool fAcceptChanges);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * bool -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, fAcceptChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="fAcceptChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="values">An array of values used to create the new row.</param>
        <param name="fAcceptChanges">
          <see langword="true" /> to accept changes; otherwise <see langword="false" />.</param>
        <summary>Finds and updates a specific row. If no matching row is found, a new row is created using the given values.</summary>
        <returns>The new <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.LoadDataRow%2A>方法接受的值的数组，并在主键列中查找匹配的值。  
  
 如果列具有默认值，请设置该列的默认值数组中传递 null 值。 同样，如果某一列具有其<xref:System.Data.DataColumn.AutoIncrement%2A>属性设置为 true，则要设置行自动生成的值的数组中传递 null 值。  
  
 如果`fAcceptChanges`参数是`true`或未指定，将添加新数据，然后<xref:System.Data.DataTable.AcceptChanges%2A>调用以接受中的所有更改<xref:System.Data.DataTable>; 如果参数是`false`，新添加的行标记为插入、 和到的更改现有行被标记为修改。  
  
 也可在发生异常<xref:System.Data.DataTable.ColumnChanging>或<xref:System.Data.DataTable.RowChanging>事件。 如果发生异常，则行未添加到表中。  
  
 使用<xref:System.Data.DataTable.LoadDataRow%2A>结合<xref:System.Data.DataTable.BeginLoadData%2A>和<xref:System.Data.DataTable.EndLoadData%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Data.DataTable.LoadDataRow%2A>方法来尝试查找行。 如果未不找到任何此类行，这些值用于创建新行。  
  
 [!code-csharp[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The array is larger than the number of columns in the table.</exception>
        <exception cref="T:System.InvalidCastException">A value doesn't match its respective column type.</exception>
        <exception cref="T:System.Data.ConstraintException">Adding the row invalidates a constraint.</exception>
        <exception cref="T:System.Data.NoNullAllowedException">Attempting to put a null in a column where <see cref="P:System.Data.DataColumn.AllowDBNull" /> is false.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * System.Data.LoadOption -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="values">An array of values used to create the new row.</param>
        <param name="loadOption">Used to determine how the array values are applied to the corresponding values in an existing row.</param>
        <summary>Finds and updates a specific row. If no matching row is found, a new row is created using the given values.</summary>
        <returns>The new <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.LoadDataRow%2A>方法接受的值的数组，并在主键列中查找匹配的值。  
  
 如果列具有默认值，请设置该列的默认值数组中传递 null 值。 同样，如果某一列具有其<xref:System.Data.DataColumn.AutoIncrement%2A>属性设置为 true，则要设置行自动生成的值的数组中传递 null 值。  
  
 值`loadOption`参数用于确定如何将数组中的值应用于现有行。 例如，如果`loadOption`设置为`OverwriteChanges`、`Original`和`Current`的每个列的值将替换中的传入行的值与`RowState`属性设置为`Unchanged`。  
  
 也可在发生异常<xref:System.Data.DataTable.ColumnChanging>或<xref:System.Data.DataTable.RowChanging>事件。 如果发生异常，则行未添加到表中。  
  
 使用<xref:System.Data.DataTable.LoadDataRow%2A>结合<xref:System.Data.DataTable.BeginLoadData%2A>和<xref:System.Data.DataTable.EndLoadData%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataTable.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the locale information used to compare strings within the table.</summary>
        <value>A<see cref="T:System.Globalization.CultureInfo" />包含有关用户的计算机的区域设置的数据。 默认值是<see cref="T:System.Data.DataSet" />对象的<see cref="T:System.Globalization.CultureInfo" />(返回<see cref="P:System.Data.DataSet.Locale" />属性) 到<see cref="T:System.Data.DataTable" />所属; 如果表不属于<see cref="T:System.Data.DataSet" />，默认值是当前系统<see cref="T:System.Globalization.CultureInfo" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Globalization.CultureInfo>表示特定区域性或社区的软件首选项。  
  
 用于字符串比较时<xref:System.Globalization.CultureInfo>影响排序比较，以及进行筛选。  
  
> [!NOTE]
>  包含表达式，列中<xref:System.StringComparison.InvariantCulture>使用。 <xref:System.StringComparison.CurrentCulture>将被忽略。  
  
   
  
## Examples  
 下面的示例设置<xref:System.Globalization.CultureInfo>通过<xref:System.Data.DataTable.Locale%2A>，并输出 ISO 语言名称。  
  
 [!code-csharp[Classic WebData DataTable.Locale Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Merge the specified <see cref="T:System.Data.DataTable" /> with the current <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Merge`方法用于合并两个<xref:System.Data.DataTable>有很大程度上类似的架构的对象。 合并通常用于对客户端应用程序，以将数据源的最新的更改合并到现有<xref:System.Data.DataTable>。 这允许客户端应用程序具有刷新<xref:System.Data.DataTable>使用数据源的最新的数据。  
  
 仅对原始表和表要合并，则合并操作将考虑在内。 不受影响或包含子表。 如果表具有一个或多个定义的一种关系，一部分的子表必须单独合并每个子表。  
  
   
  
## Examples  
 以下控制台应用程序演示的行为`missingSchemaAction`参数<xref:System.Data.DataTable.Merge%2A>方法。 此示例创建两个版本的同一个表，修改的第二个版本的架构。 然后，代码尝试将第二个表合并到第一个。  
  
> [!NOTE]
>  此示例演示如何使用合并的重载版本之一。 有关可能会提供其他示例，请参阅各个重载主题。  
  
 [!code-csharp[DataWorks DataTableMergeOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableMergeOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataTable.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">The <see cref="T:System.Data.DataTable" /> to be merged with the current <see cref="T:System.Data.DataTable" />.</param>
        <summary>Merge the specified <see cref="T:System.Data.DataTable" /> with the current <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Merge 方法用于合并两个<xref:System.Data.DataTable>有很大程度上类似的架构的对象。 合并通常用于对客户端应用程序，以将数据源的最新的更改合并到现有<xref:System.Data.DataTable>。 这允许客户端应用程序具有刷新<xref:System.Data.DataTable>使用数据源的最新的数据。  
  
 仅对原始表和表要合并，则合并操作将考虑在内。 不受影响或包含子表。 如果表具有一个或多个定义的一种关系，一部分的子表必须单独合并每个子表。  
  
 `Merge`方法通常称为涉及验证更改、 协调错误、 与所做的更改，更新数据源和最后刷新现有的过程的一系列末尾<xref:System.Data.DataTable>。  
  
 当执行合并时，在合并前的现有数据所做的更改会在合并操作期间，保留默认情况下。 开发人员可以修改此行为通过其他两个重载之一调用此方法，并指定为返回值为 false`preserveChanges`参数。  
  
 在客户端应用程序，它是通常有一个按钮，用户可以单击它来收集已更改的数据并将其发送回中间层组件之前对它进行验证。 在此方案中，<xref:System.Data.DataTable.GetChanges%2A>第一次调用方法。 方法将返回第二个<xref:System.Data.DataTable>优化为验证和合并。 第二个<xref:System.Data.DataTable>对象只包含<xref:System.Data.DataRow>已更改，从而导致原始的子集的对象<xref:System.Data.DataTable>。 此子集通常较小，因此可以更有效地传递回中间层组件。 然后，中间层组件使用通过存储过程的更改更新原始数据源。 然后，中间层可以发送回一个新<xref:System.Data.DataTable>，包括原始数据和数据源的最新数据 （通过再次运行原始查询），或者它可以发送回包含从数据源对其进行任何更改的子集。 （例如，如果数据源会自动创建唯一的主键值，这些值可以将传播回客户端应用程序。）在任一情况下，返回<xref:System.Data.DataTable>必须合并回客户端应用程序的原始<xref:System.Data.DataTable>与<xref:System.Data.DataTable.Merge%2A>方法。  
  
 合并新的源时<xref:System.Data.DataTable>到目标中时，任何源行与<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`，与具有相同的主键值的目标行匹配。 源行<xref:System.Data.DataRowState>值`Added`具有相同作为新的源行的主键值的新目标行匹配。  
  
   
  
## Examples  
 以下控制台应用程序创建一个简单<xref:System.Data.DataTable>然后将数据添加到表。 然后，示例创建表，将行添加到复制的副本。 最后，该示例调用<xref:System.Data.DataTable.Merge%2A>方法合并第二个表中的第一个表中的数据的数据。  
  
 [!code-csharp[DataWorks DataTable.Merge#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.Merge#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable, preserveChanges As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool -&gt; unit" Usage="dataTable.Merge (table, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="table">The <see langword="DataTable" /> to be merged with the current <see langword="DataTable" />.</param>
        <param name="preserveChanges">
          <see langword="true" />, to preserve changes in the current <see langword="DataTable" />; otherwise <see langword="false" />.<see langword="" /></param>
        <summary>Merge the specified <see cref="T:System.Data.DataTable" /> with the current <see langword="DataTable" />, indicating whether to preserve changes in the current <see langword="DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Merge 方法用于合并两个<xref:System.Data.DataTable>有很大程度上类似的架构的对象。 合并通常用于对客户端应用程序，以将数据源的最新的更改合并到现有<xref:System.Data.DataTable>。 这允许客户端应用程序具有刷新<xref:System.Data.DataTable>使用数据源的最新的数据。  
  
 仅对原始表和表要合并，则合并操作将考虑在内。 不受影响或包含子表。 如果表具有一个或多个定义的一种关系，一部分的子表必须单独合并每个子表。  
  
 `Merge`方法通常称为涉及验证更改、 协调错误、 与所做的更改，更新数据源和最后刷新现有的过程的一系列末尾<xref:System.Data.DataTable>。  
  
 除非开发人员指定为 false 时执行合并时，在合并前的现有数据所做的更改合并操作过程中保留`preserveChanges`参数。 如果`preserveChanges`参数设置为`true`，传入值不会覆盖现有行的当前行版本中的现有值。 如果`preserveChanges`参数设置为`false`，传入值将覆盖现有行的当前行版本中的现有值。 有关行版本的详细信息，请参阅[行状态和行版本](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)。  
  
 在客户端应用程序，它是通常有一个按钮，用户可以单击它来收集已更改的数据并将其发送回中间层组件之前对它进行验证。 在此方案中，<xref:System.Data.DataTable.GetChanges%2A>第一次调用方法。 方法将返回第二个<xref:System.Data.DataTable>优化为验证和合并。 第二个<xref:System.Data.DataTable>对象只包含<xref:System.Data.DataTable>和<xref:System.Data.DataRow>已更改，从而导致原始的子集的对象<xref:System.Data.DataTable>。 此子集是通常较小，因此此子集更有效地传递回中间层组件。 然后，中间层组件使用通过存储过程的更改更新原始数据源。 然后，中间层可以发送回一个新<xref:System.Data.DataTable>，包括原始数据和数据源的最新数据 （通过再次运行原始查询），或者它可以发送回包含从数据源对其进行任何更改的子集。 （例如，如果数据源会自动创建唯一的主键值，这些值可以将传播回客户端应用程序。）在任一情况下，返回<xref:System.Data.DataTable>必须合并回客户端应用程序的原始<xref:System.Data.DataTable>与<xref:System.Data.DataTable.Merge%2A>方法。  
  
 合并新的源时<xref:System.Data.DataTable>到目标中时，任何源行与<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`与具有相同的主键值的目标行匹配。 源行<xref:System.Data.DataRowState>值`Added`具有相同作为新的源行的主键值的新目标行匹配。  
  
   
  
## Examples  
 以下控制台应用程序创建<xref:System.Data.DataTable>包含行，修改某些这些行中的数据并尝试合并来自不同数据<xref:System.Data.DataTable>。 此示例演示为不同的行为`preserveChanges`参数。  
  
 [!code-csharp[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataTable.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">The <see cref="T:System.Data.DataTable" /> to be merged with the current <see cref="T:System.Data.DataTable" />.</param>
        <param name="preserveChanges">
          <see langword="true" />, to preserve changes in the current <see cref="T:System.Data.DataTable" />; otherwise <see langword="false" />.</param>
        <param name="missingSchemaAction">One of the <see cref="T:System.Data.MissingSchemaAction" /> values.</param>
        <summary>Merge the specified <see cref="T:System.Data.DataTable" /> with the current <see langword="DataTable" />, indicating whether to preserve changes and how to handle missing schema in the current <see langword="DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Merge`方法用于合并两个<xref:System.Data.DataTable>有很大程度上类似的架构的对象。 合并通常用于对客户端应用程序，以将数据源的最新的更改合并到现有<xref:System.Data.DataTable>。 这允许客户端应用程序具有刷新<xref:System.Data.DataTable>使用数据源的最新的数据。  
  
 仅对原始表和表要合并，则合并操作将考虑在内。 不受影响或包含子表。 如果表具有一个或多个定义的一种关系，一部分的子表必须单独合并每个子表。  
  
 `Merge`方法通常称为涉及验证更改、 协调错误、 与所做的更改，更新数据源和最后刷新现有的过程的一系列末尾<xref:System.Data.DataTable>。  
  
 除非开发人员指定为 false 时执行合并时，在合并前的现有数据所做的更改合并操作过程中保留`preserveChanges`参数。 如果`preserveChanges`参数设置为`true`，传入值不会覆盖现有行的当前行版本中的现有值。 如果`preserveChanges`参数设置为`false`，传入值将覆盖现有行的当前行版本中的现有值。 有关行版本的详细信息，请参阅[行状态和行版本](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)。  
  
 在客户端应用程序，它是通常有一个按钮，用户可以单击它来收集已更改的数据并将其发送回中间层组件之前对它进行验证。 在此方案中，<xref:System.Data.DataTable.GetChanges%2A>第一次调用方法。 方法将返回第二个<xref:System.Data.DataTable>优化为验证和合并。 第二个<xref:System.Data.DataTable>对象只包含<xref:System.Data.DataTable>和<xref:System.Data.DataRow>已更改，从而导致原始的子集的对象<xref:System.Data.DataTable>。 此子集是通常较小，因此此子集更有效地传递回中间层组件。 然后，中间层组件使用通过存储过程的更改更新原始数据源。 然后，中间层可以发送回一个新<xref:System.Data.DataTable>，包括原始数据和数据源的最新数据 （通过再次运行原始查询），或者它可以发送回包含从数据源对其进行任何更改的子集。 （例如，如果数据源会自动创建唯一的主键值，这些值可以将传播回客户端应用程序。）在任一情况下，返回<xref:System.Data.DataTable>必须合并回客户端应用程序的原始<xref:System.Data.DataTable>与<xref:System.Data.DataTable.Merge%2A>方法。  
  
 当<xref:System.Data.DataTable.Merge%2A>调用方法时，这两个架构<xref:System.Data.DataTable>对象进行比较，因为它是可能的架构可能已更改。 例如，在企业到企业方案中，新列可能已被添加到 XML 架构一个自动化过程。 如果源<xref:System.Data.DataTable>包含架构元素 (添加<xref:System.Data.DataColumn>对象) 缺少目标中，通过设置，可以将架构元素添加到目标`missingSchemaAction`参数`MissingSchemaAction.Add`。 在这种情况下，合并<xref:System.Data.DataTable>包含添加的架构和数据。  
  
 合并后的架构，则数据将合并。  
  
 合并新的源时<xref:System.Data.DataTable>到目标中时，任何源行与<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`与具有相同的主键值的目标行匹配。 源行<xref:System.Data.DataRowState>值`Added`具有相同作为新的源行的主键值的新目标行匹配。  
  
   
  
## Examples  
 以下控制台应用程序演示的行为`missingSchemaAction`参数<xref:System.Data.DataTable.Merge%2A>方法。 此示例创建两个版本的同一个表，修改的第二个版本的架构。 然后，代码尝试将第二个表合并到第一个。  
  
 [!code-csharp[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumCapacity">
      <MemberSignature Language="C#" Value="public int MinimumCapacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.MinimumCapacity" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimumCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumCapacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumCapacity : int with get, set" Usage="System.Data.DataTable.MinimumCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(50)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the initial starting size for this table.</summary>
        <value>在此表的行中初始起始大小。 默认值为 50。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.MinimumCapacity%2A>允许系统在读取数据之前创建一组适当的资源。 在这种情况时性能非常重要，设置此属性可优化性能。  
  
   
  
## Examples  
 下面的示例设置<xref:System.Data.DataTable.MinimumCapacity%2A>的<xref:System.Data.DataTable>。  
  
 [!code-csharp[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataTable.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the namespace for the XML representation of the data stored in the <see cref="T:System.Data.DataTable" />.</summary>
        <value>
          <see cref="T:System.Data.DataTable" /> 的命名空间。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow NewRow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow NewRow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRow" />
      <MemberSignature Language="VB.NET" Value="Public Function NewRow () As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ NewRow();" />
      <MemberSignature Language="F#" Value="member this.NewRow : unit -&gt; System.Data.DataRow" Usage="dataTable.NewRow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new <see cref="T:System.Data.DataRow" /> with the same schema as the table.</summary>
        <returns>A <see cref="T:System.Data.DataRow" /> with the same schema as the <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须使用<xref:System.Data.DataTable.NewRow%2A>方法来创建新<xref:System.Data.DataRow>具有相同的架构对象<xref:System.Data.DataTable>。 在创建后<xref:System.Data.DataRow>，你可以将其添加到<xref:System.Data.DataRowCollection>，直到<xref:System.Data.DataTable>对象的<xref:System.Data.DataTable.Rows%2A>属性。 当你使用<xref:System.Data.DataTable.NewRow%2A>若要创建新行，必须将添加到或删除行从数据表然后才能调用<xref:System.Data.DataTable.Clear%2A>。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.DataTable>，添加两个<xref:System.Data.DataColumn>确定表的架构，并创建几个新的对象<xref:System.Data.DataRow>对象使用<xref:System.Data.DataTable.NewRow%2A>方法。 那些<xref:System.Data.DataRow>随后会将对象添加到<xref:System.Data.DataRowCollection>使用<xref:System.Data.DataRowCollection.Add%2A>方法。  
  
 [!code-csharp[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowArray">
      <MemberSignature Language="C#" Value="protected internal System.Data.DataRow[] NewRowArray (int size);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Data.DataRow[] NewRowArray(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowArray(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function NewRowArray (size As Integer) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ NewRowArray(int size);" />
      <MemberSignature Language="F#" Value="member this.NewRowArray : int -&gt; System.Data.DataRow[]" Usage="dataTable.NewRowArray size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">A <see cref="T:System.Int32" /> value that describes the size of the array.</param>
        <summary>Returns an array of <see cref="T:System.Data.DataRow" />.</summary>
        <returns>The new array.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowFromBuilder">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataRow NewRowFromBuilder (System.Data.DataRowBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataRow NewRowFromBuilder(class System.Data.DataRowBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewRowFromBuilder (builder As DataRowBuilder) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataRow ^ NewRowFromBuilder(System::Data::DataRowBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="abstract member NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow&#xA;override this.NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow" Usage="dataTable.NewRowFromBuilder builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Data.DataRowBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">A <see cref="T:System.Data.DataRowBuilder" /> object.</param>
        <summary>Creates a new row from an existing row.</summary>
        <returns>A <see cref="T:System.Data.DataRow" /> derived class.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanged (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanged(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanged (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanged(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataColumnChangeEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.ColumnChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanging">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanging (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanging(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanging (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanging(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataColumnChangeEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.ColumnChanging" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataTable.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">A <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveColumn">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveColumn (System.Data.DataColumn column);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveColumn(class System.Data.DataColumn column) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveColumn (column As DataColumn)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveColumn(System::Data::DataColumn ^ column);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveColumn : System.Data.DataColumn -&gt; unit&#xA;override this.OnRemoveColumn : System.Data.DataColumn -&gt; unit" Usage="dataTable.OnRemoveColumn column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="column" Type="System.Data.DataColumn" />
      </Parameters>
      <Docs>
        <param name="column">The <see cref="T:System.Data.DataColumn" /> being removed.</param>
        <summary>Notifies the <see cref="T:System.Data.DataTable" /> that a <see cref="T:System.Data.DataColumn" /> is being removed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />在派生类中，一定要调用基类的<see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanged (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanged(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanged (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanged(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataRowChangeEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.RowChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanging (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanging(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanging (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanging(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataRowChangeEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.RowChanging" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleted (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleted(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleted (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleted(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataRowChangeEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.RowDeleted" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleting (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleting(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleting (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleting(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataRowChangeEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.RowDeleting" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在重写<see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />在派生类中，一定要调用基类的<see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTableCleared">
      <MemberSignature Language="C#" Value="protected virtual void OnTableCleared (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableCleared(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableCleared (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableCleared(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableCleared e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataTableClearEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.TableCleared" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发<xref:System.Data.DataTable.TableCleared>事件，成功之前清除所有行后立即触发<xref:System.Data.DataTable.Clear%2A>方法将返回给调用方的控件。  
  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableClearing">
      <MemberSignature Language="C#" Value="protected virtual void OnTableClearing (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableClearing(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableClearing (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableClearing(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableClearing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataTableClearEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.TableClearing" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发<xref:System.Data.DataTable.TableClearing>事件，在处理之前激发<xref:System.Data.DataTable.Clear%2A>操作开始。  
  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableNewRow">
      <MemberSignature Language="C#" Value="protected virtual void OnTableNewRow (System.Data.DataTableNewRowEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableNewRow(class System.Data.DataTableNewRowEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableNewRow (e As DataTableNewRowEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableNewRow(System::Data::DataTableNewRowEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit&#xA;override this.OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit" Usage="dataTable.OnTableNewRow e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableNewRowEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataTableNewRowEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.TableNewRow" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发<xref:System.Data.DataTable.TableNewRow>触发后新的事件<xref:System.Data.DataRow>已经使用创建<xref:System.Data.DataTable.NewRow%2A>。  
  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ParentRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ParentRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ParentRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ParentRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ParentRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of parent relations for this <see cref="T:System.Data.DataTable" />.</summary>
        <value>A <see cref="T:System.Data.DataRelationCollection" /> ，包含表的父关系。 如果没有，则返回一个空集合<see cref="T:System.Data.DataRelation" />对象存在。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例使用<xref:System.Data.DataTable.ParentRelations%2A>属性以返回每个父<xref:System.Data.DataRelation>中<xref:System.Data.DataTable>。 每个关系中的参数作为用<xref:System.Data.DataRow.GetParentRows%2A>方法<xref:System.Data.DataRow>返回行的数组。 然后打印的行中的每个列的值。  
  
 [!code-csharp[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ChildRelations" />
        <altmember cref="T:System.Data.DataRelation" />
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Relations" />
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataTable.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the namespace for the XML representation of the data stored in the <see cref="T:System.Data.DataTable" />.</summary>
        <value>前缀<see cref="T:System.Data.DataTable" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimaryKey">
      <MemberSignature Language="C#" Value="public System.Data.DataColumn[] PrimaryKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumn[] PrimaryKey" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.PrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrimaryKey As DataColumn()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::DataColumn ^&gt; ^ PrimaryKey { cli::array &lt;System::Data::DataColumn ^&gt; ^ get(); void set(cli::array &lt;System::Data::DataColumn ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrimaryKey : System.Data.DataColumn[] with get, set" Usage="System.Data.DataTable.PrimaryKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Data.PrimaryKeyTypeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumn[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an array of columns that function as primary keys for the data table.</summary>
        <value>一个 <see cref="T:System.Data.DataColumn" /> 对象数组。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表的主键必须唯一标识表中的记录。 还有可能获得具有主键的两个或多个列组成的表。 在单个列不能包含足够的唯一值时，将发生这种情况。 例如，"FirstName"和"LastName"列可能包含两个列的主键。 因为主键可以由构成的多个列，<xref:System.Data.DataTable.PrimaryKey%2A>属性包含的数组<xref:System.Data.DataColumn>对象。  
  
   
  
## Examples  
 第一个示例演示如何返回有关的主键列<xref:System.Data.DataTable>中显示`DataGrid`。 第二个示例演示如何设置有关的主键列<xref:System.Data.DataTable>。  
  
 [!code-csharp[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DataException">The key is a foreign key.</exception>
        <altmember cref="T:System.Data.DataColumn" />
        <altmember cref="P:System.Data.DataTable.PrimaryKey" />
        <altmember cref="T:System.Data.DataColumnCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads XML schema and data into the <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.ReadXml%2A>方法提供方法读取只将数据或数据和架构读入<xref:System.Data.DataTable>从 XML 文档，而<xref:System.Data.DataTable.ReadXmlSchema%2A>方法读取仅的架构。 若要读取数据和架构，使用之一`ReadXML`重载，以包括`XmlReadMode`参数，并将其值设置为`ReadSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.WriteXml%2A>和<xref:System.Data.DataTable.WriteXmlSchema%2A>方法，分别。 要写入的 XML 数据，或架构和数据从`DataTable`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXml" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">An object that derives from <see cref="T:System.IO.Stream" /></param>
        <summary>Reads XML schema and data into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.Stream" />.</summary>
        <returns>The <see cref="T:System.Data.XmlReadMode" /> used to read the data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前<xref:System.Data.DataTable>及其子代加载从提供的数据<xref:System.IO.Stream>。 此方法的行为等同于的<xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType>仅为当前表及其子代加载方法，这在这种情况下，数据除外。  
  
 <xref:System.Data.DataTable.ReadXml%2A>方法提供方法读取只将数据或数据和架构读入<xref:System.Data.DataTable>从 XML 文档，而<xref:System.Data.DataTable.ReadXmlSchema%2A>方法读取仅的架构。  
  
 请注意，同样适用于<xref:System.Data.DataTable.WriteXml%2A>和<xref:System.Data.DataTable.WriteXmlSchema%2A>方法，分别。 要写入的 XML 数据，或架构和数据从`DataTable`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定内联架构，内联架构用于扩展现有的关系结构之前加载数据。 如果存在任何冲突 （例如，定义具有不同数据类型的同一个表中的相同列） 被引发异常。  
  
 如果不指定任何内联架构，则关系结构通过推理，如有必要，扩展根据 XML 文档的结构。 如果无法通过推断扩展架构，才能公开的所有数据，则引发异常。  
  
> [!NOTE]
>  `DataSet`不将 XML 元素关联与其对应`DataColumn`或`DataTable`合法的 XML 字符，如 ("_") 在序列化的 XML 中的转义时。 `DataSet`本身仅为 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.DataTable>包含两个列和十个行。 此示例将<xref:System.Data.DataTable>架构和数据迁移到内存流，通过调用<xref:System.Data.DataTable.WriteXml%2A>方法。 此示例将创建第二个<xref:System.Data.DataTable>和调用<xref:System.Data.DataTable.ReadXml%2A>方法以用架构和数据填充它。  
  
 [!code-csharp[DataWorks DataTable.ReadXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">The <see cref="T:System.IO.TextReader" /> that will be used to read the data.</param>
        <summary>Reads XML schema and data into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.TextReader" />.</summary>
        <returns>The <see cref="T:System.Data.XmlReadMode" /> used to read the data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前<xref:System.Data.DataTable>及其子代加载从提供的数据<xref:System.IO.TextReader>。 此方法的行为等同于的<xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType>仅为当前表及其子代加载方法，这在这种情况下，数据除外。  
  
 <xref:System.Data.DataTable.ReadXml%2A>方法提供方法读取只将数据或数据和架构读入<xref:System.Data.DataTable>从 XML 文档，而<xref:System.Data.DataTable.ReadXmlSchema%2A>方法读取仅的架构。  
  
 请注意，同样适用于<xref:System.Data.DataTable.WriteXml%2A>和<xref:System.Data.DataTable.WriteXmlSchema%2A>方法，分别。 要写入的 XML 数据，或架构和数据从`DataTable`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定内联架构，内联架构用于扩展现有的关系结构之前加载数据。 如果存在任何冲突 （例如，定义具有不同数据类型的同一个表中的相同列） 被引发异常。  
  
 如果不指定任何内联架构，则关系结构通过推理，如有必要，扩展根据 XML 文档的结构。 如果无法通过推断扩展架构，才能公开的所有数据，则引发异常。  
  
> [!NOTE]
>  `DataSet`不将 XML 元素关联与其对应`DataColumn`或`DataTable`合法的 XML 字符，如 ("_") 在序列化的 XML 中的转义时。 `DataSet`本身仅为 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.DataTable>包含两个列和十个行。 此示例将<xref:System.Data.DataTable>架构和数据迁移到内存流，通过调用<xref:System.Data.DataTable.WriteXml%2A>方法。 此示例将创建第二个<xref:System.Data.DataTable>和调用<xref:System.Data.DataTable.ReadXml%2A>方法以用架构和数据填充它。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of the file from which to read the data.</param>
        <summary>Reads XML schema and data into the <see cref="T:System.Data.DataTable" /> from the specified file.</summary>
        <returns>The <see cref="T:System.Data.XmlReadMode" /> used to read the data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前<xref:System.Data.DataTable>及其子代加载从提供名为的文件中的数据<xref:System.String>。 此方法的行为等同于的<xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType>仅为当前表及其子代加载方法，这在这种情况下，数据除外。  
  
 <xref:System.Data.DataTable.ReadXml%2A>方法提供方法读取只将数据或数据和架构读入<xref:System.Data.DataTable>从 XML 文档，而<xref:System.Data.DataTable.ReadXmlSchema%2A>方法读取仅的架构。  
  
 请注意，同样适用于<xref:System.Data.DataTable.WriteXml%2A>和<xref:System.Data.DataTable.WriteXmlSchema%2A>方法，分别。 要写入的 XML 数据，或架构和数据从`DataTable`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定内联架构，内联架构用于扩展现有的关系结构之前加载数据。 如果存在任何冲突 （例如，定义具有不同数据类型的同一个表中的相同列） 被引发异常。  
  
 如果不指定任何内联架构，则关系结构通过推理，如有必要，扩展根据 XML 文档的结构。 如果无法通过推断扩展架构，才能公开的所有数据，则引发异常。  
  
> [!NOTE]
>  `DataSet`不将 XML 元素关联与其对应`DataColumn`或`DataTable`合法的 XML 字符，如 ("_") 在序列化的 XML 中的转义时。 `DataSet`本身仅为 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。  
  
```csharp  
using System.Data;  
public class A {  
   static void Main(string[] args) {  
      DataTable tabl = new DataTable("mytable");  
      tabl.Columns.Add(new DataColumn("id", typeof(int)));  
      for (int i = 0; i < 10; i++) {  
         DataRow row = tabl.NewRow();  
         row["id"] = i;  
         tabl.Rows.Add(row);  
      }  
      tabl.WriteXml("f.xml", XmlWriteMode.WriteSchema);  
      DataTable newt = new DataTable();  
      newt.ReadXml("f.xml");  
   }  
}  
```  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.DataTable>包含两个列和十个行。 此示例将<xref:System.Data.DataTable>架构和数据写入磁盘。 此示例将创建第二个<xref:System.Data.DataTable>和调用<xref:System.Data.DataTable.ReadXml%2A>方法以用架构和数据填充它。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">The <see cref="T:System.Xml.XmlReader" /> that will be used to read the data.</param>
        <summary>Reads XML Schema and Data into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.Xml.XmlReader" />.</summary>
        <returns>The <see cref="T:System.Data.XmlReadMode" /> used to read the data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前<xref:System.Data.DataTable>及其子代加载从提供名为的文件中的数据<xref:System.Xml.XmlReader>。 此方法的行为等同于的<xref:System.Data.DataTable.ReadXml%2A>仅为当前表及其子代加载方法，这在这种情况下，数据除外。  
  
 <xref:System.Data.DataTable.ReadXml%2A>方法提供方法读取只将数据或数据和架构读入<xref:System.Data.DataTable>从 XML 文档，而<xref:System.Data.DataTable.ReadXmlSchema%2A>方法读取仅的架构。  
  
 请注意，同样适用于<xref:System.Data.DataTable.WriteXml%2A>和<xref:System.Data.DataTable.WriteXmlSchema%2A>方法，分别。 要写入的 XML 数据，或架构和数据从`DataTable`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定内联架构，内联架构用于扩展现有的关系结构之前加载数据。 如果存在任何冲突 （例如，定义具有不同数据类型的同一个表中的相同列） 被引发异常。  
  
 如果不指定任何内联架构，则关系结构通过推理，如有必要，扩展根据 XML 文档的结构。 如果无法通过推断扩展架构，才能公开的所有数据，则引发异常。  
  
> [!NOTE]
>  `DataSet`不将 XML 元素关联与其对应`DataColumn`或`DataTable`合法的 XML 字符，如 ("_") 在序列化的 XML 中的转义时。 `DataSet`本身仅为 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.DataTable>包含两个列和十个行。 此示例将<xref:System.Data.DataTable>架构和数据写入<xref:System.Xml.XmlReader>。 此示例将创建第二个<xref:System.Data.DataTable>和调用<xref:System.Data.DataTable.ReadXml%2A>方法以填充架构和数据从<xref:System.Xml.XmlReader>实例。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`ReadXmlSchema`方法创建的架构<xref:System.Data.DataTable>。 架构包含表、 关系和约束定义。  
  
 若要写入到 XML 文档的架构，使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法。  
  
 XML 架构被指根据 XSD 标准。  
  
 `ReadXmlSchema`通常在调用之前调用方法<xref:System.Data.DataTable.ReadXml%2A>方法用于填充<xref:System.Data.DataTable>。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXmlSchema" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">The stream used to read the schema.</param>
        <summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" /> using the specified stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.ReadXmlSchema%2A>方法创建的架构<xref:System.Data.DataTable>。 架构包含表、 关系和约束定义。  
  
 若要写入到 XML 文档的架构，使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法。  
  
 XML 架构被指根据 XSD 标准。  
  
 如果 msdata:DataType 和 xs:type 类型不匹配，则会发生数据损坏。 会不引发任何异常。  
  
 `ReadXmlSchema`通常在调用之前调用方法<xref:System.Data.DataTable.ReadXml%2A>方法用于填充<xref:System.Data.DataTable>。  
  
 若要创建使用 XML 架构的嵌套的关系，使用隐式的嵌套的元素。 你还可以配置要使用显式的列名称的嵌套的关系。 元素必须隐式嵌套顺序对应的数据表中使用嵌套关系。  
  
   
  
## Examples  
 以下控制台应用程序创建一个新<xref:System.Data.DataTable>，并将写入到该表的架构的<xref:System.IO.MemoryStream>。 然后，该示例创建一个新<xref:System.Data.DataTable>，并读取其架构中的已保存的 XML 架构。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">The <see cref="T:System.IO.TextReader" /> used to read the schema information.</param>
        <summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.ReadXmlSchema%2A>方法创建的架构<xref:System.Data.DataTable>。 架构包含表、 关系和约束定义。  
  
 若要写入到 XML 文档的架构，使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法。  
  
 XML 架构被指根据 XSD 标准。  
  
 如果 msdata:DataType 和 xs:type 类型不匹配，则会发生数据损坏。 会不引发任何异常。  
  
 `ReadXmlSchema`通常在调用之前调用方法<xref:System.Data.DataTable.ReadXml%2A>方法用于填充<xref:System.Data.DataTable>。  
  
 若要创建使用 XML 架构的嵌套的关系，使用隐式的嵌套的元素。 你还可以重新配置要使用显式的列名称的嵌套的关系。 元素必须隐式嵌套顺序对应的数据表中使用嵌套关系。  
  
   
  
## Examples  
 以下控制台应用程序创建一个新<xref:System.Data.DataTable>，并将写入到该表的架构的<xref:System.IO.MemoryStream>。 然后，该示例创建一个新<xref:System.Data.DataTable>和从已保存的 XML 架构，读取其架构使用<xref:System.IO.StreamReader>(其继承自<xref:System.IO.TextReader>) 作为其源。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataTable.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of the file from which to read the schema information.</param>
        <summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" /> from the specified file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.ReadXmlSchema%2A>方法创建的架构<xref:System.Data.DataTable>。 架构包含表、 关系和约束定义。  
  
 若要写入到 XML 文档的架构，使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法。  
  
 XML 架构被指根据 XSD 标准。  
  
 如果 msdata:DataType 和 xs:type 类型不匹配，则会发生数据损坏。 会不引发任何异常。  
  
 `ReadXmlSchema`通常在调用之前调用方法<xref:System.Data.DataTable.ReadXml%2A>方法用于填充`DataTable`。  
  
 若要创建使用 XML 架构的嵌套的关系，使用隐式的嵌套的元素。 你还可以重新配置要使用显式的列名称的嵌套的关系。 元素必须隐式嵌套顺序对应的数据表中使用嵌套关系。  
  
   
  
## Examples  
 以下控制台应用程序创建一个新<xref:System.Data.DataTable>，并将该表的架构写入文件。 然后，该示例创建一个新<xref:System.Data.DataTable>而且从已保存的 XML 架构，读取其架构作为其源使用的文件。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">The <see cref="T:System.Xml.XmlReader" /> used to read the schema information.</param>
        <summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.ReadXmlSchema%2A>方法创建的架构<xref:System.Data.DataTable>。 架构包含表、 关系和约束定义。  
  
 若要写入到 XML 文档的架构，使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法。  
  
 XML 架构被指根据 XSD 标准。  
  
 如果 msdata:DataType 和 xs:type 类型不匹配，则会发生数据损坏。 会不引发任何异常。  
  
 `ReadXmlSchema`通常在调用之前调用方法<xref:System.Data.DataTable.ReadXml%2A>方法用于填充<xref:System.Data.DataTable>。  
  
> [!NOTE]
>  创建使用 XML 架构的嵌套的关系的方法是具有隐式的嵌套的元素。 此外，将嵌套的关系可能是重新配置为使用显式的列名称。 它是必需的元素，隐式嵌套为相应的数据表中使用嵌套关系。  
  
   
  
## Examples  
 以下控制台应用程序创建一个新<xref:System.Data.DataTable>，并将写入到该表的架构的<xref:System.IO.MemoryStream>。 然后，该示例创建一个新<xref:System.Data.DataTable>和从已保存的 XML 架构，读取其架构使用<xref:System.Xml.XmlTextReader>(其继承自<xref:System.Xml.XmlReader>) 作为其源。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">A <see cref="T:System.Xml.XmlReader" /> object.</param>
        <summary>Reads from an XML stream.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RejectChanges();" />
      <MemberSignature Language="F#" Value="member this.RejectChanges : unit -&gt; unit" Usage="dataTable.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rolls back all changes that have been made to the table since it was loaded, or the last time <see cref="M:System.Data.DataTable.AcceptChanges" /> was called.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Data.DataTable.RejectChanges%2A>调用时，任何<xref:System.Data.DataRow>是否仍处于编辑模式的对象将取消其编辑。 新行被移除。 与行<xref:System.Data.DataRowState>设置为`Modified`或`Deleted`返回回其原始状态。  
  
   
  
## Examples  
 下面的示例进行几次更改到<xref:System.Data.DataTable>，但通过调用拒绝所做的更改<xref:System.Data.DataTable.RejectChanges%2A>方法。  
  
 [!code-csharp[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataTable.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the serialization format.</summary>
        <value>A<see cref="T:System.Data.SerializationFormat" />枚举指定<see langword="Binary" />或<see langword="Xml" />序列化。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataTable.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resets the <see cref="T:System.Data.DataTable" /> to its original state. Reset removes all data, indexes, relations, and columns of the table. If a DataSet includes a DataTable, the table will still be part of the DataSet after the table is reset.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanged As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanged;" />
      <MemberSignature Language="F#" Value="member this.RowChanged : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanged : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after a <see cref="T:System.Data.DataRow" /> has been changed successfully.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanging As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanging;" />
      <MemberSignature Language="F#" Value="member this.RowChanging : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanging : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a <see cref="T:System.Data.DataRow" /> is changing.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleted">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleted As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleted;" />
      <MemberSignature Language="F#" Value="member this.RowDeleted : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleted : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after a row in the table has been deleted.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleting">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleting As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleting;" />
      <MemberSignature Language="F#" Value="member this.RowDeleting : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleting : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs before a row in the table is about to be deleted.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rows">
      <MemberSignature Language="C#" Value="public System.Data.DataRowCollection Rows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRowCollection Rows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Rows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rows As DataRowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRowCollection ^ Rows { System::Data::DataRowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Rows : System.Data.DataRowCollection" Usage="System.Data.DataTable.Rows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of rows that belong to this table.</summary>
        <value>A<see cref="T:System.Data.DataRowCollection" />包含<see cref="T:System.Data.DataRow" />对象; 否则为空值如果没有<see cref="T:System.Data.DataRow" />对象存在。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要创建一个新<xref:System.Data.DataRow>，必须使用<xref:System.Data.DataTable.NewRow%2A>方法以返回一个新的对象。 此类对象将自动配置为定义的架构根据<xref:System.Data.DataTable>通过其集合<xref:System.Data.DataColumn>对象。 在创建新行并设置行中的每个列的值之后, 向其中添加行<xref:System.Data.DataRowCollection>使用`Add`方法。  
  
 每个<xref:System.Data.DataRow>集合中表示表中的数据行。 若要将更改提交到行中列的值，必须调用<xref:System.Data.DataTable.AcceptChanges%2A>方法。  
  
   
  
## Examples  
 下面显示了返回并设置行的两个示例。 第一个示例使用<xref:System.Data.DataTable.Rows%2A>属性，并输出每个列的每一行的值。 第二个示例使用<xref:System.Data.DataTable>对象的<xref:System.Data.DataTable.NewRow%2A>方法来创建一个新<xref:System.Data.DataRow>与的架构对象<xref:System.Data.DataTable>。 设置行值之后, 的行被添加到<xref:System.Data.DataRowCollection>通过`Add`方法。  
  
 [!code-csharp[Classic WebData DataTable.Rows Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Rows Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.AcceptChanges" />
        <altmember cref="T:System.Data.DataRow" />
        <altmember cref="T:System.Data.DataRowCollection" />
        <altmember cref="M:System.Data.DataTable.NewRow" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets an array of <see cref="T:System.Data.DataRow" /> objects.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select" />
      <MemberSignature Language="VB.NET" Value="Public Function Select () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; System.Data.DataRow[]" Usage="dataTable.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets an array of all <see cref="T:System.Data.DataRow" /> objects.</summary>
        <returns>An array of <see cref="T:System.Data.DataRow" /> objects.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确保正确的排序顺序，指定与排序条件<xref:System.Data.DataTable.Select%2A>或<xref:System.Data.DataTable.Select%2A>。  
  
   
  
## Examples  
 下面的示例返回的数组<xref:System.Data.DataRow>对象通过<xref:System.Data.DataTable.Select%2A>方法。  
  
 [!code-csharp[Classic WebData DataTable.Select Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression);" />
      <MemberSignature Language="F#" Value="member this.Select : string -&gt; System.Data.DataRow[]" Usage="dataTable.Select filterExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">The criteria to use to filter the rows. For examples on how to filter rows, see [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <summary>Gets an array of all <see cref="T:System.Data.DataRow" /> objects that match the filter criteria.</summary>
        <returns>An array of <see cref="T:System.Data.DataRow" /> objects.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要创建`filterExpression`自变量，使用相同的规则适用于<xref:System.Data.DataColumn>类的<xref:System.Data.DataColumn.Expression%2A>创建筛选器的属性值。  
  
 若要确保正确的排序顺序，指定与排序条件<xref:System.Data.DataTable.Select%2A>或<xref:System.Data.DataTable.Select%2A>。  
  
 如果筛选器上的列包含 null 值，它将不是结果的一部分。  
  
   
  
## Examples  
 下面的示例使用筛选器表达式返回的数组<xref:System.Data.DataRow>对象。  
  
 [!code-csharp[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">The criteria to use to filter the rows. For examples on how to filter rows, see [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">A string specifying the column and sort direction.</param>
        <summary>Gets an array of all <see cref="T:System.Data.DataRow" /> objects that match the filter criteria, in the specified sort order.</summary>
        <returns>An array of <see cref="T:System.Data.DataRow" /> objects matching the filter expression.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向窗体`filterExpression`自变量，用于创建使用相同的规则<xref:System.Data.DataColumn>类的<xref:System.Data.DataColumn.Expression%2A>属性值。 `Sort`自变量还会将相同的规则用于创建类的<xref:System.Data.DataColumn.Expression%2A>字符串。  
  
 如果筛选器上的列包含 null 值，它将不是结果的一部分。  
  
   
  
## Examples  
 下面的示例使用筛选器表达式返回的数组<xref:System.Data.DataRow>对象。  
  
 [!code-csharp[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort, System.Data.DataViewRowState recordStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort, valuetype System.Data.DataViewRowState recordStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String, recordStates As DataViewRowState) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort, System::Data::DataViewRowState recordStates);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string * System.Data.DataViewRowState -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort, recordStates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
        <Parameter Name="recordStates" Type="System.Data.DataViewRowState" />
      </Parameters>
      <Docs>
        <param name="filterExpression">The criteria to use to filter the rows. For examples on how to filter rows, see [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">A string specifying the column and sort direction.</param>
        <param name="recordStates">One of the <see cref="T:System.Data.DataViewRowState" /> values.</param>
        <summary>Gets an array of all <see cref="T:System.Data.DataRow" /> objects that match the filter in the order of the sort that match the specified state.</summary>
        <returns>An array of <see cref="T:System.Data.DataRow" /> objects.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向窗体`filterExpression`自变量，用于创建使用相同的规则<xref:System.Data.DataColumn>类的<xref:System.Data.DataColumn.Expression%2A>属性值。 `Sort`自变量还会将相同的规则用于创建类的<xref:System.Data.DataColumn.Expression%2A>字符串。  
  
 如果筛选器上的列包含 null 值，它将不是结果的一部分。  
  
   
  
## Examples  
 下面的示例使用筛选器表达式和记录状态返回的数组<xref:System.Data.DataRow>对象。  
  
 [!code-csharp[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataTable.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an <see cref="T:System.ComponentModel.ISite" /> for the <see cref="T:System.Data.DataTable" />.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> 的一个 <see cref="T:System.Data.DataTable" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 站点绑定<xref:System.ComponentModel.Component>到<xref:System.ComponentModel.Container>和启用它们之间的通信，以及为要管理其组件的容器提供的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ComponentModel.IListSource.ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Data.DataTable.System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>For a description of this member, see <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>
          <see langword="true" /> 如果该集合为的集合<see cref="T:System.Collections.IList" />对象; 否则为<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Data.DataTable> 实例被强制转换为 <xref:System.ComponentModel.IListSource> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>For a description of this member, see <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>An <see cref="T:System.Collections.IList" /> that can be bound to a data source from the object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Data.DataTable> 实例被强制转换为 <xref:System.ComponentModel.IListSource> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>For a description of this member, see <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>An <see cref="T:System.Xml.Schema.XmlSchema" /> that describes the XML representation of the object that is produced by the <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> method and consumed by the <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Data.DataSet> 实例被强制转换为 <xref:System.Xml.Serialization.IXmlSerializable> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">An XmlReader.</param>
        <summary>For a description of this member, see <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Data.DataSet> 实例被强制转换为 <xref:System.Xml.Serialization.IXmlSerializable> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">An XmlWriter.</param>
        <summary>For a description of this member, see <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Data.DataSet> 实例被强制转换为 <xref:System.Xml.Serialization.IXmlSerializable> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableCleared">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableCleared;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableCleared" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableCleared" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableCleared As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableCleared;" />
      <MemberSignature Language="F#" Value="member this.TableCleared : System.Data.DataTableClearEventHandler " Usage="member this.TableCleared : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after a <see cref="T:System.Data.DataTable" /> is cleared.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableCleared>成功之前清除所有行后立即激发事件<xref:System.Data.DataTable.Clear%2A>方法将返回给调用方的控件。 <xref:System.Data.DataTable.TableCleared>如果清除操作中的任何异常不激发事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableClearing">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableClearing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableClearing" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableClearing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableClearing As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableClearing;" />
      <MemberSignature Language="F#" Value="member this.TableClearing : System.Data.DataTableClearEventHandler " Usage="member this.TableClearing : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a <see cref="T:System.Data.DataTable" /> is cleared.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableClearing>处理之前激发事件<xref:System.Data.DataTable.Clear%2A>操作开始。 此事件始终会激发<xref:System.Data.DataTable.Clear%2A>调用方法时，即使表包含零行。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TableName : string with get, set" Usage="System.Data.DataTable.TableName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the <see cref="T:System.Data.DataTable" />.</summary>
        <value>
          <see cref="T:System.Data.DataTable" /> 的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableName%2A>用于从父返回此表<xref:System.Data.DataSet>对象的<xref:System.Data.DataTableCollection>(返回<xref:System.Data.DataSet.Tables%2A>属性)。  
  
   
  
## Examples  
 下面的示例将打印<xref:System.Data.DataTable.TableName%2A>为集合中的每个表<xref:System.Data.DataTable>对象。  
  
 [!code-csharp[Classic WebData DataTable.TableName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.TableName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="null" /> or empty string ("") is passed in and this table belongs to a collection.</exception>
        <exception cref="T:System.Data.DuplicateNameException">The table belongs to a collection that already has a table with the same name. (Comparison is case-sensitive).</exception>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Tables" />
      </Docs>
    </Member>
    <Member MemberName="TableNewRow">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableNewRowEventHandler TableNewRow;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableNewRowEventHandler TableNewRow" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableNewRow" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableNewRow As DataTableNewRowEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableNewRowEventHandler ^ TableNewRow;" />
      <MemberSignature Language="F#" Value="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " Usage="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableNewRowEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a new <see cref="T:System.Data.DataRow" /> is inserted.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 后的激发<xref:System.Data.DataRow>已经使用创建<xref:System.Data.DataTable.NewRow%2A>。 此事件激发之前调用`NewRow`方法返回。 新<xref:System.Data.DataRow>分离实例; 不添加到集合。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="dataTable.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the <see cref="P:System.Data.DataTable.TableName" /> and <see cref="P:System.Data.DataTable.DisplayExpression" />, if there is one as a concatenated string.</summary>
        <returns>A string consisting of the <see cref="P:System.Data.DataTable.TableName" /> and the <see cref="P:System.Data.DataTable.DisplayExpression" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 获取<xref:System.Data.DataTable.TableName%2A>和<xref:System.Data.DataTable.DisplayExpression%2A>为<xref:System.Data.DataTable>。  
  
   
  
## Examples  
 下面的示例返回<xref:System.Data.DataTable.TableName%2A>和<xref:System.Data.DataTable.DisplayExpression%2A>使用<xref:System.Data.DataTable.ToString%2A>方法。  
  
 [!code-csharp[Classic WebData DataTable.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
   
  
## Examples  
 以下控制台应用程序创建两个<xref:System.Data.DataTable>实例，将每个<xref:System.Data.DataSet>，创建<xref:System.Data.DataRelation>相关的两个表，，然后使用<xref:System.Data.DataTable.WriteXml%2A>方法写入到父表中包含的数据<xref:System.IO.TextWriter>. 设置时，此示例演示行为`writeHierarchy`到每个其值的参数。  
  
> [!NOTE]
>  此示例演示如何使用 WriteXml 的重载版本之一。 有关可能会提供其他示例，请参阅各个重载主题。  
  
 [!code-csharp[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/VB/source.vb#1)]  
  
 该示例在控制台窗口中显示以下输出：  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">The stream to which the data will be written.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> with which to write the content.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataTable.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The file to which to write the XML data.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> with which to write the contents.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXml (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">The stream to which the data will be written.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.IO.Stream" />. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 通常`WriteXml`方法将写入当前表的数据。 要写入当前表和所有其后代的数据相关的表，请调用此方法的`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">The stream to which the data will be written.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> to the specified file using the specified <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> with which to write the content.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.IO.TextWriter" />. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 通常`WriteXml`方法将写入当前表的数据。 若要写入当前表和及其所有子代和相关的表数据，请调用与方法`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
   
  
## Examples  
 以下控制台应用程序创建两个<xref:System.Data.DataTable>实例，将每个<xref:System.Data.DataSet>，创建<xref:System.Data.DataRelation>相关的两个表，，然后使用<xref:System.Data.DataTable.WriteXml%2A>方法写入到父表中包含的数据<xref:System.IO.TextWriter>. 设置时，此示例演示行为`writeHierarchy`参数`true`。  
  
 [!code-csharp[DataWorks DataTable.WriteXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> used to write the document.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.TextWriter" /> and <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">The file to which to write the XML data.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified file. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
 通常`WriteXml`方法将写入当前表的数据。 要写入当前表和所有其后代的数据相关的表，请调用此方法的`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of the file to which the data will be written.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified file and <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> with which to write the contents.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
 通常`WriteXml`方法将写入当前表的数据。 若要写入当前表和及其所有子代和相关表的数据，调用与方法`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> used to write the document.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.Xml.XmlWriter" /> and <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (stream, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">The stream to which the data will be written.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> to the specified file using the specified <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从`DataTable`插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一`XmlWriteMode`参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
 通常情况下，`WriteXml`方法将仅对当前表的数据保存。 `WriteXml`方法提供了编写只将数据方法或数据和架构从`DataTable`插入 XML 文档，而`WriteXmlSchema`方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一`XmlWriteMode`参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
 通常`WriteXml`方法将写入当前表的数据。 要写入当前表和所有其后代的数据相关的表，请调用此方法的`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> used to write the document.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.TextWriter" /> and <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
 通常情况下，`WriteXml`方法将仅对当前表的数据保存。 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
 通常`WriteXml`方法将写入当前表的数据。 要写入当前表和所有其后代的数据相关的表，请调用此方法的`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
   
  
## Examples  
 以下控制台应用程序创建两个<xref:System.Data.DataTable>实例，将每个<xref:System.Data.DataSet>，创建<xref:System.Data.DataRelation>相关的两个表，，然后使用<xref:System.Data.DataTable.WriteXml%2A>方法写入到父表中包含的数据<xref:System.IO.TextWriter>. 设置时，此示例演示行为`writeHierarchy`到每个其值的参数。  
  
 [!code-csharp[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/VB/source.vb#1)]  
  
 该示例在控制台窗口中显示以下输出：  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of the file to which the data will be written.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified file and <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
 通常情况下，`WriteXml`方法将仅对当前表的数据保存。 如果你想要保存当前表和的架构，所有的数据<xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
 通常`WriteXml`方法将写入当前表的数据。 若要写入当前表和相关的所有子代的表数据，请调用与方法`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> used to write the document.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.Xml.XmlWriter" /> and <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据方法或数据和架构从<xref:System.Data.DataTable>插入 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将写入仅的架构。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，使用`ReadXmlSchema`方法。  
  
 通常`WriteXml`方法将写入当前表的数据。 若要写入当前表和及其所有子代和相关表的数据，调用与方法`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>，却未实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
   
  
## Examples  
 以下控制台应用程序创建两个<xref:System.Data.DataTable>实例，将每个<xref:System.Data.DataSet>，创建<xref:System.Data.DataRelation>相关的两个表，，然后使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入到父表中包含的数据<xref:System.IO.TextWriter>. 设置时，此示例演示行为`writeHierarchy`到每个其值的参数。  
  
> [!NOTE]
>  此示例演示如何使用的重载版本之一`WriteXmlSchema`有关可能可用，其他示例，请参阅各个重载主题。  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/VB/source.vb#1)]  
  
 该示例在控制台窗口中显示以下输出：  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">The stream to which the XML schema will be written.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema to the specified stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> with which to write.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema using the specified <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataTable.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of the file to use.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema to the specified file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> to use.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema using the specified <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">The stream to which the XML schema will be written.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the schema of the current table and all its descendants. If <see langword="false" /> (the default value), write the schema for the current table only.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema to the specified stream. To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 通常`WriteXmlSchema`方法将写入当前表的架构。 若要写入当前表和及其所有子代和相关表的架构，调用与方法`writeHierarchy`参数设置为`true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> with which to write.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the schema of the current table and all its descendants. If <see langword="false" /> (the default value), write the schema for the current table only.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema using the specified <see cref="T:System.IO.TextWriter" />. To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 通常`WriteXmlSchema`方法将写入当前表的架构。 若要写入当前表和及其所有子代和相关表的架构，调用与方法`writeHierarchy`参数设置为`true`。  
  
   
  
## Examples  
 以下控制台应用程序创建两个<xref:System.Data.DataTable>实例，将每个<xref:System.Data.DataSet>，创建<xref:System.Data.DataRelation>相关的两个表，，然后使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入到父表中包含的数据<xref:System.IO.TextWriter>. 设置时，此示例演示行为`writeHierarchy`到每个其值的参数。  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/VB/source.vb#1)]  
  
 该示例在控制台窗口中显示以下输出：  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of the file to use.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the schema of the current table and all its descendants. If <see langword="false" /> (the default value), write the schema for the current table only.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema to the specified file. To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 通常`WriteXmlSchema`方法将写入当前表的架构。 若要写入当前表和及其所有子代和相关表的架构，调用与方法`writeHierarchy`参数设置为`true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> used to write the document.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the schema of the current table and all its descendants. If <see langword="false" /> (the default value), write the schema for the current table only.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema using the specified <see cref="T:System.Xml.XmlWriter" />. To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入的架构<xref:System.Data.DataTable>到 XML 文档。 架构包含表、 关系和约束定义。  
  
 使用 XSD 标准编写 XML 架构。  
  
 若要将数据写入到 XML 文档，使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 通常`WriteXmlSchema`方法将写入当前表的架构。 若要写入当前表和及其所有子代和相关表的架构，调用与方法`writeHierarchy`参数设置为`true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>