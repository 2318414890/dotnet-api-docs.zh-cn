<Type Name="DataTable" FullName="System.Data.DataTable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="300369f702f863e5f202e1c54c0a83eb9edf7782" />
    <Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="12/05/2018" />
    <Meta Name="ms.locfileid" Value="52918430" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataTable extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTable" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTable&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTable : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataTable = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.DefaultEvent("RowChanging")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.DefaultProperty("TableName")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataTableSchema")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示内存中数据的一个表。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable>是 ADO.NET 库中的中心对象。 其他对象使用<xref:System.Data.DataTable>包括<xref:System.Data.DataSet>和<xref:System.Data.DataView>。  
  
 访问时<xref:System.Data.DataTable>对象，请注意，它们是有条件地区分大小写。 例如，如果一个<xref:System.Data.DataTable>名为"mydatatable"和另一个名为"Mydatatable"，用来搜索一个表的字符串将被视为区分大小写。 但是，如果存在"mydatatable"，"Mydatatable"不被件，不区分大小写的搜索字符串。 一个<xref:System.Data.DataSet>可以包含两个<xref:System.Data.DataTable>具有相同的对象<xref:System.Data.DataTable.TableName%2A>但使用不同的属性值<xref:System.Data.DataTable.Namespace%2A>属性值。 有关使用详细信息<xref:System.Data.DataTable>对象，请参阅[创建数据表](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md)。  
  
 如果要创建<xref:System.Data.DataTable>以编程方式，您首先必须通过添加定义其架构<xref:System.Data.DataColumn>对象添加到<xref:System.Data.DataColumnCollection>(通过访问<xref:System.Data.DataTable.Columns%2A>属性)。 有关添加详细信息<xref:System.Data.DataColumn>对象，请参阅[向数据表添加列](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md)。  
  
 若要将行添加到<xref:System.Data.DataTable>，必须首先使用<xref:System.Data.DataTable.NewRow%2A>方法以返回一个新<xref:System.Data.DataRow>对象。 <xref:System.Data.DataTable.NewRow%2A>方法返回的架构具有的行<xref:System.Data.DataTable>，它由表的定义<xref:System.Data.DataColumnCollection>。 行的最大数目的<xref:System.Data.DataTable>可以应用商店是 16777216。 有关详细信息，请参阅[将数据添加到 DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md)。  
  
 <xref:System.Data.DataTable>还包含一系列<xref:System.Data.Constraint>可用于确保数据完整性的对象。 有关详细信息，请参阅[数据表约束](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md)。  
  
 有很多<xref:System.Data.DataTable>可用于确定何时对表进行更改的事件。 其中包括 <xref:System.Data.DataTable.RowChanged>、<xref:System.Data.DataTable.RowChanging>、<xref:System.Data.DataTable.RowDeleting> 和 <xref:System.Data.DataTable.RowDeleted>。 有关可用于事件的详细信息<xref:System.Data.DataTable>，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
 实例时<xref:System.Data.DataTable>创建后，某些读/写属性设置为初始值。 有关这些值的列表，请参阅<xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType>构造函数主题。  
  
> [!NOTE]
>  <xref:System.Data.DataSet>并<xref:System.Data.DataTable>对象继承自<xref:System.ComponentModel.MarshalByValueComponent>，并支持<xref:System.Runtime.Serialization.ISerializable>.NET Framework 远程处理的接口。 这些是唯一可以使用.NET Framework 远程处理的 ADO.NET 对象。  
  
   
  
## Examples  
 下面的示例创建两个<xref:System.Data.DataTable>对象，另一个<xref:System.Data.DataRelation>对象，并将添加到的新对象<xref:System.Data.DataSet>。 表将显示在<xref:System.Windows.Forms.DataGridView>控件。  
  
 [!code-csharp[Classic WebData DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable Example/VB/source.vb#1)]  
  
 此示例演示如何使用特定的架构定义手动创建 DataTable：  
  
-   创建多个 DataTable 并定义初始列。  
  
-   创建表约束。  
  
-   插入值并显示表。  
  
-   创建表达式列并显示表。  
  
 可以上找到具有此代码示例的 C# 和 Visual Basic 项目[开发人员代码示例](https://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914)。  
  
 [!code-csharp[Classic WebData DataTable Example2#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/classic webdata datatable example2/cs/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example2#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/classic webdata datatable example2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是安全的多线程读取操作。 你必须同步的任何写入操作。</threadsafe>
    <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Data.DataTable" /> 类的新实例。</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>在不使用参数的情况下初始化 <see cref="T:System.Data.DataTable" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 构造函数设置的所有属性的初始值<xref:System.Data.DataTable>对象。 下表显示的属性和它们的默认值。 实例时<xref:System.Data.DataTable>创建以下读/写属性设置为初始值。  
  
|属性|默认值|  
|--------------|-------------------|  
|**CaseSensitive**|与父项相同<xref:System.Data.DataSet>，如果它属于一个。 否则为 `false`。|  
|**DisplayExpression**|空字符串 ("")|  
|**区域设置**|与父项相同<xref:System.Data.DataSet>对象的<xref:System.Globalization.CultureInfo>(返回由<xref:System.Data.DataSet.Locale%2A>属性); 如果不存在父，默认值是当前系统<xref:System.Globalization.CultureInfo>。|  
|**MinimumCapacity**|50 行。|  
  
 可以更改任何这些属性通过单独调用属性的值。  
  
   
  
## Examples  
 下面的示例创建一个新<xref:System.Data.DataTable>与<xref:System.Data.DataColumn>并<xref:System.Data.DataRow>，并将其显示<xref:System.Windows.Forms.DataGridView>控件。  
  
 [!code-csharp[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable tableName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">要向表提供的名称。 如果<paramref name="tableName" />是<see langword="null" />或空字符串，默认名称时指定添加到<see cref="T:System.Data.DataTableCollection" />。</param>
        <summary>使用指定的表名初始化 <see cref="T:System.Data.DataTable" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例创建<xref:System.Data.DataTable>并将其显示<xref:System.Windows.Forms.DataGridView>控件。  
  
 [!code-csharp[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataTable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataTable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">序列化或反序列化对象所需的数据。</param>
        <param name="context">给定序列化流的源和目标。</param>
        <summary>使用 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 和 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 初始化 <see cref="T:System.Data.DataTable" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现<xref:System.Data.DataTable>构造函数是所必需的<xref:System.Runtime.Serialization.ISerializable>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName, string tableNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName, string tableNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String, tableNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName, System::String ^ tableNamespace);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string * string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (tableName, tableNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
        <Parameter Name="tableNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">要向表提供的名称。 如果<paramref name="tableName" />是<see langword="null" />或空字符串，默认名称时指定添加到<see cref="T:System.Data.DataTableCollection" />。</param>
        <param name="tableNamespace">
          <see langword="DataTable" /> 中所存储数据的 XML 表示形式的命名空间。</param>
        <summary>使用指定的表名和命名空间初始化 <see cref="T:System.Data.DataTable" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataTable.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>提交自上次调用 <see cref="M:System.Data.DataTable.AcceptChanges" /> 以来对该表进行的所有更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Data.DataTable.AcceptChanges%2A>调用时，任何<xref:System.Data.DataRow>仍处于编辑模式的对象已成功结束其编辑。 <xref:System.Data.DataRowState>也会更改： 所有`Added`并`Modified`行成为`Unchanged`，和`Deleted`删除行。  
  
 <xref:System.Data.DataTable.AcceptChanges%2A>通常在调用方法<xref:System.Data.DataTable>尝试更新后<xref:System.Data.DataSet>使用<xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下面的示例测试有错误的每个表。 如果表中的错误可以协调 （通过将它传递给未定义的函数），<xref:System.Data.DataTable.AcceptChanges%2A>被调用; 否则为<xref:System.Data.DataTable.RejectChanges%2A>调用。  
  
 [!code-csharp[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataTable.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>开始初始化在窗体上使用或由另一个组件使用的 <see cref="T:System.Data.DataTable" />。 初始化发生在运行时。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio.NET 设计环境使用此方法开始初始化在窗体上使用或由另一个组件使用的组件。 <xref:System.Data.DataTable.EndInit%2A>方法结束初始化。 使用<xref:System.Data.DataTable.BeginInit%2A>和<xref:System.Data.DataTable.EndInit%2A>方法可以防止该控件完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadData">
      <MemberSignature Language="C#" Value="public void BeginLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoadData();" />
      <MemberSignature Language="F#" Value="member this.BeginLoadData : unit -&gt; unit" Usage="dataTable.BeginLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>加载数据时，关闭通知、索引维护和约束。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.BeginLoadData%2A>结合<xref:System.Data.DataTable.LoadDataRow%2A>和<xref:System.Data.DataTable.EndLoadData%2A>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataTable.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableCaseSensitiveDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示表中的字符串比较是否区分大小写。</summary>
        <value>
          <see langword="true" /> 如果比较不区分大小写。否则为<see langword="false" />。 默认值设置为 parent<see cref="T:System.Data.DataSet" />对象的<see cref="P:System.Data.DataSet.CaseSensitive" />属性，或<see langword="false" />如果<see cref="T:System.Data.DataTable" />创建独立于<see cref="T:System.Data.DataSet" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.CaseSensitive%2A>属性会影响排序、 搜索和筛选中的字符串比较。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Data.DataTable.Select%2A>方法两次在<xref:System.Data.DataTable>。 第一次<xref:System.Data.DataTable.CaseSensitive%2A>属性设置为`false`，则第二个`true`。  
  
 [!code-csharp[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Select" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ChildRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ChildRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ChildRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ChildRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChildRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ChildRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChildRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ChildRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableChildRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 <see cref="T:System.Data.DataTable" /> 的子关系的集合。</summary>
        <value>一个<see cref="T:System.Data.DataRelationCollection" />，包含该表的子关系。 如果没有，则返回空集合<see cref="T:System.Data.DataRelation" />存在的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个<xref:System.Data.DataRelation>定义两个表之间的关系。 通常情况下，两个表是通过包含相同的数据的单个字段链接。 例如，其中包含地址数据的表可能包含表示国家/地区代码的单个字段。 包含国家/地区的数据的第二个表将具有单个字段包含标识国家/地区代码并将以下代码以插入到第一个表中的相应字段。 一个<xref:System.Data.DataRelation>，然后，包含至少四个条信息: (1) 的第一个表的名称、 （2） 的第一个表中的列名称、 （3） 的第二个表的名称和 （4） 的第二个表中的列名称。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Data.DataTable.ChildRelations%2A>属性以返回每个子级<xref:System.Data.DataRelation>中<xref:System.Data.DataTable>。 每个关系然后用作中的自变量<xref:System.Data.DataRow.GetChildRows%2A>方法的<xref:System.Data.DataRow>若要返回的行的数组。 然后打印的行中的每个列的值。  
  
 [!code-csharp[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ParentRelations" />
        <altmember cref="M:System.Data.DataRow.GetParentRows(System.String)" />
        <altmember cref="M:System.Data.DataRow.GetChildRows(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除所有数据的 <see cref="T:System.Data.DataTable" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 删除所有表中的所有行。 如果表有任何强制的子关系，会导致将孤立的子行，将生成异常。  
  
 如果<xref:System.Data.DataSet>绑定到<xref:System.Xml.XmlDataDocument>，则调用<xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType>或<xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType>引发<xref:System.NotSupportedException>。 若要避免这种情况下，遍历每个表，一次删除每行一个。 当你使用<xref:System.Data.DataTable.NewRow%2A>若要创建新行，处理行时必须在调用之前<xref:System.Data.DataTable.Clear%2A>。  
  
   
  
## Examples  
 以下示例清除所有数据的表。  
  
 [!code-csharp[Classic WebData DataTable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataTable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataTable ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataTable&#xA;override this.Clone : unit -&gt; System.Data.DataTable" Usage="dataTable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>克隆 <see cref="T:System.Data.DataTable" /> 的结构，包括所有 <see cref="T:System.Data.DataTable" /> 架构和约束。</summary>
        <returns>新的 <see cref="T:System.Data.DataTable" />，与当前 <see cref="T:System.Data.DataTable" /> 具有相同架构。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果已派生这些类，克隆也将属于相同的派生类。  
  
 克隆可创建具有与原始 <xref:System.Data.DataTable> 相同的结构的新 <xref:System.Data.DataTable>，但不复制任何数据（新 <xref:System.Data.DataTable> 将不会包含任何 `DataRows`）。 若要同时将结构和数据复制到新 <xref:System.Data.DataTable> 中，请使用 <xref:System.Data.DataTable.Copy%2A>。  
  
   
  
## Examples  
 以下示例演示如何在执行 DataTable.Clone 后更新目标表的结构和约束。 ClonedDataTable 类将返回目标表并包括所有更新事件。 克隆后源表中的结构更改不会反映在目标表中。 具体而言，此示例将：  
  
-   更新源表中的列更改。  
  
-   更新源表中的 UniqueConstraint 更改。  
  
-   更新源表中的 ForeignKeyConstraint 更改。  
  
 可以上找到具有此代码示例的 C# 和 Visual Basic 项目[开发人员代码示例](https://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable)。  
  
```csharp  
using System;  
using System.Linq;  
using System.Data;  
using System.ComponentModel;  
  
class Program {  
   static void Main(string[] args) {  
      DataTable courses = NewCourseDataTable();  
      Console.WriteLine("This is the source table:");  
      WriteDataTable(courses);  
  
      ClonedDataTable clonedResult = new ClonedDataTable(courses);  
      DataTable clonedCourses = clonedResult.DestinationTable;  
      Console.WriteLine("This is the destination table:");  
      WriteDataTable(clonedCourses);  
  
      // Add the events of updating column collection into the source table.  
      clonedResult.UpdateAddedColumn();  
      clonedResult.UpdateDeletedColumn();  
      // Add a DataColumn in source table.  
      DataColumn columnCreidts = new DataColumn("Credits", typeof(Int32));  
      courses.Columns.Add(columnCreidts);  
      Console.WriteLine("After add a column in source table, it's the result in the destination:");  
      WriteDataTable(clonedCourses);  
  
      // Add the event of updating UniqueConstraint into the source table.  
      clonedResult.UpdateUniqueConstraint();  
  
      // Add the unique constraint in source table.  
      UniqueConstraint uniqueConstraint = new UniqueConstraint(courses.Columns["CourseId"]);  
      courses.Constraints.Add(uniqueConstraint);  
  
      Console.WriteLine(@"If we add the unique constraint in source table and then insert the duplicate   
rows into the destination table, we will get the following error:");  
      InsertDuplicateData(clonedCourses);  
      Console.WriteLine();  
  
      // Add the event of updating ForeignKeyConstraint into the source table.  
      clonedResult.UpdateForeignKeyConstraint();  
  
      // Add the ForeignKeyConstraint into the source table.  
      DataTable deparments = NewDeparmentDataTable();  
      DataSet dataset = new DataSet();  
  
      dataset.Tables.Add(courses);  
      dataset.Tables.Add(clonedCourses);  
      dataset.Tables.Add(deparments);  
  
      ForeignKeyConstraint foreignKey = new ForeignKeyConstraint(deparments.Columns["DepartmentId"], courses.Columns["DepartmentId"]);  
      courses.Constraints.Add(foreignKey);  
  
      Console.WriteLine(@"If we add the foreign key constraint in source table and then insert a row   
without the parent  into the destination table, we will get the following error:");  
      InsertNoParentRow(clonedCourses);  
      Console.WriteLine();  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   static private DataTable NewCourseDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("CourseId", typeof(String)),  
                                      new DataColumn("CourseName",typeof(String)),                                        
                                      new DataColumn("DepartmentId", typeof(Int32))  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add("C1045", "Calculus", 7);  
      newTable.Rows.Add("C1061", "Physics", 1);  
      newTable.Rows.Add("C2021", "Composition", 2);  
      newTable.Rows.Add("C2042", "Literature", 2);  
  
      return newTable;  
   }  
  
   static private DataTable NewDeparmentDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("DepartmentId", typeof(Int32)),  
                                      new DataColumn("Name",typeof(String)),  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add(1, "Engineering");  
      newTable.Rows.Add(2, "English");  
      newTable.Rows.Add(4, "Economics");  
      newTable.Rows.Add(7, "Mathematics");  
  
      return newTable;  
   }  
  
   static private void WriteDataTable(DataTable table) {  
      if (table == null)  
         return;  
  
      foreach (DataColumn column in table.Columns) {  
         Console.Write("{0,-15}", column.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         for (int i = 0; i < table.Columns.Count; i++)  
            Console.Write("{0,-15}", row[i].ToString());  
         Console.WriteLine();  
      }  
  
      Console.WriteLine();  
   }  
  
   static private void InsertDuplicateData(DataTable table) {  
      try {  
         table.Rows.Add("C1045", "Calculus", 7);  
         table.Rows.Add("C1045", "Calculus", 7);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
  
   private static void InsertNoParentRow(DataTable table) {  
      try {  
         table.Rows.Add("C1061", "Physics", 11);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
}  
  
public class ClonedDataTable {  
   private DataTable sourceTable;  
   private DataTable destinationTable;  
  
   public ClonedDataTable(DataTable source) {  
      sourceTable = source;  
      // set the cloned result  
      destinationTable = sourceTable.Clone();  
   }  
  
   public void UpdateAddedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnAdded);  
   }  
  
   public void UpdateDeletedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnDeleted);  
   }  
  
   public void UpdateUniqueConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(UniqueConstraint_Changed);  
   }  
  
   public void UpdateForeignKeyConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(ForeignKeyConstraint_Changed);  
   }  
  
   // After the source table adds a column, the method will add the same column in the destination table.  
   void ColumnAdded(object sender, System.ComponentModel.CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null) {  
            DataColumn newColumn = new DataColumn(column.ColumnName, column.DataType, column.Expression, column.ColumnMapping);  
  
            if (!destinationTable.Columns.Contains(newColumn.ColumnName))  
               destinationTable.Columns.Add(newColumn);  
         }  
      }  
   }  
  
   // After the source table deletes a column, the method will delete the same column in the destination table.  
   void ColumnDeleted(object sender, CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Remove) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null)  
            if (destinationTable.Columns.Contains(column.ColumnName))  
               destinationTable.Columns.Remove(column.ColumnName);  
      }  
   }  
  
   // After the source table changes the UniqueConstraint, this method changes the same UniqueConstraint in destination table.        
   void UniqueConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      UniqueConstraint constraint = e.Element as UniqueConstraint;  
  
      if (constraint == null)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         Boolean isPrimaryKey = constraint.IsPrimaryKey;  
  
         // Get the columns used in new constraint from the destiantion table.  
         for (Int32 i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         UniqueConstraint newConstraint = new UniqueConstraint(constraintName, columns, isPrimaryKey);  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // After the source table changes the ForeignKeyConstraint, this method changes    
   // the same ForeignKeyConstraint in the destination table.  
   void ForeignKeyConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      ForeignKeyConstraint constraint = e.Element as ForeignKeyConstraint;  
  
      if (constraint == null)  
         return;  
  
      // If the source and destination are not in the same DataSet, don't change the ForeignKeyConstraint.  
      if (sourceTable.DataSet != destinationTable.DataSet)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         DataColumn[] parentColumns = constraint.RelatedColumns;  
  
         // Get the columns used in new constraint from the destination table.  
         for (int i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constraintName, parentColumns, columns);  
         newConstraint.AcceptRejectRule = constraint.AcceptRejectRule;  
         newConstraint.DeleteRule = constraint.DeleteRule;  
         newConstraint.UpdateRule = constraint.UpdateRule;  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // return the destination table.  
   public DataTable DestinationTable {  
      get { return destinationTable; }  
   }  
}  
```  
  
 此示例演示如何更改 DataTable 中的数据和更新数据源。  
  
 首先，创建一个数据库：  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 现在可编译并运行此示例。 [如何修改 DataTable 和更新数据源中的数据](https://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4)具有此示例的 Visual Basic 和 C# 项目。  
  
```csharp  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
   string MySchoolConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True";  
  
      // Get Data  
      String selectString =  
       @"Select [CourseID],[Year],[Title],[Credits],[DepartmentID] From [dbo].[Course];  
               Select [DepartmentID],[Name],[Budget],[StartDate],[Administrator] From [dbo].[Department] ";  
  
      DataSet dataSet = new DataSet();  
      DataTable course = dataSet.Tables.Add("Course");  
      DataTable department = dataSet.Tables.Add("Department");  
  
      Console.WriteLine("Get data from database:");  
      GetDataTables(MySchoolConnectionString, selectString, dataSet, course, department);  
      Console.WriteLine();  
  
      // Use DataTable Edits to edit the data  
      String updateString =  
              @"Update [dbo].[Course] Set [Credits]=@Credits Where [CourseID]=@CourseID;";  
  
      course.ColumnChanged += OnColumnChanged;  
  
      // Set the Credits of first row is negative value, and set the Credits of second row is plus.  
      ChangeCredits(course, course.Rows[0], -1);  
      ChangeCredits(course, course.Rows[1], 11);  
  
      UpdateDataTables(MySchoolConnectionString, updateString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"),  
          new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits"));  
      Console.WriteLine("Only the Credits of second row is changed.");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      // Delete and Remove from DataTable  
      // Create the foreign key constraint, and set the DeleteRule with Cascade.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      String deleteString = @"Delete From [dbo].[Course] Where [CourseID]=@CourseID;";  
  
      department.Rows[0].Delete();  
      Console.WriteLine("If One row in Department table is deleted, the related rows in Course table will also be deleted.");  
      Console.WriteLine("Department DataTable:");  
      ShowDataTable(department);  
      Console.WriteLine();  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
      // Update the delete operation  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
      Console.WriteLine("After delete operation:");  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      course.Rows.RemoveAt(0);  
      Console.WriteLine("Now we remove one row from Course:");  
      ShowDataTable(course);  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
   }  
  
   // Use SqlDataAdapter to get data.  
   private static void GetDataTables(String connectionString, String selectString,  
       DataSet dataSet, params DataTable[] tables) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.SelectCommand = new SqlCommand(selectString);  
         adapter.SelectCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Fill(0, 0, tables);  
  
         foreach (DataTable table in dataSet.Tables) {  
            Console.WriteLine("Data in {0}:", table.TableName);  
            ShowDataTable(table);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use SqlDataAdapter to update the updata operation.  
   private static void UpdateDataTables(String connectionString, String updateString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.UpdateCommand = new SqlCommand(updateString);  
         adapter.UpdateCommand.Parameters.AddRange(parameters);  
         adapter.UpdateCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use SqlDataAdapter to update delete operation.  
   private static void DeleteDataTables(String connectionString, String deleteString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.DeleteCommand = new SqlCommand(deleteString);  
         adapter.DeleteCommand.Parameters.AddRange(parameters);  
         adapter.DeleteCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use DataTable Edits to modify the data.  
   private static void ChangeCredits(DataTable table, DataRow row, Int32 credits) {  
      row.BeginEdit();  
      Console.WriteLine("We change row {0}", table.Rows.IndexOf(row));  
      row["Credits"] = credits;  
      row.EndEdit();  
   }  
  
   // The method will be invoked when the value in DataTable is changed.  
   private static void OnColumnChanged(Object sender, DataColumnChangeEventArgs args) {  
      Int32 credits = 0;  
      // If Credits is changed and the value is negative, we'll cancel the edit.  
      if ((args.Column.ColumnName == "Credits") &&  
          (!Int32.TryParse(args.ProposedValue.ToString(), out credits) || credits < 0)) {  
         Console.WriteLine("The value of Credits is invalid. Edit canceled.");  
         args.Row.CancelEdit();  
      }  
   }  
  
   // Display the column and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "RowState");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               else  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col]);  
               else  
                  Console.Write("{0,-14}", row[col]);  
            }  
         }  
         Console.WriteLine("{0,-14}", row.RowState);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Copy" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ColumnChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanged As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanged;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnChangedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>更改 <see cref="T:System.Data.DataRow" /> 中指定的 <see cref="T:System.Data.DataColumn" /> 值之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataColumnChangeEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ColumnChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanging As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanging;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnChangingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>更改 <see cref="T:System.Data.DataRow" /> 中指定的 <see cref="T:System.Data.DataColumn" /> 值时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Columns">
      <MemberSignature Language="C#" Value="public System.Data.DataColumnCollection Columns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumnCollection Columns" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Columns" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Columns As DataColumnCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataColumnCollection ^ Columns { System::Data::DataColumnCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Columns : System.Data.DataColumnCollection" Usage="System.Data.DataTable.Columns" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取属于该表的列的集合。</summary>
        <value>一个<see cref="T:System.Data.DataColumnCollection" />，其中包含的集合<see cref="T:System.Data.DataColumn" />表对象。 如果没有，则返回空集合<see cref="T:System.Data.DataColumn" />存在的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataColumnCollection>通过定义每个列的数据类型来确定表的架构。  
  
   
  
## Examples  
 下面的示例将每一行在表中使用的每个值打印<xref:System.Data.DataTable.Columns%2A>属性。  
  
 [!code-csharp[Classic WebData DataTable.Columns Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Columns Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Compute">
      <MemberSignature Language="C#" Value="public object Compute (string expression, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Compute(string expression, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Compute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compute (expression As String, filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Compute(System::String ^ expression, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="member this.Compute : string * string -&gt; obj" Usage="dataTable.Compute (expression, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">要计算的表达式。</param>
        <param name="filter">用于限制表达式中计算的行的筛选器。</param>
        <summary>计算用来传递筛选条件的当前行上的给定表达式。</summary>
        <returns>将 <see cref="T:System.Object" /> 设置为计算结果。 如果该表达式计算结果为 null，则返回值为 <see cref="F:System.DBNull.Value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `expression`参数需要聚合函数。 例如，以下是合法的表达式：  
  
 `Count(Quantity)`  
  
 但是，此表达式不是：  
  
 `Sum (Quantity * UnitPrice)`  
  
 如果必须执行两个或多个列上的操作，则应创建<xref:System.Data.DataColumn>，请将其<xref:System.Data.DataColumn.Expression%2A>到适当的表达式，并使用在生成的列的聚合表达式中的属性。 在这种情况下，给定<xref:System.Data.DataColumn>与名称"总计"，并<xref:System.Data.DataColumn.Expression%2A>属性设置为此：  
  
 `"Quantity * UnitPrice"`  
  
 表达式参数<xref:System.Data.DataTable.Compute%2A>方法将为此：  
  
 `Sum(total)`  
  
 第二个参数， `filter`，确定在表达式中使用的行。 例如，如果表包含一个名为"colDate"的日期列，可以限制具有下面的表达式的行：  
  
 `colDate > 1/1/99 AND colDate < 17/1/99`  
  
 有关创建这两个参数的表达式的规则，请参阅<xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType>属性。  
  
   
  
## Examples  
 下面的示例计算其标识号为五位销售人员名"Total"列的值之和。  
  
 [!code-csharp[Classic WebData DataTable.Compute Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Compute Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public System.Data.ConstraintCollection Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ConstraintCollection Constraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Constraints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Constraints As ConstraintCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ConstraintCollection ^ Constraints { System::Data::ConstraintCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Constraints : System.Data.ConstraintCollection" Usage="System.Data.DataTable.Constraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableConstraintsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConstraintCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取由该表维护的约束的集合。</summary>
        <value>一个<see cref="T:System.Data.ConstraintCollection" />，其中包含的集合<see cref="T:System.Data.Constraint" />表对象。 如果没有，则返回空集合<see cref="T:System.Data.Constraint" />存在的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个<xref:System.Data.ForeignKeyConstraint>限制时删除或更新某一列 （或列） 中的值执行的操作。 此类约束旨在与主键列一起使用。 在父/子关系中两个表之间，删除一个值从父表可能会影响子行中通过以下方式之一。  
  
-   也可以是行的子删除 （级联操作）。  
  
-   中的子列 （或列） 的值可以设置为 null 值。  
  
-   中的子列 （或列） 的值可以设置为默认值。  
  
-   可以生成异常。  
  
 一个<xref:System.Data.UniqueConstraint>变为活动状态时尝试将值设置为非唯一值的主键中。  
  
   
  
## Examples  
 下面的示例添加<xref:System.Data.ForeignKeyConstraint>到约束的集合。  
  
 [!code-csharp[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataTable Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataTable" Usage="dataTable.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>复制该 <see cref="T:System.Data.DataTable" /> 的结构和数据。</summary>
        <returns>新的 <see cref="T:System.Data.DataTable" />，具有与该 <see cref="T:System.Data.DataTable" /> 相同的结构（表架构和约束）和数据。  
  
如果已派生这些类，则副本也是相同的派生类。  
  
 <see cref="M:System.Data.DataTable.Copy" /> 创建一个新 <see cref="T:System.Data.DataTable" />，后者与原始 <see cref="T:System.Data.DataTable" /> 具有相同的结构和数据。 要将结构复制到新的 <see cref="T:System.Data.DataTable" />，而不是复制到数据，请使用 <see cref="M:System.Data.DataTable.Clone" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例使用<xref:System.Data.DataTable.Copy%2A>方法来创建一份原始<xref:System.Data.DataTable>。 如果从父项继承的命名空间名称不会保留<xref:System.Data.DataTable>或<xref:System.Data.DataSet>。  
  
 [!code-csharp[Classic WebData DataTable.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataView.ToTable" />
        <altmember cref="M:System.Data.DataTable.Clone" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataTable.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回与此 <see cref="T:System.Data.DataTable" /> 内的数据对应的 <see cref="T:System.Data.DataTableReader" />。</summary>
        <returns>
          <see cref="T:System.Data.DataTableReader" /> 包含一个对应于源 <see cref="T:System.Data.DataTable" /> 实例的结果集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下控制台应用程序创建一个 <xref:System.Data.DataTable> 实例。 该示例然后将已填充<xref:System.Data.DataTable>到调用的过程<xref:System.Data.DataTable.CreateDataReader%2A>方法，该循环中包含的结果方法<xref:System.Data.DataTableReader>。  
  
 [!code-csharp[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/VB/source.vb#1)]  
  
 该示例在控制台窗口中显示以下输出：  
  
 `1 Mary`  
  
 `2 Andy`  
  
 `3 Peter`  
  
 `4 Russ`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.CreateDataReader" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateInstance () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : unit -&gt; System.Data.DataTable&#xA;override this.CreateInstance : unit -&gt; System.Data.DataTable" Usage="dataTable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建 <see cref="T:System.Data.DataTable" /> 的新实例。</summary>
        <returns>新表达式。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataSet : System.Data.DataSet" Usage="System.Data.DataTable.DataSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDataSetDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此表所属的 <see cref="T:System.Data.DataSet" />。</summary>
        <value>
          <see cref="T:System.Data.DataSet" />此表所属。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果控件数据绑定到<xref:System.Data.DataTable>，并且表属于<xref:System.Data.DataSet>，可以转到<xref:System.Data.DataSet>通过此属性。  
  
   
  
## Examples  
 下面的示例返回父<xref:System.Data.DataSet>通过给定表的<xref:System.Data.DataTable.DataSet%2A>属性。  
  
 [!code-csharp[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultView">
      <MemberSignature Language="C#" Value="public System.Data.DataView DefaultView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataView DefaultView" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DefaultView" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultView As DataView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataView ^ DefaultView { System::Data::DataView ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultView : System.Data.DataView" Usage="System.Data.DataTable.DefaultView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDefaultViewDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可能包含筛选视图或游标位置的表的自定义视图。</summary>
        <value>与 <see cref="T:System.Data.DataView" /> 关联的 <see cref="T:System.Data.DataTable" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.DefaultView%2A>属性返回<xref:System.Data.DataView>可用于排序、 筛选和搜索<xref:System.Data.DataTable>。  
  
   
  
## Examples  
 下面的示例设置的属性<xref:System.Data.DataTable>对象的<xref:System.Data.DataView>通过<xref:System.Data.DataTable.DefaultView%2A>属性。 该示例还演示的绑定<xref:System.Windows.Forms.DataGridView>控制对<xref:System.Data.DataTable>名为"供应商"包括一个名为"CompanyName"。  
  
 [!code-csharp[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayExpression">
      <MemberSignature Language="C#" Value="public string DisplayExpression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayExpression" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DisplayExpression" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayExpression As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayExpression { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayExpression : string with get, set" Usage="System.Data.DataTable.DisplayExpression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDisplayExpressionDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个表达式，该表达式返回的值用于在用户界面中表示此表。 <see langword="DisplayExpression" /> 属性用于在用户界面中显示此表名。</summary>
        <value>显示字符串。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Data.DataColumn.Expression" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataTable.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>结束在窗体上使用或由另一个组件使用的 <see cref="T:System.Data.DataTable" /> 的初始化。 初始化发生在运行时。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Visual Studio.NET 设计环境使用此方法来结束在窗体上使用或由另一个组件使用的组件的初始化。 <xref:System.Data.DataTable.BeginInit%2A>方法开始初始化。 使用<xref:System.Data.DataTable.BeginInit%2A>和<xref:System.Data.DataTable.EndInit%2A>方法可以防止该控件完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="EndLoadData">
      <MemberSignature Language="C#" Value="public void EndLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadData();" />
      <MemberSignature Language="F#" Value="member this.EndLoadData : unit -&gt; unit" Usage="dataTable.EndLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>加载数据后，打开通知、索引维护和约束。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.EndLoadData%2A>结合<xref:System.Data.DataTable.LoadDataRow%2A>和<xref:System.Data.DataTable.BeginLoadData%2A>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataTable.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("ExtendedPropertiesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取自定义用户信息的集合。</summary>
        <value>一个<see cref="T:System.Data.PropertyCollection" />，其中包含自定义用户信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.ExtendedProperties%2A>添加到自定义信息<xref:System.Data.DataTable>。 添加信息与`Add`方法。 检索信息与`Item`方法。  
  
 扩展的属性必须为类型<xref:System.String>。 不属于字符串类型的属性不会保留时<xref:System.Data.DataTable>以 XML 形式写入。  
  
   
  
## Examples  
 下面的示例添加到一个时间戳值<xref:System.Data.DataTable>通过<xref:System.Data.DataTable.ExtendedProperties%2A>属性。  
  
 [!code-csharp[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="fInitInProgress">
      <MemberSignature Language="C#" Value="protected internal bool fInitInProgress;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly bool fInitInProgress" />
      <MemberSignature Language="DocId" Value="F:System.Data.DataTable.fInitInProgress" />
      <MemberSignature Language="VB.NET" Value="Protected Friend fInitInProgress As Boolean " />
      <MemberSignature Language="C++ CLI" Value="protected public: bool fInitInProgress;" />
      <MemberSignature Language="F#" Value="val mutable fInitInProgress : bool" Usage="System.Data.DataTable.fInitInProgress" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检查是否正在进行初始化。 初始化发生在运行时。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取 <see cref="T:System.Data.DataTable" /> 的副本，该副本包含自上次加载以来或自调用 <see cref="M:System.Data.DataTable.AcceptChanges" /> 以来的所有更改。</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataTable" Usage="dataTable.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取 <see cref="T:System.Data.DataTable" /> 的副本，该副本包含自加载以来或自上次调用 <see cref="M:System.Data.DataTable.AcceptChanges" /> 以来进行的所有更改。</summary>
        <returns>此 <see cref="T:System.Data.DataTable" /> 中的更改的副本，如果未发现更改，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 创建一个新<xref:System.Data.DataSet>包含一份原始中的所有行<xref:System.Data.DataSet>具有挂起的更改。 关系约束可能会导致其他未更改的行添加到新<xref:System.Data.DataSet>如果未更改的行包含对应于已更改的行中的外键的主键。 该方法返回`null`(`Nothing`在 Visual Basic 中) 中是否存在任何行原始<xref:System.Data.DataSet>与挂起的更改。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataTable" Usage="dataTable.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">
          <see cref="T:System.Data.DataRowState" /> 值之一。</param>
        <summary>获取由 <see cref="T:System.Data.DataRowState" /> 筛选的 <see cref="T:System.Data.DataTable" /> 的副本，该副本包含上次加载以来或调用 <see cref="M:System.Data.DataTable.AcceptChanges" /> 以来进行的所有更改。</summary>
        <returns>
          <see cref="T:System.Data.DataTable" /> 的筛选副本，可以对该副本执行操作，之后可以使用 <see cref="T:System.Data.DataTable" /> 将其合并回 <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />。 如果未找到所需 <see cref="T:System.Data.DataRowState" /> 的行，则该方法返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.GetChanges%2A>方法用来生成第二个<xref:System.Data.DataTable>引入原始对象，它只包含的更改。 使用`rowStates`参数，以指定的更改应包括新的对象的类型。  
  
 关系约束可能会导致包括未更改的父行。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="GetDataTableSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataTableSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataTableSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataTableSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataTable.GetDataTableSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">一个 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 实例。</param>
        <summary>该方法返回一个包含 Web Services 描述语言 (WSDL) 的 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 实例，该语言描述了用于 Web 服务的 <see cref="T:System.Data.DataTable" />。</summary>
        <returns>
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 实例。</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="GetErrors">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] GetErrors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] GetErrors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetErrors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetErrors () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ GetErrors();" />
      <MemberSignature Language="F#" Value="member this.GetErrors : unit -&gt; System.Data.DataRow[]" Usage="dataTable.GetErrors " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取包含错误的 <see cref="T:System.Data.DataRow" /> 对象数组。</summary>
        <returns>包含错误的 <see cref="T:System.Data.DataRow" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回具有 <xref:System.Data.DataRow> 集的 <xref:System.Data.DataRow.RowError%2A> 对象的列表。 例如，在将 <xref:System.Data.Common.DataAdapter.Update%2A> 设置为 <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 的情况下调用 `true` 时，可能会出现错误。 不要对 <xref:System.Data.DataTable.AcceptChanges%2A> 调用 <xref:System.Data.DataTable>，直到您解决所有错误并重新提交 <xref:System.Data.DataSet> 以供更新。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Data.DataTable.GetErrors%2A>方法返回的数组<xref:System.Data.DataRow>具有错误的对象。  
  
 [!code-csharp[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.HasErrors" />
        <altmember cref="P:System.Data.DataRow.RowError" />
        <altmember cref="M:System.Data.DataRow.SetColumnError(System.Int32,System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">数据表 (ADO.NET)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataTable.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">一个 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象，包含与 <see cref="T:System.Data.DataTable" /> 关联的序列化数据。</param>
        <param name="context">一个 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 对象，包含与 <see cref="T:System.Data.DataTable" /> 关联的序列化流的源和目标。</param>
        <summary>使用序列化 <see cref="T:System.Data.DataTable" /> 时所需的数据填充序列化信息对象。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> 参数为 null 引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="GetRowType">
      <MemberSignature Language="C#" Value="protected virtual Type GetRowType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetRowType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetRowType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRowType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetRowType();" />
      <MemberSignature Language="F#" Value="abstract member GetRowType : unit -&gt; Type&#xA;override this.GetRowType : unit -&gt; Type" Usage="dataTable.GetRowType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取行类型。</summary>
        <returns>返回 <see cref="T:System.Data.DataRow" /> 的类型。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetSchema" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchema () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchema();" />
      <MemberSignature Language="F#" Value="abstract member GetSchema : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchema : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataTable.GetSchema " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />。</summary>
        <returns>一个 <see cref="T:System.Xml.Schema.XmlSchema" />，描述由 <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> 方法生成并由 <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> 方法使用的对象的 XML 表示形式。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataTable.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableHasErrorsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示该表所属的 <see cref="T:System.Data.DataSet" /> 的任何表的任何行中是否有错误。</summary>
        <value>
          <see langword="true" /> 如果存在错误;否则为<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用户在处理中包含的数据集上<xref:System.Data.DataTable>，可以将标记每个更改，并出现错误，如果的更改会使某些验证失败。 您可以将标记为整个<xref:System.Data.DataRow>与错误消息使用<xref:System.Data.DataRow.RowError%2A>属性。 您还可以具有的行的每个列设置错误<xref:System.Data.DataRow.SetColumnError%2A>方法。  
  
 更新的数据源之前<xref:System.Data.DataSet>，建议您首先调用<xref:System.Data.DataSet.GetChanges%2A>方法在目标上的<xref:System.Data.DataSet>。 方法会导致<xref:System.Data.DataSet>，其中包含仅与原始所做的更改。 在发送之前<xref:System.Data.DataSet>到更新的数据源，检查<xref:System.Data.DataTable.HasErrors%2A>的每个表以查看任何错误是否已附加到的行或行中的列的属性。  
  
 协调每个错误之后, 清除与错误<xref:System.Data.DataRow.ClearErrors%2A>方法的`DataRow`。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Data.DataTable.HasErrors%2A>属性来检查表是否包含错误。  
  
 [!code-csharp[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.GetErrors" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ImportRow">
      <MemberSignature Language="C#" Value="public void ImportRow (System.Data.DataRow row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ImportRow(class System.Data.DataRow row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ImportRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ImportRow (row As DataRow)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ImportRow(System::Data::DataRow ^ row);" />
      <MemberSignature Language="F#" Value="member this.ImportRow : System.Data.DataRow -&gt; unit" Usage="dataTable.ImportRow row" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="row">要导入的 <see cref="T:System.Data.DataRow" />。</param>
        <summary>将 <see cref="T:System.Data.DataRow" /> 复制到 <see cref="T:System.Data.DataTable" /> 中，保留任何属性设置以及初始值和当前值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用<xref:System.Data.DataTable.NewRow%2A>将行添加到表使用现有的表架构，但使用的行，默认值，并设置<xref:System.Data.DataRowState>到`Detached`。 调用<xref:System.Data.DataTable.ImportRow%2A>保留现有<xref:System.Data.DataRowState>以及行中的其他值。 如果`DataRow`传递当参数处于已分离状态时，它将被忽略，但不会引发异常。  
  
 将到数据表的末尾添加新行。  
  
 如果新行违反了的约束它不会添加到数据表。  
  
 你可以获取与作为 DataTable.Rows.Find 和 DataTable.Rows.IndexOf 的新行的索引。 有关更多信息，请参见<xref:System.Data.DataRowCollection>和<xref:System.Data.DataTable.Rows%2A>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5cb86d48-a987-4af4-80e0-8cc2c8373d62">操作数据表 (ADO.NET) 中的数据</related>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>初始化 <see cref="T:System.Data.DataTable" /> 后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅 <xref:System.Data.DataTable.IsInitialized%2A> 。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataTable.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否已初始化 <see cref="T:System.Data.DataTable" />。</summary>
        <value>
          <see langword="true" /> 若要指示该组件已完成初始化;否则为<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的状态<xref:System.Data.DataTable>时它正在构造，例如 Visual Studio。 <xref:System.Data.DataTable.BeginInit%2A>方法将其设置为`false`并<xref:System.Data.DataTable.EndInit%2A>方法将其设置为`true`。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>通过所提供的 <see cref="T:System.Data.IDataReader" />，用某个数据源的值填充 <see cref="T:System.Data.DataTable" />。 如果 <see langword="DataTable" /> 已经包含行，则从数据源传入的数据与现有行合并。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load`方法可在几个常见方案，都围绕着从指定的数据源获取数据并将其添加到当前的数据容器 (在这种情况下， `DataTable`)。 以下方案说明的标准用法`DataTable`、 描述其更新和合并行为。  
  
 一个`DataTable`同步或更新与单个主数据源。 `DataTable`跟踪更改，以实现与主数据源同步。 此外，`DataTable`可以接受来自一个或多个辅助数据源的增量数据。 `DataTable`不负责跟踪更改，以允许与辅助数据源同步。  
  
 给定这些两个假设数据源，用户很可能需要以下行为之一：  
  
-   初始化`DataTable`从主数据源。 在此方案中，用户想要初始化一个空`DataTable`使用主数据源中的值。 更高版本用户想要将更改传播回主数据源。  
  
-   保留更改，并从主数据源重新同步。 在此方案中，用户想要采取`DataTable`填充在前面的方案和执行增量同步使用的主数据源，保留中所做的修改`DataTable`。  
  
-   增量数据馈送从辅助数据源。 在此方案中，用户要合并来自一个或多个辅助数据源的更改并将这些更改传回的主数据源。  
  
 `Load`方法使所有这些方案成为可能。 一个重载的此方法允许您指定负载选项参数，指示如何中的现有行<xref:System.Data.DataTable>结合正在加载的行。 （不允许您指定的行为的重载使用默认负载选项。）下表描述了所提供的三个加载选项<xref:System.Data.LoadOption>枚举。 每种情况下，描述传入数据中的行的主键匹配的现有行的主键时指示的行为。  
  
|加载选项|描述|  
|-----------------|-----------------|  
|`PreserveChanges`（默认值）|使用的传入行的值更新行的原始版本。|  
|`OverwriteChanges`|使用的传入行的值更新行的当前和原始版本。|  
|`Upsert`|使用的传入行的值更新行的当前版本。|  
  
 一般情况下，`PreserveChanges`并`OverwriteChanges`选项适用于方案需要用来同步用户`DataSet`及其更改与主数据源。 `Upsert`选项可从一个或多个辅助数据源的聚合更改。  
  
   
  
## Examples  
 下面的示例演示了调用所涉及的问题的几个<xref:System.Data.DataTable.Load%2A>方法。 首先，该示例重点介绍架构问题，包括从加载推断架构<xref:System.Data.IDataReader>，，然后处理不兼容的架构和具有列缺失或其他列的架构。 该示例然后重点介绍数据问题，包括处理各种加载选项。  
  
> [!NOTE]
>  此示例演示如何使用的重载版本之一`Load`。 有关可用的其他示例，请参阅各个重载主题。  
  
 [!code-csharp[DataWorks DataTableLoad#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.Load" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (reader As IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader -&gt; unit" Usage="dataTable.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">提供结果集的 <see cref="T:System.Data.IDataReader" />。</param>
        <summary>通过所提供的 <see cref="T:System.Data.IDataReader" />，用某个数据源的值填充 <see cref="T:System.Data.DataTable" />。 如果 <see cref="T:System.Data.DataTable" /> 已经包含行，则从数据源传入的数据与现有行合并。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A>方法消耗的第一个结果集加载<xref:System.Data.IDataReader>，并成功完成后，将读取器的位置设置为下一个结果集，如果有的话。 转换数据时，`Load`方法使用相同的转换规则<xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType>方法。  
  
 <xref:System.Data.DataTable.Load%2A>方法必须考虑三个特定问题时加载的数据从<xref:System.Data.IDataReader>实例： 架构、 数据和事件的操作。 使用该架构时<xref:System.Data.DataTable.Load%2A>方法可能会遇到条件下表中所述。 架构操作进行的所有导入的结果集，甚至那些不包含任何数据。  
  
|条件|行为|  
|---------------|--------------|  
|<xref:System.Data.DataTable>没有架构。|<xref:System.Data.DataTable.Load%2A>方法将基于来自导入的结果集的架构推断<xref:System.Data.IDataReader>。|  
|<xref:System.Data.DataTable>拥有的架构，但它与加载的架构不兼容。|<xref:System.Data.DataTable.Load%2A>方法将引发异常时将数据加载到不兼容的架构，会出现特定错误相对应。|  
|架构兼容，但加载的结果集架构包含列中不存在<xref:System.Data.DataTable>。|<xref:System.Data.DataTable.Load%2A>方法将添加到额外的列`DataTable`的架构。 该方法将引发异常，如果相应列中的<xref:System.Data.DataTable>和加载的结果集不兼容的值。 该方法还从针对所有添加的列的结果集检索约束信息。 除了 Primary Key 约束的情况下，才使用此约束信息当前<xref:System.Data.DataTable>不包含任何在加载操作的起始列。|  
|架构兼容，但加载的结果集架构包含较少的列比`DataTable`。|如果缺少的列已定义的默认值或列的数据类型可以为 null，<xref:System.Data.DataTable.Load%2A>方法，要添加的行替换为默认值或`null`缺少的列的值。 如果没有默认值或`null`可用，则`Load`方法将引发异常。 如果未不提供任何特定的默认值，`Load`方法使用`null`暗含的默认值的值。|  
  
 考虑的行为之前`Load`方法在数据操作方面考虑，每个行内<xref:System.Data.DataTable>保留当前值和每个列的原始值。 这些值可能相同，或如果填充以来已更改行中的数据可能不同`DataTable`。  有关详细信息，请参阅[行状态和行版本](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)。  
  
 此版本的`Load`方法尝试保留在每个行中，保持不变的原始值的当前值。 (如果你想更好地控制传入数据的行为，请参阅<xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType>。)如果现有行和传入的行包含相应的主键值，使用其当前的行状态值处理行，否则它将被视为一个新行。  
  
 在事件操作方面<xref:System.Data.DataTable.RowChanging>发生更改的每一行之前, 发生的事件和<xref:System.Data.DataTable.RowChanged>事件发生后已更改的每一行。 每种情况下，<xref:System.Data.DataRowChangeEventArgs.Action%2A>属性的<xref:System.Data.DataRowChangeEventArgs>实例传递给事件处理程序包含有关与事件相关联的特定操作的信息。 此操作值取决于之前加载操作的行的状态。 每种情况下，这两个事件发生，且操作是为每个相同。 操作可以应用于当前或原始版本的每个行，或两者，具体取决于当前的行状态。  
  
 下表显示了行为`Load`方法。 最后一行 （标记为"（不提供）"） 描述不匹配任何现有行的传入行的行为。 此表中的每个单元格描述字段中某行的当前和原始值连同<xref:System.Data.DataRowState>后的值为`Load`方法完成。 在这种情况下，该方法不允许您指示加载选项，并使用默认情况下， `PreserveChanges`。  
  
|现有 DataRowState|之后的值`Load`方法和事件的操作|  
|---------------------------|--------------------------------------------------|  
|已添加|当前 =\<现有 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改原始值|  
|修改时间|当前 =\<现有 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改原始值|  
|Deleted|当前 =\<不可用 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<删除 ><br /><br /> 行操作 = 更改原始值|  
|Unchanged|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<未更改 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|  
|（不提供）|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<未更改 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|  
  
 中的值<xref:System.Data.DataColumn>可以通过使用属性如约束<xref:System.Data.DataColumn.ReadOnly%2A>和<xref:System.Data.DataColumn.AutoIncrement%2A>。 `Load`方法处理此类列与列的属性定义的行为保持一致的方式。 上的只读的约束<xref:System.Data.DataColumn>仅适用于在内存中发生的更改。 `Load`方法会覆盖的只读列的值，如果需要。  
  
 若要确定哪个版本的主键字段要用来进行比较的传入行，具有的当前行`Load`方法使用的主键值的行的原始版本，如果它存在。 否则为`Load`方法使用当前版本的主键字段。  
  
   
  
## Examples  
 下面的示例演示了调用所涉及的问题的几个<xref:System.Data.DataTable.Load%2A>方法。 首先，该示例重点介绍架构问题，包括从加载推断架构<xref:System.Data.IDataReader>，，然后处理不兼容的架构和具有列缺失或其他列的架构。 该示例然后调用`Load`方法，显示的数据之前和之后加载操作。  
  
 [!code-csharp[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption -&gt; unit" Usage="dataTable.Load (reader, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="reader">提供一个或多个结果集的 <see cref="T:System.Data.IDataReader" />。</param>
        <param name="loadOption">
          <see cref="T:System.Data.LoadOption" /> 枚举的值，指示 <see cref="T:System.Data.DataTable" /> 中已有的行如何与共享相同主键的传入行合并。</param>
        <summary>通过所提供的 <see cref="T:System.Data.IDataReader" />，用某个数据源的值填充 <see cref="T:System.Data.DataTable" />。 如果 <see langword="DataTable" /> 已包含行，则从数据源传入的数据根据 <paramref name="loadOption" /> 参数的值与现有行合并。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load`方法消耗的第一个结果集加载<xref:System.Data.IDataReader>，并成功完成后，将读取器的位置设置为下一个结果集，如果有的话。 转换数据时，`Load`方法使用相同的转换规则<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法。  
  
 `Load`方法必须考虑三个特定问题时加载的数据从<xref:System.Data.IDataReader>实例： 架构、 数据和事件的操作。 使用该架构时`Load`方法可能会遇到条件下表中所述。 架构操作进行的所有导入的结果集，甚至那些不包含任何数据。  
  
|条件|行为|  
|---------------|--------------|  
|<xref:System.Data.DataTable>没有架构。|`Load`方法将基于来自导入的结果集的架构推断<xref:System.Data.IDataReader>。|  
|<xref:System.Data.DataTable>拥有的架构，但它与加载的架构不兼容。|`Load`方法将引发异常时将数据加载到不兼容的架构，会出现特定错误相对应。|  
|架构兼容，但加载的结果集架构包含在中不存在的列`DataTable`。|`Load`方法将添加到额外的列`DataTable`的架构。 该方法将引发异常，如果相应列中的<xref:System.Data.DataTable>和加载的结果集不兼容的值。 该方法还从针对所有添加的列的结果集检索约束信息。 除了 Primary Key 约束的情况下，才使用此约束信息当前<xref:System.Data.DataTable>不包含任何在加载操作的起始列。|  
|架构兼容，但加载的结果集架构包含较少的列比`DataTable`。|如果缺少的列已定义的默认值或列的数据类型可以为 null，`Load`方法，要添加的行替换缺少的列的默认值或 null 值。 如果可以使用没有默认值或 null，则`Load`方法将引发异常。 如果未不提供任何特定的默认值，`Load`方法使用隐式的默认值为 null 值。|  
  
 考虑的行为之前`Load`方法在数据操作方面考虑，每个行内<xref:System.Data.DataTable>保留当前值和每个列的原始值。 这些值可能相同，或如果填充以来已更改行中的数据可能不同`DataTable`。 请参阅[行状态和行版本](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)有关详细信息。  
  
 在此方法调用中，指定<xref:System.Data.LoadOption>参数会影响传入数据的处理。 Load 方法应如何处理具有相同的主键作为现有行的加载行？ 它应修改当前值和 / 或原始值？ 这些问题，和的详细信息，由控制`loadOption`参数。  
  
 如果现有行和传入的行包含相应的主键值，使用其当前的行状态值处理行，否则它将被视为一个新行。  
  
 在事件操作方面<xref:System.Data.DataTable.RowChanging>发生更改的每一行之前, 发生的事件和<xref:System.Data.DataTable.RowChanged>事件发生后已更改的每一行。 每种情况下，<xref:System.Data.DataRowChangeEventArgs.Action%2A>属性的<xref:System.Data.DataRowChangeEventArgs>实例传递给事件处理程序包含有关与事件相关联的特定操作的信息。 此操作值各不相同，具体取决于之前加载操作的行的状态。 每种情况下，这两个事件发生，且操作是为每个相同。 操作可以应用于当前或原始版本的每个行，或两者，具体取决于当前的行状态。  
  
 下表显示了行为，Load 方法时使用的每个调用`LoadOption`值，并还显示这些值与要加载的行的行状态的交互方式。 最后一行 （标记为"（不提供）"） 描述不匹配任何现有行的传入行的行为。 此表中的每个单元格描述字段中某行的当前和原始值连同<xref:System.Data.DataRowState>后的值为`Load`方法完成。  
  
|现有 DataRowState|更新插入|OverwriteChanges|PreserveChanges （默认行为）|  
|---------------------------|------------|----------------------|------------------------------------------|  
|已添加|当前 =\<传入 ><br /><br /> 原始 =-\<不可用 ><br /><br /> 状态 =\<添加 ><br /><br /> 行操作 = 更改|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<未更改 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<现有 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改原始值|  
|修改时间|当前 =\<传入 ><br /><br /> 原始 =\<现有 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<未更改 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<现有 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改原始值|  
将已|（负载执行影响删除的行）<br /><br /> 当前 =--<br /><br /> 原始 =\<现有 ><br /><br /> 状态 =\<删除 ><br /><br /> （新行添加具有以下特征）<br /><br /> 当前 =\<传入 ><br /><br /> 原始 =\<不可用 ><br /><br /> 状态 =\<添加 ><br /><br /> 行操作 = 添加|撤消删除和<br /><br /> 当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<未更改 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<不可用 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<删除 ><br /><br /> 行操作 = 更改原始值|  
|Unchanged|当前 =\<传入 ><br /><br /> 原始 =\<现有 ><br /><br /> 如果新值为现有的值相同则<br /><br /> 状态 =\<未更改 ><br /><br /> 行操作 = Nothing<br /><br /> Else<br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<未更改 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<未更改 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|  
不存在）|当前 =\<传入 ><br /><br /> 原始 =\<不可用 ><br /><br /> 状态 =\<添加 ><br /><br /> 行操作 = 添加|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<未更改 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<未更改 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|  
  
 中的值<xref:System.Data.DataColumn>可以通过使用属性如约束<xref:System.Data.DataColumn.ReadOnly%2A>和<xref:System.Data.DataColumn.AutoIncrement%2A>。 `Load`方法处理此类列与列的属性定义的行为保持一致的方式。 上的只读的约束<xref:System.Data.DataColumn>仅适用于在内存中发生的更改。 `Load`方法会覆盖的只读列的值，如果需要。  
  
 如果指定的 OverwriteChanges 或 PreserveChanges 选项调用`Load`方法，则假设由来自传入数据`DataTable`的主数据源和数据表跟踪更改，可将传播所做的更改回数据源。 如果选择更新插入选项，假定数据来自其中一个辅助数据源，例如由中间层组件，可能是由用户更改提供的数据。 在这种情况下，假设是从一个或多个数据源中的目的是将数据聚合`DataTable`，然后可能将传播到主数据源的数据。 <xref:System.Data.LoadOption>参数用于确定要使用主键比较行的特定版本。 下表提供了详细信息。  
  
|加载选项|使用主键比较 DataRow 版本|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|原始版本，如果存在，否则为当前版本|  
|`PreserveChanges`|原始版本，如果存在，否则为当前版本|  
|`Upsert`|当前版本中，如果存在，否则为原始版本|  
  
   
  
## Examples  
 下面的示例演示了调用所涉及的问题的几个<xref:System.Data.DataTable.Load%2A>方法。 首先，该示例重点介绍架构问题，包括从加载推断架构<xref:System.Data.IDataReader>，，然后处理不兼容的架构和具有列缺失或其他列的架构。 该示例然后重点介绍数据问题，包括处理各种加载选项。  
  
 [!code-csharp[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit" Usage="dataTable.Load (reader, loadOption, errorHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
      </Parameters>
      <Docs>
        <param name="reader">提供结果集的 <see cref="T:System.Data.IDataReader" />。</param>
        <param name="loadOption">
          <see cref="T:System.Data.LoadOption" /> 枚举的值，指示 <see cref="T:System.Data.DataTable" /> 中已有的行如何与共享相同主键的传入行合并。</param>
        <param name="errorHandler">加载数据时出现错误的情况下要调用的 <see cref="T:System.Data.FillErrorEventHandler" /> 委托。</param>
        <summary>通过所提供的使用错误处理委托的 <see cref="T:System.Data.IDataReader" />，用某个数据源中的值填充 <see cref="T:System.Data.DataTable" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load`方法消耗的第一个结果集加载<xref:System.Data.IDataReader>，并成功完成后，将读取器的位置设置为下一个结果集，如果有的话。 转换数据时，`Load`方法使用相同的转换规则<xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType>方法。  
  
 `Load`方法必须考虑三个特定问题时加载的数据从<xref:System.Data.IDataReader>实例： 架构、 数据和事件的操作。 使用该架构时`Load`方法可能会遇到条件下表中所述。 架构操作进行的所有导入的结果集，甚至那些不包含任何数据。  
  
|条件|行为|  
|---------------|--------------|  
|<xref:System.Data.DataTable>没有架构。|`Load`方法将基于来自导入的结果集的架构推断<xref:System.Data.IDataReader>。|  
|<xref:System.Data.DataTable>拥有的架构，但它与加载的架构不兼容。|`Load`方法将引发异常时将数据加载到不兼容的架构，会出现特定错误相对应。|  
|架构兼容，但加载的结果集架构包含在中不存在的列`DataTable`。|`Load`方法将添加到的额外列`DataTable`的架构。 该方法将引发异常，如果相应列中的<xref:System.Data.DataTable>和加载的结果集不兼容的值。 该方法还从针对所有添加的列的结果集检索约束信息。 除了 Primary Key 约束的情况下，才使用此约束信息当前<xref:System.Data.DataTable>不包含任何在加载操作的起始列。|  
|架构兼容，但加载的结果集架构包含较少的列比`DataTable`。|如果缺少的列已定义的默认值或列的数据类型可以为 null，`Load`方法，要添加的行替换缺少的列的默认值或 null 值。 如果可以使用没有默认值或 null，则`Load`方法将引发异常。 如果未不提供任何特定的默认值，`Load`方法使用隐式的默认值为 null 值。|  
  
 考虑的行为之前`Load`方法在数据操作方面考虑，每个行内<xref:System.Data.DataTable>保留当前值和每个列的原始值。 这些值可能相同，或如果填充以来已更改行中的数据可能不同`DataTable`。 请参阅[行状态和行版本](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)有关详细信息。  
  
 在此方法调用中，指定<xref:System.Data.LoadOption>参数会影响传入数据的处理。 Load 方法应如何处理具有相同的主键作为现有行的加载行？ 它应修改当前值和 / 或原始值？ 这些问题，和的详细信息，由控制`loadOption`参数。  
  
 如果现有行和传入的行包含相应的主键值，使用其当前的行状态值处理行，否则它将被视为一个新行。  
  
 在事件操作方面<xref:System.Data.DataTable.RowChanging>发生更改的每一行之前, 发生的事件和<xref:System.Data.DataTable.RowChanged>事件发生后已更改的每一行。 每种情况下，<xref:System.Data.DataRowChangeEventArgs.Action%2A>属性的<xref:System.Data.DataRowChangeEventArgs>实例传递给事件处理程序包含有关与事件相关联的特定操作的信息。 此操作值各不相同，具体取决于之前加载操作的行的状态。 每种情况下，这两个事件发生，且操作是为每个相同。 操作可以应用于当前或原始版本的每个行，或两者，具体取决于当前的行状态。  
  
 下表显示了行为，Load 方法时使用的每个调用`LoadOption`值，并还显示这些值与要加载的行的行状态的交互方式。 最后一行 （标记为"（不提供）"） 描述不匹配任何现有行的传入行的行为。 此表中的每个单元格描述字段中某行的当前和原始值连同<xref:System.Data.DataRowState>后的值为`Load`方法完成。  
  
|现有 DataRowState|更新插入|OverwriteChanges|PreserveChanges （默认行为）|  
|---------------------------|------------|----------------------|------------------------------------------|  
|已添加|当前 =\<传入 ><br /><br /> 原始 =-\<不可用 ><br /><br /> 状态 =\<添加 ><br /><br /> 行操作 = 更改|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<未更改 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<现有 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改原始值|  
|修改时间|当前 =\<传入 ><br /><br /> 原始 =\<现有 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<未更改 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<现有 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改原始值|  
将已|（负载执行影响删除的行）<br /><br /> 当前 =--<br /><br /> 原始 =\<现有 ><br /><br /> 状态 =\<删除 ><br /><br /> （新行添加具有以下特征）<br /><br /> 当前 =\<传入 ><br /><br /> 原始 =\<不可用 ><br /><br /> 状态 =\<添加 ><br /><br /> 行操作 = 添加|撤消删除和<br /><br /> 当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<未更改 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<不可用 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<删除 ><br /><br /> 行操作 = 更改原始值|  
|Unchanged|当前 =\<传入 ><br /><br /> 原始 =\<现有 ><br /><br /> 如果新值为现有的值相同则<br /><br /> 状态 =\<未更改 ><br /><br /> 行操作 = Nothing<br /><br /> Else<br /><br /> 状态 =\<修改 ><br /><br /> 行操作 = 更改|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<未更改 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<未更改 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|  
不存在）|当前 =\<传入 ><br /><br /> 原始 =\<不可用 ><br /><br /> 状态 =\<添加 ><br /><br /> 行操作 = 添加|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<未更改 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|当前 =\<传入 ><br /><br /> 原始 =\<传入 ><br /><br /> 状态 =\<未更改 ><br /><br /> 行操作 = ChangeCurrentAndOriginal|  
  
 中的值<xref:System.Data.DataColumn>可以通过使用属性如约束<xref:System.Data.DataColumn.ReadOnly%2A>和<xref:System.Data.DataColumn.AutoIncrement%2A>。 `Load`方法处理此类列与列的属性定义的行为保持一致的方式。 上的只读的约束<xref:System.Data.DataColumn>仅适用于在内存中发生的更改。 `Load`方法会覆盖的只读列的值，如果需要。  
  
 如果指定的 OverwriteChanges 或 PreserveChanges 选项调用`Load`方法，则假设由来自传入数据`DataTable`的主数据源和数据表跟踪更改，可将传播所做的更改回数据源。 如果选择更新插入选项，假定数据来自其中一个辅助数据源，例如由中间层组件，可能是由用户更改提供的数据。 在这种情况下，假设是从一个或多个数据源中的目的是将数据聚合`DataTable`，然后可能将传播到主数据源的数据。 <xref:System.Data.LoadOption>参数用于确定要使用主键比较行的特定版本。 下表提供了详细信息。  
  
|加载选项|使用主键比较 DataRow 版本|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|原始版本，如果存在，否则为当前版本|  
|`PreserveChanges`|原始版本，如果存在，否则为当前版本|  
|`Upsert`|当前版本中，如果存在，否则为原始版本|  
  
 `errorHandler`参数是<xref:System.Data.FillErrorEventHandler>委托，它指的是将数据加载过程中发生错误时调用的过程。 <xref:System.Data.FillErrorEventArgs>参数传递给该过程提供了可用于检索有关所发生的错误，数据的当前行的信息的属性和<xref:System.Data.DataTable>所填充。 使用此委托机制，而不是更简单的 try/catch 块，可用于确定该错误，处理这种情况，并继续根据需要处理。 <xref:System.Data.FillErrorEventArgs>参数提供<xref:System.Data.FillErrorEventArgs.Continue%2A>属性： 将此属性设置为`true`以指示已处理错误，并且想要继续进行处理。 将属性设置为`false`以指示你想要停止处理。 请注意，将该属性设置为`false`会导致触发要引发异常的问题的代码。  
  
   
  
## Examples  
 [!code-csharp[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadDataRow">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>查找和更新特定行。 如果找不到任何匹配行，则使用给定值创建新行。</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, bool fAcceptChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, bool fAcceptChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadDataRow (values As Object(), fAcceptChanges As Boolean) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, bool fAcceptChanges);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * bool -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, fAcceptChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="fAcceptChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="values">用于创建新行的值数组。</param>
        <param name="fAcceptChanges">如果接受更改，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>查找和更新特定行。 如果找不到任何匹配行，则使用给定值创建新行。</summary>
        <returns>新的 <see cref="T:System.Data.DataRow" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.LoadDataRow%2A>方法接受值的数组，并在主键列中查找匹配值。  
  
 如果列具有默认值，在要设置该列的默认值的数组中传递 null 值。 同样，如果某一列具有其<xref:System.Data.DataColumn.AutoIncrement%2A>属性设置为 true，则要设置的行自动生成的值的数组中传递一个 null 值。  
  
 如果`fAcceptChanges`参数是`true`或未指定，会添加新数据，然后<xref:System.Data.DataTable.AcceptChanges%2A>调用以接受中的所有更改<xref:System.Data.DataTable>; 如果参数为`false`，新添加的行标记为插入操作，并对更改现有行被标记为修改。  
  
 也可在发生异常<xref:System.Data.DataTable.ColumnChanging>或<xref:System.Data.DataTable.RowChanging>事件。 如果发生异常，行是不会添加到表中。  
  
 使用<xref:System.Data.DataTable.LoadDataRow%2A>结合<xref:System.Data.DataTable.BeginLoadData%2A>和<xref:System.Data.DataTable.EndLoadData%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Data.DataTable.LoadDataRow%2A>方法来尝试找到行。 如果未不找到任何此类行，这些值用于创建新行。  
  
 [!code-csharp[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该数组大于表中的列数。</exception>
        <exception cref="T:System.InvalidCastException">值与其各自的列类型不匹配。</exception>
        <exception cref="T:System.Data.ConstraintException">添加行会使约束无效。</exception>
        <exception cref="T:System.Data.NoNullAllowedException">尝试将 null 值放到 <see cref="P:System.Data.DataColumn.AllowDBNull" /> 为 false 的列中。</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * System.Data.LoadOption -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="values">用于创建新行的值数组。</param>
        <param name="loadOption">用于确定数组值如何应用于现有行中的对应值。</param>
        <summary>查找和更新特定行。 如果找不到任何匹配行，则使用给定值创建新行。</summary>
        <returns>新的 <see cref="T:System.Data.DataRow" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.LoadDataRow%2A>方法接受值的数组，并在主键列中查找匹配值。  
  
 如果列具有默认值，在要设置该列的默认值的数组中传递 null 值。 同样，如果某一列具有其<xref:System.Data.DataColumn.AutoIncrement%2A>属性设置为 true，则要设置的行自动生成的值的数组中传递一个 null 值。  
  
 值`loadOption`参数用于确定如何将数组中的值应用到的现有行。 例如，如果`loadOption`设置为`OverwriteChanges`，则`Original`并`Current`每列的值替换为传入行中的值并`RowState`属性设置为`Unchanged`。  
  
 也可在发生异常<xref:System.Data.DataTable.ColumnChanging>或<xref:System.Data.DataTable.RowChanging>事件。 如果发生异常，行是不会添加到表中。  
  
 使用<xref:System.Data.DataTable.LoadDataRow%2A>结合<xref:System.Data.DataTable.BeginLoadData%2A>和<xref:System.Data.DataTable.EndLoadData%2A>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataTable.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableLocaleDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于比较表中字符串的区域设置信息。</summary>
        <value>一个<see cref="T:System.Globalization.CultureInfo" />，其中包含有关用户的计算机区域设置的数据。 默认值是<see cref="T:System.Data.DataSet" />对象的<see cref="T:System.Globalization.CultureInfo" />(返回由<see cref="P:System.Data.DataSet.Locale" />属性) 向其<see cref="T:System.Data.DataTable" />所属; 如果表不属于<see cref="T:System.Data.DataSet" />，默认值是当前系统<see cref="T:System.Globalization.CultureInfo" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个<xref:System.Globalization.CultureInfo>表示特定区域性或社区的软件首选项。  
  
 用于字符串比较时<xref:System.Globalization.CultureInfo>会影响排序的比较表达式和筛选。  
  
> [!NOTE]
>  包含表达式，列中的<xref:System.StringComparison.InvariantCulture>使用。 <xref:System.StringComparison.CurrentCulture>将被忽略。  
  
   
  
## Examples  
 下面的示例设置<xref:System.Globalization.CultureInfo>通过<xref:System.Data.DataTable.Locale%2A>并输出的 ISO 语言名称。  
  
 [!code-csharp[Classic WebData DataTable.Locale Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将指定的 <see cref="T:System.Data.DataTable" /> 与当前 <see cref="T:System.Data.DataTable" /> 合并。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Merge`方法用于合并两个<xref:System.Data.DataTable>具有很大程度上类似的架构的对象。 合并通常用于在客户端应用程序上，若要从数据源的最新更改合并到现有<xref:System.Data.DataTable>。 这样，客户端应用程序能够刷新<xref:System.Data.DataTable>数据源的最新的数据。  
  
 合并操作将考虑在内，仅对原始表，并要合并的表。 不受影响或包含子表。 如果表具有一个或多个关系的一部分定义的子表必须单独合并每个子表。  
  
   
  
## Examples  
 以下控制台应用程序演示的行为`missingSchemaAction`参数的<xref:System.Data.DataTable.Merge%2A>方法。 此示例创建两个版本的同一个表，修改第二个版本的架构。 然后，代码尝试将第二个表合并到第一个。  
  
> [!NOTE]
>  此示例演示如何使用合并的重载版本之一。 有关可用的其他示例，请参阅各个重载主题。  
  
 [!code-csharp[DataWorks DataTableMergeOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableMergeOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataTable.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">要与当前 <see cref="T:System.Data.DataTable" /> 合并的 <see cref="T:System.Data.DataTable" />。</param>
        <summary>将指定的 <see cref="T:System.Data.DataTable" /> 与当前 <see cref="T:System.Data.DataTable" /> 合并。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Merge 方法用于合并两个<xref:System.Data.DataTable>具有很大程度上类似的架构的对象。 合并通常用于在客户端应用程序上，若要从数据源的最新更改合并到现有<xref:System.Data.DataTable>。 这样，客户端应用程序能够刷新<xref:System.Data.DataTable>数据源的最新的数据。  
  
 合并操作将考虑在内，仅对原始表，并要合并的表。 不受影响或包含子表。 如果表具有一个或多个关系的一部分定义的子表必须单独合并每个子表。  
  
 `Merge`通常在一系列过程涉及验证更改、 协调错误、 所做的更改，使用更新数据源和最后刷新现有的末尾调用方法<xref:System.Data.DataTable>。  
  
 在执行合并，在合并前的现有数据所做的更改是合并操作过程中保留默认情况下。 开发人员可以通过调用其他两个重载之一针对此方法，并指定为返回值为 false 来修改此行为`preserveChanges`参数。  
  
 在客户端应用程序，它是通常有一个按钮，用户可以单击它来收集已更改的数据并将其发送回中间层组件之前对它进行验证。 在此方案中，<xref:System.Data.DataTable.GetChanges%2A>第一次调用方法。 方法返回第二个<xref:System.Data.DataTable>优化为验证和合并。 在这一秒<xref:System.Data.DataTable>对象只包含<xref:System.Data.DataRow>发生更改，从而导致原始的子集的对象<xref:System.Data.DataTable>。 此子集通常较小，因此可以更有效地传递回中间层组件。 然后，中间层组件使用通过存储过程所做的更改更新原始数据源。 然后，中间层可以发送回一个新<xref:System.Data.DataTable>（通过再次运行原始查询），包括原始数据和数据源中的最新数据或者它可以发送回包含从数据源对其进行任何更改的子集。 （例如，如果数据源自动创建唯一的主键值，这些值可以将传播回客户端应用程序。）在任一情况下，返回<xref:System.Data.DataTable>可以合并回客户端应用程序的原始<xref:System.Data.DataTable>与<xref:System.Data.DataTable.Merge%2A>方法。  
  
 合并新的源时<xref:System.Data.DataTable>到目标中时，任何源行与<xref:System.Data.DataRowState>的值`Unchanged`， `Modified`，或`Deleted`，与具有相同的主键值的目标行匹配。 源的行<xref:System.Data.DataRowState>的值`Added`与同一个作为新的源行的主键值的新目标行匹配。  
  
   
  
## Examples  
 以下控制台应用程序创建一个简单<xref:System.Data.DataTable>并将数据添加到表。 然后，示例创建表，将行添加到该副本的副本。 最后，该示例调用<xref:System.Data.DataTable.Merge%2A>方法合并第二个表中的第一个表中的数据的数据。  
  
 [!code-csharp[DataWorks DataTable.Merge#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.Merge#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable, preserveChanges As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool -&gt; unit" Usage="dataTable.Merge (table, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="table">要与当前 <see langword="DataTable" /> 合并的 <see langword="DataTable" />。</param>
        <param name="preserveChanges">如果保留当前 <see langword="DataTable" /> 中的更改，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>将指定的 <see cref="T:System.Data.DataTable" /> 与当前 <see langword="DataTable" /> 合并，指示是否保留当前 <see langword="DataTable" /> 中的更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Merge 方法用于合并两个<xref:System.Data.DataTable>具有很大程度上类似的架构的对象。 合并通常用于在客户端应用程序上，若要从数据源的最新更改合并到现有<xref:System.Data.DataTable>。 这样，客户端应用程序能够刷新<xref:System.Data.DataTable>数据源的最新的数据。  
  
 合并操作将考虑在内，仅对原始表，并要合并的表。 不受影响或包含子表。 如果表具有一个或多个关系的一部分定义的子表必须单独合并每个子表。  
  
 `Merge`通常在一系列过程涉及验证更改、 协调错误、 所做的更改，使用更新数据源和最后刷新现有的末尾调用方法<xref:System.Data.DataTable>。  
  
 除非开发人员指定为 false 时执行合并，在合并前的现有数据所做的更改合并操作过程中保留`preserveChanges`参数。 如果`preserveChanges`参数设置为`true`，传入值不会覆盖现有行的当前行版本中的现有值。 如果`preserveChanges`参数设置为`false`，传入值将覆盖现有行的当前行版本中的现有值。 有关行版本的详细信息，请参阅[行状态和行版本](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)。  
  
 在客户端应用程序，它是通常有一个按钮，用户可以单击它来收集已更改的数据并将其发送回中间层组件之前对它进行验证。 在此方案中，<xref:System.Data.DataTable.GetChanges%2A>第一次调用方法。 方法返回第二个<xref:System.Data.DataTable>优化为验证和合并。 在这一秒<xref:System.Data.DataTable>对象只包含<xref:System.Data.DataTable>并<xref:System.Data.DataRow>发生更改，从而导致原始的子集的对象<xref:System.Data.DataTable>。 此子集是通常较小，因此此子集更有效地传递回中间层组件。 然后，中间层组件使用通过存储过程所做的更改更新原始数据源。 然后，中间层可以发送回一个新<xref:System.Data.DataTable>（通过再次运行原始查询），包括原始数据和数据源中的最新数据或者它可以发送回包含从数据源对其进行任何更改的子集。 （例如，如果数据源自动创建唯一的主键值，这些值可以将传播回客户端应用程序。）在任一情况下，返回<xref:System.Data.DataTable>可以合并回客户端应用程序的原始<xref:System.Data.DataTable>与<xref:System.Data.DataTable.Merge%2A>方法。  
  
 合并新的源时<xref:System.Data.DataTable>到目标中时，任何源行与<xref:System.Data.DataRowState>的值`Unchanged`， `Modified`，或`Deleted`与具有相同的主键值的目标行匹配。 源的行<xref:System.Data.DataRowState>的值`Added`与同一个作为新的源行的主键值的新目标行匹配。  
  
   
  
## Examples  
 以下控制台应用程序创建<xref:System.Data.DataTable>其中包含的行，修改某些数据的行，并尝试合并来自不同的数据<xref:System.Data.DataTable>。 示例演示了为不同的行为`preserveChanges`参数。  
  
 [!code-csharp[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataTable.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">要与当前 <see cref="T:System.Data.DataTable" /> 合并的 <see cref="T:System.Data.DataTable" />。</param>
        <param name="preserveChanges">如果保留当前 <see cref="T:System.Data.DataTable" /> 中的更改，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <param name="missingSchemaAction">
          <see cref="T:System.Data.MissingSchemaAction" /> 值之一。</param>
        <summary>将指定的 <see cref="T:System.Data.DataTable" /> 与当前 <see langword="DataTable" /> 合并，指示是否保留更改以及如何处理当前 <see langword="DataTable" /> 中缺失的架构。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Merge`方法用于合并两个<xref:System.Data.DataTable>具有很大程度上类似的架构的对象。 合并通常用于在客户端应用程序上，若要从数据源的最新更改合并到现有<xref:System.Data.DataTable>。 这样，客户端应用程序能够刷新<xref:System.Data.DataTable>数据源的最新的数据。  
  
 合并操作将考虑在内，仅对原始表，并要合并的表。 不受影响或包含子表。 如果表具有一个或多个关系的一部分定义的子表必须单独合并每个子表。  
  
 `Merge`通常在一系列过程涉及验证更改、 协调错误、 所做的更改，使用更新数据源和最后刷新现有的末尾调用方法<xref:System.Data.DataTable>。  
  
 除非开发人员指定为 false 时执行合并，在合并前的现有数据所做的更改合并操作过程中保留`preserveChanges`参数。 如果`preserveChanges`参数设置为`true`，传入值不会覆盖现有行的当前行版本中的现有值。 如果`preserveChanges`参数设置为`false`，传入值将覆盖现有行的当前行版本中的现有值。 有关行版本的详细信息，请参阅[行状态和行版本](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)。  
  
 在客户端应用程序，它是通常有一个按钮，用户可以单击它来收集已更改的数据并将其发送回中间层组件之前对它进行验证。 在此方案中，<xref:System.Data.DataTable.GetChanges%2A>第一次调用方法。 方法返回第二个<xref:System.Data.DataTable>优化为验证和合并。 在这一秒<xref:System.Data.DataTable>对象只包含<xref:System.Data.DataTable>并<xref:System.Data.DataRow>发生更改，从而导致原始的子集的对象<xref:System.Data.DataTable>。 此子集是通常较小，因此此子集更有效地传递回中间层组件。 然后，中间层组件使用通过存储过程所做的更改更新原始数据源。 然后，中间层可以发送回一个新<xref:System.Data.DataTable>（通过再次运行原始查询），包括原始数据和数据源中的最新数据或者它可以发送回包含从数据源对其进行任何更改的子集。 （例如，如果数据源自动创建唯一的主键值，这些值可以将传播回客户端应用程序。）在任一情况下，返回<xref:System.Data.DataTable>可以合并回客户端应用程序的原始<xref:System.Data.DataTable>与<xref:System.Data.DataTable.Merge%2A>方法。  
  
 当<xref:System.Data.DataTable.Merge%2A>调用方法时，两个架构<xref:System.Data.DataTable>对象进行了比较，因为它是可能的架构可能已更改。 例如，在企业到企业方案中，新列可能具有已添加到 XML 架构的自动化过程。 如果源<xref:System.Data.DataTable>包含架构元素 (添加<xref:System.Data.DataColumn>对象) 缺少目标中，架构元素可以通过设置添加到目标`missingSchemaAction`参数`MissingSchemaAction.Add`。 在这种情况下，合并<xref:System.Data.DataTable>包含添加的架构和数据。  
  
 合并后的架构，则数据将合并。  
  
 合并新的源时<xref:System.Data.DataTable>到目标中时，任何源行与<xref:System.Data.DataRowState>的值`Unchanged`， `Modified`，或`Deleted`与具有相同的主键值的目标行匹配。 源的行<xref:System.Data.DataRowState>的值`Added`与同一个作为新的源行的主键值的新目标行匹配。  
  
   
  
## Examples  
 以下控制台应用程序演示的行为`missingSchemaAction`参数的<xref:System.Data.DataTable.Merge%2A>方法。 此示例创建两个版本的同一个表，修改第二个版本的架构。 然后，代码尝试将第二个表合并到第一个。  
  
 [!code-csharp[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="MinimumCapacity">
      <MemberSignature Language="C#" Value="public int MinimumCapacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.MinimumCapacity" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimumCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumCapacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumCapacity : int with get, set" Usage="System.Data.DataTable.MinimumCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(50)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableMinimumCapacityDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置该表最初的起始大小。</summary>
        <value>在此表的行中最初起始大小。 默认值为 50。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.MinimumCapacity%2A>允许系统提取数据之前创建一组适当的资源。 在这种情况时性能很重要，设置此属性可优化性能。  
  
   
  
## Examples  
 下面的示例设置<xref:System.Data.DataTable.MinimumCapacity%2A>的<xref:System.Data.DataTable>。  
  
 [!code-csharp[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataTable.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableNamespaceDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Data.DataTable" /> 中所存储数据的 XML 表示形式的命名空间。</summary>
        <value>
          <see cref="T:System.Data.DataTable" /> 的命名空间。</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow NewRow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow NewRow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRow" />
      <MemberSignature Language="VB.NET" Value="Public Function NewRow () As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ NewRow();" />
      <MemberSignature Language="F#" Value="member this.NewRow : unit -&gt; System.Data.DataRow" Usage="dataTable.NewRow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建与该表具有相同架构的新 <see cref="T:System.Data.DataRow" />。</summary>
        <returns>与 <see cref="T:System.Data.DataTable" /> 具有相同架构的 <see cref="T:System.Data.DataRow" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须使用<xref:System.Data.DataTable.NewRow%2A>方法来创建新<xref:System.Data.DataRow>具有相同的架构对象<xref:System.Data.DataTable>。 在创建后<xref:System.Data.DataRow>，你可以将其添加到<xref:System.Data.DataRowCollection>，通过<xref:System.Data.DataTable>对象的<xref:System.Data.DataTable.Rows%2A>属性。 当你使用<xref:System.Data.DataTable.NewRow%2A>若要创建新行，行必须添加到或从数据表中删除然后再调用<xref:System.Data.DataTable.Clear%2A>。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.DataTable>，添加两个<xref:System.Data.DataColumn>对象，以确定表的架构和创建多个新<xref:System.Data.DataRow>对象使用<xref:System.Data.DataTable.NewRow%2A>方法。 那些<xref:System.Data.DataRow>随后将对象添加到<xref:System.Data.DataRowCollection>使用<xref:System.Data.DataRowCollection.Add%2A>方法。  
  
 [!code-csharp[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="NewRowArray">
      <MemberSignature Language="C#" Value="protected internal System.Data.DataRow[] NewRowArray (int size);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Data.DataRow[] NewRowArray(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowArray(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function NewRowArray (size As Integer) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ NewRowArray(int size);" />
      <MemberSignature Language="F#" Value="member this.NewRowArray : int -&gt; System.Data.DataRow[]" Usage="dataTable.NewRowArray size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">描述数组大小的 <see cref="T:System.Int32" /> 值。</param>
        <summary>返回 <see cref="T:System.Data.DataRow" /> 的数组。</summary>
        <returns>新数组。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowFromBuilder">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataRow NewRowFromBuilder (System.Data.DataRowBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataRow NewRowFromBuilder(class System.Data.DataRowBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewRowFromBuilder (builder As DataRowBuilder) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataRow ^ NewRowFromBuilder(System::Data::DataRowBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="abstract member NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow&#xA;override this.NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow" Usage="dataTable.NewRowFromBuilder builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Data.DataRowBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">一个 <see cref="T:System.Data.DataRowBuilder" /> 对象。</param>
        <summary>从现有行创建新行。</summary>
        <returns>
          <see cref="T:System.Data.DataRow" /> 派生类。</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanged (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanged(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanged (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanged(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Data.DataColumnChangeEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Data.DataTable.ColumnChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写时<see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />在派生类中，请务必调用基类的<see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />方法。</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanging">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanging (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanging(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanging (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanging(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Data.DataColumnChangeEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Data.DataTable.ColumnChanging" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写时<see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />在派生类中，请务必调用基类的<see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />方法。</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataTable.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">包含事件数据的 <see cref="T:System.ComponentModel.PropertyChangedEventArgs" />。</param>
        <summary>引发 <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写时<see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />在派生类中，请务必调用基类的<see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />方法。</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveColumn">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveColumn (System.Data.DataColumn column);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveColumn(class System.Data.DataColumn column) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveColumn (column As DataColumn)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveColumn(System::Data::DataColumn ^ column);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveColumn : System.Data.DataColumn -&gt; unit&#xA;override this.OnRemoveColumn : System.Data.DataColumn -&gt; unit" Usage="dataTable.OnRemoveColumn column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="column" Type="System.Data.DataColumn" />
      </Parameters>
      <Docs>
        <param name="column">正在移除的 <see cref="T:System.Data.DataColumn" />。</param>
        <summary>通知 <see cref="T:System.Data.DataTable" /> 正在移除 <see cref="T:System.Data.DataColumn" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关详细信息，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写时<see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />在派生类中，请务必调用基类的<see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />方法。</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanged (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanged(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanged (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanged(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Data.DataRowChangeEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Data.DataTable.RowChanged" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写时<see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />在派生类中，请务必调用基类的<see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />方法。</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanging (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanging(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanging (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanging(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Data.DataRowChangeEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Data.DataTable.RowChanging" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写时<see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />在派生类中，请务必调用基类的<see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />方法。</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleted (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleted(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleted (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleted(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Data.DataRowChangeEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Data.DataTable.RowDeleted" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写时<see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />在派生类中，请务必调用基类的<see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />方法。</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleting (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleting(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleting (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleting(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Data.DataRowChangeEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Data.DataTable.RowDeleting" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写时<see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />在派生类中，请务必调用基类的<see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />方法。</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="OnTableCleared">
      <MemberSignature Language="C#" Value="protected virtual void OnTableCleared (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableCleared(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableCleared (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableCleared(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableCleared e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Data.DataTableClearEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Data.DataTable.TableCleared" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将引发<xref:System.Data.DataTable.TableCleared>事件，成功之前清除所有行后将立即激发<xref:System.Data.DataTable.Clear%2A>方法将控制返回给调用方。  
  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="OnTableClearing">
      <MemberSignature Language="C#" Value="protected virtual void OnTableClearing (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableClearing(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableClearing (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableClearing(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableClearing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Data.DataTableClearEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Data.DataTable.TableClearing" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将引发<xref:System.Data.DataTable.TableClearing>事件，在处理之前触发<xref:System.Data.DataTable.Clear%2A>开始操作。  
  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="OnTableNewRow">
      <MemberSignature Language="C#" Value="protected virtual void OnTableNewRow (System.Data.DataTableNewRowEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableNewRow(class System.Data.DataTableNewRowEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableNewRow (e As DataTableNewRowEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableNewRow(System::Data::DataTableNewRowEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit&#xA;override this.OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit" Usage="dataTable.OnTableNewRow e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableNewRowEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Data.DataTableNewRowEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Data.DataTable.TableNewRow" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将引发<xref:System.Data.DataTable.TableNewRow>触发的事件后一个新,<xref:System.Data.DataRow>尚未使用创建<xref:System.Data.DataTable.NewRow%2A>。  
  
 引发事件时，将通过委托调用事件处理程序。 有关概述，请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="ParentRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ParentRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ParentRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ParentRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ParentRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ParentRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableParentRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该 <see cref="T:System.Data.DataTable" /> 的父关系的集合。</summary>
        <value>一个<see cref="T:System.Data.DataRelationCollection" />，包含该表的父关系。 如果没有，则返回空集合<see cref="T:System.Data.DataRelation" />存在的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例使用<xref:System.Data.DataTable.ParentRelations%2A>属性以返回每个父级<xref:System.Data.DataRelation>中<xref:System.Data.DataTable>。 每个关系然后用作中的自变量<xref:System.Data.DataRow.GetParentRows%2A>方法的<xref:System.Data.DataRow>若要返回的行的数组。 然后打印的行中的每个列的值。  
  
 [!code-csharp[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ChildRelations" />
        <altmember cref="T:System.Data.DataRelation" />
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Relations" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataTable.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTablePrefixDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Data.DataTable" /> 中所存储数据的 XML 表示形式的命名空间。</summary>
        <value>前缀<see cref="T:System.Data.DataTable" />。</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="PrimaryKey">
      <MemberSignature Language="C#" Value="public System.Data.DataColumn[] PrimaryKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumn[] PrimaryKey" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.PrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrimaryKey As DataColumn()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::DataColumn ^&gt; ^ PrimaryKey { cli::array &lt;System::Data::DataColumn ^&gt; ^ get(); void set(cli::array &lt;System::Data::DataColumn ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrimaryKey : System.Data.DataColumn[] with get, set" Usage="System.Data.DataTable.PrimaryKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Data.PrimaryKeyTypeConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTablePrimaryKeyDescr")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumn[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用作数据表主键的列数组。</summary>
        <value>一个 <see cref="T:System.Data.DataColumn" /> 对象数组。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表的主键必须是唯一标识表中的记录。 还有可能获得的表具有主键的两个或多个列组成。 当单个列不能包含足够的唯一值时，将发生这种情况。 例如，"FirstName"和"LastName"列可能包含两个列的主键。 因为主键可以由构成的多个列，<xref:System.Data.DataTable.PrimaryKey%2A>属性包含的数组<xref:System.Data.DataColumn>对象。  
  
   
  
## Examples  
 第一个示例演示如何返回主键列<xref:System.Data.DataTable>中显示`DataGrid`。 第二个示例演示如何设置主键列<xref:System.Data.DataTable>。  
  
 [!code-csharp[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DataException">该键是外键。</exception>
        <altmember cref="T:System.Data.DataColumn" />
        <altmember cref="P:System.Data.DataTable.PrimaryKey" />
        <altmember cref="T:System.Data.DataColumnCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 XML 架构和数据读入 <see cref="T:System.Data.DataTable" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.ReadXml%2A>方法提供方法来读取只将数据或数据和架构读入<xref:System.Data.DataTable>从 XML 文档，而<xref:System.Data.DataTable.ReadXmlSchema%2A>方法读取仅架构。 若要读取数据和架构，使用之一`ReadXML`包括的重载`XmlReadMode`参数，并将其值设置为`ReadSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.WriteXml%2A>和<xref:System.Data.DataTable.WriteXmlSchema%2A>方法，分别。 若要写入 XML 数据或架构和数据从`DataTable`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXml" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">从 <see cref="T:System.IO.Stream" /> 派生的对象</param>
        <summary>使用指定的 <see cref="T:System.IO.Stream" /> 将 XML 架构和数据读入 <see cref="T:System.Data.DataTable" />。</summary>
        <returns>用于读取数据的 <see cref="T:System.Data.XmlReadMode" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前<xref:System.Data.DataTable>及其子代加载与所提供的数据<xref:System.IO.Stream>。 此方法的行为是相同的<xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType>仅为当前表及其子代加载方法，这在这种情况下，数据除外。  
  
 <xref:System.Data.DataTable.ReadXml%2A>方法提供方法来读取只将数据或数据和架构读入<xref:System.Data.DataTable>从 XML 文档，而<xref:System.Data.DataTable.ReadXmlSchema%2A>方法读取仅架构。  
  
 请注意，同样适用于<xref:System.Data.DataTable.WriteXml%2A>和<xref:System.Data.DataTable.WriteXmlSchema%2A>方法，分别。 若要写入 XML 数据或架构和数据从`DataTable`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定内联架构，则内联架构用于扩展现有的关系结构之前加载数据。 如果不存在任何冲突 （例如，具有不同数据类型定义的同一表中的同一列） 被引发异常。  
  
 如果指定没有行中的架构，则关系的结构推断，必要时，通过扩展根据 XML 文档的结构。 如果不能通过推断扩展架构，以便公开的所有数据，将引发异常。  
  
> [!NOTE]
>  `DataSet`不会将一个 XML 元素关联与其对应`DataColumn`或`DataTable`合法 XML 字符，如 ("_") 在序列化的 XML 中的转义时。 `DataSet`本身仅对 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.DataTable>包含两个列、 十行。 该示例将写入<xref:System.Data.DataTable>架构和数据写入内存流，通过调用<xref:System.Data.DataTable.WriteXml%2A>方法。 此示例将创建第二个<xref:System.Data.DataTable>，并调用<xref:System.Data.DataTable.ReadXml%2A>方法来填充具有架构和数据。  
  
 [!code-csharp[DataWorks DataTable.ReadXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">将用于读取数据的 <see cref="T:System.IO.TextReader" />。</param>
        <summary>使用指定的 <see cref="T:System.IO.TextReader" /> 将 XML 架构和数据读入 <see cref="T:System.Data.DataTable" />。</summary>
        <returns>用于读取数据的 <see cref="T:System.Data.XmlReadMode" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前<xref:System.Data.DataTable>及其子代加载与所提供的数据<xref:System.IO.TextReader>。 此方法的行为是相同的<xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType>仅为当前表及其子代加载方法，这在这种情况下，数据除外。  
  
 <xref:System.Data.DataTable.ReadXml%2A>方法提供方法来读取只将数据或数据和架构读入<xref:System.Data.DataTable>从 XML 文档，而<xref:System.Data.DataTable.ReadXmlSchema%2A>方法读取仅架构。  
  
 请注意，同样适用于<xref:System.Data.DataTable.WriteXml%2A>和<xref:System.Data.DataTable.WriteXmlSchema%2A>方法，分别。 若要写入 XML 数据或架构和数据从`DataTable`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定内联架构，则内联架构用于扩展现有的关系结构之前加载数据。 如果不存在任何冲突 （例如，具有不同数据类型定义的同一表中的同一列） 被引发异常。  
  
 如果指定没有行中的架构，则关系的结构推断，必要时，通过扩展根据 XML 文档的结构。 如果不能通过推断扩展架构，以便公开的所有数据，将引发异常。  
  
> [!NOTE]
>  `DataSet`不会将一个 XML 元素关联与其对应`DataColumn`或`DataTable`合法 XML 字符，如 ("_") 在序列化的 XML 中的转义时。 `DataSet`本身仅对 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.DataTable>包含两个列、 十行。 该示例将写入<xref:System.Data.DataTable>架构和数据写入内存流，通过调用<xref:System.Data.DataTable.WriteXml%2A>方法。 此示例将创建第二个<xref:System.Data.DataTable>，并调用<xref:System.Data.DataTable.ReadXml%2A>方法来填充具有架构和数据。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">从中读取数据的文件的名称。</param>
        <summary>从指定的文件将 XML 架构和数据读入 <see cref="T:System.Data.DataTable" />。</summary>
        <returns>用于读取数据的 <see cref="T:System.Data.XmlReadMode" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前<xref:System.Data.DataTable>及其子代加载中提供命名的文件中的数据<xref:System.String>。 此方法的行为是相同的<xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType>仅为当前表及其子代加载方法，这在这种情况下，数据除外。  
  
 <xref:System.Data.DataTable.ReadXml%2A>方法提供方法来读取只将数据或数据和架构读入<xref:System.Data.DataTable>从 XML 文档，而<xref:System.Data.DataTable.ReadXmlSchema%2A>方法读取仅架构。  
  
 请注意，同样适用于<xref:System.Data.DataTable.WriteXml%2A>和<xref:System.Data.DataTable.WriteXmlSchema%2A>方法，分别。 若要写入 XML 数据或架构和数据从`DataTable`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定内联架构，则内联架构用于扩展现有的关系结构之前加载数据。 如果不存在任何冲突 （例如，具有不同数据类型定义的同一表中的同一列） 被引发异常。  
  
 如果指定没有行中的架构，则关系的结构推断，必要时，通过扩展根据 XML 文档的结构。 如果不能通过推断扩展架构，以便公开的所有数据，将引发异常。  
  
> [!NOTE]
>  `DataSet`不会将一个 XML 元素关联与其对应`DataColumn`或`DataTable`合法 XML 字符，如 ("_") 在序列化的 XML 中的转义时。 `DataSet`本身仅对 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。  
  
```csharp  
using System.Data;  
public class A {  
   static void Main(string[] args) {  
      DataTable tabl = new DataTable("mytable");  
      tabl.Columns.Add(new DataColumn("id", typeof(int)));  
      for (int i = 0; i < 10; i++) {  
         DataRow row = tabl.NewRow();  
         row["id"] = i;  
         tabl.Rows.Add(row);  
      }  
      tabl.WriteXml("f.xml", XmlWriteMode.WriteSchema);  
      DataTable newt = new DataTable();  
      newt.ReadXml("f.xml");  
   }  
}  
```  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.DataTable>包含两个列、 十行。 该示例将写入<xref:System.Data.DataTable>架构和数据保存到磁盘。 此示例将创建第二个<xref:System.Data.DataTable>，并调用<xref:System.Data.DataTable.ReadXml%2A>方法来填充具有架构和数据。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">将用于读取数据的 <see cref="T:System.Xml.XmlReader" />。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlReader" /> 将 XML 架构和数据读入 <see cref="T:System.Data.DataTable" />。</summary>
        <returns>用于读取数据的 <see cref="T:System.Data.XmlReadMode" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前<xref:System.Data.DataTable>及其子代加载中提供命名的文件中的数据<xref:System.Xml.XmlReader>。 此方法的行为是相同的<xref:System.Data.DataTable.ReadXml%2A>仅为当前表及其子代加载方法，这在这种情况下，数据除外。  
  
 <xref:System.Data.DataTable.ReadXml%2A>方法提供方法来读取只将数据或数据和架构读入<xref:System.Data.DataTable>从 XML 文档，而<xref:System.Data.DataTable.ReadXmlSchema%2A>方法读取仅架构。  
  
 请注意，同样适用于<xref:System.Data.DataTable.WriteXml%2A>和<xref:System.Data.DataTable.WriteXmlSchema%2A>方法，分别。 若要写入 XML 数据或架构和数据从`DataTable`，使用`WriteXml`方法。 若要编写只为架构，使用`WriteXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果指定内联架构，则内联架构用于扩展现有的关系结构之前加载数据。 如果不存在任何冲突 （例如，具有不同数据类型定义的同一表中的同一列） 被引发异常。  
  
 如果指定没有行中的架构，则关系的结构推断，必要时，通过扩展根据 XML 文档的结构。 如果不能通过推断扩展架构，以便公开的所有数据，将引发异常。  
  
> [!NOTE]
>  `DataSet`不会将一个 XML 元素关联与其对应`DataColumn`或`DataTable`合法 XML 字符，如 ("_") 在序列化的 XML 中的转义时。 `DataSet`本身仅对 XML 元素名称中的非法 XML 字符进行转义，因此只能使用相同。 当 XML 元素名称中的合法字符进行转义时，处理时将忽略该元素。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Data.DataTable>包含两个列、 十行。 该示例将写入<xref:System.Data.DataTable>架构和数据到<xref:System.Xml.XmlReader>。 此示例将创建第二个<xref:System.Data.DataTable>，并调用<xref:System.Data.DataTable.ReadXml%2A>方法来填充具有架构和数据从<xref:System.Xml.XmlReader>实例。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 XML 架构读入 <see cref="T:System.Data.DataTable" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`ReadXmlSchema`方法创建的架构<xref:System.Data.DataTable>。 此架构包含表、 关系和约束定义。  
  
 若要写入的 XML 文档架构，请使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法。  
  
 XML 架构是根据标准 XSD 进行解释。  
  
 `ReadXmlSchema`通常在调用前调用方法<xref:System.Data.DataTable.ReadXml%2A>方法用于填充<xref:System.Data.DataTable>。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXmlSchema" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">用于读取架构的流。</param>
        <summary>使用指定的流将 XML 架构读入 <see cref="T:System.Data.DataTable" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.ReadXmlSchema%2A>方法创建的架构<xref:System.Data.DataTable>。 此架构包含表、 关系和约束定义。  
  
 若要写入的 XML 文档架构，请使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法。  
  
 XML 架构是根据标准 XSD 进行解释。  
  
 如果 msdata:DataType 和 xs: type 类型不匹配，则会发生数据损坏。 将不引发任何异常。  
  
 `ReadXmlSchema`通常在调用前调用方法<xref:System.Data.DataTable.ReadXml%2A>方法用于填充<xref:System.Data.DataTable>。  
  
 若要创建使用 XML 架构的嵌套的关系，使用隐式的嵌套的元素。 此外可以配置要使用显式的列名称的嵌套的关系。 元素必须隐式嵌套在相应的 DataTables 参与嵌套关系的顺序。  
  
   
  
## Examples  
 以下控制台应用程序创建一个新<xref:System.Data.DataTable>，并将写入到该表的架构<xref:System.IO.MemoryStream>。 然后，该示例创建一个新<xref:System.Data.DataTable>并从保存的 XML 架构中读取其架构。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">用于读取架构信息的 <see cref="T:System.IO.TextReader" />。</param>
        <summary>使用指定的 <see cref="T:System.IO.TextReader" /> 将 XML 架构读入 <see cref="T:System.Data.DataTable" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.ReadXmlSchema%2A>方法创建的架构<xref:System.Data.DataTable>。 此架构包含表、 关系和约束定义。  
  
 若要写入的 XML 文档架构，请使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法。  
  
 XML 架构是根据标准 XSD 进行解释。  
  
 如果 msdata:DataType 和 xs: type 类型不匹配，则会发生数据损坏。 将不引发任何异常。  
  
 `ReadXmlSchema`通常在调用前调用方法<xref:System.Data.DataTable.ReadXml%2A>方法用于填充<xref:System.Data.DataTable>。  
  
 若要创建使用 XML 架构的嵌套的关系，使用隐式的嵌套的元素。 此外可以重新配置要使用显式的列名称的嵌套的关系。 元素必须隐式嵌套在相应的 DataTables 参与嵌套关系的顺序。  
  
   
  
## Examples  
 以下控制台应用程序创建一个新<xref:System.Data.DataTable>，并将写入到该表的架构<xref:System.IO.MemoryStream>。 然后，该示例创建一个新<xref:System.Data.DataTable>并从保存的 XML 架构，读取其架构使用<xref:System.IO.StreamReader>(它是从<xref:System.IO.TextReader>) 作为其源。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataTable.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">从中读取架构信息的文件的名称。</param>
        <summary>从指定的文件将 XML 架构读入 <see cref="T:System.Data.DataTable" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.ReadXmlSchema%2A>方法创建的架构<xref:System.Data.DataTable>。 此架构包含表、 关系和约束定义。  
  
 若要写入的 XML 文档架构，请使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法。  
  
 XML 架构是根据标准 XSD 进行解释。  
  
 如果 msdata:DataType 和 xs: type 类型不匹配，则会发生数据损坏。 将不引发任何异常。  
  
 `ReadXmlSchema`通常在调用前调用方法<xref:System.Data.DataTable.ReadXml%2A>方法用于填充`DataTable`。  
  
 若要创建使用 XML 架构的嵌套的关系，使用隐式的嵌套的元素。 此外可以重新配置要使用显式的列名称的嵌套的关系。 元素必须隐式嵌套在相应的 DataTables 参与嵌套关系的顺序。  
  
   
  
## Examples  
 以下控制台应用程序创建一个新<xref:System.Data.DataTable>，并将该表的架构写入文件。 然后，该示例创建一个新<xref:System.Data.DataTable>而且从保存的 XML 架构，读取其架构作为其源使用的文件。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">用于读取架构信息的 <see cref="T:System.Xml.XmlReader" />。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlReader" /> 将 XML 架构读入 <see cref="T:System.Data.DataTable" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.ReadXmlSchema%2A>方法创建的架构<xref:System.Data.DataTable>。 此架构包含表、 关系和约束定义。  
  
 若要写入的 XML 文档架构，请使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法。  
  
 XML 架构是根据标准 XSD 进行解释。  
  
 如果 msdata:DataType 和 xs: type 类型不匹配，则会发生数据损坏。 将不引发任何异常。  
  
 `ReadXmlSchema`通常在调用前调用方法<xref:System.Data.DataTable.ReadXml%2A>方法用于填充<xref:System.Data.DataTable>。  
  
> [!NOTE]
>  若要创建使用 XML 架构的嵌套的关系的方法是隐式嵌套元素。 此外，将嵌套的关系可以是重新配置为使用显式的列名称。 它是必需的元素针对相应的 Datatable 中的嵌套关系参与隐式嵌套。  
  
   
  
## Examples  
 以下控制台应用程序创建一个新<xref:System.Data.DataTable>，并将写入到该表的架构<xref:System.IO.MemoryStream>。 然后，该示例创建一个新<xref:System.Data.DataTable>并从保存的 XML 架构，读取其架构使用<xref:System.Xml.XmlTextReader>(它是从<xref:System.Xml.XmlReader>) 作为其源。  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">一个 <see cref="T:System.Xml.XmlReader" /> 对象。</param>
        <summary>从 XML 流中读取。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RejectChanges();" />
      <MemberSignature Language="F#" Value="member this.RejectChanges : unit -&gt; unit" Usage="dataTable.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>回滚自该表加载以来或上次调用 <see cref="M:System.Data.DataTable.AcceptChanges" /> 以来对该表进行的所有更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Data.DataTable.RejectChanges%2A>调用时，任何<xref:System.Data.DataRow>仍处于编辑模式的对象将取消其编辑。 新行并删除。 与行<xref:System.Data.DataRowState>设置为`Modified`或`Deleted`返回回其原始状态。  
  
   
  
## Examples  
 以下示例使多个更改<xref:System.Data.DataTable>，通过调用拒绝所做的更改，但<xref:System.Data.DataTable.RejectChanges%2A>方法。  
  
 [!code-csharp[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataTable.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置序列化格式。</summary>
        <value>一个<see cref="T:System.Data.SerializationFormat" />枚举指定<see langword="Binary" />或<see langword="Xml" />序列化。</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataTable.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将 <see cref="T:System.Data.DataTable" /> 重置为其初始状态。 重置将移除表的所有数据、索引、关系和列。 如果数据集包含一个数据表，则在重置该表之后，它将仍是数据集的一部分。</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="RowChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanged As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanged;" />
      <MemberSignature Language="F#" Value="member this.RowChanged : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanged : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowChangedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在成功更改 <see cref="T:System.Data.DataRow" /> 后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="RowChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanging As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanging;" />
      <MemberSignature Language="F#" Value="member this.RowChanging : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanging : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowChangingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在更改 <see cref="T:System.Data.DataRow" /> 时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="RowDeleted">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleted As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleted;" />
      <MemberSignature Language="F#" Value="member this.RowDeleted : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleted : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowDeletedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>删除表中的行后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="RowDeleting">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleting As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleting;" />
      <MemberSignature Language="F#" Value="member this.RowDeleting : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleting : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowDeletingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要删除表中的行之前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[处理数据表事件](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md)。  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Rows">
      <MemberSignature Language="C#" Value="public System.Data.DataRowCollection Rows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRowCollection Rows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Rows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rows As DataRowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRowCollection ^ Rows { System::Data::DataRowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Rows : System.Data.DataRowCollection" Usage="System.Data.DataTable.Rows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取属于该表的行的集合。</summary>
        <value>一个<see cref="T:System.Data.DataRowCollection" />，其中包含<see cref="T:System.Data.DataRow" />对象; 否则为空值如果没有<see cref="T:System.Data.DataRow" />存在的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要创建一个新<xref:System.Data.DataRow>，则必须使用<xref:System.Data.DataTable.NewRow%2A>方法以返回一个新的对象。 根据为定义的架构会自动配置此类对象<xref:System.Data.DataTable>遍历其集合<xref:System.Data.DataColumn>对象。 创建一个新行并设置每个列的值的行中后, 向其中添加行<xref:System.Data.DataRowCollection>使用`Add`方法。  
  
 每个<xref:System.Data.DataRow>集合中表示的表中的数据行。 若要将更改提交到的行中列的值，必须调用<xref:System.Data.DataTable.AcceptChanges%2A>方法。  
  
   
  
## Examples  
 下面显示了返回和设置行的两个示例。 第一个示例使用<xref:System.Data.DataTable.Rows%2A>属性，并输出每个行的每个列的值。 第二个示例使用<xref:System.Data.DataTable>对象的<xref:System.Data.DataTable.NewRow%2A>方法来创建一个新<xref:System.Data.DataRow>具有的架构对象<xref:System.Data.DataTable>。 在设置后的行值，将行添加到<xref:System.Data.DataRowCollection>通过`Add`方法。  
  
 [!code-csharp[Classic WebData DataTable.Rows Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Rows Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.AcceptChanges" />
        <altmember cref="T:System.Data.DataRow" />
        <altmember cref="T:System.Data.DataRowCollection" />
        <altmember cref="M:System.Data.DataTable.NewRow" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取 <see cref="T:System.Data.DataRow" /> 对象数组。</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select" />
      <MemberSignature Language="VB.NET" Value="Public Function Select () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; System.Data.DataRow[]" Usage="dataTable.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取由所有 <see cref="T:System.Data.DataRow" /> 对象组成的数组。</summary>
        <returns>一个 <see cref="T:System.Data.DataRow" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确保正确的顺序排列，请指定与排序条件<xref:System.Data.DataTable.Select(System.String,System.String)>或<xref:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)>。  
  
   
  
## Examples  
 下面的示例返回的数组<xref:System.Data.DataRow>对象通过<xref:System.Data.DataTable.Select%2A>方法。  
  
 [!code-csharp[Classic WebData DataTable.Select Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">Null 值</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression);" />
      <MemberSignature Language="F#" Value="member this.Select : string -&gt; System.Data.DataRow[]" Usage="dataTable.Select filterExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">用于筛选行的条件。 有关如何筛选行的示例，请参阅 [DataView RowFilter 语法 [C#]](https://www.csharp-examples.net/dataview-rowfilter/)。</param>
        <summary>获取由与筛选条件匹配的所有 <see cref="T:System.Data.DataRow" /> 对象组成的数组。</summary>
        <returns>一个 <see cref="T:System.Data.DataRow" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要创建`filterExpression`参数，使用相同的规则应用于<xref:System.Data.DataColumn>类的<xref:System.Data.DataColumn.Expression%2A>创建筛选器的属性值。  
  
若要确保正确的顺序排列，请指定与排序条件<xref:System.Data.DataTable.Select(System.String,System.String)>或<xref:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)>。
  
 如果在筛选器列包含 null 值，它将不是结果的一部分。  
  
   
  
## Examples  
 以下示例使用筛选器表达式返回的数组<xref:System.Data.DataRow>对象。  
  
 [!code-csharp[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">Null 值</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">用于筛选行的条件。 有关如何筛选行的示例，请参阅 [DataView RowFilter 语法 [C#]](https://www.csharp-examples.net/dataview-rowfilter/)。</param>
        <param name="sort">指定列和排序方向的字符串。</param>
        <summary>以指定排序顺序，获取由与筛选条件匹配的所有 <see cref="T:System.Data.DataRow" /> 对象组成的数组。</summary>
        <returns>由与筛选条件匹配的 <see cref="T:System.Data.DataRow" /> 对象组成的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向窗体`filterExpression`自变量，用于创建使用相同的规则<xref:System.Data.DataColumn>类的<xref:System.Data.DataColumn.Expression%2A>属性值。 `Sort`自变量也使用相同的规则来创建类的<xref:System.Data.DataColumn.Expression%2A>字符串。  
  
 如果在筛选器列包含 null 值，它将不是结果的一部分。  
  
   
  
## Examples  
 以下示例使用筛选器表达式返回的数组<xref:System.Data.DataRow>对象。  
  
 [!code-csharp[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">Null 值</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort, System.Data.DataViewRowState recordStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort, valuetype System.Data.DataViewRowState recordStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String, recordStates As DataViewRowState) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort, System::Data::DataViewRowState recordStates);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string * System.Data.DataViewRowState -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort, recordStates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
        <Parameter Name="recordStates" Type="System.Data.DataViewRowState" />
      </Parameters>
      <Docs>
        <param name="filterExpression">用于筛选行的条件。 有关如何筛选行的示例，请参阅 [DataView RowFilter 语法 [C#]](https://www.csharp-examples.net/dataview-rowfilter/)。</param>
        <param name="sort">指定列和排序方向的字符串。</param>
        <param name="recordStates">
          <see cref="T:System.Data.DataViewRowState" /> 值之一。</param>
        <summary>以与指定状态匹配的排序顺序，获取由与筛选条件匹配的所有 <see cref="T:System.Data.DataRow" /> 对象组成的数组。</summary>
        <returns>一个 <see cref="T:System.Data.DataRow" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向窗体`filterExpression`自变量，用于创建使用相同的规则<xref:System.Data.DataColumn>类的<xref:System.Data.DataColumn.Expression%2A>属性值。 `Sort`自变量也使用相同的规则来创建类的<xref:System.Data.DataColumn.Expression%2A>字符串。  
  
 如果在筛选器列包含 null 值，它将不是结果的一部分。  
  
   
  
## Examples  
 下面的示例使用筛选器表达式和记录状态用于返回的数组<xref:System.Data.DataRow>对象。  
  
 [!code-csharp[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">Null 值</related>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataTable.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Data.DataTable" /> 的 <see cref="T:System.ComponentModel.ISite" />。</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> 的一个 <see cref="T:System.Data.DataTable" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 站点绑定<xref:System.ComponentModel.Component>到<xref:System.ComponentModel.Container>启用它们之间的通信，以及为要管理其组件的容器提供的方法。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>有关此成员的说明，请参阅 <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />。</summary>
        <value>
          <see langword="true" /> 如果集合是一系列<see cref="T:System.Collections.IList" />对象; 否则为<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Data.DataTable> 实例被强制转换为 <xref:System.ComponentModel.IListSource> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.ComponentModel.IListSource.GetList" />。</summary>
        <returns>对象中可以绑定到数据源的 <see cref="T:System.Collections.IList" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Data.DataTable> 实例被强制转换为 <xref:System.ComponentModel.IListSource> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">一个 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象。</param>
        <param name="context">一个 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 对象。</param>
        <summary>使用序列化 <see cref="T:System.Data.DataTable" /> 时所需的数据填充序列化信息对象。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />。</summary>
        <returns>一个 <see cref="T:System.Xml.Schema.XmlSchema" />，描述由 <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> 方法生成并由 <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> 方法使用的对象的 XML 表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Data.DataSet> 实例被强制转换为 <xref:System.Xml.Serialization.IXmlSerializable> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">XmlReader。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Data.DataSet> 实例被强制转换为 <xref:System.Xml.Serialization.IXmlSerializable> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">XmlWriter。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Data.DataSet> 实例被强制转换为 <xref:System.Xml.Serialization.IXmlSerializable> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableCleared">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableCleared;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableCleared" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableCleared" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableCleared As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableCleared;" />
      <MemberSignature Language="F#" Value="member this.TableCleared : System.Data.DataTableClearEventHandler " Usage="member this.TableCleared : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>清除 <see cref="T:System.Data.DataTable" /> 后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableCleared>成功之前清除所有行后将立即激发事件<xref:System.Data.DataTable.Clear%2A>方法将控制返回给调用方。 <xref:System.Data.DataTable.TableCleared>如果清除操作中的任何异常，不触发事件。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="TableClearing">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableClearing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableClearing" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableClearing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableClearing As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableClearing;" />
      <MemberSignature Language="F#" Value="member this.TableClearing : System.Data.DataTableClearEventHandler " Usage="member this.TableClearing : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>清除 <see cref="T:System.Data.DataTable" /> 时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableClearing>处理之前触发事件<xref:System.Data.DataTable.Clear%2A>开始操作。 此事件始终会激发<xref:System.Data.DataTable.Clear%2A>调用方法时，即使表包含零行。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TableName : string with get, set" Usage="System.Data.DataTable.TableName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableTableNameDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Data.DataTable" /> 的名称。</summary>
        <value>
          <see cref="T:System.Data.DataTable" /> 的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableName%2A>用于此表返回从父<xref:System.Data.DataSet>对象的<xref:System.Data.DataTableCollection>(返回<xref:System.Data.DataSet.Tables%2A>属性)。  
  
   
  
## Examples  
 下面的示例打印<xref:System.Data.DataTable.TableName%2A>集合中的每个表<xref:System.Data.DataTable>对象。  
  
 [!code-csharp[Classic WebData DataTable.TableName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.TableName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">传入 <see langword="null" /> 或空字符串 ("")，此表属于一个集合。</exception>
        <exception cref="T:System.Data.DuplicateNameException">该表属于一个集合，该集合已包含同名的表。 （比较区分大小写）。</exception>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Tables" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="TableNewRow">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableNewRowEventHandler TableNewRow;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableNewRowEventHandler TableNewRow" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableNewRow" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableNewRow As DataTableNewRowEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableNewRowEventHandler ^ TableNewRow;" />
      <MemberSignature Language="F#" Value="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " Usage="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableNewRowEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>插入新的 <see cref="T:System.Data.DataRow" /> 时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 后一个新激发<xref:System.Data.DataRow>使用已创建<xref:System.Data.DataTable.NewRow%2A>。 激发此事件之前被调用`NewRow`方法返回。 新<xref:System.Data.DataRow>分离实例; 不添加到集合。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">处理数据表事件</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="dataTable.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取 <see cref="P:System.Data.DataTable.TableName" /> 和 <see cref="P:System.Data.DataTable.DisplayExpression" />（如果有一个用作连接字符串）。</summary>
        <returns>一个由 <see cref="P:System.Data.DataTable.TableName" /> 和 <see cref="P:System.Data.DataTable.DisplayExpression" /> 值字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 获取<xref:System.Data.DataTable.TableName%2A>并<xref:System.Data.DataTable.DisplayExpression%2A>为<xref:System.Data.DataTable>。  
  
   
  
## Examples  
 下面的示例返回<xref:System.Data.DataTable.TableName%2A>并<xref:System.Data.DataTable.DisplayExpression%2A>使用<xref:System.Data.DataTable.ToString%2A>方法。  
  
 [!code-csharp[Classic WebData DataTable.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>以 XML 形式写入 <see cref="T:System.Data.DataTable" /> 的当前内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据的方法或数据和架构从<xref:System.Data.DataTable>转换为 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，请使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
   
  
## Examples  
 以下控制台应用程序创建两个<xref:System.Data.DataTable>实例，将为每个<xref:System.Data.DataSet>，创建<xref:System.Data.DataRelation>相关的两个表，并使用<xref:System.Data.DataTable.WriteXml%2A>方法写入父表中包含的数据<xref:System.IO.TextWriter>. 设置时，此示例演示行为`writeHierarchy`到它的值的每个参数。  
  
> [!NOTE]
>  此示例演示如何使用 WriteXml 的重载版本之一。 有关可用的其他示例，请参阅各个重载主题。  
  
 [!code-csharp[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/VB/source.vb#1)]  
  
 该示例在控制台窗口中显示以下输出：  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">要向其写入数据的流。</param>
        <summary>通过指定的 <see cref="T:System.IO.Stream" />，按 XML 形式编写 <see cref="T:System.Data.DataTable" /> 的当前内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据的方法或数据和架构从<xref:System.Data.DataTable>转换为 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，请使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入内容的 <see cref="T:System.IO.TextWriter" />。</param>
        <summary>通过指定的 <see cref="T:System.IO.TextWriter" />，按 XML 形式编写 <see cref="T:System.Data.DataTable" /> 的当前内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据的方法或数据和架构从<xref:System.Data.DataTable>转换为 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，请使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataTable.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要向其写入 XML 数据的文件。</param>
        <summary>使用指定的文件以 XML 形式写入 <see cref="T:System.Data.DataTable" /> 的当前内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据的方法或数据和架构从<xref:System.Data.DataTable>转换为 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，请使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入内容的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <summary>通过指定的 <see cref="T:System.Xml.XmlWriter" />，按 XML 形式编写 <see cref="T:System.Data.DataTable" /> 的当前内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据的方法或数据和架构从<xref:System.Data.DataTable>转换为 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，请使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXml (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">要向其写入数据的流。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的内容。 如果为 <see langword="false" />（默认值），则只写入当前表的数据。</param>
        <summary>通过指定的 <see cref="T:System.IO.Stream" />，按 XML 形式编写 <see cref="T:System.Data.DataTable" /> 的当前内容。 若要保存该表及其所有子代的数据，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法来写入的架构<xref:System.Data.DataTable>到 XML 文档。 此架构包含表、 关系和约束定义。  
  
 XML 架构编写使用 XSD 标准。  
  
 若要将数据写入到 XML 文档，请使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 通常情况下`WriteXml`方法写入当前表的数据。 若要写入当前表和其后代的所有数据相关的表，请调用与方法`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">要向其写入数据的流。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 值之一。</param>
        <summary>使用指定的 <see cref="T:System.Data.XmlWriteMode" /> 将 <see cref="T:System.Data.DataTable" /> 的当前数据和架构（可选）写入指定的文件。 若要写入架构，请将 <paramref name="mode" /> 参数的值设置为 <see langword="WriteSchema" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据的方法或数据和架构从<xref:System.Data.DataTable>转换为 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，请使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入内容的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的内容。 如果为 <see langword="false" />（默认值），则只写入当前表的数据。</param>
        <summary>通过指定的 <see cref="T:System.IO.TextWriter" />，按 XML 形式编写 <see cref="T:System.Data.DataTable" /> 的当前内容。 若要保存该表及其所有子代的数据，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据的方法或数据和架构从<xref:System.Data.DataTable>转换为 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 通常情况下`WriteXml`方法写入当前表的数据。 若要写入当前表和及其所有子代和相关的表的数据，调用方法替换`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
   
  
## Examples  
 以下控制台应用程序创建两个<xref:System.Data.DataTable>实例，将为每个<xref:System.Data.DataSet>，创建<xref:System.Data.DataRelation>相关的两个表，并使用<xref:System.Data.DataTable.WriteXml%2A>方法写入父表中包含的数据<xref:System.IO.TextWriter>. 设置时，此示例演示行为`writeHierarchy`参数`true`。  
  
 [!code-csharp[DataWorks DataTable.WriteXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入文档的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 值之一。</param>
        <summary>使用指定的 <see cref="T:System.IO.TextWriter" /> 和 <see cref="T:System.Data.XmlWriteMode" /> 写入 <see cref="T:System.Data.DataTable" /> 的当前数据和架构（可选）。 若要写入架构，请将 <paramref name="mode" /> 参数的值设置为 <see langword="WriteSchema" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据的方法或数据和架构从<xref:System.Data.DataTable>转换为 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，请使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">要向其写入 XML 数据的文件。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的内容。 如果为 <see langword="false" />（默认值），则只写入当前表的数据。</param>
        <summary>使用指定的文件以 XML 形式写入 <see cref="T:System.Data.DataTable" /> 的当前内容。 若要保存该表及其所有子代的数据，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据的方法或数据和架构从<xref:System.Data.DataTable>转换为 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，请使用`ReadXmlSchema`方法。  
  
 通常情况下`WriteXml`方法写入当前表的数据。 若要写入当前表和其后代的所有数据相关的表，请调用与方法`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">将向其写入数据的文件名称。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 值之一。</param>
        <summary>使用指定的文件和 <see cref="T:System.Data.XmlWriteMode" /> 写入 <see cref="T:System.Data.DataTable" /> 的当前数据和架构（可选）。 若要写入架构，请将 <paramref name="mode" /> 参数的值设置为 <see langword="WriteSchema" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据的方法或数据和架构从<xref:System.Data.DataTable>转换为 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，请使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入内容的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的内容。 如果为 <see langword="false" />（默认值），则只写入当前表的数据。</param>
        <summary>通过指定的 <see cref="T:System.Xml.XmlWriter" />，按 XML 形式编写 <see cref="T:System.Data.DataTable" /> 的当前内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据的方法或数据和架构从<xref:System.Data.DataTable>转换为 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，请使用`ReadXmlSchema`方法。  
  
 通常情况下`WriteXml`方法写入当前表的数据。 若要写入当前表和及其所有子代和相关表的数据，调用方法替换`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入文档的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 值之一。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlWriter" /> 和 <see cref="T:System.Data.XmlWriteMode" /> 写入 <see cref="T:System.Data.DataTable" /> 的当前数据和架构（可选）。 若要写入架构，请将 <paramref name="mode" /> 参数的值设置为 <see langword="WriteSchema" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据的方法或数据和架构从<xref:System.Data.DataTable>转换为 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，请使用`ReadXmlSchema`方法。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (stream, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">要向其写入数据的流。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 值之一。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的内容。 如果为 <see langword="false" />（默认值），则只写入当前表的数据。</param>
        <summary>使用指定的 <see cref="T:System.Data.XmlWriteMode" /> 将 <see cref="T:System.Data.DataTable" /> 的当前数据和架构（可选）写入指定的文件。 若要写入架构，请将 <paramref name="mode" /> 参数的值设置为 <see langword="WriteSchema" />。 若要保存该表及其所有子代的数据，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据的方法或数据和架构从`DataTable`转换为 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一`XmlWriteMode`参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，请使用`ReadXmlSchema`方法。  
  
 通常情况下，`WriteXml`方法保存仅对当前表的数据。 `WriteXml`方法提供了编写只将数据的方法或数据和架构从`DataTable`转换为 XML 文档，而`WriteXmlSchema`方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一`XmlWriteMode`参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，请使用`ReadXmlSchema`方法。  
  
 通常情况下`WriteXml`方法写入当前表的数据。 若要写入当前表和其后代的所有数据相关的表，请调用与方法`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入文档的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 值之一。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的内容。 如果为 <see langword="false" />（默认值），则只写入当前表的数据。</param>
        <summary>使用指定的 <see cref="T:System.IO.TextWriter" /> 和 <see cref="T:System.Data.XmlWriteMode" /> 写入 <see cref="T:System.Data.DataTable" /> 的当前数据和架构（可选）。 若要写入架构，请将 <paramref name="mode" /> 参数的值设置为 <see langword="WriteSchema" />。 若要保存该表及其所有子代的数据，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据的方法或数据和架构从<xref:System.Data.DataTable>转换为 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，请使用`ReadXmlSchema`方法。  
  
 通常情况下，`WriteXml`方法保存仅对当前表的数据。 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据的方法或数据和架构从<xref:System.Data.DataTable>转换为 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，请使用`ReadXmlSchema`方法。  
  
 通常情况下`WriteXml`方法写入当前表的数据。 若要写入当前表和其后代的所有数据相关的表，请调用与方法`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
   
  
## Examples  
 以下控制台应用程序创建两个<xref:System.Data.DataTable>实例，将为每个<xref:System.Data.DataSet>，创建<xref:System.Data.DataRelation>相关的两个表，并使用<xref:System.Data.DataTable.WriteXml%2A>方法写入父表中包含的数据<xref:System.IO.TextWriter>. 设置时，此示例演示行为`writeHierarchy`到它的值的每个参数。  
  
 [!code-csharp[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/VB/source.vb#1)]  
  
 该示例在控制台窗口中显示以下输出：  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">将向其写入数据的文件名称。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 值之一。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的内容。 如果为 <see langword="false" />（默认值），则只写入当前表的数据。</param>
        <summary>使用指定的文件和 <see cref="T:System.Data.XmlWriteMode" /> 写入 <see cref="T:System.Data.DataTable" /> 的当前数据和架构（可选）。 若要写入架构，请将 <paramref name="mode" /> 参数的值设置为 <see langword="WriteSchema" />。 若要保存该表及其所有子代的数据，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据的方法或数据和架构从<xref:System.Data.DataTable>转换为 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，请使用`ReadXmlSchema`方法。  
  
 通常情况下，`WriteXml`方法保存仅对当前表的数据。 如果你想要保存当前表和架构，所有的数据<xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据的方法或数据和架构从<xref:System.Data.DataTable>转换为 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，请使用`ReadXmlSchema`方法。  
  
 通常情况下`WriteXml`方法写入当前表的数据。 若要写入当前表和相关的所有子代的表的数据，调用方法替换`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入文档的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="mode">
          <see cref="T:System.Data.XmlWriteMode" /> 值之一。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的内容。 如果为 <see langword="false" />（默认值），则只写入当前表的数据。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlWriter" /> 和 <see cref="T:System.Data.XmlWriteMode" /> 写入 <see cref="T:System.Data.DataTable" /> 的当前数据和架构（可选）。 若要写入架构，请将 <paramref name="mode" /> 参数的值设置为 <see langword="WriteSchema" />。 若要保存该表及其所有子代的数据，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A>方法提供了编写只将数据的方法或数据和架构从<xref:System.Data.DataTable>转换为 XML 文档，而<xref:System.Data.DataTable.WriteXmlSchema%2A>方法将仅架构写入。 若要编写数据和架构，使用包含的重载之一<xref:System.Data.XmlWriteMode>参数，并将其值设置为`WriteSchema`。  
  
 请注意，同样适用于<xref:System.Data.DataTable.ReadXml%2A>和<xref:System.Data.DataTable.ReadXmlSchema%2A>方法，分别。 读取 XML 数据或架构和数据读入`DataTable`，使用`ReadXml`方法。 若要只读取架构，请使用`ReadXmlSchema`方法。  
  
 通常情况下`WriteXml`方法写入当前表的数据。 若要写入当前表和及其所有子代和相关表的数据，调用方法替换`writeHierarchy`参数设置为`true`。  
  
> [!NOTE]
>  <xref:System.InvalidOperationException>如果中的列类型，将引发`DataRow`正在读取或写入到实现<xref:System.Dynamic.IDynamicMetaObjectProvider>并不实现<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Data.DataTable" /> 的当前数据结构以 XML 架构形式写入。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法来写入的架构<xref:System.Data.DataTable>到 XML 文档。 此架构包含表、 关系和约束定义。  
  
 XML 架构编写使用 XSD 标准。  
  
 若要将数据写入到 XML 文档，请使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
   
  
## Examples  
 以下控制台应用程序创建两个<xref:System.Data.DataTable>实例，将为每个<xref:System.Data.DataSet>，创建<xref:System.Data.DataRelation>相关的两个表，并使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入父表中包含的数据<xref:System.IO.TextWriter>. 设置时，此示例演示行为`writeHierarchy`到它的值的每个参数。  
  
> [!NOTE]
>  此示例演示如何使用的重载版本之一`WriteXmlSchema`有关可能可用，其他示例，请参阅各个重载主题。  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/VB/source.vb#1)]  
  
 该示例在控制台窗口中显示以下输出：  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">要向其写入 XML 架构的流。</param>
        <summary>以 XML 架构的形式将 <see cref="T:System.Data.DataTable" /> 的当前数据结构写入指定的流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法来写入的架构<xref:System.Data.DataTable>到 XML 文档。 此架构包含表、 关系和约束定义。  
  
 XML 架构编写使用 XSD 标准。  
  
 若要将数据写入到 XML 文档，请使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入的 <see cref="T:System.IO.TextWriter" />。</param>
        <summary>使用指定的 <see cref="T:System.IO.TextWriter" /> 以 XML 架构的形式写入 <see cref="T:System.Data.DataTable" /> 的当前数据结构。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法来写入的架构<xref:System.Data.DataTable>到 XML 文档。 此架构包含表、 关系和约束定义。  
  
 XML 架构编写使用 XSD 标准。  
  
 若要将数据写入到 XML 文档，请使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataTable.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要使用的文件的名称。</param>
        <summary>以 XML 架构的形式将 <see cref="T:System.Data.DataTable" /> 的当前数据结构写入指定的文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法来写入的架构<xref:System.Data.DataTable>到 XML 文档。 此架构包含表、 关系和约束定义。  
  
 XML 架构编写使用 XSD 标准。  
  
 若要将数据写入到 XML 文档，请使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">要使用的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlWriter" /> 以 XML 架构的形式写入 <see cref="T:System.Data.DataTable" /> 的当前数据结构。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法来写入的架构<xref:System.Data.DataTable>到 XML 文档。 此架构包含表、 关系和约束定义。  
  
 XML 架构编写使用 XSD 标准。  
  
 若要将数据写入到 XML 文档，请使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">要向其写入 XML 架构的流。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的架构。 如果为 <see langword="false" />（默认值），则只写入当前表的架构。</param>
        <summary>以 XML 架构的形式将 <see cref="T:System.Data.DataTable" /> 的当前数据结构写入指定的流。 若要保存该表及其所有子代的架构，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法来写入的架构<xref:System.Data.DataTable>到 XML 文档。 此架构包含表、 关系和约束定义。  
  
 XML 架构编写使用 XSD 标准。  
  
 若要将数据写入到 XML 文档，请使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 通常情况下`WriteXmlSchema`方法写入当前表的架构。 若要写入当前表和及其所有子代和相关表的架构，调用方法替换`writeHierarchy`参数设置为`true`。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的架构。 如果为 <see langword="false" />（默认值），则只写入当前表的架构。</param>
        <summary>使用指定的 <see cref="T:System.IO.TextWriter" /> 以 XML 架构的形式写入 <see cref="T:System.Data.DataTable" /> 的当前数据结构。 若要保存该表及其所有子代的架构，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法来写入的架构<xref:System.Data.DataTable>到 XML 文档。 此架构包含表、 关系和约束定义。  
  
 XML 架构编写使用 XSD 标准。  
  
 若要将数据写入到 XML 文档，请使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 通常情况下`WriteXmlSchema`方法写入当前表的架构。 若要写入当前表和及其所有子代和相关表的架构，调用方法替换`writeHierarchy`参数设置为`true`。  
  
   
  
## Examples  
 以下控制台应用程序创建两个<xref:System.Data.DataTable>实例，将为每个<xref:System.Data.DataSet>，创建<xref:System.Data.DataRelation>相关的两个表，并使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法写入父表中包含的数据<xref:System.IO.TextWriter>. 设置时，此示例演示行为`writeHierarchy`到它的值的每个参数。  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/VB/source.vb#1)]  
  
 该示例在控制台窗口中显示以下输出：  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">要使用的文件的名称。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的架构。 如果为 <see langword="false" />（默认值），则只写入当前表的架构。</param>
        <summary>以 XML 架构的形式将 <see cref="T:System.Data.DataTable" /> 的当前数据结构写入指定的文件。 若要保存该表及其所有子代的架构，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法来写入的架构<xref:System.Data.DataTable>到 XML 文档。 此架构包含表、 关系和约束定义。  
  
 XML 架构编写使用 XSD 标准。  
  
 若要将数据写入到 XML 文档，请使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 通常情况下`WriteXmlSchema`方法写入当前表的架构。 若要写入当前表和及其所有子代和相关表的架构，调用方法替换`writeHierarchy`参数设置为`true`。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">用于写入文档的 <see cref="T:System.Xml.XmlWriter" />。</param>
        <param name="writeHierarchy">如果为 <see langword="true" />，则写入当前表及其所有子代的架构。 如果为 <see langword="false" />（默认值），则只写入当前表的架构。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlWriter" /> 以 XML 架构的形式写入 <see cref="T:System.Data.DataTable" /> 的当前数据结构。 若要保存该表及其所有子代的架构，请将 <paramref name="writeHierarchy" /> 参数设置为 <see langword="true" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Data.DataTable.WriteXmlSchema%2A>方法来写入的架构<xref:System.Data.DataTable>到 XML 文档。 此架构包含表、 关系和约束定义。  
  
 XML 架构编写使用 XSD 标准。  
  
 若要将数据写入到 XML 文档，请使用<xref:System.Data.DataTable.WriteXml%2A>方法。  
  
 通常情况下`WriteXmlSchema`方法写入当前表的架构。 若要写入当前表和及其所有子代和相关表的架构，调用方法替换`writeHierarchy`参数设置为`true`。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">创建和使用 DataTables</related>
      </Docs>
    </Member>
  </Members>
</Type>