<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0f6fed664b044da1885a7b85efbbbf8911c7ce56" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="58875562" /></Metadata><TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ControlAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlAdapter abstract" />
  <TypeSignature Language="F#" Value="type ControlAdapter = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>自定义附加了适配器的派生控件的呈现，以修改特定浏览器的默认标记或行为，是所有控件适配器都可以继承的基类。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控件适配器是组件，可以重写某些<xref:System.Web.UI.Control>类中执行生命周期以允许浏览器或特定于标记的处理方法和事件。 .NET Framework 映射到的单个派生的控件适配器<xref:System.Web.UI.Control>为每个客户端请求的对象。  
  
 适配器修改特定浏览器或浏览器的类的控件，或作为针对某些功能的任意筛选器。 通常由浏览器使用 （例如，XHTML 或 HTML 3.2） 的标记语言定义适配器。 呈现行为的适应性很多可以封装在派生的专用类<xref:System.Web.UI.HtmlTextWriter>类。 因此，很可能一个适配器可以用于多种浏览器类行为，或者包括在适应性<xref:System.Web.UI.HtmlTextWriter>类可以使控件适配器的使用不必要。  
  
 控件类的适配器适用于所有控件都继承自该类的除非存在更专业的适配器。 例如，对于适配器<xref:System.Web.UI.WebControls.BaseValidator>类可用于所有`Validator`对象。  
  
 适配器通常不直接从继承<xref:System.Web.UI.Adapters.ControlAdapter>类，但从一个特定于目标的适配器基类，后者可提供特定于控件类型和目标浏览器的其他功能或特定的呈现所需。  
  
 控件本身并不一定需要适配器。 如果控件通过组合扩展，通常子控件适配器已足够。  
  
 每个控件具有通过.browser 定义文件的显式映射到适配器。 因此，任何访问<xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType>属性使用<xref:System.Web.HttpBrowserCapabilities>从浏览器定义文件来查找到控件适配器的映射中提取的对象。  
  
 在处理期间，.NET Framework 截获对可能是特定于目标的一个控件的可重写方法的调用。 如果附加了控件适配器，.NET Framework 调用关联的适配器方法。  
  
 适配器通过控件执行呈现<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法。 如果重写，则<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>可能不应调用基类实现，它执行调用返回因为<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>方法。 这可能会导致出现两次，一次由适配器和一次由该控件的呈现。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>基于方法调用<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>控件的方法。 因此，如果重写<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>，除非您实现的呈现之外，提供的不应调用基类实现<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>的控件。  
  
 您必须确保.NET Framework 的子控件的适配器执行拦截。 您可以执行此操作通过调用<xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A>基方法，以便调用<xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType>控件的方法从你<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>重写。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>并<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>方法由该控件之前和之后 （分别） 的控件调用立即调用<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法。 如果前和后呈现唯一的浏览器特定处理任务，使用<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>并<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>可能会使用户无需重写<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>。 默认行为<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>并<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>方法是调用的相应方法<xref:System.Web.UI.HtmlTextWriter>。  
  
 若要维护其自己的状态信息，控件适配器可以重写<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>，和<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>方法。 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A><xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>，和<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>当保存和加载，分别专用控件和视图状态时调用。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>， <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>，和<xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A>基方法将调用回调的相应<xref:System.Web.UI.Control>类方法。 因此，其中的任何<xref:System.Web.UI.Adapters.ControlAdapter>将被重写的方法必须调用其基方法; 否则为该事件与<xref:System.Web.UI.Control>类方法将不会引发。  
  
 控件和适配器可以选择实现<xref:System.Web.UI.IPostBackDataHandler>和<xref:System.Web.UI.IPostBackEventHandler>接口。 .NET Framework 确定适配器是否存在以及是否适配器实现这些接口。 如果是这样，适配器应重写<xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>， <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>，和<xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A>方法，根据需要。 如果回发数据无法识别在适配器中，它必须返回调用控件以对其进行处理。 后续的事件处理程序还必须调用返回在控件上。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，需要常规适配器功能的控件应具有相应的适配器基类，在模式中名为<paramref name="ControlType" /> <see langword="Adapter" /> (例如， <see langword="TextBoxAdapter" />)。 适配器应至少返回通过控件的强类型实例及其<see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" />属性。  
  
1.  对于给定的控件类型和标记语言应命名模式中控制适配器<paramref name="MarkupControlType" /> <see langword="Adapter" /> (例如， <see langword="XhtmlTextBoxAdapter" />)。 应在实现控件的适配器<see langword="Adapters" />子命名空间。  
  
控件适配器应继承自相应的基类，并遵循相同的继承模型为控件。 例如，从继承的控件的适配器<see cref="T:System.Web.UI.Control" />应该继承基类<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类或相关<paramref name="ControlType" /><see langword="Adapter" />类。  
  
应为专用控件下的所有配置.browser 文件中的设备节点定义任何专用的适配器。  
  
正确实现的控件不应假定附加了适配器，或附加的适配器实现特定接口。 相反，它应检查这些之前调用。  
  
可以模拟重写受保护的事件方法在控件中，如<see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" />方法的<see cref="T:System.Web.UI.WebControls.LinkButton" />。 首先，创建一种适配器类与<c>OnClick</c>方法。 然后，创建新的控件派生自<see cref="T:System.Web.UI.WebControls.LinkButton" />并重写<see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" />方法。 重写<see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" />方法调用<c>OnClick</c>适配器的方法。 该适配器对象是可通过受保护<see cref="P:System.Web.UI.Control.Adapter" />属性的<see cref="T:System.Web.UI.Control" />类。 <see cref="P:System.Web.UI.Control.Adapter" />控件的属性是<see langword="null" />时没有任何关联的适配器，因此任何代码应检查该条件之前调用该适配器的方法。</para></block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ControlAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 在内部构建此适配器时它会创建相应<xref:System.Web.UI.Control>对象。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected internal virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub BeginRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void BeginRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.BeginRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">包含可呈现特定于目标的输出的方法的 <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>在呈现控件前调用。 在派生的 adapter 类中，生成特定目标需要但 HTML 浏览器不需要的开始标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>之前调用方法<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法，并且用于执行特定于目标的预处理在呈现控件之前。  
  
 使用<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>方法结合<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>方法，以确保开始和结束标记的一致性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，<see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />基类的方法调用<see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />方法。 因此，重写<see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />方法应调用<see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />基方法，仅当其处理为除此之外，而不是而不是，<see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />方法。</para></block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities" Usage="System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对发出当前 HTTP 请求的客户端的浏览器功能的引用。</summary>
        <value>一个 <see cref="T:System.Web.HttpBrowserCapabilities" />，指定客户端浏览器和标记功能。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个<xref:System.Web.UI.Adapters.ControlAdapter>对象确定从客户端浏览器功能<xref:System.Web.HttpBrowserCapabilities>返回的对象<xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A>属性。 这使得<xref:System.Web.UI.Adapters.ControlAdapter>对象来呈现特定于浏览器的标记或以其他方式修改的行为<xref:System.Web.UI.Control>。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A>属性来访问请求的浏览器的详细信息。 在此示例中，代码会检查以确定是否在浏览器适用于 JavaScript，然后允许开发人员在这种情况下呈现自定义的输出。  
  
 [!code-cpp[ControlAdapter_Browser#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter_Browser#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter_Browser#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Control ^ Control { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Control : System.Web.UI.Control" Usage="System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对附加了此控件适配器的控件的引用。</summary>
        <value>附加此 <see cref="T:System.Web.UI.Control" /> 的 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当派生的控件适配器附加到控件时，.NET Framework 调用某些适配器成员而不是控件成员。  
  
   
  
## Examples  
 下面的代码示例演示如何从自定义控件从<xref:System.Web.UI.Control>类，然后创建继承自的相应适配器<xref:System.Web.UI.Adapters.ControlAdapter>类。 适配器重写<xref:System.Web.UI.Adapters.ControlAdapter.Control%2A>属性，并返回控件的强类型引用。  
  
 [!code-cpp[ControlAdapter.Control#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，最小值，则应实现<see langword="Control" />属性以返回该控件的强类型实例，如示例部分中所示。</para></block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="controlAdapter.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为复合控件创建特定于目标的子控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果没有派生的控件适配器附加到<xref:System.Web.UI.Control>对象和<xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A>重写方法，而不是调用该重写<xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType>方法。 因此，<xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A>可用于创建特定于目标的子控件集。  
  
 有关组合控件来创建新控件的详细信息，请参阅[复合控件](https://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果创建继承的类并重写<see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />方法，则不要调用基方法，除非你想要将控件添加到所创建的基方法。 否则可以创建两个集的子控件。</para></block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected internal virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub EndRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void EndRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member EndRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.EndRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.EndRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">包含可呈现特定于目标的输出的方法的 <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>在呈现控件后调用。 在派生的 adapter 类中，生成特定目标需要但 HTML 浏览器不需要的结束标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>紧随其后调用方法<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法，并且用于在呈现控件后执行特定于目标的后续处理。  
  
 使用<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>方法结合<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>方法，以确保开始和结束标记的一致性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，<see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />基类的方法调用<see cref="M:System.Web.UI.HtmlTextWriter.EndRender" />方法。 因此，重写<see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />方法应调用<see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />基方法，仅当其处理为除此之外，而不是而不是，<see cref="M:System.Web.UI.HtmlTextWriter.EndRender" />方法。</para></block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterControlState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterControlState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterControlState : obj -&gt; unit&#xA;override this.LoadAdapterControlState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterControlState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Object" />，其中包含适配器的控件状态信息作为 <see cref="T:System.Web.UI.StateBag" />。</param>
        <summary>加载适配器控件状态信息，该信息由 <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> 在以前请求与此控件适配器关联的控件所驻留的页时保存。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控件状态是即使禁用了视图状态所需的基本状态信息。 当适配器需要维护其自己的控件状态信息时，它会重写<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>方法。  
  
 适配器可能需要在有需要在请求中，独立于关联控件的状态之间维护状态的功能时保持控件状态信息。 例如，大型文本显示和一组组成的复合控件<xref:System.Web.UI.WebControls.RadioButton>控件可能会呈现为台式计算机浏览器上的单一视图。 在其他浏览器，它可能会拆分其呈现的文本显示，另一个用于单选按钮组的一个视图。 适配器需要维护其自己的特定于目标的信息有关当前处于活动状态的视图。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>方法后立即调用<xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType>方法，请在`LoadState`生命周期阶段。 适配器控件状态是独立且除了该控件的控件状态。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterViewState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterViewState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterViewState : obj -&gt; unit&#xA;override this.LoadAdapterViewState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterViewState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Object" />，其中包含适配器视图的状态信息作为 <see cref="T:System.Web.UI.StateBag" />。</param>
        <summary>加载适配器视图状态信息，该信息由 <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> 在以前请求与此控件适配器关联的控件所驻留的页时保存。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当适配器需要维护其自己的视图状态信息时，它会重写<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>方法。  
  
 适配器需要在请求中，独立于关联控件的视图状态之间必须保持的数据时维护视图状态信息。 例如，在台式计算机浏览器上的网格控件可能会呈现为单个视图的行和列的值。 在其他浏览器，它可能会拆分为多个单独的视图，如行和详细信息的单个行的列表及其呈现。 适配器需要维护视图状态中不是当前处于活动状态的视图的数据。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>方法调用之前<xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType>中的方法`LoadState`生命周期阶段。 适配器视图状态是独立且除了该控件的视图状态。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="controlAdapter.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>重写关联控件的 <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> 方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果没有适配器连接到<xref:System.Web.UI.Control>对象和<xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>重写方法，重写方法调用而不是<xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType>方法。  
  
 重写<xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>来执行特定于目标的处理中`Initialize`控件生命周期阶段。 通常情况下，它们是创建一个控件时，将执行的函数。  
  
   
  
## Examples  
 下面的代码示例都派生自定义控件适配器从<xref:System.Web.UI.Adapters.ControlAdapter>类。 然后它将替代<xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>方法关联的控件上设置属性并调用基方法，以完成控件的初始化。  
  
 [!code-cpp[ControlAdapter_OnInit#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter_OnInit#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter_OnInit#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，适配器并重写<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />方法中，适配器必须调用相应的基类方法又调用<see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />方法。 如果<see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />不会调用方法，<see cref="E:System.Web.UI.Control.Init" />不会引发事件。</para></block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="controlAdapter.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>重写关联控件的 <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> 方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果没有适配器连接到<xref:System.Web.UI.Control>对象和<xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>重写方法，重写方法调用而不是<xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType>方法。  
  
 重写<xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>方法来执行特定于目标的处理中`Load`控件生命周期阶段。 通常情况下，它们应为每个客户端请求执行的函数。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，适配器并重写<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />方法中，适配器必须调用相应的基类方法又调用<see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />方法。 如果<see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />未调用<see cref="E:System.Web.UI.Control.Load" />不会引发事件。</para></block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="controlAdapter.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>重写关联控件的 <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> 方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果没有适配器连接到<xref:System.Web.UI.Control>对象和<xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>重写方法，重写方法调用而不是<xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType>方法。  
  
 重写<xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>方法来执行特定于目标的处理中`PreRender`控件生命周期阶段。 通常情况下，这些是紧跟呈现控件输出的函数。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，适配器并重写<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />方法中，适配器必须调用相应的基类方法又调用<see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />方法。 如果<see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />不会调用方法，<see cref="E:System.Web.UI.Control.PreRender" />不会引发事件。</para></block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="controlAdapter.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>重写关联控件的 <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> 方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果没有适配器连接到<xref:System.Web.UI.Control>对象和<xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A>重写方法，重写方法调用而不是<xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType>方法。  
  
 重写<xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A>方法来执行特定于目标的处理操作`Unload`控件生命周期阶段。 通常情况下，这些是前加上处理控件的清理功能。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，适配器并重写<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />方法中，适配器必须调用相应的基类方法又调用<see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />方法。 如果<see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />未调用<see cref="E:System.Web.UI.Control.Unload" />不会引发事件。</para></block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page" Usage="System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对与此适配器关联的控件所驻留的页的引用。</summary>
        <value>一个 <see cref="T:System.Web.UI.Page" />，可提供对关联控件所在的页实例的访问权限。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A>属性提供对访问<xref:System.Web.UI.Page?displayProperty=nameWithType>控件所在的对象。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对关联控件所驻留的页的页适配器的引用。</summary>
        <value>用于与当前 <see cref="T:System.Web.UI.Adapters.PageAdapter" /> 关联的控件所在的页的 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A>属性提供访问权限<xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType>对象<xref:System.Web.UI.Page>对象的<xref:System.Web.UI.Control>关联与当前对象<xref:System.Web.UI.Adapters.ControlAdapter>对象的权限。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A>属性可用于访问页面级别的适配器，如常见可应用到的页上的多个控件类型的特定于目标的函数的其他项。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">用于呈现特定于目标的输出的 <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>为附加了控件适配器的控件生成目标特定的标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重写<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法来生成特定于目标的标记将发送到客户端浏览器。 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>方法调用来代替<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>方法如果<xref:System.Web.UI.Adapters.ControlAdapter>对象附加到<xref:System.Web.UI.Control>对象。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />基类的方法调用<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法。 因此，重写<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法应调用<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />基方法，仅当其处理为除此之外，而不是而不是，<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法。  
  
对于复合控件，适配器开发人员必须确保呈现子控件。 如果<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法使子控件呈现，但不会生成标记，它可能适合<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法以调用其基方法。 如果子控件的特定于目标的呈现是必需的适配器应实现<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法并调用<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法从<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法。</para></block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">用于呈现特定于目标的输出的 <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>为附加了控件适配器的复合控件中的子控件生成特定于目标的标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重写<xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A>方法时需要此外到各个子控件的标记生成复合控件的子控件集的特定于目标的标记。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>继承自<see cref="T:System.Web.UI.Adapters.ControlAdapter" />类，用于复合控件，适配器开发人员必须确保呈现子控件。 如果适配器重写<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法，则应调用<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法的重写从<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法。  
  
如果<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法使子控件呈现，但本身不会生成标记，它可能适合<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />方法来调用其基方法，调用<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />方法，而不是实现的替代<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />方法。</para></block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterControlState : unit -&gt; obj&#xA;override this.SaveAdapterControlState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>保存控件适配器的控件状态信息。</summary>
        <returns>一个 <see cref="T:System.Object" />，其中包含适配器的控件状态信息作为 <see cref="T:System.Web.UI.StateBag" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控件状态是即使禁用了视图状态所需的基本状态信息。 当适配器需要维护其自己的控件状态信息时，它会重写<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>方法。  
  
 适配器可能需要在有需要在请求中，独立于关联控件的状态之间维护状态的功能时保持控件状态信息。 例如，大型文本显示和一组组成的复合控件<xref:System.Web.UI.WebControls.RadioButton>控件可能会呈现为台式计算机浏览器上的单一视图。 在其他浏览器，它可能会拆分其呈现的文本显示，另一个用于单选按钮组的一个视图。 适配器需要维护其自己的特定于目标的信息有关当前处于活动状态的视图。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>方法后立即调用<xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType>中的方法`SaveState`生命周期阶段。 适配器控件状态是独立且除了该控件的控件状态。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterViewState : unit -&gt; obj&#xA;override this.SaveAdapterViewState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>保存控件适配器的视图状态信息。</summary>
        <returns>一个 <see cref="T:System.Object" />，其中包含适配器视图的状态信息作为 <see cref="T:System.Web.UI.StateBag" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当适配器需要维护其自己的视图状态信息时，它会重写<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>和<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>方法。  
  
 适配器需要在请求中，独立于控件的关联的视图状态之间必须保持的数据时维护视图状态信息。 例如，在台式计算机浏览器上的网格控件可能会呈现为单个视图的行和列的值。 在其他浏览器，它可能会拆分为多个单独的视图，如行和详细信息的单个行的列表及其呈现。 适配器需要维护视图状态中不是当前处于活动状态的视图的数据。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>方法调用之前<xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType>中的方法`SaveState`生命周期阶段。 适配器视图状态是独立且除了该控件的视图状态。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>