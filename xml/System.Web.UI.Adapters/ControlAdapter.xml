<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ControlAdapter.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac531e3a9db18b7cba85d5901fe816b3124d2f065ba.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">31e3a9db18b7cba85d5901fe816b3124d2f065ba</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Customizes rendering for the derived control to which the adapter is attached, to modify the default markup or behavior for specific browsers, and is the base class from which all control adapters inherit.</source>
          <target state="translated">自定义附加了适配器的派生控件的呈现，以修改特定浏览器的默认标记或行为，是所有控件适配器都可以继承的基类。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Control adapters are components that override certain <ph id="ph1">&lt;xref:System.Web.UI.Control&gt;</ph> class methods and events in its execution lifecycle to allow browser or markup-specific handling.</source>
          <target state="translated">控件适配器是可重写某些组件<ph id="ph1">&lt;xref:System.Web.UI.Control&gt;</ph>类方法和事件在其执行生命周期，以允许浏览器或特定于标记的处理。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>The .NET Framework maps a single derived control adapter to a <ph id="ph1">&lt;xref:System.Web.UI.Control&gt;</ph> object for each client request.</source>
          <target state="translated">.NET Framework 映射的单个派生的控件适配器<ph id="ph1">&lt;xref:System.Web.UI.Control&gt;</ph>为每个客户端请求的对象。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>An adapter modifies a control for a specific browser or class of browsers or acts as an arbitrary filter on some capability.</source>
          <target state="translated">适配器修改特定浏览器或浏览器的类的控件，或作为针对某些功能的任意筛选器。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Typically the adapter is defined by the markup language that the browser uses (for example, XHTML or HTML 3.2).</source>
          <target state="translated">通常由浏览器使用 （例如，XHTML 或 HTML 3.2） 的标记语言定义适配器。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Much of the adaptability in rendering behavior can be encapsulated in the specialized classes that derive from the <ph id="ph1">&lt;xref:System.Web.UI.HtmlTextWriter&gt;</ph> class.</source>
          <target state="translated">在呈现行为适应性大部分可以封装在派生自的专用类<ph id="ph1">&lt;xref:System.Web.UI.HtmlTextWriter&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Therefore, it is likely that a single adapter can be used for a number of browser class behaviors or that inclusion of the adaptability in the <ph id="ph1">&lt;xref:System.Web.UI.HtmlTextWriter&gt;</ph> classes could make the use of a control adapter unnecessary.</source>
          <target state="translated">因此，很可能单个适配器可以用于大量的浏览器类行为，或者包括在适应性<ph id="ph1">&lt;xref:System.Web.UI.HtmlTextWriter&gt;</ph>类无法进行不必要的使用控件适配器。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>An adapter for a control class applies to all controls that inherit from that class, unless more specialized adapters are present.</source>
          <target state="translated">控件类适配器适用于从该类，继承的所有控件，除非存在更多专用的适配器。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>For example, an adapter for the <ph id="ph1">&lt;xref:System.Web.UI.WebControls.BaseValidator&gt;</ph> class can be used for all <ph id="ph2">`Validator`</ph> objects.</source>
          <target state="translated">例如，为适配器<ph id="ph1">&lt;xref:System.Web.UI.WebControls.BaseValidator&gt;</ph>类可以用于所有<ph id="ph2">`Validator`</ph>对象。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Adapters typically do not inherit directly from the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter&gt;</ph> class, but from one of the target-specific adapter base classes that provide additional functionality specific to the control type and target browser or the particular rendering required.</source>
          <target state="translated">适配器通常不会继承直接从<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter&gt;</ph>类，但特定于目标的适配器的一个基类，后者可提供其他功能特定于控件类型和目标浏览器或所需特定呈现。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Controls themselves do not necessarily require an adapter.</source>
          <target state="translated">控件本身不一定需要适配器。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>If controls are extended through composition, generally the child control adapters are sufficient.</source>
          <target state="translated">如果控件通过组合扩展，通常子控件适配器已经足够。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Each control has explicit mappings to adapters through the .browser definition files.</source>
          <target state="translated">每个控件都有显式映射到适配器穿过.browser 定义文件。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Thus, any access to the <ph id="ph1">&lt;xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType&gt;</ph> property uses the <ph id="ph2">&lt;xref:System.Web.HttpBrowserCapabilities&gt;</ph> object extracted from the browser definition files to perform the lookup for the mapping of the adapter to control.</source>
          <target state="translated">因此，任何访问到<ph id="ph1">&lt;xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType&gt;</ph>属性使用<ph id="ph2">&lt;xref:System.Web.HttpBrowserCapabilities&gt;</ph>从适配器到控件的映射执行查找的浏览器定义文件中提取的对象。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>During processing, the .NET Framework intercepts calls to the overridable methods of a control that could be target-specific.</source>
          <target state="translated">在处理期间，.NET Framework 截获对可能目标特定的控件可重写方法的调用。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>If a control adapter is attached, the .NET Framework calls the associated adapter methods.</source>
          <target state="translated">如果附加了控件适配器，.NET Framework 调用关联的适配器方法。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>The adapter performs rendering for the control through the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph> method.</source>
          <target state="translated">适配器执行通过控件的呈现<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>If overridden, <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph> potentially should not call the base class implementation because that performs a call back on the <ph id="ph2">&lt;xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">如果重写，<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph>可能不应调用基类实现，它执行调用返回因为<ph id="ph2">&lt;xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>This might cause the rendering to occur twice, once by the adapter and once by the control.</source>
          <target state="translated">这可能会导致发生两次，一次适配器进行一次的控件的呈现。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>The <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph> base method calls back on the <ph id="ph2">&lt;xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType&gt;</ph> method of the control.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph>基方法调用回调<ph id="ph2">&lt;xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType&gt;</ph>的控件的方法。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Thus, if you override <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph>, you should not call the base class implementation unless the rendering you implement is in addition to that provided by <ph id="ph2">&lt;xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType&gt;</ph> of the control.</source>
          <target state="translated">因此，如果你重写<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph>，你不应调用基类实现，除非你实现的呈现以及由<ph id="ph2">&lt;xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType&gt;</ph>的控件。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>You must ensure that the .NET Framework performs interception for adapters of the child controls.</source>
          <target state="translated">你必须确保.NET Framework 执行截获，适配器的子控件。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>You can do this by calling the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A&gt;</ph> base method, which calls the <ph id="ph2">&lt;xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType&gt;</ph> method of the control, from your <ph id="ph3">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph> override.</source>
          <target state="translated">你可以执行此操作通过调用<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A&gt;</ph>基方法，以便调用<ph id="ph2">&lt;xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType&gt;</ph>方法的控件，从你<ph id="ph3">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph>重写。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>The <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A&gt;</ph> methods are called by the control immediately before and after (respectively) the control calls the <ph id="ph3">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A&gt;</ph>立即之前和之后 （分别） 控件调用，方法调用该控件的<ph id="ph3">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>If pre- and post-rendering are the only browser-specific processing tasks required, using <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A&gt;</ph> might make it unnecessary to override <ph id="ph3">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph>.</source>
          <target state="translated">如果预和后呈现唯一的浏览器特定处理任务需要，使用<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A&gt;</ph>可能使用户无需重写<ph id="ph3">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>The default behavior of the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A&gt;</ph> methods is to call the corresponding methods of the <ph id="ph3">&lt;xref:System.Web.UI.HtmlTextWriter&gt;</ph>.</source>
          <target state="translated">默认行为<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A&gt;</ph>方法是调用方法相应<ph id="ph3">&lt;xref:System.Web.UI.HtmlTextWriter&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>To maintain its own state information, a control adapter can override the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A&gt;</ph> methods.</source>
          <target state="translated">若要维护其自己的状态信息，控件适配器可以重写<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source><ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A&gt;</ph> are called when the private control and view states are saved and loaded, respectively.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A&gt;</ph><ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A&gt;</ph>保存和加载，分别私有控件和视图状态时，将调用。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>The <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A&gt;</ph> base methods call back on the corresponding <ph id="ph5">&lt;xref:System.Web.UI.Control&gt;</ph> class methods.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A&gt;</ph>，和<ph id="ph4">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A&gt;</ph>基方法调用回调相应<ph id="ph5">&lt;xref:System.Web.UI.Control&gt;</ph>类方法。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Thus, any of these <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter&gt;</ph> methods that are overridden must call their base methods; otherwise, the event associated with the <ph id="ph2">&lt;xref:System.Web.UI.Control&gt;</ph> class method will not be raised.</source>
          <target state="translated">因此，其中的任何<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter&gt;</ph>方法已重写必须调用其基方法; 否则，事件与<ph id="ph2">&lt;xref:System.Web.UI.Control&gt;</ph>类方法将不会引发。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Controls and adapters optionally implement the <ph id="ph1">&lt;xref:System.Web.UI.IPostBackDataHandler&gt;</ph> and <ph id="ph2">&lt;xref:System.Web.UI.IPostBackEventHandler&gt;</ph> interfaces.</source>
          <target state="translated">控件和适配器 （可选） 实现<ph id="ph1">&lt;xref:System.Web.UI.IPostBackDataHandler&gt;</ph>和<ph id="ph2">&lt;xref:System.Web.UI.IPostBackEventHandler&gt;</ph>接口。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>The .NET Framework determines whether an adapter exists and whether the adapter implements these interfaces.</source>
          <target state="translated">.NET Framework 确定是否存在的适配器和适配器是否实现这些接口。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>If it does, the adapter should override the <ph id="ph1">&lt;xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A&gt;</ph> methods, as necessary.</source>
          <target state="translated">如果已存在，应重写适配器<ph id="ph1">&lt;xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A&gt;</ph>方法，根据需要。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>If the postback data is not recognized in the adapter, it must call back on the control to process it.</source>
          <target state="translated">如果回发数据无法识别与适配器中，则必须重新调用上要对其进行处理的控件。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Subsequent event handlers also must call back on the control.</source>
          <target state="translated">后续的事件处理程序还必须调用返回在控件上。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>When you inherit from the <ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph> class, a control that requires general adapter functionality should have a corresponding adapter base class, named in the pattern <ph id="ph2">&lt;paramref name="ControlType" /&gt;</ph><ph id="ph3">&lt;see langword="Adapter" /&gt;</ph> (for example, <ph id="ph4">&lt;see langword="TextBoxAdapter" /&gt;</ph>).</source>
          <target state="translated">继承自<ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph>类，需要常规的适配器的功能的控件应该具有基类，名为模式中的相应适配器<ph id="ph2">&lt;paramref name="ControlType" /&gt;</ph> <ph id="ph3">&lt;see langword="Adapter" /&gt;</ph> (例如， <ph id="ph4">&lt;see langword="TextBoxAdapter" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>The adapter should at a minimum return a strongly-typed instance of the control through its <ph id="ph1">&lt;see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /&gt;</ph> property.</source>
          <target state="translated">适配器应至少返回强类型实例的控制通过其<ph id="ph1">&lt;see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Control adapters for a given control type and markup language should be named in the pattern <ph id="ph1">&lt;paramref name="MarkupControlType" /&gt;</ph><ph id="ph2">&lt;see langword="Adapter" /&gt;</ph> (for example, <ph id="ph3">&lt;see langword="XhtmlTextBoxAdapter" /&gt;</ph>).</source>
          <target state="translated">给定的控件类型和标记语言应模式中名为控件适配器<ph id="ph1">&lt;paramref name="MarkupControlType" /&gt;</ph> <ph id="ph2">&lt;see langword="Adapter" /&gt;</ph> (例如， <ph id="ph3">&lt;see langword="XhtmlTextBoxAdapter" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Adapters for a control should be implemented in an <ph id="ph1">&lt;see langword="Adapters" /&gt;</ph> subnamespace.</source>
          <target state="translated">应在实现控件的适配器<ph id="ph1">&lt;see langword="Adapters" /&gt;</ph>子命名空间。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Control adapters should inherit from the appropriate base class and follow the same inheritance model as the control.</source>
          <target state="translated">控件适配器应从相应的基类继承，并遵循相同的继承模型为控件。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>For example, an adapter for a control inheriting from the <ph id="ph1">&lt;see cref="T:System.Web.UI.Control" /&gt;</ph> base class should inherit from either the <ph id="ph2">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph> class or the relevant <ph id="ph3">&lt;paramref name="ControlType" /&gt;</ph><ph id="ph4">&lt;see langword="Adapter" /&gt;</ph> class.</source>
          <target state="translated">例如，从继承的控件适配器<ph id="ph1">&lt;see cref="T:System.Web.UI.Control" /&gt;</ph>应该继承基类<ph id="ph2">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph>类或相关<ph id="ph3">&lt;paramref name="ControlType" /&gt;</ph><ph id="ph4">&lt;see langword="Adapter" /&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Any specialized adapters should be defined for the specialized control under all of the device nodes in configuration .browser files.</source>
          <target state="translated">应为所有配置.browser 文件中的设备节点下的专用控件定义任何专用的适配器。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>A properly implemented control should not assume that an adapter is attached, or that the attached adapter implements a specific interface.</source>
          <target state="translated">正确实现的控件不应假定附加了适配器，或附加的适配器实现特定接口。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Instead, it should check for these before calling.</source>
          <target state="translated">相反，它应检查这些之前调用。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>It is possible to simulate overriding protected event methods in the control, such as the <ph id="ph1">&lt;see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /&gt;</ph> method of the <ph id="ph2">&lt;see cref="T:System.Web.UI.WebControls.LinkButton" /&gt;</ph>.</source>
          <target state="translated">可以模拟如重写在控件中，受保护的事件方法<ph id="ph1">&lt;see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /&gt;</ph>方法<ph id="ph2">&lt;see cref="T:System.Web.UI.WebControls.LinkButton" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>First, create an adapter class with an <bpt id="p1">&lt;c&gt;</bpt>OnClick<ept id="p1">&lt;/c&gt;</ept> method.</source>
          <target state="translated">首先，创建一种适配器类与<bpt id="p1">&lt;c&gt;</bpt>OnClick<ept id="p1">&lt;/c&gt;</ept>方法。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>Then create a new control derived from <ph id="ph1">&lt;see cref="T:System.Web.UI.WebControls.LinkButton" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /&gt;</ph> method.</source>
          <target state="translated">然后创建一个新的控件派生自<ph id="ph1">&lt;see cref="T:System.Web.UI.WebControls.LinkButton" /&gt;</ph>，并重写<ph id="ph2">&lt;see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>The overriden <ph id="ph1">&lt;see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /&gt;</ph> method calls the <bpt id="p1">&lt;c&gt;</bpt>OnClick<ept id="p1">&lt;/c&gt;</ept> method of the adapter.</source>
          <target state="translated">重写<ph id="ph1">&lt;see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /&gt;</ph>方法调用<bpt id="p1">&lt;c&gt;</bpt>OnClick<ept id="p1">&lt;/c&gt;</ept>的适配器的方法。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>The adapter object is available through the protected <ph id="ph1">&lt;see cref="P:System.Web.UI.Control.Adapter" /&gt;</ph> property of the <ph id="ph2">&lt;see cref="T:System.Web.UI.Control" /&gt;</ph> class.</source>
          <target state="translated">该适配器对象可用于通过受保护<ph id="ph1">&lt;see cref="P:System.Web.UI.Control.Adapter" /&gt;</ph>属性<ph id="ph2">&lt;see cref="T:System.Web.UI.Control" /&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Web.UI.Adapters.ControlAdapter">
          <source>The <ph id="ph1">&lt;see cref="P:System.Web.UI.Control.Adapter" /&gt;</ph> property of the control is <ph id="ph2">&lt;see langword="null" /&gt;</ph> when there is no associated adapter, so any code should check for that condition before calling methods of the adapter.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Web.UI.Control.Adapter" /&gt;</ph>的控件的属性是<ph id="ph2">&lt;see langword="null" /&gt;</ph>时没有任何关联的适配器，因此任何代码应为该条件在调用之前检查的适配器的方法。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.#ctor">
          <source>The .NET Framework internally constructs this adapter when it creates the corresponding <ph id="ph1">&lt;xref:System.Web.UI.Control&gt;</ph> object.</source>
          <target state="translated">.NET Framework 内部构造此适配器时它会创建相应<ph id="ph1">&lt;xref:System.Web.UI.Control&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Web.UI.HtmlTextWriter" /&gt;</ph> containing methods to render the target-specific output.</source>
          <target state="translated">包含可呈现特定于目标的输出的方法的 <ph id="ph1">&lt;see cref="T:System.Web.UI.HtmlTextWriter" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)">
          <source>Called prior to the rendering of a control.</source>
          <target state="translated">在呈现控件前调用。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)">
          <source>In a derived adapter class, generates opening tags that are required by a specific target but not needed by HTML browsers.</source>
          <target state="translated">在派生的 adapter 类中，生成特定目标需要但 HTML 浏览器不需要的开始标记。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)">
          <source>The <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A&gt;</ph> method is called just before the <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph> method, and is used to perform target-specific preprocessing before the rendering of the control.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A&gt;</ph>之前调用方法<ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph>方法，并用于执行特定于目标的预处理之前的控件的呈现。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)">
          <source>Use the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A&gt;</ph> method in combination with the <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A&gt;</ph> method to ensure opening and closing tag consistency.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A&gt;</ph>方法结合<ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A&gt;</ph>方法，以确保开始标记与结束标记的一致性。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)">
          <source>When you inherit from the <ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph> class, the <ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /&gt;</ph> base method calls the <ph id="ph3">&lt;see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /&gt;</ph> method.</source>
          <target state="translated">继承自<ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph>类，<ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /&gt;</ph>基方法调用<ph id="ph3">&lt;see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)">
          <source>Thus, overrides of the <ph id="ph1">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /&gt;</ph> method should call the <ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /&gt;</ph> base method only if its processing is in addition to, rather than instead of, the <ph id="ph3">&lt;see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /&gt;</ph> method.</source>
          <target state="translated">因此，重写<ph id="ph1">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /&gt;</ph>方法应调用<ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /&gt;</ph>基方法，仅当其处理为中而非取代，后者而不是，<ph id="ph3">&lt;see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="P:System.Web.UI.Adapters.ControlAdapter.Browser">
          <source>Gets a reference to the browser capabilities of the client making the current HTTP request.</source>
          <target state="translated">获取对发出当前 HTTP 请求的客户端的浏览器功能的引用。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Web.UI.Adapters.ControlAdapter.Browser">
          <source>An <ph id="ph1">&lt;see cref="T:System.Web.HttpBrowserCapabilities" /&gt;</ph> specifying client browser and markup capabilities.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Web.HttpBrowserCapabilities" /&gt;</ph>，指定客户端浏览器和标记功能。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Web.UI.Adapters.ControlAdapter.Browser">
          <source>A <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter&gt;</ph> object determines the client browser capabilities from the <ph id="ph2">&lt;xref:System.Web.HttpBrowserCapabilities&gt;</ph> object that is returned by the <ph id="ph3">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A&gt;</ph> property.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter&gt;</ph>对象确定从客户端浏览器功能<ph id="ph2">&lt;xref:System.Web.HttpBrowserCapabilities&gt;</ph>返回的对象<ph id="ph3">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Web.UI.Adapters.ControlAdapter.Browser">
          <source>This enables the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter&gt;</ph> object to render browser-specific markup or otherwise modify the behavior of the <ph id="ph2">&lt;xref:System.Web.UI.Control&gt;</ph>.</source>
          <target state="translated">这使<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter&gt;</ph>对象浏览器特定标记呈现，或者修改的行为<ph id="ph2">&lt;xref:System.Web.UI.Control&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Web.UI.Adapters.ControlAdapter.Browser">
          <source>The following code example shows how to use the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A&gt;</ph> property to access the details of the requesting browser.</source>
          <target state="translated">下面的代码示例演示如何使用<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A&gt;</ph>属性来访问请求的浏览器的详细信息。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Web.UI.Adapters.ControlAdapter.Browser">
          <source>In this example, the code checks to determine whether the browser is compatible with JavaScript, and then allows the developer to render customized output in that case.</source>
          <target state="translated">在此示例中，代码检查以确定是否浏览器是否与 JavaScript 兼容，并随后允许开发人员可以在这种情况下呈现自定义的输出。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="P:System.Web.UI.Adapters.ControlAdapter.Control">
          <source>Gets a reference to the control to which this control adapter is attached.</source>
          <target state="translated">获取对附加了此控件适配器的控件的引用。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Web.UI.Adapters.ControlAdapter.Control">
          <source>The <ph id="ph1">&lt;see cref="T:System.Web.UI.Control" /&gt;</ph> to which this <ph id="ph2">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph> is attached.</source>
          <target state="translated">附加此 <ph id="ph1">&lt;see cref="T:System.Web.UI.Control" /&gt;</ph> 的 <ph id="ph2">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Web.UI.Adapters.ControlAdapter.Control">
          <source>When a derived control adapter is attached to a control, the .NET Framework calls certain adapter members instead of the control members.</source>
          <target state="translated">当派生的控件适配器附加到控件时，.NET Framework 调用而不是控件成员某些适配器成员。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Web.UI.Adapters.ControlAdapter.Control">
          <source>The following code example shows how to derive a custom control from the <ph id="ph1">&lt;xref:System.Web.UI.Control&gt;</ph> class, and then create a corresponding adapter that inherits from the <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter&gt;</ph> class.</source>
          <target state="translated">下面的代码示例演示如何从自定义控件从<ph id="ph1">&lt;xref:System.Web.UI.Control&gt;</ph>类，然后再创建继承自相应适配器<ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Web.UI.Adapters.ControlAdapter.Control">
          <source>The adapter overrides the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Control%2A&gt;</ph> property and returns a strongly-typed reference to the control.</source>
          <target state="translated">适配器重写<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Control%2A&gt;</ph>属性并返回到控件的强类型引用。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Web.UI.Adapters.ControlAdapter.Control">
          <source>When you inherit from the <ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph> class, at a minimum, you should implement a <ph id="ph2">&lt;see langword="Control" /&gt;</ph> property to return a strongly-typed instance of the control, as shown in the Example section.</source>
          <target state="translated">继承自<ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph>类，在最低限度上，则应实现<ph id="ph2">&lt;see langword="Control" /&gt;</ph>属性以返回该控件的强类型实例，如示例部分中所示。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls">
          <source>Creates the target-specific child controls for a composite control.</source>
          <target state="translated">为复合控件创建特定于目标的子控件。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls">
          <source>If there is a derived control adapter attached to a <ph id="ph1">&lt;xref:System.Web.UI.Control&gt;</ph> object and the <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A&gt;</ph> method is overridden, the override is called instead of the <ph id="ph3">&lt;xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">如果没有派生的控件适配器附加到<ph id="ph1">&lt;xref:System.Web.UI.Control&gt;</ph>对象和<ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A&gt;</ph>方法被重写，重写调用而不是<ph id="ph3">&lt;xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls">
          <source>Thus, <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A&gt;</ph> can be used to create a target-specific child control set.</source>
          <target state="translated">因此，<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A&gt;</ph>可以用于创建特定于目标的子控件集。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls">
          <source>For more information about combining controls to create a new control, see <bpt id="p1">[</bpt>Composite Controls<ept id="p1">](http://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0)</ept>.</source>
          <target state="translated">有关组合控件，创建一个新的控件的详细信息，请参阅<bpt id="p1">[</bpt>复合控件<ept id="p1">](http://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0)</ept>。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls">
          <source>If you create an inheriting class and override the <ph id="ph1">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /&gt;</ph> method, do not call the base method unless you want to add controls to those created by the base method.</source>
          <target state="translated">如果创建继承类并重写<ph id="ph1">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /&gt;</ph>方法，则不要不基方法，除非你想要将控件添加到那些创建由基方法的调用。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls">
          <source>Otherwise you could create two sets of child controls.</source>
          <target state="translated">否则你可以创建两个集的子控件。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Web.UI.HtmlTextWriter" /&gt;</ph> containing methods to render the target-specific output.</source>
          <target state="translated">包含可呈现特定于目标的输出的方法的 <ph id="ph1">&lt;see cref="T:System.Web.UI.HtmlTextWriter" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)">
          <source>Called after the rendering of a control.</source>
          <target state="translated">在呈现控件后调用。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)">
          <source>In a derived adapter class, generates closing tags that are required by a specific target but not needed by HTML browsers.</source>
          <target state="translated">在派生的 adapter 类中，生成特定目标需要但 HTML 浏览器不需要的结束标记。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)">
          <source>The <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A&gt;</ph> method is called just after the <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph> method, and is used to perform target-specific postprocessing after the rendering of the control.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A&gt;</ph>方法调用紧随其后<ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph>方法，并用于执行特定于目标的后处理后的控件的呈现。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)">
          <source>Use the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A&gt;</ph> method in combination with the <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A&gt;</ph> method to ensure opening and closing tag consistency.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A&gt;</ph>方法结合<ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A&gt;</ph>方法，以确保开始标记与结束标记的一致性。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)">
          <source>When you inherit from the <ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph> class, the <ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /&gt;</ph> base method calls the <ph id="ph3">&lt;see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /&gt;</ph> method.</source>
          <target state="translated">继承自<ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph>类，<ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /&gt;</ph>基方法调用<ph id="ph3">&lt;see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)">
          <source>Thus, overrides of the <ph id="ph1">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /&gt;</ph> method should call the <ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /&gt;</ph> base method only if its processing is in addition to, rather than instead of, the <ph id="ph3">&lt;see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /&gt;</ph> method.</source>
          <target state="translated">因此，重写<ph id="ph1">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /&gt;</ph>方法应调用<ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /&gt;</ph>基方法，仅当其处理为中而非取代，后者而不是，<ph id="ph3">&lt;see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> that contains the adapter's control state information as a <ph id="ph2">&lt;see cref="T:System.Web.UI.StateBag" /&gt;</ph>.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>，其中包含适配器的控件状态信息作为 <ph id="ph2">&lt;see cref="T:System.Web.UI.StateBag" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)">
          <source>Loads adapter control state information that was saved by <ph id="ph1">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /&gt;</ph> during a previous request to the page where the control associated with this control adapter resides.</source>
          <target state="translated">加载适配器控件状态信息，该信息由 <ph id="ph1">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /&gt;</ph> 在以前请求与此控件适配器关联的控件所驻留的页时保存。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)">
          <source>Control state is the essential state information needed even if view state is disabled.</source>
          <target state="translated">控件状态是所需即使禁用了视图状态的基本状态信息。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)">
          <source>When an adapter needs to maintain its own control state information, it can override the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A&gt;</ph> methods.</source>
          <target state="translated">当适配器需要维护其自己的控件状态信息时，它可以重写<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)">
          <source>An adapter might need to maintain control state information when there are features that need to have state maintained across requests, independent from the state of the associated control.</source>
          <target state="translated">适配器可能需要时有需要具有多个请求，独立于关联控件的状态之间保持的状态的功能保持控件状态信息。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)">
          <source>For example, a composite control consisting of a large textual display and a group of <ph id="ph1">&lt;xref:System.Web.UI.WebControls.RadioButton&gt;</ph> controls might render as a single view on desktop computer browsers.</source>
          <target state="translated">例如，大型的文本显示和一组组成的复合控件<ph id="ph1">&lt;xref:System.Web.UI.WebControls.RadioButton&gt;</ph>控件可能呈现为台式计算机浏览器上的单一视图。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)">
          <source>On other browsers, it might split its rendering—one view for the textual display and the other for the radio button group.</source>
          <target state="translated">在其他浏览器，它可能会拆分其呈现-文本显示和另一个用于的单选按钮组的一个视图。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)">
          <source>The adapter would need to maintain its own target-specific information about the currently active view.</source>
          <target state="translated">适配器需要维护其自己的特定于目标的信息，有关当前处于活动状态的视图。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A&gt;</ph> method is called immediately after the <ph id="ph2">&lt;xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType&gt;</ph> method, in the <ph id="ph3">`LoadState`</ph> lifecycle stage.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A&gt;</ph>方法之后，立即调用<ph id="ph2">&lt;xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType&gt;</ph>方法，请在<ph id="ph3">`LoadState`</ph>生命周期阶段。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)">
          <source>The adapter control state is separate and in addition to the control state of the control.</source>
          <target state="translated">适配器控件状态是分开的并且除了该控件的控件状态。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> that contains the adapter view state information as a <ph id="ph2">&lt;see cref="T:System.Web.UI.StateBag" /&gt;</ph>.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>，其中包含适配器视图的状态信息作为 <ph id="ph2">&lt;see cref="T:System.Web.UI.StateBag" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)">
          <source>Loads adapter view state information that was saved by <ph id="ph1">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /&gt;</ph> during a previous request to the page where the control associated with this control adapter resides.</source>
          <target state="translated">加载适配器视图状态信息，该信息由 <ph id="ph1">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /&gt;</ph> 在以前请求与此控件适配器关联的控件所驻留的页时保存。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)">
          <source>When an adapter needs to maintain its own view state information, it can override the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A&gt;</ph> methods.</source>
          <target state="translated">当适配器需要维护其自己的视图状态信息时，它可以重写<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)">
          <source>An adapter needs to maintain view state information when there is data that must be maintained across requests, independent from the view state of the associated control.</source>
          <target state="translated">适配器需要必须在请求中独立于关联控件的视图状态之间保持的数据时维护视图状态信息。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)">
          <source>For example, a grid control on desktop computer browsers might render as a single view of rows and columns of values.</source>
          <target state="translated">例如，台式计算机浏览器上的网格控件可能呈现为单个视图的行和列的值。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)">
          <source>On other browsers, it might split its rendering into multiple separate views, such as a list of rows and details of a single row.</source>
          <target state="translated">在其他浏览器，它可能会拆分为多个单独的视图，例如的行和单个行的详细信息列表其呈现。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)">
          <source>The adapter would need to maintain the data for the views that are not currently active in view state.</source>
          <target state="translated">适配器需要保持视图状态中不是当前处于活动状态的视图的数据。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A&gt;</ph> method is called immediately before the <ph id="ph2">&lt;xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType&gt;</ph> method in the <ph id="ph3">`LoadState`</ph> lifecycle stage.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A&gt;</ph>方法立即之前调用<ph id="ph2">&lt;xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType&gt;</ph>中的方法<ph id="ph3">`LoadState`</ph>生命周期阶段。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)">
          <source>The adapter view state is separate and in addition to the view state of the control.</source>
          <target state="translated">适配器视图状态是分开进行，并且除了该控件的视图状态。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)">
          <source>An <ph id="ph1">&lt;see cref="T:System.EventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">包含事件数据的 <ph id="ph1">&lt;see cref="T:System.EventArgs" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)">
          <source>Overrides the <ph id="ph1">&lt;see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /&gt;</ph> method for the associated control.</source>
          <target state="translated">重写关联控件的 <ph id="ph1">&lt;see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)">
          <source>If there is an adapter attached to a <ph id="ph1">&lt;xref:System.Web.UI.Control&gt;</ph> object and the <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A&gt;</ph> method is overridden, the override method is called instead of the <ph id="ph3">&lt;xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">如果没有适配器连接到<ph id="ph1">&lt;xref:System.Web.UI.Control&gt;</ph>对象和<ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A&gt;</ph>方法被重写，重写方法调用而不是<ph id="ph3">&lt;xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)">
          <source>Override <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A&gt;</ph> to perform target-specific processing in the <ph id="ph2">`Initialize`</ph> stage of the control lifecycle.</source>
          <target state="translated">重写<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A&gt;</ph>来执行特定于目标的处理中<ph id="ph2">`Initialize`</ph>控件生命周期的阶段。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)">
          <source>Typically, these are functions that are performed when a control is created.</source>
          <target state="translated">通常，这些都是创建一个控件时，将执行的函数。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)">
          <source>The following code sample derives a custom control adapter from the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter&gt;</ph> class.</source>
          <target state="translated">下面的代码示例派生的自定义控件适配器从<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)">
          <source>It then overrides the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A&gt;</ph> method to set a property on the associated control and call the base method to complete the control initialization.</source>
          <target state="translated">然后，它将替代<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A&gt;</ph>方法以在关联的控件上设置属性并调用基方法，以完成控件初始化。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)">
          <source>When you inherit from the <ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph> class and the adapter overrides the <ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /&gt;</ph> method, the adapter must call the corresponding base class method, which in turn calls the <ph id="ph3">&lt;see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /&gt;</ph> method.</source>
          <target state="translated">继承自<ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph>类，适配器并重写<ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /&gt;</ph>方法，适配器必须调用相应的基类方法，后者反过来调用<ph id="ph3">&lt;see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)">
          <source>If the <ph id="ph1">&lt;see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /&gt;</ph> method is not called, the <ph id="ph2">&lt;see cref="E:System.Web.UI.Control.Init" /&gt;</ph> event will not be raised.</source>
          <target state="translated">如果<ph id="ph1">&lt;see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /&gt;</ph>不调用方法，<ph id="ph2">&lt;see cref="E:System.Web.UI.Control.Init" /&gt;</ph>不会引发事件。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)">
          <source>An <ph id="ph1">&lt;see cref="T:System.EventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">包含事件数据的 <ph id="ph1">&lt;see cref="T:System.EventArgs" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)">
          <source>Overrides the <ph id="ph1">&lt;see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /&gt;</ph> method for the associated control.</source>
          <target state="translated">重写关联控件的 <ph id="ph1">&lt;see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)">
          <source>If there is an adapter attached to a <ph id="ph1">&lt;xref:System.Web.UI.Control&gt;</ph> object and the <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A&gt;</ph> method is overridden, the override method is called instead of the <ph id="ph3">&lt;xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">如果没有适配器连接到<ph id="ph1">&lt;xref:System.Web.UI.Control&gt;</ph>对象和<ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A&gt;</ph>方法被重写，重写方法调用而不是<ph id="ph3">&lt;xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)">
          <source>Override the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A&gt;</ph> method to perform target-specific processing in the <ph id="ph2">`Load`</ph> stage of the control lifecycle.</source>
          <target state="translated">重写<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A&gt;</ph>方法来执行特定于目标的处理中<ph id="ph2">`Load`</ph>控件生命周期的阶段。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)">
          <source>Typically, these are functions that should be performed for each client request.</source>
          <target state="translated">通常，这些都是应为每个客户端请求执行的函数。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)">
          <source>When you inherit from the <ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph> class and the adapter overrides the <ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /&gt;</ph> method, the adapter must call the corresponding base class method, which in turn calls the <ph id="ph3">&lt;see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /&gt;</ph> method.</source>
          <target state="translated">继承自<ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph>类，适配器并重写<ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /&gt;</ph>方法，适配器必须调用相应的基类方法，后者反过来调用<ph id="ph3">&lt;see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)">
          <source>If <ph id="ph1">&lt;see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /&gt;</ph> is not called, the <ph id="ph2">&lt;see cref="E:System.Web.UI.Control.Load" /&gt;</ph> event will not be raised.</source>
          <target state="translated">如果<ph id="ph1">&lt;see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /&gt;</ph>不调用，<ph id="ph2">&lt;see cref="E:System.Web.UI.Control.Load" /&gt;</ph>不会引发事件。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)">
          <source>An <ph id="ph1">&lt;see cref="T:System.EventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">包含事件数据的 <ph id="ph1">&lt;see cref="T:System.EventArgs" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)">
          <source>Overrides the <ph id="ph1">&lt;see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /&gt;</ph> method for the associated control.</source>
          <target state="translated">重写关联控件的 <ph id="ph1">&lt;see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)">
          <source>If there is an adapter attached to a <ph id="ph1">&lt;xref:System.Web.UI.Control&gt;</ph> object and the <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A&gt;</ph> method is overridden, the override method is called instead of the <ph id="ph3">&lt;xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">如果没有适配器连接到<ph id="ph1">&lt;xref:System.Web.UI.Control&gt;</ph>对象和<ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A&gt;</ph>方法被重写，重写方法调用而不是<ph id="ph3">&lt;xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)">
          <source>Override the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A&gt;</ph> method to perform target-specific processing in the <ph id="ph2">`PreRender`</ph> stage of the control lifecycle.</source>
          <target state="translated">重写<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A&gt;</ph>方法来执行特定于目标的处理中<ph id="ph2">`PreRender`</ph>控件生命周期的阶段。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)">
          <source>Typically, these are functions that immediately precede rendering of the control output.</source>
          <target state="translated">通常，这些都是紧跟呈现控制输出的函数。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)">
          <source>When you inherit from the <ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph> class and the adapter overrides the <ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /&gt;</ph> method, the adapter must call the corresponding base class method, which in turn calls the <ph id="ph3">&lt;see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /&gt;</ph> method.</source>
          <target state="translated">继承自<ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph>类，适配器并重写<ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /&gt;</ph>方法，适配器必须调用相应的基类方法，后者反过来调用<ph id="ph3">&lt;see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)">
          <source>If the <ph id="ph1">&lt;see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /&gt;</ph> method is not called, the <ph id="ph2">&lt;see cref="E:System.Web.UI.Control.PreRender" /&gt;</ph> event will not be raised.</source>
          <target state="translated">如果<ph id="ph1">&lt;see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /&gt;</ph>不调用方法，<ph id="ph2">&lt;see cref="E:System.Web.UI.Control.PreRender" /&gt;</ph>不会引发事件。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)">
          <source>An <ph id="ph1">&lt;see cref="T:System.EventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">包含事件数据的 <ph id="ph1">&lt;see cref="T:System.EventArgs" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)">
          <source>Overrides the <ph id="ph1">&lt;see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /&gt;</ph> method for the associated control.</source>
          <target state="translated">重写关联控件的 <ph id="ph1">&lt;see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)">
          <source>If there is an adapter attached to a <ph id="ph1">&lt;xref:System.Web.UI.Control&gt;</ph> object and the <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A&gt;</ph> method is overridden, the override method is called instead of the <ph id="ph3">&lt;xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">如果没有适配器连接到<ph id="ph1">&lt;xref:System.Web.UI.Control&gt;</ph>对象和<ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A&gt;</ph>方法被重写，重写方法调用而不是<ph id="ph3">&lt;xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)">
          <source>Override the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A&gt;</ph> method to do target-specific processing in the <ph id="ph2">`Unload`</ph> stage of the control lifecycle.</source>
          <target state="translated">重写<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A&gt;</ph>方法来执行特定于目标的处理操作<ph id="ph2">`Unload`</ph>控件生命周期的阶段。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)">
          <source>Typically, these are cleanup functions that precede disposition of the control.</source>
          <target state="translated">通常情况下，它们是位于之前处理控件的清理函数。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)">
          <source>When you inherit from the <ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph> class and the adapter overrides the <ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /&gt;</ph> method, the adapter must call the corresponding base class method, which in turn calls the <ph id="ph3">&lt;see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /&gt;</ph> method.</source>
          <target state="translated">继承自<ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph>类，适配器并重写<ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /&gt;</ph>方法，适配器必须调用相应的基类方法，后者反过来调用<ph id="ph3">&lt;see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)">
          <source>If <ph id="ph1">&lt;see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /&gt;</ph> is not called, the <ph id="ph2">&lt;see cref="E:System.Web.UI.Control.Unload" /&gt;</ph> event will not be raised.</source>
          <target state="translated">如果<ph id="ph1">&lt;see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /&gt;</ph>不调用，<ph id="ph2">&lt;see cref="E:System.Web.UI.Control.Unload" /&gt;</ph>不会引发事件。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="P:System.Web.UI.Adapters.ControlAdapter.Page">
          <source>Gets a reference to the page where the control associated with this adapter resides.</source>
          <target state="translated">获取对与此适配器关联的控件所驻留的页的引用。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Web.UI.Adapters.ControlAdapter.Page">
          <source>A <ph id="ph1">&lt;see cref="T:System.Web.UI.Page" /&gt;</ph> that provides access to the page instance where the associated control is situated.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Web.UI.Page" /&gt;</ph>，可提供对关联控件所在的页实例的访问权限。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Web.UI.Adapters.ControlAdapter.Page">
          <source>The <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Page%2A&gt;</ph> property provides access to the <ph id="ph2">&lt;xref:System.Web.UI.Page?displayProperty=nameWithType&gt;</ph> object where the control is situated.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Page%2A&gt;</ph>属性提供访问权限<ph id="ph2">&lt;xref:System.Web.UI.Page?displayProperty=nameWithType&gt;</ph>控件所在的对象。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter">
          <source>Gets a reference to the page adapter for the page where the associated control resides.</source>
          <target state="translated">获取对关联控件所驻留的页的页适配器的引用。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter">
          <source>A <ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.PageAdapter" /&gt;</ph> for the page where the control associated with the current <ph id="ph2">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph> is situated.</source>
          <target state="translated">用于与当前 <ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.PageAdapter" /&gt;</ph> 关联的控件所在的页的 <ph id="ph2">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter">
          <source>The <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A&gt;</ph> property provides access to the <ph id="ph2">&lt;xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType&gt;</ph> object for the <ph id="ph3">&lt;xref:System.Web.UI.Page&gt;</ph> object where the <ph id="ph4">&lt;xref:System.Web.UI.Control&gt;</ph> object associated with the current <ph id="ph5">&lt;xref:System.Web.UI.Adapters.ControlAdapter&gt;</ph> object is situated.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A&gt;</ph>属性提供访问权限<ph id="ph2">&lt;xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType&gt;</ph>对象<ph id="ph3">&lt;xref:System.Web.UI.Page&gt;</ph>对象其中<ph id="ph4">&lt;xref:System.Web.UI.Control&gt;</ph>关联与当前对象<ph id="ph5">&lt;xref:System.Web.UI.Adapters.ControlAdapter&gt;</ph>对象的权限。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter">
          <source>The <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A&gt;</ph> property can be used to access other items at the page adapter level, such as common target-specific functions that could apply to several control types on the page.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A&gt;</ph>属性可用来访问页级别适配器，如可应用于页面上的多个控件类型的公共目标特定函数的其他项。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Web.UI.HtmlTextWriter" /&gt;</ph> to use to render the target-specific output.</source>
          <target state="translated">用于呈现特定于目标的输出的 <ph id="ph1">&lt;see cref="T:System.Web.UI.HtmlTextWriter" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)">
          <source>Generates the target-specific markup for the control to which the control adapter is attached.</source>
          <target state="translated">为附加了控件适配器的控件生成目标特定的标记。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)">
          <source>Override the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph> method to generate target-specific markup to send to the client browser.</source>
          <target state="translated">重写<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph>方法来生成特定于目标的标记将发送到客户端浏览器。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)">
          <source>The <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph> method is called in place of the <ph id="ph2">&lt;xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType&gt;</ph> method if a <ph id="ph3">&lt;xref:System.Web.UI.Adapters.ControlAdapter&gt;</ph> object is attached to a <ph id="ph4">&lt;xref:System.Web.UI.Control&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.Render%2A&gt;</ph>代替了调用方法<ph id="ph2">&lt;xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType&gt;</ph>方法如果<ph id="ph3">&lt;xref:System.Web.UI.Adapters.ControlAdapter&gt;</ph>对象附加到<ph id="ph4">&lt;xref:System.Web.UI.Control&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)">
          <source>When you inherit from the <ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph> class, the <ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph> base method calls the <ph id="ph3">&lt;see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph> method.</source>
          <target state="translated">继承自<ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph>类，<ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph>基方法调用<ph id="ph3">&lt;see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)">
          <source>Thus, overrides of the <ph id="ph1">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph> method should call the <ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph> base method only if its processing is in addition to, rather than instead of, the <ph id="ph3">&lt;see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph> method.</source>
          <target state="translated">因此，重写<ph id="ph1">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph>方法应调用<ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph>基方法，仅当其处理为中而非取代，后者而不是，<ph id="ph3">&lt;see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)">
          <source>For a composite control, the adapter developer must ensure that the child controls are rendered.</source>
          <target state="translated">对于复合控件，适配器开发人员必须确保呈现子控件。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)">
          <source>If the <ph id="ph1">&lt;see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph> method causes the child controls to be rendered but does not generate markup, it might be appropriate for the <ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph> method to call its base method.</source>
          <target state="translated">如果<ph id="ph1">&lt;see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph>方法使子控件呈现，但不会生成标记，它可能适用于<ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph>方法来调用其基的方法。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)">
          <source>If target-specific rendering of the child controls is necessary, the adapter should implement the <ph id="ph1">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /&gt;</ph> method and call the <ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /&gt;</ph> method from the <ph id="ph3">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph> method.</source>
          <target state="translated">如果子控件的特定于目标的呈现有必要，应实现适配器<ph id="ph1">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /&gt;</ph>方法并且调用<ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /&gt;</ph>方法从<ph id="ph3">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Web.UI.HtmlTextWriter" /&gt;</ph> to use to render the target-specific output.</source>
          <target state="translated">用于呈现特定于目标的输出的 <ph id="ph1">&lt;see cref="T:System.Web.UI.HtmlTextWriter" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)">
          <source>Generates the target-specific markup for the child controls in a composite control to which the control adapter is attached.</source>
          <target state="translated">为附加了控件适配器的复合控件中的子控件生成特定于目标的标记。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)">
          <source>Override the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A&gt;</ph> method when it is necessary to generate target-specific markup for the child control set of a composite control, in addition to the markup for the individual child controls.</source>
          <target state="translated">重写<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A&gt;</ph>方法需要生成目标特定于标记的子控件一套复合控件，此外到各个子控件的标记时。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)">
          <source>When you inherit from the <ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph> class, for a composite control, the adapter developer must ensure that the child controls are rendered.</source>
          <target state="translated">继承自<ph id="ph1">&lt;see cref="T:System.Web.UI.Adapters.ControlAdapter" /&gt;</ph>复合控件，适配器开发人员的类，必须确保能呈现子控件。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)">
          <source>If the adapter overrides the <ph id="ph1">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /&gt;</ph> method, it should call the <ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /&gt;</ph> method from an override of the <ph id="ph3">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph> method.</source>
          <target state="translated">如果适配器重写<ph id="ph1">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /&gt;</ph>方法，则应调用<ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /&gt;</ph>方法的重写<ph id="ph3">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)">
          <source>If the <ph id="ph1">&lt;see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph> method causes the child controls to be rendered but itself does not generate markup, it might be appropriate for the <ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph> method to call its base method, which calls the <ph id="ph3">&lt;see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph> method, instead of implementing an override for the <ph id="ph4">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /&gt;</ph> method.</source>
          <target state="translated">如果<ph id="ph1">&lt;see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph>方法使子控件呈现，但本身不会生成标记，它可能适用于<ph id="ph2">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph>方法来调用与其基方法，调用该方法<ph id="ph3">&lt;see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /&gt;</ph>方法，而不是实现的替代<ph id="ph4">&lt;see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState">
          <source>Saves control state information for the control adapter.</source>
          <target state="translated">保存控件适配器的控件状态信息。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState">
          <source>An <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> that contains the adapter's control state information as a <ph id="ph2">&lt;see cref="T:System.Web.UI.StateBag" /&gt;</ph>.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>，其中包含适配器的控件状态信息作为 <ph id="ph2">&lt;see cref="T:System.Web.UI.StateBag" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState">
          <source>Control state is the essential state information needed even if view state is disabled.</source>
          <target state="translated">控件状态是所需即使禁用了视图状态的基本状态信息。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState">
          <source>When an adapter needs to maintain its own control state information, it can override the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A&gt;</ph> methods.</source>
          <target state="translated">当适配器需要维护其自己的控件状态信息时，它可以重写<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState">
          <source>An adapter might need to maintain control state information when there are features that need to have state maintained across requests, independent from the state of the associated control.</source>
          <target state="translated">适配器可能需要时有需要具有多个请求，独立于关联控件的状态之间保持的状态的功能保持控件状态信息。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState">
          <source>For example, a composite control consisting of a large textual display and a group of <ph id="ph1">&lt;xref:System.Web.UI.WebControls.RadioButton&gt;</ph> controls might render as a single view on desktop computer browsers.</source>
          <target state="translated">例如，大型的文本显示和一组组成的复合控件<ph id="ph1">&lt;xref:System.Web.UI.WebControls.RadioButton&gt;</ph>控件可能呈现为台式计算机浏览器上的单一视图。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState">
          <source>On other browsers, it might split its rendering—one view for the textual display and the other for the radio button group.</source>
          <target state="translated">在其他浏览器，它可能会拆分其呈现-文本显示和另一个用于的单选按钮组的一个视图。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState">
          <source>The adapter would need to maintain its own target-specific information about the currently active view.</source>
          <target state="translated">适配器需要维护其自己的特定于目标的信息，有关当前处于活动状态的视图。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState">
          <source>The <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A&gt;</ph> method is called immediately after the <ph id="ph2">&lt;xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType&gt;</ph> method in the <ph id="ph3">`SaveState`</ph> lifecycle stage.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A&gt;</ph>方法之后，立即调用<ph id="ph2">&lt;xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType&gt;</ph>中的方法<ph id="ph3">`SaveState`</ph>生命周期阶段。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState">
          <source>The adapter control state is separate and in addition to the control state of the control.</source>
          <target state="translated">适配器控件状态是分开的并且除了该控件的控件状态。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState">
          <source>Saves view state information for the control adapter.</source>
          <target state="translated">保存控件适配器的视图状态信息。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState">
          <source>An <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> that contains the adapter view state information as a <ph id="ph2">&lt;see cref="T:System.Web.UI.StateBag" /&gt;</ph>.</source>
          <target state="translated">一个 <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>，其中包含适配器视图的状态信息作为 <ph id="ph2">&lt;see cref="T:System.Web.UI.StateBag" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState">
          <source>When an adapter needs to maintain its own view state information, it can override the <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A&gt;</ph> methods.</source>
          <target state="translated">当适配器需要维护其自己的视图状态信息时，它可以重写<ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState">
          <source>An adapter needs to maintain view state information when there is data that must be maintained across requests, independent from the associated view state of the control.</source>
          <target state="translated">适配器需要必须在请求中独立于控件的关联的视图状态之间保持的数据时维护视图状态信息。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState">
          <source>For example, a grid control on desktop computer browsers might render as a single view of rows and columns of values.</source>
          <target state="translated">例如，台式计算机浏览器上的网格控件可能呈现为单个视图的行和列的值。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState">
          <source>On other browsers, it might split its rendering into multiple separate views, such as a list of rows and details of a single row.</source>
          <target state="translated">在其他浏览器，它可能会拆分为多个单独的视图，例如的行和单个行的详细信息列表其呈现。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState">
          <source>The adapter would need to maintain the data for the views that are not currently active in view state.</source>
          <target state="translated">适配器需要保持视图状态中不是当前处于活动状态的视图的数据。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState">
          <source>The <ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A&gt;</ph> method is called immediately before the <ph id="ph2">&lt;xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType&gt;</ph> method in the <ph id="ph3">`SaveState`</ph> lifecycle stage.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A&gt;</ph>方法立即之前调用<ph id="ph2">&lt;xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType&gt;</ph>中的方法<ph id="ph3">`SaveState`</ph>生命周期阶段。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState">
          <source>The adapter view state is separate and in addition to the view state of the control.</source>
          <target state="translated">适配器视图状态是分开进行，并且除了该控件的视图状态。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>