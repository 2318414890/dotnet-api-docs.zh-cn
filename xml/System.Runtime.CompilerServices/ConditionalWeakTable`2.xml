<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ConditionalWeakTable`2.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac575a1ca0bc007b584e93073f8cc318bd920092d8d.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">75a1ca0bc007b584e93073f8cc318bd920092d8d</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The reference type to which the field is attached.</source>
          <target state="translated">字段所附加到的引用类型。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The field's type.</source>
          <target state="translated">字段的类型。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>This must be a reference type.</source>
          <target state="translated">此类型必须是引用类型。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>Enables compilers to dynamically attach object fields to managed objects.</source>
          <target state="translated">使编译器可以将对象字段动态附加到托管对象。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> class enables language compilers to attach arbitrary properties to managed objects at run time.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph>类使语言编译器可以在运行时将任意属性附加到托管对象。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>A <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> object is a dictionary that binds a managed object, which is represented by a key, to its attached property, which is represented by a value.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph>对象是一个将托管的对象，由一个键，表示绑定到由的值表示其附加属性的字典。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The object's keys are the individual instances of the <ph id="ph1">`TKey`</ph> class to which the property is attached, and its values are the property values that are assigned to the corresponding objects.</source>
          <target state="translated">对象的键是的单独实例<ph id="ph1">`TKey`</ph>类向其附加属性，且其值分配给相应的对象的属性值。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>Keys must be unique; in other words, the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> class supports one attached value per managed object.</source>
          <target state="translated">密钥必须是唯一的;换而言之，<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph>类支持每个托管对象的一个附加的值。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>Two keys are equal if passing them to the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">两个键是否相等，如果将它们传递给<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>方法返回<ph id="ph2">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>You cannot control equality comparisons by overriding <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> to explicitly set the hash code for a key.</source>
          <target state="translated">您不能通过重写来控制相等比较<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>来显式设置键的哈希代码。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> class does not use the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method to compute hash codes, and therefore does not invoke <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> overrides.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph>类不使用<ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>方法来计算哈希代码，并因此不会调用<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>重写。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>Although the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> class holds a collection of key/value pairs, it is best thought of as a table rather than a dictionary object.</source>
          <target state="translated">尽管<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph>类包含键/值对的集合，它最视为表，而不是字典对象。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> class differs from a dictionary in several ways:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph>类不同于以下几种方式字典：</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>It does not persist keys.</source>
          <target state="translated">它不会保留密钥。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>That is, a key is not kept alive only because it is a member of the collection.</source>
          <target state="translated">也就是说，一个密钥不保持活动状态只是因为它是集合的成员。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>It does not include all the methods (such as <ph id="ph1">`GetEnumerator`</ph> or <ph id="ph2">`Contains`</ph>) that a dictionary typically has.</source>
          <target state="translated">它不包括所有方法 (如<ph id="ph1">`GetEnumerator`</ph>或<ph id="ph2">`Contains`</ph>) 通常具有一个字典。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>It does not implement the <ph id="ph1">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph> interface.</source>
          <target state="translated">它未实现<ph id="ph1">&lt;xref:System.Collections.Generic.IDictionary%602&gt;</ph>接口。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> class differs from other collection objects in its management of the object lifetime of keys stored in the collection.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph>类不同于其存储在集合中的键的对象生存期管理中的其他集合对象。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>Ordinarily, when an object is stored in a collection, its lifetime lasts until it is removed (and there are no additional references to the object) or until the collection object itself is destroyed.</source>
          <target state="translated">通常，当对象存储在集合中时，其生存期是指直到将会删除 （并且没有任何其他引用的对象） 或销毁集合对象本身。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>However, in the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> class, adding a key/value pair to the table does not ensure that the key will persist, even if it can be reached directly from a value stored in the table (for example, if the table contains one key, A, with a value V1, and a second key, B, with a value P2 that contains a reference to A).</source>
          <target state="translated">但是，在<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph>类，添加到表的键/值对不能确保，将会保留密钥，即使它可以直接从存储 （例如，如果表包含一个键，A，值 V1 表中的值已达到，和一个第二个 B，值包含一个对的引用的 P2)。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>Instead, <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> automatically removes the key/value entry as soon as no other references to a key exist outside the table.</source>
          <target state="translated">相反，<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph>自动中移除的键/值项，只要外部表不存在任何其他引用的密钥。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The example provides an illustration.</source>
          <target state="translated">说明如示例所示。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The following example illustrates that a key stored in the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> table does not persist after references to it outside the table are destroyed.</source>
          <target state="translated">下面的示例阐释了密钥存储在<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph>到它引用外部表会被销毁后未保留表。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The example defines two classes: <ph id="ph1">`ManagedClass`</ph>, which represents the key in the table, and <ph id="ph2">`ClassData`</ph>, which represents the key's value.</source>
          <target state="translated">该示例定义两个类： <ph id="ph1">`ManagedClass`</ph>，它表示在表中，密钥和<ph id="ph2">`ClassData`</ph>，它表示密钥的值。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The example instantiates three objects of each type.</source>
          <target state="translated">该示例实例化每种类型的三个的对象。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>It also instantiates a <ph id="ph1">&lt;xref:System.WeakReference&gt;</ph> object that represents the second <ph id="ph2">`ManagedClass`</ph>, and then destroys the second <ph id="ph3">`ManagedClass`</ph> instance.</source>
          <target state="translated">它还实例化<ph id="ph1">&lt;xref:System.WeakReference&gt;</ph>对象，表示第二个<ph id="ph2">`ManagedClass`</ph>，然后销毁第二个<ph id="ph3">`ManagedClass`</ph>实例。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>The attempt to retrieve the second <ph id="ph1">`ManagedClass`</ph> object from the <ph id="ph2">&lt;xref:System.WeakReference.Target%2A&gt;</ph> property indicates that no references to the object remain.</source>
          <target state="translated">尝试检索第二个<ph id="ph1">`ManagedClass`</ph>对象<ph id="ph2">&lt;xref:System.WeakReference.Target%2A&gt;</ph>属性指示没有对对象的引用保留。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>Instances of the <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /&gt;</ph> class are thread safe.</source>
          <target state="translated">实例<ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /&gt;</ph>类都是线程安全。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.ConditionalWeakTable`2">
          <source>They do not require callers to do any additional locking.</source>
          <target state="translated">它们不需要调用方执行任何其他的锁定。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A&gt;</ph> constructor instantiates an empty <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> table; that is, the table contains no key/value pairs.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A&gt;</ph>构造函数实例化一个空<ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph>表; 也就是说，表中包含没有键/值对。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor">
          <source>You can add key/value pairs by calling the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph> method.</source>
          <target state="translated">可以通过调用来添加键/值对添加<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph>，或<ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> object must be unique.</source>
          <target state="translated">中的所有键<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph>对象必须是唯一的。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor">
          <source>Keys are not unique if they refer to the same object (that is, if passing them as arguments to the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method returns <ph id="ph2">`true`</ph>).</source>
          <target state="translated">键不是唯一的如果它们是指同一对象 (即，如果将它们作为自变量传递<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>方法返回<ph id="ph2">`true`</ph>)。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>The key to add.</source>
          <target state="translated">要添加的键。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source><bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept> represents the object to which the property is attached.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept> 表示该属性附加到的对象。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>The key's property value.</source>
          <target state="translated">该键的属性值。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>Adds a key to the table.</source>
          <target state="translated">将键添加到表中。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>Every key in a <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> object must be unique.</source>
          <target state="translated">中的所有键<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph>对象必须是唯一的。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>Keys are not unique if they refer to the same object (that is, if passing them as arguments to the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method returns <ph id="ph2">`true`</ph>).</source>
          <target state="translated">键不是唯一的如果它们是指同一对象 (即，如果将它们作为自变量传递<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>方法返回<ph id="ph2">`true`</ph>)。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>If the key is garbage-collected during the addition operation, the existing key/value pair is removed and the new key/value pair is added without an exception being thrown.</source>
          <target state="translated">如果键在加法运算是垃圾回收，删除现有的键/值对，并不会引发异常的情况下添加新的键/值对。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>The following example defines a <ph id="ph1">`MainClass`</ph> class and a <ph id="ph2">`MainInfo`</ph> class, which provides information about the <ph id="ph3">`MainClass`</ph> instance.</source>
          <target state="translated">下面的示例定义<ph id="ph1">`MainClass`</ph>类和一个<ph id="ph2">`MainInfo`</ph>类，该类相关信息提供<ph id="ph3">`MainClass`</ph>实例。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph> method to add a <ph id="ph2">`MainClass`</ph> object and its attached <ph id="ph3">`MainInfo`</ph> object to a <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> table.</source>
          <target state="translated">该示例然后调用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph>方法将添加<ph id="ph2">`MainClass`</ph>对象和其附加<ph id="ph3">`MainInfo`</ph>对象传递给<ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph>表。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>The example also illustrates calls to the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> methods to add key/value pairs to the table, and to the <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph> method to retrieve the value of an existing key.</source>
          <target state="translated">该示例还演示如何调用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph>方法来将键/值对添加到表中，和<ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph>方法来检索现有键的值。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> already exists.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> 已存在。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Finalize">
          <source>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /&gt;</ph> object.</source>
          <target state="translated">确保垃圾回收器回收 <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /&gt;</ph> 对象时释放资源并执行其他清理操作。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Finalize">
          <source>The garbage collector calls <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A&gt;</ph> when the current object is ready to be finalized.</source>
          <target state="translated">垃圾回收器调用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A&gt;</ph>何时准备好完成当前的对象。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>The key to search for.</source>
          <target state="translated">要搜索的键。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source><bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept> represents the object to which the property is attached.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept> 表示该属性附加到的对象。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>Atomically searches for a specified key in the table and returns the corresponding value.</source>
          <target state="translated">以原子方式在表中搜索指定键，并返回对应的值。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>If the key does not exist in the table, the method invokes the default constructor of the class that represents the table's value to create a value that is bound to the specified key.</source>
          <target state="translated">如果表中不存在该键，此方法将调用表示表值的类的默认构造函数，以创建绑定到指定键的值。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>The value that corresponds to <ph id="ph1">&lt;paramref name="key" /&gt;</ph>, if <ph id="ph2">&lt;paramref name="key" /&gt;</ph> already exists in the table; otherwise, a new value created by the default constructor of the class defined by the <ph id="ph3">&lt;paramref name="TValue" /&gt;</ph> generic type parameter.</source>
          <target state="translated">如果表中已存在 <ph id="ph1">&lt;paramref name="key" /&gt;</ph>，则为对应于 <ph id="ph2">&lt;paramref name="key" /&gt;</ph> 的值；否则为 <ph id="ph3">&lt;paramref name="TValue" /&gt;</ph> 范型类型参数定义的类的默认构造函数创建的新值。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>If <ph id="ph1">`key`</ph> does not exist in the table, the method adds it, along with the object that is instantiated by calling the default constructor of the class defined by the <ph id="ph2">`TValue`</ph> generic type parameter.</source>
          <target state="translated">如果<ph id="ph1">`key`</ph>不存在在表中，该方法将其添加，以及通过调用默认构造函数的定义的类实例化对象<ph id="ph2">`TValue`</ph>泛型类型参数。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>If the <ph id="ph1">`TValue`</ph> class has no default constructor, a <ph id="ph2">&lt;xref:System.MissingMethodException&gt;</ph> is thrown.</source>
          <target state="translated">如果<ph id="ph1">`TValue`</ph>类具有无默认构造函数中，<ph id="ph2">&lt;xref:System.MissingMethodException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>This is the recommended method of retrieving an existing value or adding a new value to the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> table if the class of the table's value defines a default constructor.</source>
          <target state="translated">这是建议的方法检索现有值或添加新值赋给<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph>表如果表的值的类定义的默认构造函数。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>If it does not define a default constructor, you can instead call the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> method, which relies on a callback-provided method to instantiate the object representing the table's value</source>
          <target state="translated">如果它未定义默认构造函数，可以改为调用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph>方法，这种提供回调的方法来实例化对象，表示表的值在依赖于</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>To retrieve the value of an existing key without adding the key/value pair if the key is not found in the table, call the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph> method.</source>
          <target state="translated">若要检索现有密钥的值，而无需添加键/值对，如果在表中，未找到此项调用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>The following example defines a <ph id="ph1">`MainClass`</ph> class and a <ph id="ph2">`MainInfo`</ph> class, which provides information about the <ph id="ph3">`MainClass`</ph> instance.</source>
          <target state="translated">下面的示例定义<ph id="ph1">`MainClass`</ph>类和一个<ph id="ph2">`MainInfo`</ph>类，该类相关信息提供<ph id="ph3">`MainClass`</ph>实例。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>The example calls the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph> method to add a <ph id="ph2">`MainClass`</ph> object and its attached <ph id="ph3">`MainInfo`</ph> object to a <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> table.</source>
          <target state="translated">该示例通过调用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph>方法将添加<ph id="ph2">`MainClass`</ph>对象和其附加<ph id="ph3">`MainInfo`</ph>对象传递给<ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph>表。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>The example also illustrates calls to the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> methods to add key/value pairs to the table, and to the <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph> method to retrieve the value of an existing key.</source>
          <target state="translated">该示例还演示如何调用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph>方法来将键/值对添加到表中，和<ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph>方法来检索现有键的值。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.MissingMemberException" /&gt;</ph>, instead.</source>
          <target state="translated">在<bpt id="p1">[</bpt>适用于 Windows 应用商店应用的 .NET<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> 或<bpt id="p2">[</bpt>可移植类库<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>中，改为捕获基类异常 <ph id="ph1">&lt;see cref="T:System.MissingMemberException" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)">
          <source>The class that represents the table's value does not define a default constructor.</source>
          <target state="translated">表示表中值的类未定义默认构造函数。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>The key to search for.</source>
          <target state="translated">要搜索的键。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source><bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept> represents the object to which the property is attached.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept> 表示该属性附加到的对象。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>A delegate to a method that can create a value for the given <bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">可以为给定 <bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept> 创建值的方法的委托。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>It has a single parameter of type <bpt id="p1">&lt;c&gt;</bpt>TKey<ept id="p1">&lt;/c&gt;</ept>, and returns a value of type <bpt id="p2">&lt;c&gt;</bpt>TValue<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">它只有一个 <bpt id="p1">&lt;c&gt;</bpt>TKey<ept id="p1">&lt;/c&gt;</ept> 类型的参数，并返回一个 <bpt id="p2">&lt;c&gt;</bpt>TValue<ept id="p2">&lt;/c&gt;</ept> 类型的值。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>Atomically searches for a specified key in the table and returns the corresponding value.</source>
          <target state="translated">以原子方式在表中搜索指定键，并返回对应的值。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>If the key does not exist in the table, the method invokes a callback method to create a value that is bound to the specified key.</source>
          <target state="translated">如果表中不存在该键，此方法将调用一个回调方法来创建绑定到指定键的值。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>The value attached to <ph id="ph1">&lt;paramref name="key" /&gt;</ph>, if <ph id="ph2">&lt;paramref name="key" /&gt;</ph> already exists in the table; otherwise, the new value returned by the <ph id="ph3">&lt;paramref name="createValueCallback" /&gt;</ph> delegate.</source>
          <target state="translated">如果表中已存在 <ph id="ph1">&lt;paramref name="key" /&gt;</ph>，则为附加到 <ph id="ph2">&lt;paramref name="key" /&gt;</ph> 的值；否则为 <ph id="ph3">&lt;paramref name="createValueCallback" /&gt;</ph> 委托返回的新值。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>If <ph id="ph1">`key`</ph> does not exist in the table, <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> invokes the method that is defined by the <ph id="ph3">`createValueCallback`</ph> parameter and passes it the key.</source>
          <target state="translated">如果<ph id="ph1">`key`</ph>不在表中，存在<ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph>调用方法定义的<ph id="ph3">`createValueCallback`</ph>参数并将其传递该密钥。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>A new value is bound to the key in the table and returned as a result.</source>
          <target state="translated">新值为绑定到表中的键，并作为结果返回。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>Use this method only when the class that represents the table's value does not define a default constructor.</source>
          <target state="translated">仅当表示表的值的类未定义默认构造函数时，请使用此方法。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>If it does define a default constructor, use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph> method instead.</source>
          <target state="translated">如果它没有定义默认构造函数，则使用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph>方法相反。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>To retrieve the value of an existing key without adding the key/value pair if the key is not found in the table, call the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph> method.</source>
          <target state="translated">若要检索现有密钥的值，而无需添加键/值对，如果在表中，未找到此项调用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>If multiple threads try to create the same key, <ph id="ph1">`createValueCallback`</ph> may be invoked multiple times with the same key.</source>
          <target state="translated">如果多个线程尝试创建相同的键，<ph id="ph1">`createValueCallback`</ph>使用相同的密钥可以调用多次。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>Only one of these calls will succeed, and its returned value will be added to the table.</source>
          <target state="translated">只有一个这些调用将成功，并且其返回的值将添加到表。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>Which thread succeeds in creating the value is indeterminate.</source>
          <target state="translated">哪个线程便可以成功创建值是不确定的。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>This rule permits the table to invoke <ph id="ph1">`createValueCallback`</ph> outside the internal table lock to prevent deadlocks.</source>
          <target state="translated">此规则只允许表来调用<ph id="ph1">`createValueCallback`</ph>外部内部表锁，以防止死锁。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>The following example defines a <ph id="ph1">`MainClass`</ph> class and a <ph id="ph2">`MainInfo`</ph> class, which provides information about the <ph id="ph3">`MainClass`</ph> instance.</source>
          <target state="translated">下面的示例定义<ph id="ph1">`MainClass`</ph>类和一个<ph id="ph2">`MainInfo`</ph>类，该类相关信息提供<ph id="ph3">`MainClass`</ph>实例。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>It also defines a static (<ph id="ph1">`Shared`</ph> in Visual Basic) <ph id="ph2">`CreateAttachedValue`</ph> method that can be assigned to the <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback&gt;</ph> delegate and passed to the <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> method.</source>
          <target state="translated">它还定义一个静态 (<ph id="ph1">`Shared`</ph>在 Visual Basic 中)<ph id="ph2">`CreateAttachedValue`</ph>方法可以分配给<ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback&gt;</ph>委派并传递给<ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>The example calls the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> method to add a <ph id="ph2">`MainClass`</ph> object and its attached <ph id="ph3">`MainInfo`</ph> object to a <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> table.</source>
          <target state="translated">该示例通过调用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph>方法将添加<ph id="ph2">`MainClass`</ph>对象和其附加<ph id="ph3">`MainInfo`</ph>对象传递给<ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph>表。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>The example also illustrates calls to the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph> methods to add key/value pairs to the table, and to the <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph> method to retrieve the value of an existing key.</source>
          <target state="translated">该示例还演示如何调用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph>方法来将键/值对添加到表中，和<ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph>方法来检索现有键的值。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> or <ph id="ph2">&lt;paramref name="createValueCallback" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="createValueCallback" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)">
          <source>The key to remove.</source>
          <target state="translated">要移除的键。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)">
          <source>Removes a key and its value from the table.</source>
          <target state="translated">从表中移除某个键及其值。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the key is found and removed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果找到并移除该键，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)">
          <source>If the key is garbage-collected during this operation, the method does not raise an exception and the return value is undefined.</source>
          <target state="translated">如果键在此操作过程是垃圾回收，该方法不会引发异常，并返回值是不确定。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>The key that represents an object with an attached property.</source>
          <target state="translated">一个键，表示具有所附加的属性的对象。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>When this method returns, contains the attached property value.</source>
          <target state="translated">此方法返回时，将包含所附加的属性值。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept> is not found, <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> contains the default value.</source>
          <target state="translated">如果找不到 <bpt id="p1">&lt;c&gt;</bpt>key<ept id="p1">&lt;/c&gt;</ept>，则 <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> 包含默认值。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>Gets the value of the specified key.</source>
          <target state="translated">获取指定键的值。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="key" /&gt;</ph> is found; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果找到 <ph id="ph2">&lt;paramref name="key" /&gt;</ph>，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>If the key is garbage-collected during this operation, the method may return <ph id="ph1">`false`</ph> and set <ph id="ph2">`value`</ph> to the default value (as if the key were not present).</source>
          <target state="translated">如果密钥是垃圾回收在此操作期间，该方法可能返回<ph id="ph1">`false`</ph>并设置<ph id="ph2">`value`</ph>到默认值 （如同键不存在）。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>The following example defines a <ph id="ph1">`MainClass`</ph> class and a <ph id="ph2">`MainInfo`</ph> class, which provides information about the <ph id="ph3">`MainClass`</ph> instance.</source>
          <target state="translated">下面的示例定义<ph id="ph1">`MainClass`</ph>类和一个<ph id="ph2">`MainInfo`</ph>类，该类相关信息提供<ph id="ph3">`MainClass`</ph>实例。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>The example calls the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph> methods to add key/value pairs to a <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph> table.</source>
          <target state="translated">该示例通过调用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A&gt;</ph>，和<ph id="ph3">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A&gt;</ph>添加到的键/值对的方法<ph id="ph4">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602&gt;</ph>表。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>In each case, the example calls the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph> method to confirm that the key/value pair has been added to the table.</source>
          <target state="translated">在每个情况下，该示例调用<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A&gt;</ph>方法来确认已将键/值对添加到表。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>