<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TaskScheduler.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5ddd94061f594e353cba8674c76ffcb77a643ddb1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ddd94061f594e353cba8674c76ffcb77a643ddb1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Represents an object that handles the low-level work of queuing tasks onto threads.</source>
          <target state="translated">表示一个处理将任务排队到线程中的低级工作的对象。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> class represents a task scheduler.</source>
          <target state="translated">实例<ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph>类表示任务计划程序。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>A task scheduler ensures that the work of a task is eventually executed.</source>
          <target state="translated">任务计划程序确保最终执行任务作业。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance.</source>
          <target state="translated">默认的任务计划程序基于 .NET Framework 4 线程池，提供工作窃取实现负载平衡、线程注入/退出以实现最大吞吐量，并提供整体卓越性能。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>It should be sufficient for most scenarios.</source>
          <target state="translated">它应足以满足大多数方案。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> class also serves as the extension point for all customizable scheduling logic.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph>类也可作为所有可自定义计划逻辑的扩展点。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers.</source>
          <target state="translated">这包括机制，如 逼的执行，任务和如何计划的任务应公开给调试器。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.</source>
          <target state="translated">如果需要特殊功能，你可以创建自定义计划程序和启用以执行特定任务或查询。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In this topic:</source>
          <target state="translated">本主题内容：</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>The default task scheduler and the thread pool<ept id="p1">](#Default)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>默认任务计划程序和线程池<ept id="p1">](#Default)</ept></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>The global queue vs. local queues<ept id="p1">](#Queues)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>全局队列与本地队列<ept id="p1">](#Queues)</ept></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Work stealing<ept id="p1">](#Stealing)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>工作窃取<ept id="p1">](#Stealing)</ept></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Long-running tasks<ept id="p1">](#LongRunning)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>长时间运行的任务<ept id="p1">](#LongRunning)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Task inlining<ept id="p1">](#Inlining)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>任务内联<ept id="p1">](#Inlining)</ept></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source><bpt id="p1">[</bpt>Specifying a synchronization context<ept id="p1">](#Sync)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>指定同步上下文<ept id="p1">](#Sync)</ept></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The default task scheduler and the thread pool</source>
          <target state="translated">默认任务计划程序和线程池</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> class, to queue and execute work.</source>
          <target state="translated">任务并行库和 PLINQ 的默认计划程序使用.NET Framework 线程池，由表示<ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph>类进行排队并执行工作。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The thread pool uses the information that is provided by the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.</source>
          <target state="translated">线程池使用由提供的信息<ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph>类型有效支持并行任务和查询通常表示的细化并行 （生存期较短的工作单位）。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The global queue vs. local queues</source>
          <target state="translated">全局队列与本地队列</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain.</source>
          <target state="translated">该线程池保持全局的 FIFO （先进先出） 工作队列中的每个应用程序域中的线程。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Whenever a program calls the <ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph> (or <ph id="ph2">&lt;xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available.</source>
          <target state="translated">每当程序调用<ph id="ph1">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph>(或<ph id="ph2">&lt;xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType&gt;</ph>) 方法，工作均放在此共享队列上并最终取消排队变得可用的下一个线程。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> class.</source>
          <target state="translated">从.NET Framework 4 开始，此队列已经得到改进以使用类似于无锁算法<ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items.</source>
          <target state="translated">通过使用此无锁实现，线程池消耗较少的时间时它排队和离队工作项。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This performance benefit is available to all programs that use the thread pool.</source>
          <target state="translated">此性能优势可供使用线程池的所有程序。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item.</source>
          <target state="translated">最高级任务（即不在其他任务的上下文中创建的任务）与任何其他工作项一样放在全局队列上。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>However, nested or child tasks, which are created in the context of another task, are handled quite differently.</source>
          <target state="translated">但是，嵌套任务或子任务（在其他任务的上下文中创建）的处理方式大不相同。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing.</source>
          <target state="translated">子任务或嵌套任务放置在特定于执行父任务的线程的本地队列上。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The parent task may be a top-level task or it also may be the child of another task.</source>
          <target state="translated">父任务可能是最高级任务，也可能是其他任务的子任务。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>When this thread is ready for more work, it first looks in the local queue.</source>
          <target state="translated">当此线程准备好执行更多工作时，首先查看本地队列。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If work items are waiting there, they can be accessed quickly.</source>
          <target state="translated">如果工作项在此处等待，即可快速访问它们。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention.</source>
          <target state="translated">在上一次在先进先出顺序 (LIFO) 保留缓存区域并减少争用访问本地队列。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>For more information about child tasks and nested tasks, see <bpt id="p1">[</bpt>Attached and Detached Child Tasks<ept id="p1">](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)</ept>.</source>
          <target state="translated">有关子任务和嵌套的任务的详细信息，请参阅<bpt id="p1">[</bpt>附加和分离的子任务<ept id="p1">](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)</ept>。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality.</source>
          <target state="translated">使用本地队列不仅可减少全局队列上的压力，而且还可利用数据位置。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Work items in the local queue frequently reference data structures that are physically near one another in memory.</source>
          <target state="translated">工作项的本地队列经常引用以物理方式靠近另一个是在内存中的数据结构。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In these cases, the data is already in the cache after the first task has run and can be accessed quickly.</source>
          <target state="translated">在这些情况下，数据后已在缓存中的第一个任务已运行并可以快速访问。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Both <bpt id="p1">[</bpt>Parallel LINQ (PLINQ)<ept id="p1">](~/docs/standard/parallel-programming/parallel-linq-plinq.md)</ept> and the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel&gt;</ph> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.</source>
          <target state="translated">同时<bpt id="p1">[</bpt>并行 LINQ (PLINQ)<ept id="p1">](~/docs/standard/parallel-programming/parallel-linq-plinq.md)</ept>和<ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel&gt;</ph>类广泛使用嵌套任务和子任务，并通过使用本地工作队列实现显著的加速。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Work stealing</source>
          <target state="translated">工作窃取</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues.</source>
          <target state="translated">从.NET Framework 4 开始，线程池还提供了工作窃取算法，帮助确保没有线程处于空闲其他仍在各自队列中工作时。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads.</source>
          <target state="translated">当线程池线程准备好执更多工作时，首先查看其本地队列的开头，再查看全局队列，然后查看其他线程的本地队列。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently.</source>
          <target state="translated">如果在其他线程的本地队列中找到工作项，它会先应用试探法以确保可有效运行工作。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>If it can, it de-queues the work item from the tail (in FIFO order).</source>
          <target state="translated">如果它知道如何操作，则取消排队工作项 （按 FIFO 顺序） 从结尾。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This reduces contention on each local queue and preserves data locality.</source>
          <target state="translated">这样可以减少每个本地队列上的争用并保留数据位置。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This architecture helps the  thread pool load-balance work more efficiently than past versions did.</source>
          <target state="translated">此体系结构可帮助线程池负载平衡比以前版本更有效地工作。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Long-running tasks</source>
          <target state="translated">长时间运行的任务</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>You may want to explicitly prevent a task from being put on a local queue.</source>
          <target state="translated">可能想要显式防止将任务放到本地队列上。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue.</source>
          <target state="translated">例如，你可能知道特定工作项将运行相对长的时间并可能阻塞本地队列中的所有其他工作项。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In this case, you can specify the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType&gt;</ph> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue.</source>
          <target state="translated">在这种情况下，可指定 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType&gt;</ph> 选项，它提示附加线程执行任务时可能需要计划程序，以使此任务不阻塞本地队列中其他线程或工作项的向前推动。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>By using this option you avoid the thread pool completely, including the global and local queues.</source>
          <target state="translated">通过使用此选项可以避免线程池完全，包括全局和本地队列。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Task inlining</source>
          <target state="translated">任务内联</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In some cases when a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> is waited on, it may be executed synchronously on the thread that is performing the wait operation.</source>
          <target state="translated">在某些情况下当<ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph>处于等待状态，可能会在同步执行它正在执行等待操作的线程上。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise.</source>
          <target state="translated">这可通过阻止其他线程的需求，并改为使用的现有线程，否则本会被阻塞提高性能。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>To prevent errors due to re-entrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.</source>
          <target state="translated">若要防止造成的错误，才出现任务内联在相关线程的本地队列中找到等待目标时。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Specifying a synchronization context</source>
          <target state="translated">指定同步上下文</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph> method to specify that a task should be scheduled to run on a particular thread.</source>
          <target state="translated">可使用 <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph> 方法指定任务应计划在特定线程上运行。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created.</source>
          <target state="translated">在 Windows 窗体和 Windows Presentation Foundation 等框架中此操作非常有用，在此类框架中对用户界面对象的访问限制为只可访问在创建 UI 对象的同一线程上运行的代码。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType&gt;</ph>用于计划任务在创建用户界面 (UI) 控件所在的同一线程上的 Windows Presentation Foundation (WPF) 应用中的方法。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The example creates a mosaic of images that are randomly selected from a specified directory.</source>
          <target state="translated">该示例创建马赛克从指定的目录中随机选择的映像。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The WPF objects are used to load and resize the images.</source>
          <target state="translated">WPF 对象用于加载和调整图像的大小。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The raw pixels are then passed to a task that uses a <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.For%2A&gt;</ph> loop to write the pixel data into a large single-byte array.</source>
          <target state="translated">原始像素然后传递给使用的任务<ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.For%2A&gt;</ph>循环像素数据写入一个大型的单字节数组。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>No synchronization is required because no two tiles occupy the same array elements.</source>
          <target state="translated">因为没有两个磁贴占用相同的数组元素，不需要进行同步。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The tiles can also be written in any order because their position is calculated independently of any other tile.</source>
          <target state="translated">因为它们的位置计算独立于任何其他磁贴，也可以按任意顺序写入磁贴。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.</source>
          <target state="translated">大型数组然后传递给其中像素数据加载到图像控件在 UI 线程运行的任务。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The example moves data off the UI thread, modifies it by using parallel loops and <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objects, and then passes it back to a task that runs on the UI thread.</source>
          <target state="translated">上面的示例将出 UI 线程的数据移动，对其进行修改通过使用并行循环和<ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph>对象，然后将其传递回 UI 线程运行的任务。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast.</source>
          <target state="translated">当您必须使用任务并行库执行 WPF API 中，不支持或不足够快的操作时，此方法非常有用。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Another way to create an image mosaic in WPF is to use a <ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType&gt;</ph> control and add images to it.</source>
          <target state="translated">在 WPF 中创建映像马赛克另一种方法是使用<ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType&gt;</ph>控件并将映像添加到它。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel&gt;</ph> handles the work of positioning the tiles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.WrapPanel&gt;</ph>处理的工作的定位磁贴。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>However, this work can only be performed on the UI thread.</source>
          <target state="translated">但是，仅可以在 UI 线程上执行此工作。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>To create the example, create a WPF application project in Visual Studio and assign it a name of your choice.</source>
          <target state="translated">若要创建此示例，在 Visual Studio 中创建一个 WPF 应用程序项目，并将其分配一个你选择的名称。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Then do the following:</source>
          <target state="translated">然后执行以下操作：</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In design view, drag an <ph id="ph1">&lt;xref:System.Windows.Controls.Image&gt;</ph> control from the <bpt id="p1">**</bpt>Toolbox<ept id="p1">**</ept> to the design surface.</source>
          <target state="translated">在设计视图中，将拖动<ph id="ph1">&lt;xref:System.Windows.Controls.Image&gt;</ph>控件从<bpt id="p1">**</bpt>工具箱<ept id="p1">**</ept>到设计图面。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In XAML view, specify the horizontal alignment as "Left."</source>
          <target state="translated">在 XAML 视图中，指定为"Left。"的水平对齐方式</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The size does not matter because the control is be dynamically resized at run time.</source>
          <target state="translated">因为在运行时动态调整控件大小并不重要。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Accept the default name, "image".</source>
          <target state="translated">接受默认名称，"映像"。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Drag a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> control from the <bpt id="p1">**</bpt>Toolbox<ept id="p1">**</ept> to the lower left part of the application window.</source>
          <target state="translated">拖动<ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph>控件从<bpt id="p1">**</bpt>工具箱<ept id="p1">**</ept>到应用程序窗口的左下角。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Double-click the button to add a <ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event handler.</source>
          <target state="translated">双击按钮以添加<ph id="ph1">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph>事件处理程序。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In XAML view, specify the <ph id="ph1">&lt;xref:System.Windows.Controls.ContentControl.Content%2A&gt;</ph> property of the button as "Make a Mosaic" and specify its horizontal alignment as "Left".</source>
          <target state="translated">在 XAML 视图中，指定<ph id="ph1">&lt;xref:System.Windows.Controls.ContentControl.Content%2A&gt;</ph>"使马赛克"以及指定"Left"作为其水平对齐方式，该按钮的属性。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Accept the default name, "button".</source>
          <target state="translated">接受默认名称，"button"。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example.</source>
          <target state="translated">将 MainWindow.xaml.cs 或 MainWindow.xaml.vb 文件的全部内容替换此示例中的代码。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Make sure that the name of the workspace matches the project name.</source>
          <target state="translated">请确保工作区的名称匹配项目名称。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The example reads JPEG images from a directory named C:\Users\Public\Pictures\Sample Pictures<ph id="ph1">\\</ph>.</source>
          <target state="translated">该示例从名为 C:\Users\Public\Pictures\Sample 图片的目录中读取 JPEG 图像<ph id="ph1">\\</ph>。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.</source>
          <target state="translated">请创建目录和某些图像置于它，或者更改要引用包含映像的一些其他目录的路径。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>This example has some limitations.</source>
          <target state="translated">此示例具有一些限制。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <ph id="ph1">&lt;xref:System.Windows.Media.Imaging.BitmapImage&gt;</ph> object during the resizing operation.</source>
          <target state="translated">例如，支持仅 32-每像素位数映像;其他格式中的映像已损坏的<ph id="ph1">&lt;xref:System.Windows.Media.Imaging.BitmapImage&gt;</ph>大小调整操作过程中的对象。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>Also, the source images must all be larger than the tile size.</source>
          <target state="translated">此外，源映像都必须大于磁贴大小。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.</source>
          <target state="translated">在进一步的练习，你可以添加功能以处理多个像素格式和文件大小。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>The following example is taken from the <bpt id="p1">[</bpt>Samples for Parallel Programming with the .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept> on the MSDN Code Gallery Web site.</source>
          <target state="translated">下面的示例摘自<bpt id="p1">[</bpt>使用.NET Framework 4 进行并行编程示例<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept>MSDN 代码库网站上。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>It creates a custom task scheduler that limits the number of threads used by the app.</source>
          <target state="translated">它将创建的自定义任务计划程序限制的应用使用的线程数。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.</source>
          <target state="translated">然后，将启动两个任务组，并显示有关任务和在其执行任务的线程的信息。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>In addition, several sample task schedulers are available on Code Gallery: <bpt id="p1">[</bpt>Samples for Parallel Programming with the .NET Framework 4<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept>.</source>
          <target state="translated">此外，多个示例任务计划程序中有代码库：<bpt id="p1">[</bpt>使用.NET Framework 4 进行并行编程示例<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=165717)</ept>。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.TaskScheduler">
          <source>All members of the abstract <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> type are thread-safe and may be used from multiple threads concurrently.</source>
          <target state="translated">抽象的所有成员<ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>类型是线程安全的可从多个线程同时使用。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.#ctor">
          <source>Initializes the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the currently executing task.</source>
          <target state="translated">获取与当前正在执行的任务关联的 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the currently executing task.</source>
          <target state="translated">返回与当前正在执行的任务关联的 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>When not called from within a task, <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A&gt;</ph> will return the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.Default%2A&gt;</ph> scheduler.</source>
          <target state="translated">当不从任务中调用时<ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A&gt;</ph>将返回<ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.Default%2A&gt;</ph>计划程序。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Current">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph>.</source>
          <target state="translated">有关详情，请参阅<ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.Default">
          <source>Gets the default <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> instance that is provided by the .NET Framework.</source>
          <target state="translated">获取由 .NET Framework 提供的默认 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> 实例。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Default">
          <source>Returns the default <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> instance.</source>
          <target state="translated">返回默认的 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> 实例。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Default">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>任务计划程序<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the current <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph>.</source>
          <target state="translated">创建与当前 <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph> 关联的 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> associated with the current <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph>, as determined by <ph id="ph3">&lt;see cref="P:System.Threading.SynchronizationContext.Current" /&gt;</ph>.</source>
          <target state="translated">与当前 <ph id="ph2">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph> 关联的 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>，由 <ph id="ph3">&lt;see cref="P:System.Threading.SynchronizationContext.Current" /&gt;</ph> 确定。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>All <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances queued to the returned scheduler will be executed through a call to the <ph id="ph2">&lt;xref:System.Threading.SynchronizationContext.Post%2A&gt;</ph> method on that context.</source>
          <target state="translated">所有<ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph>实例排入返回计划程序将执行通过调用<ph id="ph2">&lt;xref:System.Threading.SynchronizationContext.Post%2A&gt;</ph>该上下文上的方法。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>任务计划程序<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext">
          <source>The current SynchronizationContext may not be used as a TaskScheduler.</source>
          <target state="translated">当前的 SynchronizationContext 不能用作 TaskScheduler。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>For debugger support only, generates an enumerable of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances currently queued to the scheduler waiting to be executed.</source>
          <target state="translated">仅对于调试器支持，生成当前排队到计划程序中等待执行的 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 实例的枚举。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</source>
          <target state="translated">一个允许调试器遍历当前排队到此计划程序中的任务的枚举。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>A class derived from <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implements this method in order to support integration with debuggers.</source>
          <target state="translated">从派生的类<ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph>实现此方法，以便支持与调试器集成。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This method will only be invoked by the .NET Framework when the debugger requests access to the data.</source>
          <target state="translated">当调试器请求的数据访问权限，则仅将由.NET Framework 调用此方法。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.</source>
          <target state="translated">将按调试实用程序，以访问的任务进行遍历的可枚举项返回当前排队到此计划程序，启用调试器提供的表示形式的用户界面中的此信息。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>It is important to note that, when this method is called, all other threads in the process will be frozen.</source>
          <target state="translated">请务必注意，当调用此方法时，所有其他进程中的线程将被冻结。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>Therefore, it's important to avoid synchronization with other threads that may lead to blocking.</source>
          <target state="translated">因此，务必避免与其他线程的同步可能会导致阻塞。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang.</source>
          <target state="translated">如果同步是必需的并且无法获取此方法中的锁，然后应引发异常，以便调试器未挂起。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>The following example shows one possible approach in C#:</source>
          <target state="translated">下面的示例演示 C# 中的一种可行方法：</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>Additionally, this method and the enumerable returned must not modify any globally visible state.</source>
          <target state="translated">此外，此方法，并返回的可枚举不能修改任何全局可见状态。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>The returned enumerable should never be null.</source>
          <target state="translated">返回可枚举应永远不会为 null。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>If there are currently no queued tasks, an empty enumerable should be returned instead.</source>
          <target state="translated">如果当前没有任何排队的任务，应改为返回可枚举为空。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method <ph id="ph1">`GetScheduledTasksForDebugger`</ph> instead: <ph id="ph2">`internal Task[] GetScheduledTasksForDebugger()`</ph>.</source>
          <target state="translated">开发人员要实现自定义调试器不应直接调用此方法，但应使用内部包装方法<ph id="ph1">`GetScheduledTasksForDebugger`</ph>相反： <ph id="ph2">`internal Task[] GetScheduledTasksForDebugger()`</ph>。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This wrapper method returns an array of tasks instead of an enumerable.</source>
          <target state="translated">此包装方法返回任务而不是一个可枚举对象的数组。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>To retrieve a list of active schedulers, use the internal method <ph id="ph1">`internal static TaskScheduler[] GetTaskSchedulersForDebugger()`</ph>.</source>
          <target state="translated">若要检索的活动计划程序列表，请使用内部方法<ph id="ph1">`internal static TaskScheduler[] GetTaskSchedulersForDebugger()`</ph>。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This static method returns an array of all active <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> instances.</source>
          <target state="translated">此静态方法返回的所有活动数组<ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph>实例。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>You can then use <ph id="ph1">`GetScheduledTasksForDebugger`</ph> on each scheduler instance to retrieve its list of scheduled tasks.</source>
          <target state="translated">然后，可以使用<ph id="ph1">`GetScheduledTasksForDebugger`</ph>上每个计划程序实例来检索其计划任务的列表。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <source>This scheduler is unable to generate a list of queued tasks at this time.</source>
          <target state="translated">此计划程序无法在此时生成排队任务的列表。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.Id">
          <source>Gets the unique ID for this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">获取此 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> 的唯一 ID。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Id">
          <source>Returns the unique ID for this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">返回此 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> 的唯一 ID。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.Id">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>任务计划程序<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>Indicates the maximum concurrency level this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> is able to support.</source>
          <target state="translated">指示此 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> 能够支持的最大并发级别。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>Returns an integer that represents the maximum concurrency level.</source>
          <target state="translated">返回表示最大并发级别的一个整数。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>The default scheduler returns <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">默认计划程序返回 <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>任务计划程序<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to be queued.</source>
          <target state="translated">要排队的 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>Queues a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to the scheduler.</source>
          <target state="translated">将 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 排队到计划程序中。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>A class derived from <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implements this method to accept tasks being scheduled on the scheduler.</source>
          <target state="translated">从派生的类<ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph>实现此方法，可以接受在计划程序计划的任务。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.</source>
          <target state="translated">典型的实现将存储在内部数据结构中，这将提供将在未来某个时刻执行这些任务的线程服务的任务。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>This method is only meant to be called by the .NET Framework and should not be called directly by the derived class.</source>
          <target state="translated">此方法仅用于由.NET Framework 调用，不应直接由派生类调用。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>This is necessary for maintaining the consistency of the system.</source>
          <target state="translated">这是系统的必要的维护的一致性。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="task" /&gt;</ph> 参数为 null。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to be dequeued.</source>
          <target state="translated">要取消排队的 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>Attempts to dequeue a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> that was previously queued to this scheduler.</source>
          <target state="translated">尝试将以前排队到此计划程序中的 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 取消排队。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>A Boolean denoting whether the <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument was successfully dequeued.</source>
          <target state="translated">一个布尔值，该值指示是否已成功地将 <ph id="ph1">&lt;paramref name="task" /&gt;</ph> 参数取消排队。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>任务计划程序<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <ph id="ph1">&lt;xref:System.Threading.CancellationTokenRegistration&gt;</ph> objects can be disposed of in a timely manner.</source>
          <target state="translated">此方法中可能会执行 finally 块;因此，它应返回以尽可能快因此使任何资源，如<ph id="ph1">&lt;xref:System.Threading.CancellationTokenRegistration&gt;</ph>对象可以及时的释放。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="task" /&gt;</ph> 参数为 null。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> object to be executed.</source>
          <target state="translated">要执行的 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>Attempts to execute the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> on this scheduler.</source>
          <target state="translated">尝试在此计划程序上执行提供的 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>A Boolean that is true if <ph id="ph1">&lt;paramref name="task" /&gt;</ph> was successfully executed, false if it was not.</source>
          <target state="translated">一个布尔值，如果成功执行了 <ph id="ph1">&lt;paramref name="task" /&gt;</ph>，则该值为 true；如果未成功执行，则该值为 false。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.</source>
          <target state="translated">执行失败的常见原因是，该任务先前已经执行或者位于正在由另一个线程执行的进程中。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>Scheduler implementations are provided with <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances to be executed through either the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> method or the <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A&gt;</ph> method.</source>
          <target state="translated">附带了计划程序实现<ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph>实例执行通过<ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph>方法或<ph id="ph3">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>When the scheduler deems it appropriate to run the provided task, <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> should be used to do so.</source>
          <target state="translated">当计划程序认为适当运行提供的任务，<ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph>应该用于这样做。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.</source>
          <target state="translated">TryExecuteTask 处理执行任务，包括操作调用、 异常处理、 状态管理和生命周期控件的所有的方面。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> 必须仅用于.NET Framework 基础结构提供给此计划程序任务。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>It should not be used to execute arbitrary tasks obtained through custom mechanisms.</source>
          <target state="translated">不应该用于执行任意任务获取通过自定义机制。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> is not associated with this scheduler.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="task" /&gt;</ph> 与此计划程序无关联。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to be executed.</source>
          <target state="translated">要执行的 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A Boolean denoting whether or not task has previously been queued.</source>
          <target state="translated">一个布尔值，该值指示任务之前是否已排队。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</source>
          <target state="translated">如果此参数为 True，则该任务以前可能已排队（已计划）；如果为 False，则已知该任务尚未排队，此时将执行此调用，以便以内联方式执行该任务，而不用将其排队。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>Determines whether the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> can be executed synchronously in this call, and if it can, executes it.</source>
          <target state="translated">确定是否可以在此调用中同步执行提供的 <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>，如果可以，将执行该任务。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A Boolean value indicating whether the task was executed inline.</source>
          <target state="translated">一个布尔值，该值指示是否已以内联方式执行该任务。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A class derived from <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implements this function to support inline execution of a task on a thread that initiates a wait on that task object.</source>
          <target state="translated">从派生的类<ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph>实现此函数，以便启动该任务对象上的等待的线程上支持内联执行的任务。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>Inline execution is optional, and the request may be rejected by returning false.</source>
          <target state="translated">内联执行是可选的并且可能会返回 false 拒绝请求。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>However, the more tasks that can be inlined, the better the scheduler will scale.</source>
          <target state="translated">但是，多个任务可以进行内联，更好地计划程序将扩展。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>In fact, a scheduler that inlines too little may be prone to deadlocks.</source>
          <target state="translated">事实上，计划程序该内联过少可能容易出现死锁。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline.</source>
          <target state="translated">正确实现应确保下保证由调度器的策略执行的请求可以成功内联。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.</source>
          <target state="translated">例如，如果计划程序使用的专用的线程执行任务，该线程从任何内联请求应会成功。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> method with the provided task object, propagating the return value.</source>
          <target state="translated">如果计划程序决定执行内联执行，它应执行操作来调用基 taskscheduler 计划的<ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph>与提供的任务对象，传播的返回值的方法。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request.</source>
          <target state="translated">它也可能是适用于从其内部数据结构中删除一个内联的任务，如果它决定接受内联请求的计划程序。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> method.</source>
          <target state="translated">但请注意，在某些情况下一个计划程序可能要求先内联不到它与以前提供的任务<ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.</source>
          <target state="translated">派生的计划程序会负责确保调用线程适用于执行指定的任务，就其自身的计划，并且而言执行策略。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Task Schedulers<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>任务计划程序<ept id="p1">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> argument is null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="task" /&gt;</ph> 参数为 null。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <source>The <ph id="ph1">&lt;paramref name="task" /&gt;</ph> was already executed.</source>
          <target state="translated">已执行的 <ph id="ph1">&lt;paramref name="task" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</source>
          <target state="translated">出错的任务中未观察到的异常将触发异常呈报策略时出现，默认情况下会终止进程。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.</source>
          <target state="translated">此应用程序的全域性事件触发提供一种机制来防止异常升级策略 （默认情况下，终止进程）。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>To make it easier for developers to write asynchronous code based on tasks, the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> changes the default exception behavior for unobserved exceptions.</source>
          <target state="translated">为了更加便于开发人员编写基于任务的异步代码<ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>更改默认的异常行为的未观察到异常。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Although unobserved exceptions still raise the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException&gt;</ph> exception, the process does not terminate by default.</source>
          <target state="translated">虽然仍未观察到的异常引发<ph id="ph1">&lt;xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException&gt;</ph>异常，该过程不会终止默认情况下。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception.</source>
          <target state="translated">相反，此异常处理由运行时后引发事件时，无论是否事件处理程序观察到异常。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>This behavior can be configured.</source>
          <target state="translated">可以配置该行为。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, you can use the  configuration element to revert to the behavior of the <ph id="ph2">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> and terminate the process:</source>
          <target state="translated">从开始<ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>，你可以使用的配置元素以恢复到的行为<ph id="ph2">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>和终止进程：</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>