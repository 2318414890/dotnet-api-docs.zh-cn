<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ddd94061f594e353cba8674c76ffcb77a643ddb1" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530651" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示一个处理将任务排队到线程中的低级工作的对象。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 实例<xref:System.Threading.Tasks.TaskScheduler>类表示任务计划程序。 任务计划程序确保最终执行任务作业。  
  
 默认的任务计划程序基于 .NET Framework 4 线程池，提供工作窃取实现负载平衡、线程注入/退出以实现最大吞吐量，并提供整体卓越性能。 它应足以满足大多数方案。  
  
 <xref:System.Threading.Tasks.TaskScheduler>类也可作为所有可自定义计划逻辑的扩展点。  这包括机制，如 逼的执行，任务和如何计划的任务应公开给调试器。 如果需要特殊功能，你可以创建自定义计划程序和启用以执行特定任务或查询。  
  
 本主题内容：  
[默认任务计划程序和线程池](#Default)  
 [全局队列与本地队列](#Queues)  
 [工作窃取](#Stealing)  
 [长时间运行的任务](#LongRunning)  
 [任务内联](#Inlining)  
[指定同步上下文](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a>默认任务计划程序和线程池  
 任务并行库和 PLINQ 的默认计划程序使用.NET Framework 线程池，由表示<xref:System.Threading.ThreadPool>类进行排队并执行工作。 线程池使用由提供的信息<xref:System.Threading.Tasks.Task>类型有效支持并行任务和查询通常表示的细化并行 （生存期较短的工作单位）。  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a>全局队列与本地队列  
 该线程池保持全局的 FIFO （先进先出） 工作队列中的每个应用程序域中的线程。 每当程序调用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType>(或<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) 方法，工作均放在此共享队列上并最终取消排队变得可用的下一个线程。 从.NET Framework 4 开始，此队列已经得到改进以使用类似于无锁算法<xref:System.Collections.Concurrent.ConcurrentQueue%601>类。 通过使用此无锁实现，线程池消耗较少的时间时它排队和离队工作项。 此性能优势可供使用线程池的所有程序。  
  
 最高级任务（即不在其他任务的上下文中创建的任务）与任何其他工作项一样放在全局队列上。 但是，嵌套任务或子任务（在其他任务的上下文中创建）的处理方式大不相同。 子任务或嵌套任务放置在特定于执行父任务的线程的本地队列上。 父任务可能是最高级任务，也可能是其他任务的子任务。 当此线程准备好执行更多工作时，首先查看本地队列。 如果工作项在此处等待，即可快速访问它们。 在上一次在先进先出顺序 (LIFO) 保留缓存区域并减少争用访问本地队列。 有关子任务和嵌套的任务的详细信息，请参阅[附加和分离的子任务](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)。  
  
 使用本地队列不仅可减少全局队列上的压力，而且还可利用数据位置。 工作项的本地队列经常引用以物理方式靠近另一个是在内存中的数据结构。 在这些情况下，数据后已在缓存中的第一个任务已运行并可以快速访问。 同时[并行 LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md)和<xref:System.Threading.Tasks.Parallel>类广泛使用嵌套任务和子任务，并通过使用本地工作队列实现显著的加速。  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a>工作窃取  
 从.NET Framework 4 开始，线程池还提供了工作窃取算法，帮助确保没有线程处于空闲其他仍在各自队列中工作时。 当线程池线程准备好执更多工作时，首先查看其本地队列的开头，再查看全局队列，然后查看其他线程的本地队列。 如果在其他线程的本地队列中找到工作项，它会先应用试探法以确保可有效运行工作。 如果它知道如何操作，则取消排队工作项 （按 FIFO 顺序） 从结尾。 这样可以减少每个本地队列上的争用并保留数据位置。 此体系结构可帮助线程池负载平衡比以前版本更有效地工作。  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a>长时间运行的任务  
 可能想要显式防止将任务放到本地队列上。 例如，你可能知道特定工作项将运行相对长的时间并可能阻塞本地队列中的所有其他工作项。 在这种情况下，可指定 <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> 选项，它提示附加线程执行任务时可能需要计划程序，以使此任务不阻塞本地队列中其他线程或工作项的向前推动。 通过使用此选项可以避免线程池完全，包括全局和本地队列。  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a>任务内联  
 在某些情况下当<xref:System.Threading.Tasks.Task>处于等待状态，可能会在同步执行它正在执行等待操作的线程上。 这可通过阻止其他线程的需求，并改为使用的现有线程，否则本会被阻塞提高性能。 若要防止造成的错误，才出现任务内联在相关线程的本地队列中找到等待目标时。  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a>指定同步上下文  
 可使用 <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> 方法指定任务应计划在特定线程上运行。 在 Windows 窗体和 Windows Presentation Foundation 等框架中此操作非常有用，在此类框架中对用户界面对象的访问限制为只可访问在创建 UI 对象的同一线程上运行的代码。  
  
 下面的示例使用<xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType>用于计划任务在创建用户界面 (UI) 控件所在的同一线程上的 Windows Presentation Foundation (WPF) 应用中的方法。   该示例创建马赛克从指定的目录中随机选择的映像。 WPF 对象用于加载和调整图像的大小。 原始像素然后传递给使用的任务<xref:System.Threading.Tasks.Parallel.For%2A>循环像素数据写入一个大型的单字节数组。 因为没有两个磁贴占用相同的数组元素，不需要进行同步。 因为它们的位置计算独立于任何其他磁贴，也可以按任意顺序写入磁贴。 大型数组然后传递给其中像素数据加载到图像控件在 UI 线程运行的任务。  
  
 上面的示例将出 UI 线程的数据移动，对其进行修改通过使用并行循环和<xref:System.Threading.Tasks.Task>对象，然后将其传递回 UI 线程运行的任务。 当您必须使用任务并行库执行 WPF API 中，不支持或不足够快的操作时，此方法非常有用。 在 WPF 中创建映像马赛克另一种方法是使用<xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType>控件并将映像添加到它。 <xref:System.Windows.Controls.WrapPanel>处理的工作的定位磁贴。 但是，仅可以在 UI 线程上执行此工作。  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 若要创建此示例，在 Visual Studio 中创建一个 WPF 应用程序项目，并将其分配一个你选择的名称。 然后执行以下操作：  
  
1.  在设计视图中，将拖动<xref:System.Windows.Controls.Image>控件从**工具箱**到设计图面。 在 XAML 视图中，指定为"Left。"的水平对齐方式 因为在运行时动态调整控件大小并不重要。 接受默认名称，"映像"。  
  
2.  拖动<xref:System.Windows.Controls.Button>控件从**工具箱**到应用程序窗口的左下角。 双击按钮以添加<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件处理程序。 在 XAML 视图中，指定<xref:System.Windows.Controls.ContentControl.Content%2A>"使马赛克"以及指定"Left"作为其水平对齐方式，该按钮的属性。 接受默认名称，"button"。  
  
3.  将 MainWindow.xaml.cs 或 MainWindow.xaml.vb 文件的全部内容替换此示例中的代码。 请确保工作区的名称匹配项目名称。  
  
4.  该示例从名为 C:\Users\Public\Pictures\Sample 图片的目录中读取 JPEG 图像\\。 请创建目录和某些图像置于它，或者更改要引用包含映像的一些其他目录的路径。  
  
 此示例具有一些限制。 例如，支持仅 32-每像素位数映像;其他格式中的映像已损坏的<xref:System.Windows.Media.Imaging.BitmapImage>大小调整操作过程中的对象。 此外，源映像都必须大于磁贴大小。 在进一步的练习，你可以添加功能以处理多个像素格式和文件大小。  
  
   
  
## Examples  
 下面的示例摘自[使用.NET Framework 4 进行并行编程示例](http://go.microsoft.com/fwlink/?LinkID=165717)MSDN 代码库网站上。  它将创建的自定义任务计划程序限制的应用使用的线程数。 然后，将启动两个任务组，并显示有关任务和在其执行任务的线程的信息。  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 此外，多个示例任务计划程序中有代码库：[使用.NET Framework 4 进行并行编程示例](http://go.microsoft.com/fwlink/?LinkID=165717)。  
  
 ]]></format>
    </remarks>
    <threadsafe>抽象的所有成员<see cref="T:System.Threading.Tasks.TaskScheduler" />类型是线程安全的可从多个线程同时使用。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与当前正在执行的任务关联的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</summary>
        <value>返回与当前正在执行的任务关联的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当不从任务中调用时<xref:System.Threading.Tasks.TaskScheduler.Current%2A>将返回<xref:System.Threading.Tasks.TaskScheduler.Default%2A>计划程序。  
  
 有关详情，请参阅<xref:System.Threading.Tasks.TaskScheduler>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取由 .NET Framework 提供的默认 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 实例。</summary>
        <value>返回默认的 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 实例。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[任务计划程序](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建与当前 <see cref="T:System.Threading.SynchronizationContext" /> 关联的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</summary>
        <returns>与当前 <see cref="T:System.Threading.SynchronizationContext" /> 关联的 <see cref="T:System.Threading.Tasks.TaskScheduler" />，由 <see cref="P:System.Threading.SynchronizationContext.Current" /> 确定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 所有<xref:System.Threading.Tasks.Task>实例排入返回计划程序将执行通过调用<xref:System.Threading.SynchronizationContext.Post%2A>该上下文上的方法。  
  
 有关详细信息，请参阅[任务计划程序](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前的 SynchronizationContext 不能用作 TaskScheduler。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>仅对于调试器支持，生成当前排队到计划程序中等待执行的 <see cref="T:System.Threading.Tasks.Task" /> 实例的枚举。</summary>
        <returns>一个允许调试器遍历当前排队到此计划程序中的任务的枚举。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从派生的类<xref:System.Threading.Tasks.TaskScheduler>实现此方法，以便支持与调试器集成。 当调试器请求的数据访问权限，则仅将由.NET Framework 调用此方法。 将按调试实用程序，以访问的任务进行遍历的可枚举项返回当前排队到此计划程序，启用调试器提供的表示形式的用户界面中的此信息。  
  
 请务必注意，当调用此方法时，所有其他进程中的线程将被冻结。 因此，务必避免与其他线程的同步可能会导致阻塞。 如果同步是必需的并且无法获取此方法中的锁，然后应引发异常，以便调试器未挂起。 下面的示例演示 C# 中的一种可行方法：  
  
```  
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 此外，此方法，并返回的可枚举不能修改任何全局可见状态。  
  
 返回可枚举应永远不会为 null。 如果当前没有任何排队的任务，应改为返回可枚举为空。  
  
 开发人员要实现自定义调试器不应直接调用此方法，但应使用内部包装方法`GetScheduledTasksForDebugger`相反： `internal Task[] GetScheduledTasksForDebugger()`。 此包装方法返回任务而不是一个可枚举对象的数组。 若要检索的活动计划程序列表，请使用内部方法`internal static TaskScheduler[] GetTaskSchedulersForDebugger()`。 此静态方法返回的所有活动数组<xref:System.Threading.Tasks.TaskScheduler>实例。 然后，可以使用`GetScheduledTasksForDebugger`上每个计划程序实例来检索其计划任务的列表。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此计划程序无法在此时生成排队任务的列表。</exception>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 的唯一 ID。</summary>
        <value>返回此 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 的唯一 ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[任务计划程序](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示此 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 能够支持的最大并发级别。</summary>
        <value>返回表示最大并发级别的一个整数。 默认计划程序返回 <see cref="F:System.Int32.MaxValue" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[任务计划程序](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">要排队的 <see cref="T:System.Threading.Tasks.Task" />。</param>
        <summary>将 <see cref="T:System.Threading.Tasks.Task" /> 排队到计划程序中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从派生的类<xref:System.Threading.Tasks.TaskScheduler>实现此方法，可以接受在计划程序计划的任务。  
  
 典型的实现将存储在内部数据结构中，这将提供将在未来某个时刻执行这些任务的线程服务的任务。  
  
 此方法仅用于由.NET Framework 调用，不应直接由派生类调用。 这是系统的必要的维护的一致性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="task" /> 参数为 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">要取消排队的 <see cref="T:System.Threading.Tasks.Task" />。</param>
        <summary>尝试将以前排队到此计划程序中的 <see cref="T:System.Threading.Tasks.Task" /> 取消排队。</summary>
        <returns>一个布尔值，该值指示是否已成功地将 <paramref name="task" /> 参数取消排队。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息，请参阅[任务计划程序](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)。  
  
 此方法中可能会执行 finally 块;因此，它应返回以尽可能快因此使任何资源，如<xref:System.Threading.CancellationTokenRegistration>对象可以及时的释放。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="task" /> 参数为 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">要执行的 <see cref="T:System.Threading.Tasks.Task" /> 对象。</param>
        <summary>尝试在此计划程序上执行提供的 <see cref="T:System.Threading.Tasks.Task" />。</summary>
        <returns>一个布尔值，如果成功执行了 <paramref name="task" />，则该值为 true；如果未成功执行，则该值为 false。 执行失败的常见原因是，该任务先前已经执行或者位于正在由另一个线程执行的进程中。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附带了计划程序实现<xref:System.Threading.Tasks.Task>实例执行通过<xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A>方法或<xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A>方法。 当计划程序认为适当运行提供的任务，<xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A>应该用于这样做。 TryExecuteTask 处理执行任务，包括操作调用、 异常处理、 状态管理和生命周期控件的所有的方面。  
  
 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> 必须仅用于.NET Framework 基础结构提供给此计划程序任务。 不应该用于执行任意任务获取通过自定义机制。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="task" /> 与此计划程序无关联。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task">要执行的 <see cref="T:System.Threading.Tasks.Task" />。</param>
        <param name="taskWasPreviouslyQueued">一个布尔值，该值指示任务之前是否已排队。 如果此参数为 True，则该任务以前可能已排队（已计划）；如果为 False，则已知该任务尚未排队，此时将执行此调用，以便以内联方式执行该任务，而不用将其排队。</param>
        <summary>确定是否可以在此调用中同步执行提供的 <see cref="T:System.Threading.Tasks.Task" />，如果可以，将执行该任务。</summary>
        <returns>一个布尔值，该值指示是否已以内联方式执行该任务。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从派生的类<xref:System.Threading.Tasks.TaskScheduler>实现此函数，以便启动该任务对象上的等待的线程上支持内联执行的任务。 内联执行是可选的并且可能会返回 false 拒绝请求。 但是，多个任务可以进行内联，更好地计划程序将扩展。 事实上，计划程序该内联过少可能容易出现死锁。 正确实现应确保下保证由调度器的策略执行的请求可以成功内联。 例如，如果计划程序使用的专用的线程执行任务，该线程从任何内联请求应会成功。  
  
 如果计划程序决定执行内联执行，它应执行操作来调用基 taskscheduler 计划的<xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A>与提供的任务对象，传播的返回值的方法。 它也可能是适用于从其内部数据结构中删除一个内联的任务，如果它决定接受内联请求的计划程序。 但请注意，在某些情况下一个计划程序可能要求先内联不到它与以前提供的任务<xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A>方法。  
  
 派生的计划程序会负责确保调用线程适用于执行指定的任务，就其自身的计划，并且而言执行策略。  
  
 有关详细信息，请参阅[任务计划程序](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="task" /> 参数为 null。</exception>
        <exception cref="T:System.InvalidOperationException">已执行的 <paramref name="task" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>出错的任务中未观察到的异常将触发异常呈报策略时出现，默认情况下会终止进程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此应用程序的全域性事件触发提供一种机制来防止异常升级策略 （默认情况下，终止进程）。  
  
 为了更加便于开发人员编写基于任务的异步代码[!INCLUDE[net_v45](~/includes/net-v45-md.md)]更改默认的异常行为的未观察到异常。 虽然仍未观察到的异常引发<xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException>异常，该过程不会终止默认情况下。 相反，此异常处理由运行时后引发事件时，无论是否事件处理程序观察到异常。 可以配置该行为。 从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，你可以使用的配置元素以恢复到的行为[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]和终止进程：  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>