<Type Name="NavigationService" FullName="System.Windows.Navigation.NavigationService">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3d082dd7c9628002f1da7a6e1f97b52c5dbf6533" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32694126" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class NavigationService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit NavigationService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Navigation.NavigationService" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NavigationService" />
  <TypeSignature Language="C++ CLI" Value="public ref class NavigationService sealed" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>包含支持导航的各种方法、属性和事件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService> 封装能够下载的浏览器样式导航的上下文中的内容。  
  
 内容可以是任何类型的.NET Framework 对象和 HTML 文件。 一般情况下，但是，页面是首选的作为导航的包内容的方法时 (请参阅<xref:System.Windows.Controls.Page>)。  
  
 通过提供对象的实例并调用的重载的情况下，内容可以导航到<xref:System.Windows.Navigation.NavigationService.Navigate%2A>接受对象的方法：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>  
  
 或者，内容可以导航到通过将相对或绝对 URI 传递给之一<xref:System.Windows.Navigation.NavigationService.Navigate%2A>接受 URI 的方法重载：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%2CSystem.Boolean%29?displayProperty=nameWithType>  
  
 通过 URI，导航到内容<xref:System.Windows.Navigation.NavigationService>将返回包含内容的对象。  
  
 导航的生存期可以跟踪通过以下事件：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigated>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationProgress>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationStopped>  
  
-   <xref:System.Windows.Navigation.NavigationService.LoadCompleted>  
  
-   <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>。  
  
 并非所有事件都引发发生导航; 每次（取消、 已停止，或失败），将由导航发生 （内容或内容片段） 和如何完成导航的类型确定的一套引发的事件。  
  
 下图中会引发这些事件序列：  
  
 ![页面导航流程图](~/add/media/navigationoverviewfigure11.png "页面导航流程图")  
  
 期间或之后导航窗格中，<xref:System.Windows.Navigation.NavigationService>提供信息，其中包括要导航到内容的 URI 导航目标的内容 (<xref:System.Windows.Navigation.NavigationService.Source%2A>)，当前内容的 URI (<xref:System.Windows.Navigation.NavigationService.CurrentSource%2A>)，并包含的对象导航到的内容 (<xref:System.Windows.Navigation.NavigationService.Content%2A>)。  
  
 在内容导航到时,<xref:System.Windows.Navigation.NavigationService>导航历史记录中记录为条目的导航。 添加一个条目后退导航历史记录，新导航时，通过调用<xref:System.Windows.Navigation.NavigationService.Navigate%2A>方法，或通过导航到前进导航历史记录中的项通过调用<xref:System.Windows.Navigation.NavigationService.GoForward%2A>。 条目添加到前进导航历史记录上，通过导航到条目后退导航历史记录，通过调用<xref:System.Windows.Navigation.NavigationService.GoBack%2A>。 <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> 和<xref:System.Windows.Navigation.NavigationService.CanGoForward%2A>报告是否存在条目后退和前进导航历史记录，分别。 此外，最新条目后退导航历史记录可能会通过调用<xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A>。  
  
 默认情况下，<xref:System.Windows.Navigation.NavigationService>不导航历史记录中存储内容的对象的实例。 相反，<xref:System.Windows.Navigation.NavigationService>创建使用导航历史记录导航到每次的内容对象的新实例。 此行为旨在时较大数字和大片的内容要导航到避免过多的内存消耗。 因此，内容的状态将不会保留从一个导航到下一步。 但是，WPF 提供了几种方法，使您可以导航历史记录中存储的一条的一段内容的状态。  
  
 使用<xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A>，您还可以保留多个集的单个页面实例的状态。  
  
 <xref:System.Windows.Navigation.NavigationService> 是`sealed`类，因此不能被实例化; 相反，<xref:System.Windows.Navigation.NavigationService>导航器用于启用导航。 在 WPF 中，有两个导航器：<xref:System.Windows.Navigation.NavigationWindow>和<xref:System.Windows.Controls.Frame>。  
  
 您可以看到，[!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)]使用[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]作为导航器，以提供集成的用户体验。 以物理方式，但[!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)]实际使用<xref:System.Windows.Navigation.NavigationWindow>像导航;<xref:System.Windows.Application.MainWindow%2A>属性[!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]中运行[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]将返回到引用<xref:System.Windows.Navigation.NavigationWindow>，以及由该导航历史记录<xref:System.Windows.Navigation.NavigationWindow>由导航历史记录与集成[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]通过以下方式：  
  
-   当内容导航到通过调用<xref:System.Windows.Navigation.NavigationService.Navigate%2A>， <xref:System.Windows.Navigation.NavigationService.GoBack%2A>，和<xref:System.Windows.Navigation.NavigationService.GoForward%2A>中[!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]相关导航历史记录条目也将添加到[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]导航历史记录。  
  
-   当中的条目[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]导航[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]选择，[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]导致<xref:System.Windows.Navigation.NavigationService>以后或向前导航到与这些条目相关联的内容。  
  
> [!NOTE]
>  A<xref:System.Windows.Controls.Frame>可以提供自己的导航历史记录，或使用承载它的导航器导航历史记录。 如果<xref:System.Windows.Controls.Frame>提供其自己导航历史记录中，它可以显示其自身导航[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]浏览导航历史记录; 中的条目的条目不会添加到主机导航器导航历史记录 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>， [!INCLUDE[TLA2#tla_iegeneric](~/includes/tla2sharptla-iegeneric-md.md)])，因此，无法导航到从导航栏上[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]每个 (请参阅<xref:System.Windows.Controls.Frame.JournalOwnership%2A>)。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddBackEntry">
      <MemberSignature Language="C#" Value="public void AddBackEntry (System.Windows.Navigation.CustomContentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBackEntry(class System.Windows.Navigation.CustomContentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBackEntry (state As CustomContentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBackEntry(System::Windows::Navigation::CustomContentState ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Navigation.CustomContentState" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Windows.Navigation.CustomContentState" /> 对象，该对象表示与特定内容片段关联的应用程序定义的状态。</param>
        <summary>向包含 <see cref="T:System.Windows.Navigation.CustomContentState" /> 对象的后退导航历史记录中添加一个条目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A><xref:System.Windows.Navigation.CustomContentState>，和<xref:System.Windows.Navigation.IProvideCustomContentState>来帮助记住多个集的当前内容的状态。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="state" /> 为 <see langword="null" />，并且 <see cref="T:System.Windows.Navigation.CustomContentState" /> 对象不是从 <see cref="M:System.Windows.Navigation.IProvideCustomContentState.GetContentState" /> 返回的对象。</exception>
        <altmember cref="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      </Docs>
    </Member>
    <Member MemberName="CanGoBack">
      <MemberSignature Language="C#" Value="public bool CanGoBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoBack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoBack { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示后退导航历史记录中是否至少有一个条目。</summary>
        <value>
          如果后退导航历史记录中至少具有一个条目，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> 若要确定后退导航历史记录中是否存在至少一个条目。 此属性应检查，然后再调<xref:System.Windows.Navigation.NavigationService.GoBack%2A>; 如果<xref:System.Windows.Navigation.NavigationService.GoBack%2A>称为和后退导航历史记录中不存在项<xref:System.InvalidOperationException>引发。  
  
> [!NOTE]
>  如果导航历史记录共享的多个导航器 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>)、 最新条目后退导航历史记录可能已添加通过<xref:System.Windows.Navigation.NavigationService>当前导航器。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="CanGoForward">
      <MemberSignature Language="C#" Value="public bool CanGoForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoForward As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoForward { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示前进导航历史记录中是否至少有一个条目。</summary>
        <value>
          如果前进导航历史记录中至少具有一个条目，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> 若要确定前进导航历史记录中是否存在至少一个条目。 此属性应检查，然后再调<xref:System.Windows.Navigation.NavigationService.GoForward%2A>; 如果<xref:System.Windows.Navigation.NavigationService.GoForward%2A>称为和前进导航历史记录中不存在项<xref:System.InvalidOperationException>引发。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置对包含当前内容的对象的引用。</summary>
        <value>一个对象，它是对包含当前内容的对象的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内容可以设置两种方法之一：  
  
-   直接使用，方式将其设置为对对象的引用。  
  
-   间接方法，通过调用<xref:System.Windows.Navigation.NavigationService.Navigate%2A>， <xref:System.Windows.Navigation.NavigationService.GoBack%2A>，或<xref:System.Windows.Navigation.NavigationService.GoForward%2A>。  
  
 设置<xref:System.Windows.Navigation.NavigationService>导航是异步的因为启动新的导航;<xref:System.Windows.Navigation.NavigationService.Content%2A>不会返回一个值，如果它在设置之后立即对其进行检查。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
    <Member MemberName="CurrentSource">
      <MemberSignature Language="C#" Value="public Uri CurrentSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri CurrentSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentSource As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ CurrentSource { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取上次导航到的内容的 URI。</summary>
        <value>A<see cref="T:System.Uri" />内容的最后导航到，如果导航到使用 URI; 否则为<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.Windows.Navigation.NavigationService.CurrentSource%2A>直到成功完成到不同的 URI 的导航属性不会更改。  
  
 <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A> 可以使用仅限片段的 URI 设置。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当开始导航到某个内容片段时发生，如果所需片段位于当前内容中，它会立即发生；或者，如果所需片段位于不同内容中，它会在加载了源 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 内容之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，内容片段是内容，它是包含的命名<xref:System.Windows.UIElement>，即<xref:System.Windows.UIElement>其<xref:System.Windows.FrameworkElement.Name%2A>设置属性，例如：  
  
```  
<TextBlock Name="FragmentName">...</TextBlock>  
```  
  
 导航到[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]URI 提供采用以下格式的后缀的片段：  
  
 \#*FragmentName*  
  
 下面显示引用到内容片段的 URI 的示例：  
  
 `http://www.microsoft.com/targetpage.xaml#FragmentName`  
  
 在源页面加载后 (后<xref:System.Windows.Navigation.NavigationService.LoadCompleted>引发事件)，开始片段导航和<xref:System.Windows.Navigation.NavigationService>尝试定位[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]片段。 如果[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]找到片段，则<xref:System.Windows.Navigation.NavigationService>指示内容导航器 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>) 若要显示的片段。 如果你需要更改此行为，你可以处理<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>以提供您自己片段导航行为。 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation> 传递<xref:System.Windows.Navigation.FragmentNavigationEventArgs>参数公开属性，可用于此目的，包括：  
  
-   拥有此导航服务导航器 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>)。  
  
-   片段名称。  
  
 你可以处理<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>可重写默认 WPF 片段实现与自定义实现。 如果这样做，则需要设置<xref:System.Windows.Navigation.FragmentNavigationEventArgs.Handled%2A>到`true`; 否则为应用默认 WPF 片段处理行为。  
  
 应避免直接启动中的导航<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>事件处理程序。 由于<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>在现有的导航，启动新的导航从期间引发<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>事件处理程序创建可能会导致嵌套的导航<xref:System.ExecutionEngineException>引发。 相反，可以间接启动导航通过创建项使用异步工作<xref:System.Windows.Threading.Dispatcher>。  
  
> [!NOTE]
>  当<xref:System.Windows.Navigation.NavigationService>引发<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>，它还会引发<xref:System.Windows.Application.FragmentNavigation?displayProperty=nameWithType>上的事件<xref:System.Windows.Application>对象。  
  
> [!IMPORTANT]
>  片段导航不支持对松散[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]页 (仅限标记的[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]文件都具有`Page`作为根元素) 在以下情况：  
>   
>  • 导航到中一个松散的片段时[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]页。  
>   
>  • 从一个松散导航时[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]页中另一个松散的片段[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]页。  
>   
>  但是，一个松散[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]页可以导航到其自己的片段。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>以提供自定义片段导航行为。 在这种情况下，该示例打开错误[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]页上，如果源中的片段[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]找不到页面。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowfragmentnavigationcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowfragmentnavigationcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetNavigationService">
      <MemberSignature Language="C#" Value="public static System.Windows.Navigation.NavigationService GetNavigationService (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Navigation.NavigationService GetNavigationService(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GetNavigationService(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Navigation::NavigationService ^ GetNavigationService(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">由导航器承载的内容中的 <see cref="T:System.Windows.DependencyObject" />。</param>
        <summary>获取对导航器的 <see cref="T:System.Windows.Navigation.NavigationService" /> 的引用，该导航器的内容中包含指定的 <see cref="T:System.Windows.DependencyObject" />。</summary>
        <returns>对导航器（该导航器的内容中包含指定的 <see cref="T:System.Windows.DependencyObject" />）的 <see cref="T:System.Windows.Navigation.NavigationService" /> 的引用在某些情况下可以为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器具有<xref:System.Windows.Navigation.NavigationService>用于处理内容的导航。 WPF 具有两个导航器：<xref:System.Windows.Navigation.NavigationWindow>和<xref:System.Windows.Controls.Frame>。 若要处理导航请求和管理导航生存期，导航器将使用 WPF 导航服务，它将作为实现<xref:System.Windows.Navigation.NavigationService>类。 通过导航器承载的内容可以获取对导航器的引用<xref:System.Windows.Navigation.NavigationService>通过调用<xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A>方法。  
  
 <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A> 返回`null`时`dependencyObject`:  
  
-   是<xref:System.Windows.Navigation.NavigationWindow>。  
  
-   是<xref:System.Windows.Controls.Frame>的：  
  
    1.  由另一个导航器进行承载。  
  
    2.  具有其<xref:System.Windows.Controls.Frame.JournalOwnership%2A>属性设置为<xref:System.Windows.Navigation.JournalOwnership.UsesParentJournal>。  
  
-   不是内容的通过导航器承载的一部分。  
  
 WPF 提供两个快捷方式来获取对引用<xref:System.Windows.Navigation.NavigationService>:  
  
-   <xref:System.Windows.Navigation.NavigationService>处理到导航<xref:System.Windows.Controls.Page>可以从访问<xref:System.Windows.Controls.Page>本身获取的值通过其<xref:System.Windows.Controls.Page.NavigationService%2A?displayProperty=nameWithType>属性。  
  
-   <xref:System.Windows.Navigation.NavigationService> ，它由<xref:System.Windows.Controls.Frame>处理导航可以通过获取的值<xref:System.Windows.Controls.Frame.NavigationService%2A>属性。  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.Windows.Controls.UserControl>可以通过调用来检索导航服务<xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A>。  
  
 [!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode1)]
 [!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode1)]  
[!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode2)]
[!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dependencyObject" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GoBack">
      <MemberSignature Language="C#" Value="public void GoBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoBack();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>导航到后退导航历史记录中的最新条目（如果有）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 之前调用<xref:System.Windows.Navigation.NavigationService.GoBack%2A>、<xref:System.Windows.Navigation.NavigationService.CanGoBack%2A>属性进行检查，以确定后退导航历史记录中是否存在条目。  
  
   
  
## Examples  
 下面的示例导航到的最新条目后退导航历史记录，如果存在。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowbackcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowbackcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          在调用 <see cref="M:System.Windows.Navigation.NavigationService.GoBack" /> 时后退导航历史记录中没有条目。</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="GoForward">
      <MemberSignature Language="C#" Value="public void GoForward ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoForward() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoForward" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoForward ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoForward();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>导航到前进导航历史记录中的最新条目（如果有）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 之前调用<xref:System.Windows.Navigation.NavigationService.GoForward%2A>、<xref:System.Windows.Navigation.NavigationService.CanGoForward%2A>属性进行检查，以确定前进导航历史记录中是否存在条目。  
  
   
  
## Examples  
 如果存在，下面的示例导航到前进导航历史记录中的最新条目。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowforwardcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowforwardcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          如果前进导航历史记录中没有任何条目，则调用 <see cref="M:System.Windows.Navigation.NavigationService.GoForward" />。</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当已加载、分析并开始呈现目标导航内容时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你处理<xref:System.Windows.Navigation.NavigationService.LoadCompleted>如果想要发现关于在加载完成时的导航请求的相关信息。 此信息可从<xref:System.Windows.Navigation.NavigationEventArgs>对象传递给<xref:System.Windows.Navigation.NavigationService.LoadCompleted>事件处理程序，并包括：  
  
-   内容和其 URI。  
  
-   导航器 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>)。  
  
-   其他数据，如果启动了导航，通过调用<xref:System.Windows.Navigation.NavigationService.Navigate%2A>或<xref:System.Windows.Navigation.NavigationService.Navigate%2A>。  
  
-   响应详细信息 (使用<xref:System.Net.WebResponse>对象)。  
  
 <xref:System.Windows.Navigation.NavigationService.LoadCompleted> 无法找到或加载在这种情况下，源页时，则不会引发<xref:System.Windows.Navigation.NavigationService.NavigationFailed>引发。  
  
> [!NOTE]
>  当<xref:System.Windows.Navigation.NavigationService>引发<xref:System.Windows.Navigation.NavigationService.LoadCompleted>，它还会引发<xref:System.Windows.Application.LoadCompleted?displayProperty=nameWithType>上的事件<xref:System.Windows.Application>对象。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.LoadCompleted>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowloadcompletedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowloadcompletedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>异步导航到指定的源内容。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">一个包含目标导航内容的对象。</param>
        <summary>异步导航到某个对象中包含的内容。</summary>
        <returns>
          如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 将导航到<xref:System.Object>指定的`root`如果满足以下条件：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>事件不会被取消。  
  
-   Web 请求 (请参阅<xref:System.Windows.Navigation.NavigationService.Navigating>) 可以创建。  
  
 如果`root`是`null`，现有的内容 (<xref:System.Windows.Navigation.NavigationService.Content%2A>) 处于未选中状态。  
  
> [!NOTE]
>  当下载 Web 内容时，你可能会收到 Web 异常 (例如，404： 找不到文件)。 你可以处理此类异常从<xref:System.Windows.Navigation.NavigationService.NavigationFailed>。  
  
   
  
## Examples  
 下面的示例演示如何导航到<xref:System.Windows.Controls.Page>对象，其中包含源内容树。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigateobjectcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigateobjectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="source">使用所需内容的 URI 初始化的 <see cref="T:System.Uri" /> 对象。</param>
        <summary>异步导航到由 URI 指定的内容。</summary>
        <returns>
          如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值`source`可以是一个[!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)]或有效的包 URI (请参阅[WPF 中的包 Uri](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md))。  
  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A> 将导航到指定的 URI`source`如果满足以下条件：  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>事件不会被取消。  
  
-   Web 请求 (请参阅<xref:System.Windows.Navigation.NavigationService.Navigating>) 可以创建。  
  
 如果`source`是`null`，现有的内容 (<xref:System.Windows.Navigation.NavigationService.Content%2A>) 处于未选中状态。  
  
> [!NOTE]
>  当下载 Web 内容时，你可能会收到 Web 异常 (例如，404： 找不到文件)。 你可以处理此类异常从<xref:System.Windows.Navigation.NavigationService.NavigationFailed>。  
  
 你可以使用<xref:System.Windows.Navigation.NavigationService.Navigate%2A>可导航到内容片段。 如果通过 URI 标识的内容为当前的内容，它将不重新下载。  
  
   
  
## Examples  
 下面的示例演示如何导航到的 URI。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatecode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatecode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root, System::Object ^ navigationState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">一个包含目标导航内容的对象。</param>
        <param name="navigationState">一个包含要在导航过程中进行处理的数据的对象。</param>
        <summary>异步导航某个对象包含的内容，并传递一个对象，其中包含要在导航过程中进行处理的数据。</summary>
        <returns>
          如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有相同的行为<xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>，尽管而不是一个 URI 传递的对象。  
  
   
  
## Examples  
 下面的示例演示如何导航到<xref:System.Windows.Controls.Page>对象包含源内容中，并传递导航状态。  
  
 [!code-csharp[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">使用所需内容的 URI 初始化的 <see cref="T:System.Uri" /> 对象。</param>
        <param name="navigationState">一个包含要在导航过程中进行处理的数据的对象。</param>
        <summary>异步导航到位于某个 URI 中的源内容，并传递一个对象，其中包含要在导航过程中进行处理的数据。</summary>
        <returns>
          如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于导航是异步的它时进行多个要在同一时间处于正在进行的导航。 例如，如果在一页有两个子框架，无法导航这两个框架。 在此情况下，引发的各种导航事件<xref:System.Windows.Navigation.NavigationService>可能会引发多个时间，一个用于每项内容要导航到，不一定以便请求的导航。 因此，如果某个特定导航请求需要处理特定于单个请求的数据，则无法使用可供所有导航请求的数据。 相反，你可以使用`navigationState`导航处理的是特定于某个导航请求中传入数据。  
  
 以下事件自变量提供对导航状态的访问：  
  
-   <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ExtraData%2A> (传递到<xref:System.Windows.Navigation.NavigationService.Navigating>事件)。  
  
-   <xref:System.Windows.Navigation.NavigationEventArgs.ExtraData%2A> (传递到<xref:System.Windows.Navigation.NavigationService.Navigated>， <xref:System.Windows.Navigation.NavigationService.NavigationStopped>，<xref:System.Windows.Navigation.NavigationService.LoadCompleted>事件处理程序)。  
  
   
  
## Examples  
 下面的示例演示如何导航到的 URI，并传递导航状态。  
  
 [!code-csharp[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState, bool sandboxExternalContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object, sandboxExternalContent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState, bool sandboxExternalContent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
        <Parameter Name="sandboxExternalContent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">使用所需内容的 URI 初始化的 <see cref="T:System.Uri" /> 对象。</param>
        <param name="navigationState">一个包含要在导航过程中进行处理的数据的对象。</param>
        <param name="sandboxExternalContent">将内容下载到部分信任的安全沙盒中（如果为 <see langword="true" />，则具有默认的 Internet 区域权限集）。 默认值为 <see langword="false" />。</param>
        <summary>异步导航到位于某个 URI 中的源内容，传递一个对象（其中包含在导航过程中进行处理的导航状态），并沙盒处理内容。</summary>
        <returns>
          如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法仅适用于独立应用程序和[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]内容。  
  
 此方法具有相同的行为<xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>，并通过确保正在下载的内容置于部分信任安全沙盒对其进行扩展 (具有默认 Internet 区域集的权限-请参阅[WPF 部分信任安全](~/docs/framework/wpf/wpf-partial-trust-security.md))。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>找到导航的目标内容且可通过 <see cref="P:System.Windows.Navigation.NavigationService.Content" /> 属性得到这些内容时发生，即使尚未加载完毕也是如此。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你处理<xref:System.Windows.Navigation.NavigationService.Navigated>如果你需要下载开始时发现有关导航请求的信息。 此信息可从<xref:System.Windows.Navigation.NavigationEventArgs>对象传递给<xref:System.Windows.Navigation.NavigationService.Navigated>事件处理程序，并包括：  
  
-   源页中。 当<xref:System.Windows.Navigation.NavigationService.Navigated>引发时，至少部分的源页的[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]分析，树并将其附加到目标内容控件。  
  
-   请求的 URI。  
  
-   导航器 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>)。  
  
-   其他数据，如果启动了导航，通过调用<xref:System.Windows.Navigation.NavigationService.Navigate%2A>或<xref:System.Windows.Navigation.NavigationService.Navigate%2A>。  
  
-   响应详细信息 (使用<xref:System.Net.WebResponse>对象)。  
  
 <xref:System.Windows.Navigation.NavigationService.Navigated> 无法找到或加载在这种情况下，源页时，则不会引发<xref:System.Windows.Navigation.NavigationService.NavigationFailed>引发。  
  
> [!NOTE]
>  当<xref:System.Windows.Navigation.NavigationService>引发<xref:System.Windows.Navigation.NavigationService.NavigationFailed>，它还会引发<xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType>上的事件<xref:System.Windows.Application>对象。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.Navigated>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>请求新导航时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigating> 当请求一个新导航，但在源之前请求内容，包括何时引发：  
  
-   调用 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>。  
  
-   <xref:System.Windows.Navigation.NavigationService.GoBack%2A> 或<xref:System.Windows.Navigation.NavigationService.GoForward%2A>称为 (或从导航栏上选择一个条目[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)])。  
  
-   内容片段导航到。  
  
 你处理<xref:System.Windows.Navigation.NavigationService.Navigating>如果想要发现关于导航开始之前的导航请求的相关信息。 此信息可从<xref:System.Windows.Navigation.NavigatingCancelEventArgs>对象传递给<xref:System.Windows.Navigation.NavigationService.Navigating>事件处理程序。  
  
 A<xref:System.Net.WebRequest>对象用于导航的创建，并且可从<xref:System.Windows.Navigation.NavigatingCancelEventArgs>参数; 此时尚未成为实际的请求，因为你可以重新配置<xref:System.Net.WebRequest>对象，如有必要。  
  
 你还处理<xref:System.Windows.Navigation.NavigatingCancelEventArgs>取消导航窗格中，如果需要，通过设置<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>为 true。 如果您取消导航，则会不引发任何其他导航事件。  
  
> [!NOTE]
>  如果你的应用程序托管在浏览器中，你不能防止用户离开你的应用程序通过取消<xref:System.Windows.Navigation.NavigationService.Navigating>事件。  
  
 内容的第一条已导航至由导航后 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>)，每项导航离开的内容添加到导航历史记录。 如果你需要保存状态信息导航离开的内容，你可以将状态添加到该内容的日记条目通过设置<xref:System.Windows.Navigation.NavigatingCancelEventArgs.ContentStateToSave%2A>与<xref:System.Windows.Navigation.CustomContentState>对象。  
  
> [!NOTE]
>  当<xref:System.Windows.Navigation.NavigationService>引发<xref:System.Windows.Navigation.NavigationService.Navigating>，它还会引发<xref:System.Windows.Application.Navigating?displayProperty=nameWithType>上的事件<xref:System.Windows.Application>对象。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.Navigating>以检测是否提出了刷新静态内容的请求，如果是这样，若要取消请求。  
  
 <xref:System.Windows.Navigation.NavigationService.Navigating>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在导航到所请求内容出错时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 时请<xref:System.Net.WebException>或<xref:System.IO.IOException>在导航窗格中，过程中引发<xref:System.Windows.Navigation.NavigationService.NavigationFailed>引发事件。 <xref:System.Windows.Navigation.NavigationService.NavigationFailed> 传递<xref:System.Windows.Navigation.NavigationFailedEventArgs>，封装有关异常和导致异常的导航的详细信息的信息。  
  
 时异常导致的失败的导航窗格中，并且未经处理，按列出的顺序引发以下事件：  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>。  
  
-   <xref:System.Windows.Controls.Frame.NavigationFailed?displayProperty=nameWithType> 或 <xref:System.Windows.Navigation.NavigationWindow.NavigationFailed?displayProperty=nameWithType>。  
  
-   <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType>。  
  
-   <xref:System.Windows.Application.DispatcherUnhandledException>。  
  
 如果导航器 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>) 都由一个或多个导航器`NavigationFailed`则不会对其中任何一引发。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.NavigationFailed>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationfailedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationfailedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在下载过程中定期发生，用于提供定位进度信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 传递<xref:System.Windows.Navigation.NavigationProgressEventArgs>可公开以下的进度信息：  
  
-   到目前为止下载的字节数 (<xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A>)。  
  
-   若要下载的总字节数 (<xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A>)。  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 下载完成后的内容每 1024 个字节，和引发一次的剩余字节数是否曾小于 1024 个字节。 为此，处理<xref:System.Windows.Navigation.NavigationService.NavigationProgress>提供有用的方式来跟踪和显示当前下载的进度。  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress> 在某些情况下，例如当相同的内容导航到，或当内容片段导航到当前已加载的内容将不会引发 (即值<xref:System.Windows.Navigation.NavigationService.Content%2A>属性)。  
  
 导航到已编译的 XAML 资源，则最后时<xref:System.Windows.Navigation.NavigationService.NavigationProgress>可能不会引发事件。 这意味着，在下载结束时，上次报告<xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A>值可能不等于<xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A>值。 处理<xref:System.Windows.Navigation.NavigationService.LoadCompleted>导航已完成时要通知的事件。  
  
> [!NOTE]
>  当<xref:System.Windows.Navigation.NavigationService>引发<xref:System.Windows.Navigation.NavigationService.NavigationProgress>，它还会引发<xref:System.Windows.Application.NavigationProgress?displayProperty=nameWithType>上的事件<xref:System.Windows.Application>对象。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.NavigationProgress>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationprogresscode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationprogresscode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在调用 <see cref="M:System.Windows.Navigation.NavigationService.StopLoading" /> 方法时发生，或者在当前导航正处于进行过程中时又请求一个新导航时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你处理<xref:System.Windows.Navigation.NavigationService.NavigationStopped>如果你需要下载停止时发现有关导航请求的信息。 此信息可从<xref:System.Windows.Navigation.NavigationEventArgs>对象传递给<xref:System.Windows.Navigation.NavigationService.NavigationStopped>事件处理程序，并包括：  
  
-   请求的 URI。  
  
-   导航器 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>)。  
  
-   其他数据，如果启动了导航，通过调用<xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>或<xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  当<xref:System.Windows.Navigation.NavigationService>引发<xref:System.Windows.Navigation.NavigationService.NavigationStopped>，它还会引发<xref:System.Windows.Application.NavigationStopped?displayProperty=nameWithType>上的事件<xref:System.Windows.Application>对象。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.NavigationStopped>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationstoppedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationstoppedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重新加载当前内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前的内容 (的值指定的<xref:System.Windows.Navigation.NavigationService.Source%2A>属性) 再次，导航到<xref:System.Windows.Navigation.NavigationService>不会下载内容。 若要强制<xref:System.Windows.Navigation.NavigationService>重新导航到内容，调用<xref:System.Windows.Navigation.NavigationService.Refresh%2A>。  
  
 请注意，如果当前内容再次，导航到通过调用<xref:System.Windows.Navigation.NavigationService.Navigate%2A>或<xref:System.Windows.Navigation.NavigationService.Refresh%2A>，新的条目不会添加到导航历史记录。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
      </Docs>
    </Member>
    <Member MemberName="RemoveBackEntry">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.JournalEntry RemoveBackEntry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Navigation.JournalEntry RemoveBackEntry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveBackEntry () As JournalEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Navigation::JournalEntry ^ RemoveBackEntry();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.JournalEntry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>移除后退历史记录中的最新日记条目。</summary>
        <returns>后退导航历史记录中的最新 <see cref="T:System.Windows.Navigation.JournalEntry" />（如果有）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果两个或多个导航器 (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>) 共享相同的导航历史记录，可以使用一个导航器<xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A>检索发生在另一个导航器中导航的后退导航历史记录条目。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前内容的 URI，或当前正在导航到的新内容的 URI。</summary>
        <value>A <see cref="T:System.Uri" /> ，其中包含当前的内容，或当前导航到的内容 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果将此属性设置为比当前正显示，则导航器不同的 URI (<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>) 导航到指定的 URI。  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A> 设置为除非取消导航，则导航到，URI 中加载的内容。  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A> 可以使用仅限片段的 URI 设置，并可以将设置为`null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopLoading">
      <MemberSignature Language="C#" Value="public void StopLoading ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopLoading() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.StopLoading" />
      <MemberSignature Language="VB.NET" Value="Public Sub StopLoading ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StopLoading();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>停止为当前导航请求下载更多内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> 可以调用立即<xref:System.Windows.Navigation.NavigationService.Navigate%2A>返回，并停止正在进行子框架中的导航。  
  
 (<xref:System.Windows.Controls.Frame>).  
  
 调用<xref:System.Windows.Navigation.NavigationService.StopLoading%2A>方法引发<xref:System.Windows.Navigation.NavigationService.NavigationStopped>事件。  
  
> [!NOTE]
>  <xref:System.Windows.Navigation.NavigationService.StopLoading%2A> 必须启动导航在同一线程上调用。  
  
   
  
## Examples  
 下面的示例演示如何以停止加载。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowstoploadingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowstoploadingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
  </Members>
</Type>