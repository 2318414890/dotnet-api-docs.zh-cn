<Type Name="XmlNodeReader" FullName="System.Xml.XmlNodeReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d76c4652023d77cbb774d22ddeab922d2807704d" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34254575" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlNodeReader : System.Xml.XmlReader, System.Xml.IXmlNamespaceResolver" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlNodeReader extends System.Xml.XmlReader implements class System.Xml.IXmlNamespaceResolver" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlNodeReader" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlNodeReader&#xA;Inherits XmlReader&#xA;Implements IXmlNamespaceResolver" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlNodeReader : System::Xml::XmlReader, System::Xml::IXmlNamespaceResolver" />
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlReader</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Xml.IXmlNamespaceResolver</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>表示提供对 <see cref="T:System.Xml.XmlNode" /> 中的 XML 数据进行快速、非缓存的只进访问的读取器。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  而不是使用<xref:System.Xml.XmlNodeReader>，我们建议你创建<xref:System.Xml.XmlReader>实例使用<xref:System.Xml.XmlReaderSettings>类和<xref:System.Xml.XmlReader.Create%2A>方法。 这使你充分利用的一致性检查和对 XML 1.0 建议的符合性。  
  
 `XmlNodeReader`能够读取 XML DOM 子树。 此类不支持文档类型定义 (DTD) 或架构验证。 但是，你可以创建<xref:System.Xml.XmlReader>对象来包装<xref:System.Xml.XmlNodeReader>要验证中存储的数据对象<xref:System.Xml.XmlNodeReader>对象，如示例部分中所示。  
  
   
  
## Examples  
 在以下示例中，XML 文件加载到 XML 文档中并进行修改。 XML 文档传递给 <xref:System.Xml.XmlNodeReader>，后者再传递给 <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> 方法。 在验证读取器分析文件时，可以验证对 XML 文件所作的任何更改。  
  
 [!code-csharp[XmlReader_Validate_DOM#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Validate_DOM/CS/valid_dom.cs#1)]
 [!code-vb[XmlReader_Validate_DOM#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Validate_DOM/VB/valid_dom.vb#1)]  
  
## <a name="input"></a>输入  
 下列文件作为输入使用。  
  
#### <a name="bookschemaxml"></a>bookSchema.xml  
 [!code-xml[XML_Core_Files#8](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/booksschema.xml#8)]  
  
#### <a name="booksxsd"></a>books.xsd  
 [!code-xml[XML_Core_Files#9](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/books.xsd#9)]  
  
## <a name="output"></a>输出  
 验证错误：未声明“publisher”属性。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlNodeReader (System.Xml.XmlNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.#ctor(System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (node As XmlNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlNodeReader(System::Xml::XmlNode ^ node);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="node">要读取的 <see langword="XmlNode" />。</param>
        <summary>使用指定的 <see cref="T:System.Xml.XmlNode" /> 创建 <see langword="XmlNodeReader" /> 类的实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 有关详细信息和示例的代码用于创建`XmlNodeReader`，请参阅<xref:System.Xml.XmlReader>的重载和<xref:System.Xml.XmlReader.Create%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public override int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.AttributeCount" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AttributeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int AttributeCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前节点上的属性数目。</summary>
        <value>当前节点上的属性数目。 该数目包括默认属性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 此属性是与相关`Element`，`DocumentType`和`XmlDeclaration`仅限节点。 （其他节点类型不具有属性。）  
  
   
  
## Examples  
 下面的示例读取根节点上的所有属性。  
  
 [!code-cpp[Classic WebData XmlNodeReader.AttributeCount Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.AttributeCount Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.AttributeCount Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.AttributeCount Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.AttributeCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.AttributeCount Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public override string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前节点的基 URI。</summary>
        <value>当前节点的基 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 联网的 XML 文档的聚合使用各种 W3C 标准包含机制的数据块组成，因此包含来自不同位置的节点。 DTD 实体是该示例，但这并不限于 Dtd。 基 URI 将指示你这些节点来自何处。 如果没有要返回的节点没有基 URI （例如，它们已分析从内存中字符串），返回 String.Empty。  
  
   
  
## Examples  
 下面的示例分析文件并显示每个节点的基 URI。  
  
 [!code-cpp[Classic WebData XmlNodeReader.BaseURI Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.BaseURI Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.BaseURI Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.BaseURI Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.BaseURI Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.BaseURI Example/VB/source.vb#1)]  
  
 该示例使用文件，`uri.xml`作为输入。  
  
 [!code-xml[Classic WebData XmlNodeReader.BaseURI Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlNodeReader.BaseURI Example/XML/source.xml#2)]  
  
 `style.xml`文件包含的 XML 文本`<style>hardcover</style>`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public override bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.CanReadBinaryContent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanReadBinaryContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadBinaryContent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Xml.XmlNodeReader" /> 是否实现二进制内容读取方法。</summary>
        <value>如果实现了二进制内容读取方法，则为 <see langword="true" />；否则为 <see langword="false" />。 <see cref="T:System.Xml.XmlNodeReader" /> 类始终返回 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 二进制内容读取方法包括<xref:System.Xml.XmlNodeReader.ReadContentAsBase64%2A>， <xref:System.Xml.XmlNodeReader.ReadContentAsBinHex%2A>， <xref:System.Xml.XmlNodeReader.ReadElementContentAsBase64%2A>，和<xref:System.Xml.XmlNodeReader.ReadElementContentAsBinHex%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public override bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.CanResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanResolveEntity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanResolveEntity { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此读取器是否可以分析和解析实体。</summary>
        <value>如果此读取器可以分析和解析实体，则为 <see langword="true" />；否则为 <see langword="false" />。 <see langword="XmlNodeReader" /> 始终返回 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将 <see cref="P:System.Xml.XmlNodeReader.ReadState" /> 改为 <see langword="Closed" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 此方法也会释放读取时占用的任何资源。 如果`Close`已被调用，不执行任何操作。  
  
   
  
## Examples  
 下面的示例分析文件并关闭读取器。  
  
 [!code-cpp[Classic WebData XmlNodeReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/VB/source.vb#1)]  
  
 该示例使用文件，`items.xml`作为输入。  
  
 [!code-xml[Classic WebData XmlNodeReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public override int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Depth { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 XML 文档中当前节点的深度。</summary>
        <value>XML 文档中当前节点的深度。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public override bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.EOF" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property EOF As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EOF { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示读取器是否定位在流结尾。</summary>
        <value>如果此读取器定位在流的结尾，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取属性的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public override string GetAttribute (int attributeIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetAttribute(int32 attributeIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.GetAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAttribute (attributeIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetAttribute(int attributeIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="attributeIndex">属性的索引。 索引是从零开始的。 （第一个属性的索引为 0。）</param>
        <summary>获取具有指定索引的属性的值。</summary>
        <returns>指定的属性的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 此方法不移动读取器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="i" /> 参数小于 0 或大于等于 <see cref="P:System.Xml.XmlNodeReader.AttributeCount" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public override string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAttribute (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetAttribute(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">属性的限定名称。</param>
        <summary>获取具有指定名称的属性的值。</summary>
        <returns>指定的属性的值。 如果未找到该属性，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 此方法不移动读取器。  
  
 如果读取器定位在`DocumentType`节点，此方法可以用于获取的公共和系统文本，例如， `reader.GetAttribute("PUBLIC")`  
  
   
  
## Examples  
 下面的示例获取 ISBN 属性的值。  
  
 [!code-cpp[Classic WebData XmlNodeReader.GetAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.GetAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.GetAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.GetAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.GetAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.GetAttribute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public override string GetAttribute (string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetAttribute(string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.GetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAttribute (name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetAttribute(System::String ^ name, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">属性的本地名称。</param>
        <param name="namespaceURI">属性的命名空间 URI。</param>
        <summary>获取具有指定本地名称和命名空间 URI 的属性的值。</summary>
        <returns>指定的属性的值。 如果未找到该属性，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 下面的 XML 包含特定的命名空间中的属性：  
  
```xml  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 你可以查找`dt:type`属性使用一个自变量 （前缀和本地名称） 或两个自变量 （本地名称和命名空间 URI）：  
  
```csharp  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 查找`xmlns:dt`特性，请使用以下参数之一：  
  
```csharp  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 你还可以获得此信息使用<xref:System.Xml.XmlNodeReader.Prefix%2A>属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAttributes">
      <MemberSignature Language="C#" Value="public override bool HasAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.HasAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property HasAttributes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasAttributes { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前节点是否有任何属性。</summary>
        <value>如果当前节点具有属性，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
   
  
## Examples  
 下面的示例读取根节点上的所有属性。  
  
 [!code-cpp[Classic WebData XmlNodeReader.AttributeCount Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.AttributeCount Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.AttributeCount Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.AttributeCount Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.AttributeCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.AttributeCount Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public override bool HasValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.HasValue" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property HasValue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasValue { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前节点是否可以具有 <see cref="P:System.Xml.XmlNodeReader.Value" />。</summary>
        <value>如果读取器当前定位在的节点可以具有 <see langword="Value" />，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 下表列出具有要返回的值的节点类型。  
  
|节点类型|“值”|  
|---------------|-----------|  
|`Attribute`|属性的值。|  
|`CDATA`|CDATA 节的内容。|  
|`Comment`|注释的内容。|  
|`DocumentType`|内部子集。|  
|`ProcessingInstruction`|全部内容（不包括指令目标）。|  
|`SignificantWhitespace`|混合内容模型中标记之间的空白。|  
|`Text`|文本节点的内容。|  
|`Whitespace`|标记之间的空白。|  
|`XmlDeclaration`|声明的内容。|  
  
   
  
## Examples  
 下面的示例显示的值可以在每个节点的值。  
  
 [!code-cpp[Classic WebData XmlNodeReader.HasValue Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.HasValue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.HasValue Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.HasValue Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.HasValue Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.HasValue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public override bool IsDefault { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.IsDefault" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDefault { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前节点是否是从文档类型定义 (DTD) 或架构中定义的默认值生成的属性。</summary>
        <value>如果当前节点是其值从 DTD 或架构中定义的默认值生成的属性，则为 <see langword="true" />；如果属性值为显式设置的，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 此属性适用于仅限属性节点。 如果读取器未定位在属性节点上，此属性返回`false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public override bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.IsEmptyElement" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEmptyElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEmptyElement { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前节点是否为空元素（例如 <c>&lt;MyElement/&gt;</c>）。</summary>
        <value>
          <see langword="true" /> 如果当前节点为元素 (<see cref="P:System.Xml.XmlNodeReader.NodeType" />等于<see langword="XmlNodeType.Element" />) 和结束的<c> / &gt; </c>; 否则为<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 此属性使您能够确定下面各项之间的差异：  
  
 `<item num="123"/>` (`IsEmptyElement`是`true`)。  
  
 `<item num="123">` (`IsEmptyElement`是`false`，尽管元素内容为空)。  
  
 相应`EndElement`节点不为空的元素生成。  
  
   
  
## Examples  
 下面的示例显示了每个元素的文本内容。  
  
 [!code-cpp[Classic WebData XmlNodeReader.IsEmptyElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.IsEmptyElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.IsEmptyElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.IsEmptyElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.IsEmptyElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.IsEmptyElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public override string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前节点的本地名称。</summary>
        <value>移除了前缀的当前节点的名称。 例如，<see langword="LocalName" />是<see langword="book" />元素<c> &lt;bk:book&gt;</c>。  对于没有名称的节点类型（如 <see langword="Text" />、<see langword="Comment" /> 等），该属性返回 String.Empty。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
   
  
## Examples  
 下面的示例显示每个节点的本地名称并且，如果它们存在，前缀和命名空间 URI。  
  
 [!code-cpp[Classic WebData XmlNodeReader.NamespaceURI Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.NamespaceURI Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.NamespaceURI Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.NamespaceURI Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.NamespaceURI Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.NamespaceURI Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public override string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function LookupNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ LookupNamespace(System::String ^ prefix);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.LookupNamespace(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">要解析其命名空间 URI 的前缀。 若要匹配默认命名空间，请传递一个空字符串。 不必原子化该字符串。</param>
        <summary>解析当前元素的范围内的命名空间前缀。</summary>
        <returns>前缀映射到的命名空间 URI；如果未找到任何匹配的前缀，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 在下面的 XML 字符串，如果读取器定位在`href`特性，前缀`a`通过调用解决`reader.LookupNamespace("a")`。 返回的字符串是`urn:456`。  
  
```xml  
<root xmlns:a="urn:456">  
 <item>  
 <ref href="a:b"/>  
 </item>  
</root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveToAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>移动到指定的属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public override void MoveToAttribute (int attributeIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void MoveToAttribute(int32 attributeIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.MoveToAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub MoveToAttribute (attributeIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void MoveToAttribute(int attributeIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="attributeIndex">属性的索引。</param>
        <summary>移动到具有指定索引的属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
   
  
## Examples  
 下面的示例读取根节点上的所有属性。  
  
 [!code-cpp[Classic WebData XmlNodeReader.AttributeCount Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.AttributeCount Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.AttributeCount Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.AttributeCount Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.AttributeCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.AttributeCount Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="i" /> 参数小于 0 或大于等于 <see cref="P:System.Xml.XmlReader.AttributeCount" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.MoveToAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToAttribute (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToAttribute(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">属性的限定名称。</param>
        <summary>移动到具有指定名称的属性。</summary>
        <returns>如果找到了属性，则为 <see langword="true" />；否则为 <see langword="false" />。 如果为 <see langword="false" />，则读取器的位置未改变。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 调用此方法后<xref:System.Xml.XmlNodeReader.Name%2A>， <xref:System.Xml.XmlNodeReader.NamespaceURI%2A>，和<xref:System.Xml.XmlNodeReader.Prefix%2A>属性反映该属性的属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToAttribute (string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToAttribute(string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.MoveToAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToAttribute (name As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToAttribute(System::String ^ name, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">属性的本地名称。</param>
        <param name="namespaceURI">属性的命名空间 URI。</param>
        <summary>移动到具有指定本地名称和命名空间 URI 的属性。</summary>
        <returns>如果找到了属性，则为 <see langword="true" />；否则为 <see langword="false" />。 如果为 <see langword="false" />，则读取器的位置未改变。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 调用此方法后<xref:System.Xml.XmlNodeReader.Name%2A>， <xref:System.Xml.XmlNodeReader.NamespaceURI%2A>，和<xref:System.Xml.XmlNodeReader.Prefix%2A>属性反映该属性的属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public override bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.MoveToElement" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToElement();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>移动到包含当前属性节点的元素。</summary>
        <returns>如果读取器定位在属性上（读取器移动到拥有该属性的元素），则为 <see langword="true" />；如果读取器未定位在属性上（读取器的位置不更改），则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 使用此方法在其属性导航后返回到该元素。 此方法将读取器移动到以下节点类型之一： `Element`， `DocumentType`，或`XmlDeclaration`。  
  
   
  
## Examples  
 下面的示例读取根节点上的所有属性。  
  
 [!code-cpp[Classic WebData XmlNodeReader.AttributeCount Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.AttributeCount Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.AttributeCount Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.AttributeCount Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.AttributeCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.AttributeCount Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.MoveToFirstAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToFirstAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToFirstAttribute();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>移动到第一个属性。</summary>
        <returns>如果属性存在（读取器移动到第一个属性），则为 <see langword="true" />；否则为 <see langword="false" />（读取器的位置不更改）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这使您可以充分利用所有中引入的新功能[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
   
  
## Examples  
 下面的示例获取根节点的第一个属性的值。  
  
 [!code-cpp[Classic WebData XmlNodeReader.MoveToFirstAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.MoveToFirstAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.MoveToFirstAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.MoveToFirstAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.MoveToFirstAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.MoveToFirstAttribute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.MoveToNextAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToNextAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToNextAttribute();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>移动到下一个属性。</summary>
        <returns>如果存在下一个属性，则为 <see langword="true" />；如果没有其他属性，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 如果当前节点不是属性节点，则此方法等效于<xref:System.Xml.XmlNodeReader.MoveToFirstAttribute%2A>。 如果`MoveToNextAttribute`返回`true`，读取器移动到下一步属性; 否则，读取器的位置不会更改。  
  
   
  
## Examples  
 下面的示例读取一本书。  
  
 [!code-cpp[Classic WebData XmlNodeReader.MoveToNextAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.MoveToNextAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.MoveToNextAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.MoveToNextAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.MoveToNextAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.MoveToNextAttribute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前节点的限定名称。</summary>
        <value>当前节点的限定名称。 例如，<see langword="Name" />是<see langword="bk:book" />元素<c> &lt;bk:book&gt;</c>。  返回的名称取决于节点的 <see cref="P:System.Xml.XmlNodeReader.NodeType" />。 下列节点类型返回所列的值。 所有其他节点类型返回空字符串。  
  
 <list type="table"><listheader><term> 节点类型</term><description>名称</description></listheader><item><term><see langword="Attribute" /></term><description>属性的名称。</description></item><item><term><see langword="DocumentType" /></term><description> 文档类型名称。</description></item><item><term><see langword="Element" /></term><description> 标记名称。</description></item><item><term><see langword="EntityReference" /></term><description> 引用的实体名称。</description></item><item><term><see langword="ProcessingInstruction" /></term><description> 处理指令的目标。</description></item><item><term><see langword="XmlDeclaration" /></term><description> 文字字符串<see langword="xml" />。  </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
   
  
## Examples  
 下面的示例读取 XML，并显示每个节点。  
  
 [!code-cpp[Classic WebData XmlNodeReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/VB/source.vb#1)]  
  
 该示例使用文件，`items.xml`作为输入。  
  
 [!code-xml[Classic WebData XmlNodeReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public override string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取读取器定位在的节点的命名空间 URI（采用 W3C 命名空间规范中定义）。</summary>
        <value>当前节点的命名空间 URI；否则为空字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 此属性是与相关`Element`和`Attribute`仅限节点。  
  
   
  
## Examples  
 下面的示例显示每个节点的本地名称并且，如果它们存在，前缀和命名空间 URI。  
  
 [!code-cpp[Classic WebData XmlNodeReader.NamespaceURI Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.NamespaceURI Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.NamespaceURI Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.NamespaceURI Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.NamespaceURI Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.NamespaceURI Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与此实现关联的 <see cref="T:System.Xml.XmlNameTable" />。</summary>
        <value>
          <see langword="XmlNameTable" />，它使你能够获取该节点内字符串的原子化版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 此类从返回的所有节点和属性名称进行原子都化使用`NameTable`。 当多次返回相同的名称 (例如， `Customer`)，然后相同`String`为该名称返回对象。 这使您可以编写高效的代码，未对象上而不是昂贵的字符串比较这些字符串的比较。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前节点的类型。</summary>
        <value>
          <see cref="T:System.Xml.XmlNodeType" /> 值之一，表示当前节点的类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
   
  
## Examples  
 下面的示例读取 XML，并显示每个节点。  
  
 [!code-cpp[Classic WebData XmlNodeReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/VB/source.vb#1)]  
  
 该示例使用文件，`items.xml`作为输入。  
  
 [!code-xml[Classic WebData XmlNodeReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public override string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Prefix { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与当前节点关联的命名空间前缀。</summary>
        <value>与当前节点关联的命名空间前缀。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
   
  
## Examples  
 下面的示例显示每个节点的本地名称并且，如果它们存在，前缀和命名空间 URI。  
  
 [!code-cpp[Classic WebData XmlNodeReader.NamespaceURI Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.NamespaceURI Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.NamespaceURI Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.NamespaceURI Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.NamespaceURI Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.NamespaceURI Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Read();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从流中读取下一个节点。</summary>
        <returns>如果成功读取了下一个节点，则为 <see langword="true" />；如果没有其他节点可读取，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 当首次创建和初始化一个读取器时，没有任何可用信息。 必须调用`Read`读取的第一个节点。  
  
   
  
## Examples  
 下面的示例读取 XML，并显示每个节点。  
  
 [!code-cpp[Classic WebData XmlNodeReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/VB/source.vb#1)]  
  
 该示例使用文件，`items.xml`作为输入。  
  
 [!code-xml[Classic WebData XmlNodeReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public override bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.ReadAttributeValue" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAttributeValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ReadAttributeValue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将属性值分析为一个或多个 <see langword="Text" />、<see langword="EntityReference" /> 或 <see langword="EndEntity" /> 节点。</summary>
        <returns>如果有可返回的节点，则为 <see langword="true" />。  
  
 如果进行初始调用时读取器不是定位在属性节点上，或者如果已读取了所有属性值，则为 <see langword="false" />。  如果是空属性，如 <c>misc=""</c>，则返回 <see langword="true" />，同时返回值为 String.Empty 的单个节点。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 使用此方法之后调用<xref:System.Xml.XmlNodeReader.MoveToAttribute%2A>通读构成的属性值的文本或实体引用节点。 <xref:System.Xml.XmlNodeReader.Depth%2A>属性值节点是一个加上属性节点的深度; 它递增和递减由一个单步执行和跳出执行常规实体引用时。  
  
   
  
## Examples  
 下面的示例读取一个带文本或实体引用节点的属性。  
  
 [!code-cpp[Classic WebData XmlNodeReader.ReadAttributeValue Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.ReadAttributeValue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.ReadAttributeValue Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.ReadAttributeValue Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.ReadAttributeValue Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.ReadAttributeValue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public override int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>读取内容并返回 Base64 解码的二进制字节。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 此方法的内容流式处理，对 Base64 内容进行解码并返回已解码的二进制字节 （例如，内联 Base64 编码的 GIF 图像） 到缓冲区。 可以连续调用此方法，以读取大的嵌入文本流。 有关详细信息，请参阅 RFC 1521"MIME （多用途 Internet 邮件扩展） 部分一个： 机制来指定以及描述 Internet 消息正文的格式"。 你可以获取从 Rfc[征求意见文档网站](https://www.rfc-editor.org)。  
  
> [!NOTE]
>  不应访问的任何读取器属性之间调用<xref:System.Xml.XmlNodeReader.ReadContentAsBase64%2A>方法，直到该方法返回值 0。  
  
 此方法具有以下行为：  
  
-   <xref:System.Xml.XmlNodeReader.ReadContentAsBase64%2A> 当它已达到它正在操作的字节流的末尾，则返回值 0。 读取器定位在的第一个非内容节点上。  
  
-   如果你请求更少，或者在当前位置保持的字节数比流中读取器剩余的精确数目。  
  
-   <xref:System.Xml.XmlNodeReader.ReadContentAsBase64%2A> 不支持对以下 XML 节点类型： 元素、 XmlDeclaration，无、 文档、 文档类型、 表示法、 实体、 DocumentFragment。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">当前节点不支持 <see cref="M:System.Xml.XmlNodeReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">缓冲区中的索引或者索引与计数之和大于分配的缓冲区大小。</exception>
        <altmember cref="M:System.Xml.XmlNodeReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Xml.XmlNodeReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public override int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>读取内容并返回 BinHex 解码的二进制字节。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 此方法的内容流式处理，对 BinHex 内容进行解码并返回解码的二进制字节 （例如，内联 BinHex 编码的 GIF 图像） 到缓冲区。 可以连续调用此方法，以读取大的嵌入文本流。  
  
> [!NOTE]
>  不应访问的任何读取器属性之间调用<xref:System.Xml.XmlNodeReader.ReadContentAsBinHex%2A>方法，直到该方法返回值 0。  
  
 此方法具有以下行为：  
  
-   <xref:System.Xml.XmlNodeReader.ReadContentAsBinHex%2A> 当它已达到它正在操作的字节流的末尾，则返回值 0。 读取器定位在的第一个非内容节点上。  
  
-   如果你请求更少，或者在当前位置保持的字节数比流中读取器剩余的精确数目。  
  
-   <xref:System.Xml.XmlNodeReader.ReadContentAsBinHex%2A> 不支持对以下 XML 节点类型： 元素、 XmlDeclaration，无、 文档、 文档类型、 表示法、 实体、 DocumentFragment。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">当前节点不支持 <see cref="M:System.Xml.XmlNodeReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">缓冲区中的索引或者索引与计数之和大于分配的缓冲区大小。</exception>
        <altmember cref="M:System.Xml.XmlNodeReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Xml.XmlNodeReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public override int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadElementContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadElementContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>读取元素并对 Base64 内容进行解码。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 此方法读取内容，使用 Base64 编码进行解码并返回解码的二进制字节 （例如，内联 Base64 编码的 GIF 图像） 到缓冲区。 有关详细信息，请参阅 RFC 1521"MIME （多用途 Internet 邮件扩展） 部分一个： 机制来指定以及描述 Internet 消息正文的格式"。 你可以获取从 Rfc[征求意见文档网站](https://www.rfc-editor.org)。  
  
 此方法只能读取简单内容元素。 该元素可以包含文本、 空白、 有效空白、 CDATA 节、 注释和处理指令。 它还可以包含实体引用自动展开。 元素不能有子元素。  
  
 此方法是非常类似于<xref:System.Xml.XmlNodeReader.ReadContentAsBase64%2A>方法，但它只能在元素节点类型上调用。  
  
 如果计数值高于在文档中，字节数，或是否等于在文档中，字节数<xref:System.Xml.XmlNodeReader>读取文档中的所有剩余字节，并返回读取的字节数。 下一步<xref:System.Xml.XmlNodeReader.ReadElementContentAsBase64%2A>方法调用将返回零，并将读取器移动到节点以下<xref:System.Xml.XmlNodeType.EndElement>节点。  
  
 如果调用<xref:System.Xml.XmlNodeReader.Read%2A>消耗了全部元素内容时之前，读取器的行为类似于第一个内容已被用尽，然后<xref:System.Xml.XmlNodeReader.Read%2A>调用了方法。 这意味着读取器读取的所有文本，直到遇到 end 元素。 随后，将结束标记节点，读取下一个节点，然后将自身定位在下一步的后续节点。  
  
   
  
## Examples  
 请参阅<xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A?displayProperty=nameWithType>若要查看使用此方法的示例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">当前节点不是元素节点。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">缓冲区中的索引或者索引与计数之和大于分配的缓冲区大小。</exception>
        <exception cref="T:System.Xml.XmlException">该元素包含混合内容。</exception>
        <exception cref="T:System.FormatException">无法将内容转换成请求的类型。</exception>
        <altmember cref="M:System.Xml.XmlNodeReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Xml.XmlNodeReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public override int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadElementContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadElementContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>读取元素并对 BinHex 内容进行解码。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 此方法读取元素内容，对使用 BinHex 编码，对其进行解码并返回解码的二进制字节 （例如，内联 BinHex 编码的 GIF 图像） 到缓冲区。  
  
 此方法只能读取简单内容元素。 该元素可以包含文本、 空白、 有效空白、 CDATA 节、 注释和处理指令。 它还可以包含实体引用自动展开。 元素不能有子元素。  
  
 此方法是非常类似于<xref:System.Xml.XmlNodeReader.ReadContentAsBinHex%2A>方法，但它只能在元素节点类型上调用。  
  
 如果计数值高于在文档中，字节数，或是否等于在文档中，字节数<xref:System.Xml.XmlNodeReader>读取文档中的所有剩余字节，并返回读取的字节数。 下一步<xref:System.Xml.XmlNodeReader>方法调用将返回零，并将读取器移动到节点以下<xref:System.Xml.XmlNodeType.EndElement>节点。  
  
 如果调用<xref:System.Xml.XmlNodeReader.Read%2A>消耗了全部元素内容时之前，读取器的行为类似于第一个内容已被用尽，然后<xref:System.Xml.XmlNodeReader.Read%2A>调用了方法。 这意味着读取器读取的所有文本，直到遇到 end 元素。 随后，将结束标记节点，读取下一个节点，然后将自身定位在下一步的后续节点。  
  
   
  
## Examples  
 请参阅<xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A?displayProperty=nameWithType>若要查看使用此方法的示例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">当前节点不是元素节点。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">缓冲区中的索引或者索引与计数之和大于分配的缓冲区大小。</exception>
        <exception cref="T:System.Xml.XmlException">该元素包含混合内容。</exception>
        <exception cref="T:System.FormatException">无法将内容转换成请求的类型。</exception>
        <altmember cref="M:System.Xml.XmlNodeReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Xml.XmlNodeReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public override System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.ReadState" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReadState As ReadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::ReadState ReadState { System::Xml::ReadState get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取读取器的状态。</summary>
        <value>
          <see cref="T:System.Xml.ReadState" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public override string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将元素或文本节点的内容读取为一个字符串。</summary>
        <returns>元素或类似文本节点（这可以包括 CDATA、Text 节点等）的内容。 如果读取器定位在元素或文本节点以外的位置，或者当前上下文中没有其他文本内容可返回，则这可以是空字符串。  
  
 <see langword="Note:" />文本节点可以是元素或属性文本节点。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 如果定位在元素上，`ReadString`一起连接所有文本、 有效空白，空白区域和 CData 部分节点类型和返回作为元素内容的串联的数据。 它会停止时遇到任何标记。 这可以在混合内容模型中发生，也可以在读取元素结束标记时发生。  
  
 如果在类似文本节点上定位`ReadString`执行相同的串联从文本节点到元素结束标记。 如果读取器定位在属性文本节点上，则 `ReadString` 与读取器定位在元素开始标记上时的功能相同。 它返回所有串联在一起的元素文本节点。  
  
   
  
## Examples  
 下面的示例显示每个元素的文本的内容。  
  
 [!code-cpp[Classic WebData XmlNodeReader.IsEmptyElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.IsEmptyElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.IsEmptyElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.IsEmptyElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.IsEmptyElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.IsEmptyElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public override void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.ResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ResolveEntity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ResolveEntity();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>解析 <see langword="EntityReference" /> 节点的实体引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 如果读取器定位在`EntityReference`节点 (`XmlNodeType.EntityReference`)，如果<xref:System.Xml.XmlNodeReader.Read%2A>称为之后调用此方法，实体替换文本进行分析。 完成实体替换文本后，`EndEntity`将返回节点关闭实体引用作用域。  
  
> [!NOTE]
>  调用此方法后，如果实体为一部分的属性值时，你必须调用<xref:System.Xml.XmlNodeReader.ReadAttributeValue%2A>以单步执行该实体。  
  
   
  
## Examples  
 下面的示例使用`ResolveEntity`展开常规实体。  
  
 [!code-cpp[Classic WebData XmlNodeReader.ResolveEntity Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.ResolveEntity Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.ResolveEntity Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.ResolveEntity Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.ResolveEntity Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.ResolveEntity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">读取器不是定位在 <see langword="EntityReference" /> 节点上。</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public override System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已分配给当前节点的架构信息。</summary>
        <value>一个包含当前节点的架构信息的 <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 <xref:System.Xml.Schema.IXmlSchemaInfo>接口表示后架构验证信息集 (PSVI) 的基础 XML 节点。 已验证该节点之后设置此属性的 PSVI 内容。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Schema.XmlSchemaInfo" />
        <altmember cref="Overload:System.Xml.XmlDocument.Validate" />
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public override void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Skip();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>跳过当前节点的子级。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 例如，假设有以下 XML 输入：  
  
```xml  
<a name="bob" age="123">  
   <x/>abc<y/>  
 </a>  
 <b>  
...  
 </b>  
```  
  
 如果读取器定位在"\<>"节点或任何其属性、 调用`Skip`到读取器定位"\<b >"节点。  
  
 如果读取器定位在叶节点 （如"x"元素或文本节点"abc"），调用`Skip`等同于调用<xref:System.Xml.XmlNodeReader.Read%2A>。  
  
 此方法会检查格式正确的 XML。  
  
   
  
## Examples  
 下面的示例读取 XML 文档中的价格元素节点。  
  
 [!code-cpp[Classic WebData XmlNodeReader.Skip Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.Skip Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.Skip Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.Skip Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.Skip Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.Skip Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlNamespaceResolver.GetNamespacesInScope">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IDictionary&lt;string,string&gt; IXmlNamespaceResolver.GetNamespacesInScope (System.Xml.XmlNamespaceScope scope);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(valuetype System.Xml.XmlNamespaceScope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.System#Xml#IXmlNamespaceResolver#GetNamespacesInScope(System.Xml.XmlNamespaceScope)" />
      <MemberSignature Language="VB.NET" Value="Function GetNamespacesInScope (scope As XmlNamespaceScope) As IDictionary(Of String, String) Implements IXmlNamespaceResolver.GetNamespacesInScope" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System::Xml::XmlNamespaceScope scope) = System::Xml::IXmlNamespaceResolver::GetNamespacesInScope;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System.Xml.XmlNamespaceScope)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Xml.XmlNamespaceScope" />
      </Parameters>
      <Docs>
        <param name="scope">
          <see cref="T:System.Xml.XmlNamespaceScope" /> 对象。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System.Xml.XmlNamespaceScope)" />。</summary>
        <returns>包含范围内命名空间的 <see cref="T:System.Collections.IDictionary" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Xml.XmlNodeReader> 实例强制转换为 <xref:System.Xml.IXmlNamespaceResolver> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlNamespaceResolver.LookupNamespace">
      <MemberSignature Language="C#" Value="string IXmlNamespaceResolver.LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.Xml.IXmlNamespaceResolver.LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.System#Xml#IXmlNamespaceResolver#LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function LookupNamespace (prefix As String) As String Implements IXmlNamespaceResolver.LookupNamespace" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.Xml.IXmlNamespaceResolver.LookupNamespace(System::String ^ prefix) = System::Xml::IXmlNamespaceResolver::LookupNamespace;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.LookupNamespace(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">包含命名空间前缀的 <see cref="T:System.String" />。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.Xml.IXmlNamespaceResolver.LookupNamespace(System.String)" />。</summary>
        <returns>包含命名空间名称的 <see cref="T:System.String" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Xml.XmlNodeReader> 实例强制转换为 <xref:System.Xml.IXmlNamespaceResolver> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlNamespaceResolver.LookupPrefix">
      <MemberSignature Language="C#" Value="string IXmlNamespaceResolver.LookupPrefix (string namespaceName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.Xml.IXmlNamespaceResolver.LookupPrefix(string namespaceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNodeReader.System#Xml#IXmlNamespaceResolver#LookupPrefix(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function LookupPrefix (namespaceName As String) As String Implements IXmlNamespaceResolver.LookupPrefix" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.Xml.IXmlNamespaceResolver.LookupPrefix(System::String ^ namespaceName) = System::Xml::IXmlNamespaceResolver::LookupPrefix;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.LookupPrefix(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="namespaceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="namespaceName">标识命名空间的 <see cref="T:System.String" /> 对象。</param>
        <summary>有关此成员的说明，请参阅 <see cref="M:System.Xml.IXmlNamespaceResolver.LookupPrefix(System.String)" />。</summary>
        <returns>包含命名空间前缀的 <see cref="T:System.String" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Xml.XmlNodeReader> 实例强制转换为 <xref:System.Xml.IXmlNamespaceResolver> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public override string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.Value" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Value { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前节点的文本值。</summary>
        <value>返回的值取决于节点的 <see cref="P:System.Xml.XmlNodeReader.NodeType" />。 下表列出具有要返回的值的节点类型。 所有其他节点类型返回 String.Empty。  
  
 <list type="table"><listheader><term> 节点类型</term><description>值</description></listheader><item><term><see langword="Attribute" /></term><description>属性的值。</description></item><item><term><see langword="CDATA" /></term><description> CDATA 节的内容。</description></item><item><term><see langword="Comment" /></term><description> 注释的内容。</description></item><item><term><see langword="DocumentType" /></term><description> 内部子集。</description></item><item><term><see langword="ProcessingInstruction" /></term><description> 整个内容 （不包括目标）。</description></item><item><term><see langword="SignificantWhitespace" /></term><description> 在混合内容模型中的标记之间的空白。</description></item><item><term><see langword="Text" /></term><description> 文本节点的内容。</description></item><item><term><see langword="Whitespace" /></term><description> 标记之间的空白。</description></item><item><term><see langword="XmlDeclaration" /></term><description> 声明的内容。  </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
   
  
## Examples  
 下面的示例读取 XML，并显示每个节点。  
  
 [!code-cpp[Classic WebData XmlNodeReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNodeReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNodeReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/VB/source.vb#1)]  
  
 该示例使用文件，`items.xml`作为输入。  
  
 [!code-xml[Classic WebData XmlNodeReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlNodeReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public override string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property XmlLang As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see langword="xml:lang" /> 范围。</summary>
        <value>当前 <see langword="xml:lang" /> 范围。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 此属性表示当前节点驻留在其中的 xml: lang 作用域。 例如，下面是与 XML 片段`xml:lang`设置为英语 （美国） 的根元素中：  
  
```xml  
<root xml:lang="en-us">   
<name>Fred</name>   
</root>   
```  
  
 当读取器定位在`name`元素，你可以使用此属性来发现它是否在美国英语的作用域`xml:lang`属性。  
  
 返回的字符串也是在<xref:System.Xml.XmlNodeReader.NameTable%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNodeReader.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property XmlSpace As XmlSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see langword="xml:space" /> 范围。</summary>
        <value>
          <see cref="T:System.Xml.XmlSpace" /> 值之一。 如果不存在任何 <see langword="xml:space" /> 范围，则该属性默认值为 <see langword="XmlSpace.None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] 中，建议的做法是使用 <xref:System.Xml.XmlReader> 类和 <xref:System.Xml.XmlReaderSettings> 方法创建 <xref:System.Xml.XmlReader.Create%2A> 实例。 这样可以充分利用 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 中引入的所有新功能。 有关详细信息，请参阅备注部分中的<xref:System.Xml.XmlReader>引用页。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>