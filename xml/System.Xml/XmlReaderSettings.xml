<Type Name="XmlReaderSettings" FullName="System.Xml.XmlReaderSettings">
  <Metadata><Meta Name="ms.openlocfilehash" Value="adf00ca7f047d43ff6881b848edebef8034fd9f7" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56402597" /></Metadata><TypeSignature Language="C#" Value="public sealed class XmlReaderSettings" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit XmlReaderSettings extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlReaderSettings" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class XmlReaderSettings" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlReaderSettings sealed" />
  <TypeSignature Language="F#" Value="type XmlReaderSettings = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>指定在由 <see cref="T:System.Xml.XmlReader" /> 方法创建的 <see cref="Overload:System.Xml.XmlReader.Create" /> 对象上支持的一组功能。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您使用<xref:System.Xml.XmlReader.Create%2A>方法来获取<xref:System.Xml.XmlReader>实例。 此方法使用<xref:System.Xml.XmlReaderSettings>类，以指定要在中实现的功能<xref:System.Xml.XmlReader>对象创建。  
  
 请参阅备注部分<xref:System.Xml.XmlReader>和<xref:System.Xml.XmlReader.Create%2A>参考有关要用于符合性检查、 验证和其他常见方案的设置信息的页。 请参阅<xref:System.Xml.XmlReaderSettings.%23ctor>构造函数的默认设置的列表。  
  
## <a name="security-considerations"></a>安全注意事项  
 使用时，请考虑以下<xref:System.Xml.XmlReaderSettings>类。  
  
-   默认情况下不设置 <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> 对象的 <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> 和 <xref:System.Xml.XmlReaderSettings> 验证标志。 设置了这些标志后，<xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象的 <xref:System.Xml.XmlReaderSettings> 用于在 <xref:System.Xml.XmlReader> 中解析实例文档中遇到的架构位置。 如果<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>对象是`null`，则不解析架构位置即使<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>和<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation>设置验证标志。  
  
-   在验证过程中添加的架构会添加新类型，并且可能更改被验证的文档的验证结果。 因此，只应从可信的源解析外部架构。  
  
-   验证错误消息可能会公开敏感内容模型的信息。 使用处理验证错误和警告消息<xref:System.Xml.Schema.ValidationEventHandler>委派，或作为公开<xref:System.Xml.Schema.XmlSchemaValidationException>如果没有事件处理程序提供给<xref:System.Xml.XmlReaderSettings>对象 (验证警告不会导致<xref:System.Xml.Schema.XmlSchemaValidationException>引发)。 此内容模型的信息不应在不受信任的情况下公开。 验证警告消息所抑制的默认值，并可以通过设置报告<xref:System.Xml.Schema.XmlSchemaValidationFlags.ReportValidationWarnings>标志。  
  
-   <xref:System.Xml.Schema.XmlSchemaException.SourceUri%2A>属性的<xref:System.Xml.Schema.XmlSchemaValidationException>返回导致异常的架构文件的 URI 路径。 <xref:System.Xml.Schema.XmlSchemaException.SourceUri%2A>不应在不受信任的情况下公开属性。  
  
-   禁用<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints>时验证不受信任的大型 XML 文档中实现高可用性方案中，针对具有标识约束的架构文档的很大程度上，建议使用标志 （默认情况下启用）。  
  
-   <xref:System.Xml.XmlReaderSettings> 对象可以包含敏感信息，例如用户凭据。 在缓存 <xref:System.Xml.XmlReaderSettings> 对象时，或在将 <xref:System.Xml.XmlReaderSettings> 对象从一个组件传递到另一个组件时，应小心。  
  
-   默认情况下禁用 DTD 处理。 如果启用 DTD 处理，需要注意的包括来自不受信任的源和可能的拒绝服务攻击的 Dtd。 使用<xref:System.Xml.XmlSecureResolver>来限制的资源的<xref:System.Xml.XmlReader>可以访问。  
  
-   不接受来自不可信的源的支持组件，例如 <xref:System.Xml.NameTable>、<xref:System.Xml.XmlNamespaceManager> 和 <xref:System.Xml.XmlResolver> 对象。  
  
-   使用 <xref:System.Xml.XmlReader> 的应用程序的内存使用量可能与分析的 XML 文档的大小有关。 拒绝服务攻击的一种形式是提交过大的 XML 文档进行分析。 您可以限制可通过设置分析文档的大小<xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A>属性，然后限制通过设置扩展实体产生的字符数<xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A>属性。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Xml.XmlReader>，它使用<xref:System.Xml.XmlUrlResolver>与所需的凭据。  
  
 [!code-csharp[XmlReader.Create#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#2)]
 [!code-vb[XmlReader.Create#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#2)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/data/xml/index.md">XML 文档和数据</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Xml.XmlReaderSettings" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlReaderSettings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReaderSettings.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlReaderSettings();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Xml.XmlReaderSettings" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表显示的实例的初始属性值<xref:System.Xml.XmlReaderSettings>。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Xml.XmlReaderSettings.Async%2A>|`false`。|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|`true`。|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document>。|  
|<xref:System.Xml.XmlReaderSettings.IgnoreComments%2A>|`false`。|  
|<xref:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions%2A>|`false`。|  
|<xref:System.Xml.XmlReaderSettings.IgnoreWhitespace%2A>|`false`。|  
|<xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>|0.|  
|<xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>|0.|  
|<xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A>|（没有扩展实体产生的字符数没有限制） 为 0。|  
|<xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A>|（在 XML 文档的大小没有任何限制） 为 0。|  
|<xref:System.Xml.XmlReaderSettings.NameTable%2A>|`null`。|  
|<xref:System.Xml.XmlTextReader.DtdProcessing%2A>|<xref:System.Xml.DtdProcessing.Prohibit>|  
|<xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A>|`true`。 此属性已过时。 请改用 <xref:System.Xml.XmlTextReader.DtdProcessing%2A>。 如果已设置<xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A>为其默认值`true`设置<xref:System.Xml.XmlTextReader.DtdProcessing%2A>到`Prohibit`。 如果已设置<xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A>到`false`设置<xref:System.Xml.XmlTextReader.DtdProcessing%2A>到`Parse`。|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|一个空 <xref:System.Xml.Schema.XmlSchemaSet> 对象。|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints>。|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A>|<xref:System.Xml.ValidationType.None>。|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|一个新 <xref:System.Xml.XmlUrlResolver> 对象。|  
  
   
  
## Examples  
 以下命令创建可用于构造去除处理指令、 注释和无关紧要的空白区域的读取器的设置对象。  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlReaderSettings (System.Xml.XmlResolver resolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlResolver resolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReaderSettings.#ctor(System.Xml.XmlResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resolver As XmlResolver)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlReaderSettings(System::Xml::XmlResolver ^ resolver);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlReaderSettings : System.Xml.XmlResolver -&gt; System.Xml.XmlReaderSettings" Usage="new System.Xml.XmlReaderSettings resolver" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="resolver" Type="System.Xml.XmlResolver" />
      </Parameters>
      <Docs>
        <param name="resolver">XML 解析器。</param>
        <summary>初始化 <see cref="T:System.Xml.XmlReaderSettings" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Async">
      <MemberSignature Language="C#" Value="public bool Async { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Async" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.Async" />
      <MemberSignature Language="VB.NET" Value="Public Property Async As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Async { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Async : bool with get, set" Usage="System.Xml.XmlReaderSettings.Async" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置是否可对特定 <see cref="T:System.Xml.XmlReader" /> 实例使用异步 <see cref="T:System.Xml.XmlReader" /> 方法。</summary>
        <value>则可以使用异步方法，则为 <see langword="true" />；否则，为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须将此值设置为`true`创建一个新<xref:System.Xml.XmlReader>实例，如果你想要使用异步<xref:System.Xml.XmlReader>该实例上的方法。 之后<xref:System.Xml.XmlReader>创建实例后，<xref:System.Xml.XmlReaderSettings.Async%2A>属性是只读的。 此属性的默认值为 `false`。  
  
 通过忽略此标志<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>重载。 这意味着，如果您创建一个新<xref:System.Xml.XmlReader>基于现有<xref:System.Xml.XmlReader>，异步行为取决于输入<xref:System.Xml.XmlReader>，并且您无法使用<xref:System.Xml.XmlReaderSettings.Async%2A>更改异步行为的标志。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="CheckCharacters">
      <MemberSignature Language="C#" Value="public bool CheckCharacters { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CheckCharacters" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.CheckCharacters" />
      <MemberSignature Language="VB.NET" Value="Public Property CheckCharacters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CheckCharacters { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckCharacters : bool with get, set" Usage="System.Xml.XmlReaderSettings.CheckCharacters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否进行字符检查。</summary>
        <value>如果进行字符检查，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。  
  
 <block subset="none" type="note"><para>  
 如果 <see cref="T:System.Xml.XmlReader" /> 处理文本数据，则无论属性如何设置，读取器将总是检查 XML 名称和文本内容是否有效。 将 <see cref="P:System.Xml.XmlReaderSettings.CheckCharacters" /> 设置为 <see langword="false" /> 会禁用对字符实体引用的字符检查。  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性指示要检查它读取和引发的 XML 数据中的字符的 XML 读取器<xref:System.Xml.XmlException>如果任何字符不在合法 XML 字符的范围。 如果启用字符检查，必须确保符合下列条件：  
  
-   定义的字符是合法的 XML 字符的范围内[2.2 字符](https://www.w3.org/TR/2006/REC-xml-20060816/#charsets)W3C XML 1.0 建议的部分。  
  
-   定义的所有 XML 名称都是否有效， [2.3 常用语法构造](https://www.w3.org/TR/2006/REC-xml-20060816/#NT-Name)W3C XML 1.0 建议的部分。  
  
 当此属性设置为`true`，这是默认设置，<xref:System.Xml.XmlException>引发异常，如果 XML 文件中包含非法字符或无效的 XML 名称 （例如，元素名称以数字开头）。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Xml.XmlReaderSettings Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlReaderSettings Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReaderSettings.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As XmlReaderSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlReaderSettings ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Xml.XmlReaderSettings" Usage="xmlReaderSettings.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReaderSettings</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建 <see cref="T:System.Xml.XmlReaderSettings" /> 实例的副本。</summary>
        <returns>克隆的 <see cref="T:System.Xml.XmlReaderSettings" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 克隆<xref:System.Xml.XmlReaderSettings>而不会影响原始对象上的设置可以修改对象。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CloseInput">
      <MemberSignature Language="C#" Value="public bool CloseInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CloseInput" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.CloseInput" />
      <MemberSignature Language="VB.NET" Value="Public Property CloseInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CloseInput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CloseInput : bool with get, set" Usage="System.Xml.XmlReaderSettings.CloseInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示当读取器关闭时，是否应关闭基础流或 <see cref="T:System.IO.TextReader" />。</summary>
        <value>如果当读取器关闭时基础流或 <see cref="T:System.IO.TextReader" /> 也应关闭，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当流时使用此设置或<xref:System.IO.TextReader>传递给<xref:System.Xml.XmlReader.Create%2A>方法。 如果进行自身处理读取器创建一个流，如创建读取器时使用的 URI 或打开外部文档类型定义时，它始终关闭读取器关闭时。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConformanceLevel">
      <MemberSignature Language="C#" Value="public System.Xml.ConformanceLevel ConformanceLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ConformanceLevel ConformanceLevel" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.ConformanceLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ConformanceLevel As ConformanceLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::ConformanceLevel ConformanceLevel { System::Xml::ConformanceLevel get(); void set(System::Xml::ConformanceLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ConformanceLevel : System.Xml.ConformanceLevel with get, set" Usage="System.Xml.XmlReaderSettings.ConformanceLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.ConformanceLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Xml.XmlReader" /> 将遵循的一致性级别。</summary>
        <value>指定一致性级别（XML 读取器将强制该级别）的枚举值之一。 默认值为 <see cref="F:System.Xml.ConformanceLevel.Document" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过创建的 XML 读取器<xref:System.Xml.XmlReader.Create%2A>方法默认情况下满足以下符合性要求：  
  
-   新行和属性值根据 W3C 进行规范化[XML 1.0 建议](https://www.w3.org/TR/2006/REC-xml-20060816/)。  
  
-   自动展开所有实体。  
  
-   即使在读取器不会验证时，总是会添加文档类型定义中声明的默认属性。  
  
-   允许的声明映射到正确的 XML 命名空间 URI 的 XML 前缀。  
  
-   在单个的表示法名称`NotationType`特性声明并`NmTokens`在单个`Enumeration`特性声明是不同的。  
  
 可以使用<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>属性来检查并确保正在读取的流符合格式正确的 XML 1.0 文档或文档片段的规则。 如果数据不相符，<xref:System.Xml.XmlException>引发异常。 默认值是<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>（文档级一致性）。  
  
 三个符合性级别为：  
  
|设置|描述|  
|-------------|-----------------|  
|<xref:System.Xml.ConformanceLevel.Document>|可确保 XML 数据符合格式正确的 XML 1.0 文档的规则。 此检查级别确保任何处理器均可以使用作为正在读取的流[格式正确的 XML 1.0 文档](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-well-formed)。<br /><br /> 读取器检查下列事项：<br /><br /> -顶级项不得包含 XML 声明、 文档类型定义 (DTD)、 元素、 注释、 空格或处理指令以外的任何节点。<br />XML 数据必须具有恰好一个顶级元素节点。|  
|<xref:System.Xml.ConformanceLevel.Fragment>|可确保 XML 数据符合格式正确的 XML 1.0 文档片断的规则。<br /><br /> 此设置接受包含多个根元素的 XML 数据或位于顶级的文本节点。 此检查级别确保任何处理器均可以使用作为正在读取的流[外部已分析的实体](https://www.w3.org/TR/2006/REC-xml-20060816/#wf-entities)。|  
|<xref:System.Xml.ConformanceLevel.Auto>|指定读取器应确定的基于传入数据的一致性检查级别。<br /><br /> 如果 XML 数据包含 DTD 信息，将应用文档一致性检查。<br /><br /> 如果 XML 数据包含下列某一项，将应用片断一致性检查。<br /><br /> 的在根级别文本、 CDATA 或实体引用节点。<br />的在根级别多个元素。<br />的在根级别任何元素。<br /><br /> 如果存在冲突，例如在根级别存在文本节点和 DTD 时，将引发 <xref:System.Xml.XmlException>。<br /><br /> 如果使用 <xref:System.Xml.XmlReader.Create%2A> 方法为现有 <xref:System.Xml.XmlReader> 添加附加功能，可以在包装方案中使用此设置。 在这种情况下，<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>不会添加任何新的一致性检查。 一致性检查留给正在包装的 <xref:System.Xml.XmlReader>。|  
  
> [!NOTE]
>  如果存在 DTD，XML 1.0 建议要求文档级别的一致性。 因此，如果读取器配置为支持<xref:System.Xml.ConformanceLevel.Fragment?displayProperty=nameWithType>，但是 XML 数据包含文档类型定义 (DTD)<xref:System.Xml.XmlException>引发。  
  
 下面是读取器如何处理特定符合性冲突，具体取决于设置<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>属性：  
  
|条件|<xref:System.Xml.ConformanceLevel.Document>|<xref:System.Xml.ConformanceLevel.Fragment>|<xref:System.Xml.ConformanceLevel.Auto>|  
|---------------|---------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------|  
|文本或类型化的值将显示在顶级。|<xref:System.Xml.XmlException> 将引发。|不考虑此设置的冲突。|不考虑此设置的冲突。|  
|多个元素或没有任何元素出现在最高级别。|<xref:System.Xml.XmlException> 将引发。|不考虑此设置的冲突。|不考虑此设置的冲突。|  
|顶级项是空白。|不考虑此设置的冲突。|不考虑此设置的冲突。|不考虑此设置的冲突。|  
|顶级项是 （被识别为文本节点） 的属性。|<xref:System.Xml.XmlException> 将引发。|不考虑此设置的冲突。|不考虑此设置的冲突。|  
|发现多个连续的文本节点。|不考虑此设置的冲突。|不考虑此设置的冲突。|不考虑此设置的冲突。|  
|在相同的局部范围中两次声明相同的命名空间前缀。|<xref:System.Xml.XmlException> 将引发。|<xref:System.Xml.XmlException> 将引发。|<xref:System.Xml.XmlException> 将引发。|  
|在本地作用域中不存在的元素或属性中的命名空间。|<xref:System.Xml.XmlException> 将引发。|<xref:System.Xml.XmlException> 将引发。|<xref:System.Xml.XmlException> 将引发。|  
|数据包含前缀和命名空间不匹配。|<xref:System.Xml.XmlException> 将引发。|<xref:System.Xml.XmlException> 将引发。|<xref:System.Xml.XmlException> 将引发。|  
|`xml:space` 属性包含无效值。|<xref:System.Xml.XmlException> 将引发。|<xref:System.Xml.XmlException> 将引发。|<xref:System.Xml.XmlException> 将引发。|  
|遇到无效的名称。|<xref:System.Xml.XmlException> 将引发。|<xref:System.Xml.XmlException> 将引发。|<xref:System.Xml.XmlException> 将引发。|  
|`xml`前缀不与匹配http://www.w3.org/XML/1998/namespaceURI。|<xref:System.Xml.XmlException> 将引发。|<xref:System.Xml.XmlException> 将引发。|<xref:System.Xml.XmlException> 将引发。|  
  
   
  
## Examples  
 下面的示例创建<xref:System.Xml.XmlReader>对象，它读取 XML 片段。  
  
 [!code-csharp[XmlReader.Create#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#1)]
 [!code-vb[XmlReader.Create#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DtdProcessing">
      <MemberSignature Language="C#" Value="public System.Xml.DtdProcessing DtdProcessing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.DtdProcessing DtdProcessing" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.DtdProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Property DtdProcessing As DtdProcessing" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::DtdProcessing DtdProcessing { System::Xml::DtdProcessing get(); void set(System::Xml::DtdProcessing value); };" />
      <MemberSignature Language="F#" Value="member this.DtdProcessing : System.Xml.DtdProcessing with get, set" Usage="System.Xml.XmlReaderSettings.DtdProcessing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.DtdProcessing</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置确定 DTD 的处理的值。</summary>
        <value>确定 DTD 的处理的枚举值之一。 默认值为 <see cref="F:System.Xml.DtdProcessing.Prohibit" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文档类型定义 (DTD) 验证通过在 W3C 中定义的有效性约束来实现[可扩展标记语言 (XML) 1.0 （第四版） 建议](https://www.w3.org/TR/2006/REC-xml-20060816/)。 Dtd 使用形式语法来描述的结构和语法符合 XML 文档;它们指定的内容和 XML 文档的允许值。  
  
 此属性可以具有下列值之一：  
  
-   <xref:System.Xml.DtdProcessing.Parse?displayProperty=nameWithType> 若要启用 DTD 处理。  
  
-   <xref:System.Xml.DtdProcessing.Prohibit?displayProperty=nameWithType> 若要引发<xref:System.Xml.XmlException>遇到 DTD 时出现异常。  
  
-   <xref:System.Xml.DtdProcessing.Ignore?displayProperty=nameWithType> 若要禁用 DTD 处理而不是警告或异常。  
  
 为针对 DTD 执行验证，<xref:System.Xml.XmlReader> 使用 XML 文档的 DOCTYPE 声明中所定义的 DTD。 DOCTYPE 声明既可以指向内联 DTD，也可以是对外部 DTD 文件的引用。 若要验证对 DTD 的 XML 文件：  
  
-   将 <xref:System.Xml.XmlReaderSettings.DtdProcessing%2A?displayProperty=nameWithType> 属性设置为 `DtdProcessing.Parse.`  
  
-   将 <xref:System.Xml.XmlReaderSettings.ValidationType%2A?displayProperty=nameWithType> 属性设置为 `ValidationType.DTD`。  
  
-   如果 DTD 是存储在要求进行身份验证的网络资源上的外部文件，请将具有必要凭据的 <xref:System.Xml.XmlResolver> 对象传递给 <xref:System.Xml.XmlReader.Create%2A> 方法。  
  
> [!IMPORTANT]
>  如果<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>属性设置为<xref:System.Xml.DtdProcessing.Ignore?displayProperty=nameWithType>，则<xref:System.Xml.XmlReader>不会报告 Dtd。 这意味着 DTD/DOCTYPE 上输出都将丢失。  
  
   
  
## Examples  
 以下示例使用 DTD 文件验证 XML 文件。  
  
 [!code-cpp[XmlReaderSettings.DtdValidate#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.DtdValidate/CPP/XmlReaderSettings.DtdValidate.cpp#1)]
 [!code-csharp[XmlReaderSettings.DtdValidate#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.DtdValidate/CS/validdtd.cs#1)]
 [!code-vb[XmlReaderSettings.DtdValidate#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.DtdValidate/VB/validdtd.vb#1)]  
  
## <a name="input"></a>输入  
 示例使用 `itemDTD.xml` 文件作为输入。  
  
 [!code-xml[XmlReaderSettings.DtdValidate#2](~/samples/snippets/xml/VS_Snippets_Data/XmlReaderSettings.DtdValidate/XML/itemDTD.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreComments">
      <MemberSignature Language="C#" Value="public bool IgnoreComments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreComments" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.IgnoreComments" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreComments As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreComments { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreComments : bool with get, set" Usage="System.Xml.XmlReaderSettings.IgnoreComments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否忽略注释。</summary>
        <value>如果忽略注释，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性设置为`true`可能会导致从读取器返回的多个连续的文本节点。 此值不影响验证。  
  
   
  
## Examples  
 以下命令创建可用于构造去除处理指令、 注释和无关紧要的空白区域的读取器的设置对象。  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreProcessingInstructions">
      <MemberSignature Language="C#" Value="public bool IgnoreProcessingInstructions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreProcessingInstructions" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreProcessingInstructions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreProcessingInstructions { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreProcessingInstructions : bool with get, set" Usage="System.Xml.XmlReaderSettings.IgnoreProcessingInstructions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否忽略处理指令。</summary>
        <value>如果忽略处理指令，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性设置为`true`可能会导致从读取器返回的多个连续的文本节点。 此值不影响验证。  
  
   
  
## Examples  
 以下命令创建可用于构造去除处理指令、 注释和无关紧要的空白区域的读取器的设置对象。  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreWhitespace">
      <MemberSignature Language="C#" Value="public bool IgnoreWhitespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.IgnoreWhitespace" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreWhitespace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreWhitespace { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreWhitespace : bool with get, set" Usage="System.Xml.XmlReaderSettings.IgnoreWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否忽略无关紧要的空白区域。</summary>
        <value>如果忽略空白，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不被视为是有意义的空白包括空格、 制表符和用来分隔的标记为了提高可读性的空白行。 此示例是在元素内容中的空白区域。  
  
 此属性设置不会影响在混合内容模式或的作用域中出现的空白区域中的标记之间的空白区域`xml:space='preserve'`属性。  
  
   
  
## Examples  
 以下命令创建可用于构造去除处理指令、 注释和无关紧要的空白区域的读取器的设置对象。  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LineNumberOffset">
      <MemberSignature Language="C#" Value="public int LineNumberOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LineNumberOffset" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.LineNumberOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property LineNumberOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LineNumberOffset { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.LineNumberOffset : int with get, set" Usage="System.Xml.XmlReaderSettings.LineNumberOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Xml.XmlReader" /> 对象的行号偏移量。</summary>
        <value>行号偏移量。 默认值为 0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>设置确定的点位置<xref:System.Xml.IXmlLineInfo.LineNumber%2A>属性开始计数。 这是更大的文档中嵌入 XML 数据的情况下很有用。 例如，如果您的 XML 数据嵌入在一个更大的文档，并且你的数据开始文档的第 101 行，您可能想要指定读取器开始第 100 行。 因此，如果读取器引发了异常分析 XML 的第一行时，它将报告作为第 101 行，而不是第 1 行的行号。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LinePositionOffset">
      <MemberSignature Language="C#" Value="public int LinePositionOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LinePositionOffset" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.LinePositionOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property LinePositionOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LinePositionOffset { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.LinePositionOffset : int with get, set" Usage="System.Xml.XmlReaderSettings.LinePositionOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Xml.XmlReader" /> 对象的行位置偏移量。</summary>
        <value>行位置偏移量。 默认值为 0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>设置确定的点位置<xref:System.Xml.IXmlLineInfo.LinePosition%2A>属性开始计数。 如果您的 XML 数据嵌入在更大的文档和没有开头的 XML 的新行，这非常有用。 在这种情况下，如果读取器引发了异常分析 XML 时，您希望其返回的行位置相对于主文档，而不仅仅是相对于 XML 片段。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MaxCharactersFromEntities">
      <MemberSignature Language="C#" Value="public long MaxCharactersFromEntities { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxCharactersFromEntities" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.MaxCharactersFromEntities" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxCharactersFromEntities As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxCharactersFromEntities { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxCharactersFromEntities : int64 with get, set" Usage="System.Xml.XmlReaderSettings.MaxCharactersFromEntities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示文档中允许扩展实体产生的最大字符数。</summary>
        <value>扩展实体中允许的最大字符数。 默认值为 0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 零 (0) 值表示的扩展实体产生的字符数没有限制。 一个非零值指定的最大可以扩展实体产生的字符数。  
  
 如果读取器读取的文档所包含的实体扩展的大小将超出此属性，将尝试<xref:System.Xml.XmlException>将引发。  
  
 此属性允许您以缓解拒绝服务攻击，攻击者将提交尝试超过内存限制通过扩展实体的 XML 文档。 通过限制从扩展实体产生的字符，可以检测攻击和可靠地进行恢复。  
  
   
  
## Examples  
 下面的代码设置此属性，再然后尝试包含扩展的大小大于设置限制到的实体的文档进行分析。 在实际方案中，您将此限制设置为足够大，可用于尚未处理有效文档值足够小，以限制来自恶意文档的威胁。  
  
```csharp  
string markup =  
@"<!DOCTYPE Root [  
  <!ENTITY anEntity ""Expands to more than 30 characters"">  
  <!ELEMENT Root (#PCDATA)>  
]>  
<Root>Content &anEntity;</Root>";  
  
XmlReaderSettings settings = new XmlReaderSettings();  
settings.DtdProcessing = DtdProcessing.Parse;  
settings.ValidationType = ValidationType.DTD;  
settings.MaxCharactersFromEntities = 30;  
  
try  
{  
    XmlReader reader = XmlReader.Create(new StringReader(markup), settings);  
    while (reader.Read()) { }  
}  
catch (XmlException ex)  
{  
    Console.WriteLine(ex.Message);  
}  
```  
  
```vb  
Dim markup As String = _  
    "<!DOCTYPE Root [" + Environment.NewLine + _  
    "  <!ENTITY anEntity ""Expands to more than 30 characters"">" + Environment.NewLine + _  
    "  <!ELEMENT Root (#PCDATA)>" + Environment.NewLine + _  
    "]>" + Environment.NewLine + _  
    "<Root>Content &anEntity;</Root>"  
  
Dim settings As XmlReaderSettings = New XmlReaderSettings()  
settings.DtdProcessing = DtdProcessing.Parse;  
settings.ValidationType = ValidationType.DTD  
settings.MaxCharactersFromEntities = 30  
  
Try  
    Dim reader As XmlReader = XmlReader.Create(New StringReader(markup), settings)  
    While (reader.Read())  
    End While  
Catch ex As XmlException  
    Console.WriteLine(ex.Message)  
End Try  
```  
  
 该示例产生下面的输出：  
  
```  
There is an error in XML document (MaxCharactersFromEntities, ).  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxCharactersInDocument">
      <MemberSignature Language="C#" Value="public long MaxCharactersInDocument { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxCharactersInDocument" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.MaxCharactersInDocument" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxCharactersInDocument As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxCharactersInDocument { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxCharactersInDocument : int64 with get, set" Usage="System.Xml.XmlReaderSettings.MaxCharactersInDocument" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指明 XML 文档中所允许的最大字符数。 零 (0) 值表示对 XML 文档的大小没有限制。 非零值指定最大大小（以字符数计）。</summary>
        <value>XML 文档中所允许的最大字符数。 默认值为 0。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 零 (0) 值表示已分析文档中的字符数没有限制。 一个非零值指定的最大可分析的字符数。  
  
 文档的最大字符计数包括生成扩展实体中的字符计数。  
  
 如果读取器读取的文档大小超过了此属性，将尝试<xref:System.Xml.XmlException>将引发。  
  
 此属性允许您以缓解拒绝服务攻击，攻击者将提交极大 XML 文档。 通过限制文档的大小，可以检测攻击和可靠地进行恢复。  
  
   
  
## Examples  
 下面的代码设置此属性，然后尝试分析文档大小超过限制。 在实际方案中，您将此限制设置为足够大，可用于尚未处理有效文档值足够小，以限制来自恶意文档的威胁。  
  
```csharp  
string markup = "<Root>Content</Root>";  
  
XmlReaderSettings settings = new XmlReaderSettings();  
settings.MaxCharactersInDocument = 10;  
  
try  
{  
    XmlReader reader = XmlReader.Create(new StringReader(markup), settings);  
    while (reader.Read()) { }  
}  
catch (XmlException ex)  
{  
    Console.WriteLine(ex.Message);  
}  
```  
  
```vb  
Dim markup As String = "<Root>Content</Root>"  
  
Dim settings As XmlReaderSettings = New XmlReaderSettings()  
settings.MaxCharactersInDocument = 10  
  
Try  
    Dim reader As XmlReader = XmlReader.Create(New StringReader(markup), settings)  
    While (reader.Read())  
    End While  
Catch ex As XmlException  
    Console.WriteLine(ex.Message)  
End Try  
```  
  
 此代码生成以下输出：  
  
```  
There is an error in XML document (MaxCharactersInDocument, ).  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNameTable NameTable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); void set(System::Xml::XmlNameTable ^ value); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable with get, set" Usage="System.Xml.XmlReaderSettings.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于原子化字符串比较的 <see cref="T:System.Xml.XmlNameTable" />。</summary>
        <value><see cref="T:System.Xml.XmlNameTable" />，它存储使用此 <see cref="T:System.Xml.XmlReader" /> 对象创建的所有 <see cref="T:System.Xml.XmlReaderSettings" /> 实例使用的所有原子化字符串。  
  
默认值为 <see langword="null" />。 如果该值为<see langword="null" />，创建的 <see cref="T:System.Xml.XmlReader" /> 实例将使用新的空 <see cref="T:System.Xml.NameTable" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将此属性设置为<xref:System.Xml.XmlNameTable>如果你想要共享的常见名称表在所有实例创建<xref:System.Xml.XmlReader>实例。  
  
> [!NOTE]
>  
  <xref:System.Xml.NameTable> 类不是线程安全的。 因此它不能共享之间<xref:System.Xml.XmlReader>同时运行在不同的线程中的对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProhibitDtd">
      <MemberSignature Language="C#" Value="public bool ProhibitDtd { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ProhibitDtd" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.ProhibitDtd" />
      <MemberSignature Language="VB.NET" Value="Public Property ProhibitDtd As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ProhibitDtd { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ProhibitDtd : bool with get, set" Usage="System.Xml.XmlReaderSettings.ProhibitDtd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Use XmlReaderSettings.DtdProcessing property instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否禁用文档类型定义 (DTD) 处理。 此属性已过时。 请改用 <see cref="P:System.Xml.XmlTextReader.DtdProcessing" />。</summary>
        <value>如果禁用 DTD 处理，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果设置为`true`，则<xref:System.Xml.XmlReader>引发<xref:System.Xml.XmlException>时遇到任何 DTD 内容。 如果您担心拒绝服务问题或您在处理不可信的源，则不要启用 DTD 处理。  
  
 如果启用了 DTD 处理，可以使用 <xref:System.Xml.XmlSecureResolver> 限制 <xref:System.Xml.XmlReader> 可以访问的资源。 还可以设计应用程序以使 XML 处理受内存和时间的约束。 例如，在 ASP.NET 应用程序中配置超时限制。  
  
 此属性已过时。 请改用 <xref:System.Xml.XmlTextReader.DtdProcessing%2A>。 如果已设置<xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A>为其默认值`true`设置<xref:System.Xml.XmlTextReader.DtdProcessing%2A>到`Prohibit`。 如果已设置<xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A>到`false`设置<xref:System.Xml.XmlTextReader.DtdProcessing%2A>到`Parse`。  
  
   
  
## Examples  
 下面的示例验证使用 DTD 的数据。  
  
 [!code-cpp[XmlReaderSettings.DtdValidate#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.DtdValidate/CPP/XmlReaderSettings.DtdValidate.cpp#1)]
 [!code-csharp[XmlReaderSettings.DtdValidate#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.DtdValidate/CS/validdtd.cs#1)]
 [!code-vb[XmlReaderSettings.DtdValidate#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.DtdValidate/VB/validdtd.vb#1)]  
  
 该示例使用 itemDTD.xml 文件作为输入。  
  
 [!code-xml[XmlReaderSettings.DtdValidate#2](~/samples/snippets/xml/VS_Snippets_Data/XmlReaderSettings.DtdValidate/XML/itemDTD.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReaderSettings.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; unit" Usage="xmlReaderSettings.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将设置类的成员重置为各自的默认值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表显示的实例的初始属性值<xref:System.Xml.XmlReaderSettings>。  
  
|属性|初始值|  
|--------------|-------------------|  
|<xref:System.Xml.XmlReaderSettings.Async%2A>|`false`。|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|`true`。|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document>。|  
|<xref:System.Xml.XmlReaderSettings.IgnoreComments%2A>|`false`。|  
|<xref:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions%2A>|`false`。|  
|<xref:System.Xml.XmlReaderSettings.IgnoreWhitespace%2A>|`false`。|  
|<xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>|0.|  
|<xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>|0.|  
|<xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A>|（没有扩展实体产生的字符数没有限制） 为 0。|  
|<xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A>|（在 XML 文档的大小没有任何限制） 为 0。|  
|<xref:System.Xml.XmlReaderSettings.NameTable%2A>|`null`。|  
|<xref:System.Xml.XmlTextReader.DtdProcessing%2A>|<xref:System.Xml.DtdProcessing.Prohibit>|  
|<xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A>|`true`。 此属性已过时。 请改用 <xref:System.Xml.XmlTextReader.DtdProcessing%2A>。 如果已设置<xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A>为其默认值`true`设置<xref:System.Xml.XmlTextReader.DtdProcessing%2A>到`Prohibit`。 如果已设置<xref:System.Xml.XmlReaderSettings.ProhibitDtd%2A>到`false`设置<xref:System.Xml.XmlTextReader.DtdProcessing%2A>到`Parse`。|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|一个空 <xref:System.Xml.Schema.XmlSchemaSet> 对象。|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints>。|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A>|<xref:System.Xml.ValidationType.None>。|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|一个新 <xref:System.Xml.XmlUrlResolver> 对象。|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Schemas">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchemaSet Schemas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.XmlSchemaSet Schemas" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.Schemas" />
      <MemberSignature Language="VB.NET" Value="Public Property Schemas As XmlSchemaSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Schema::XmlSchemaSet ^ Schemas { System::Xml::Schema::XmlSchemaSet ^ get(); void set(System::Xml::Schema::XmlSchemaSet ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Schemas : System.Xml.Schema.XmlSchemaSet with get, set" Usage="System.Xml.XmlReaderSettings.Schemas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在执行架构验证时使用的 <see cref="T:System.Xml.Schema.XmlSchemaSet" />。</summary>
        <value>当执行架构验证时使用的 <see cref="T:System.Xml.Schema.XmlSchemaSet" />。 默认为空的 <see cref="T:System.Xml.Schema.XmlSchemaSet" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> -   不要使用来自未知或不受信任的源或位置的架构。 执行此操作将影响你的代码的安全性。  
> -   XML 架构 （包括内联架构） 是本质上是容易受到拒绝服务攻击;不接受不受信任的方案中。  
> -   架构验证错误消息和异常可能会公开的内容模型的架构文件的 URI 路径的敏感信息。 请注意不公开此信息向不受信任调用方。  
> -   有关其他信息，请参阅"安全注意事项"部分。  
  
 <xref:System.Xml.Schema.XmlSchemaSet>类仅支持 XML 架构定义语言 (XSD) 架构。 <xref:System.Xml.XmlReader> 创建的实例<xref:System.Xml.XmlReader.Create%2A>方法不能配置为启用 XML 数据缩减 (XDR) 架构验证。  
  
## <a name="security-considerations"></a>安全注意事项  
  
-   不要使用来自未知或不受信任的源架构。 执行此操作将影响你的代码的安全性。 <xref:System.Xml.XmlUrlResolver>类用于解析外部架构默认情况下。 若要禁用解析导入、 包括和重新定义架构的元素，设置<xref:System.Xml.Schema.XmlSchemaSet.XmlResolver%2A?displayProperty=nameWithType>属性设置为`null`。  
  
-   由于使用而引发的异常<xref:System.Xml.Schema.XmlSchemaSet>类，如<xref:System.Xml.Schema.XmlSchemaException>类可能包含不应在不受信任的方案中公开的敏感信息。 例如，<xref:System.Xml.Schema.XmlSchemaException.SourceUri%2A>属性的<xref:System.Xml.Schema.XmlSchemaException>返回导致异常的架构文件的 URI 路径。 <xref:System.Xml.Schema.XmlSchemaException.SourceUri%2A>不应在不受信任的情况下公开属性。 应正确处理异常，以便在不受信任的情况下不公开此敏感信息。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlReaderSettings>对象和<xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType>方法以将架构与 XML 文档相关联。 该架构添加到<xref:System.Xml.XmlReaderSettings.Schemas%2A>属性的<xref:System.Xml.XmlReaderSettings>对象。 值<xref:System.Xml.XmlReaderSettings.Schemas%2A>属性是<xref:System.Xml.Schema.XmlSchemaSet>对象。 架构用于验证 XML 文档符合架构内容模型。 由处理架构验证错误和警告<xref:System.Xml.XmlReaderSettings.ValidationEventHandler>中定义<xref:System.Xml.XmlReaderSettings>对象。  
  
 [!code-cpp[XmlSchemaSetOverall Example#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlSchemaSetOverall Example/CPP/xmlschemasetexample.cpp#1)]
 [!code-csharp[XmlSchemaSetOverall Example#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlSchemaSetOverall Example/CS/xmlschemasetexample.cs#1)]
 [!code-vb[XmlSchemaSetOverall Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlSchemaSetOverall Example/VB/xmlschemasetexample.vb#1)]  
  
 该示例使用 books.xml 文件作为输入。  
  
 [!code-xml[XmlSchemaSetOverall Example#2](~/samples/snippets/xml/VS_Snippets_Data/XmlSchemaSetOverall Example/XML/books.xml#2)]  
  
 该示例使用 books.xsd 文件作为输入。  
  
 [!code-xml[XmlSchemaSetOverall Example#3](~/samples/snippets/xml/VS_Snippets_Data/XmlSchemaSetOverall Example/XML/books.xsd#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidationEventHandler">
      <MemberSignature Language="C#" Value="public event System.Xml.Schema.ValidationEventHandler ValidationEventHandler;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.Schema.ValidationEventHandler ValidationEventHandler" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlReaderSettings.ValidationEventHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::Schema::ValidationEventHandler ^ ValidationEventHandler;" />
      <MemberSignature Language="F#" Value="member this.ValidationEventHandler : System.Xml.Schema.ValidationEventHandler " Usage="member this.ValidationEventHandler : System.Xml.Schema.ValidationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.ValidationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在读取器遇到验证错误时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这些事件发生时读取 XML 实例文档，如果<xref:System.Xml.XmlReaderSettings.ValidationType%2A>设置为<xref:System.Xml.ValidationType.DTD>或<xref:System.Xml.ValidationType.Schema>。 如果<xref:System.Xml.Schema.XmlSchemaValidationFlags.ReportValidationWarnings>上启用了设置<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>时遇到的所有验证警告时，也可能发生这些事件的属性。  
  
 如果读取器配置为进行验证，并且没有验证事件处理程序已设置，<xref:System.Xml.Schema.XmlSchemaValidationException>所有验证错误时都引发。 (验证警告不会导致<xref:System.Xml.Schema.XmlSchemaValidationException>引发)。  
  
> [!IMPORTANT]
>  验证错误消息可能会公开敏感内容模型的信息。 使用处理验证错误和警告消息<xref:System.Xml.Schema.ValidationEventHandler>委派，或作为公开<xref:System.Xml.Schema.XmlSchemaValidationException>如果没有事件处理程序提供给<xref:System.Xml.XmlReaderSettings>对象 (验证警告不会导致<xref:System.Xml.Schema.XmlSchemaValidationException>引发)。 此内容模型的信息不应在不受信任的情况下公开。 验证警告消息所抑制的默认值，并可以通过设置报告<xref:System.Xml.Schema.XmlSchemaValidationFlags.ReportValidationWarnings>标志。  
>   
>  <xref:System.Xml.Schema.XmlSchemaException.SourceUri%2A>属性的<xref:System.Xml.Schema.XmlSchemaValidationException>返回导致异常的架构文件的 URI 路径。 <xref:System.Xml.Schema.XmlSchemaException.SourceUri%2A>不应在不受信任的情况下公开属性。  
  
   
  
## Examples  
 下面的示例显示了设置，以指定要创建一个读取器来验证使用内联架构和显示验证警告。 验证事件处理程序使用<xref:System.Xml.Schema.XmlSeverityType>枚举来区分警告和错误。  
  
 [!code-csharp[XmlReaderSettings.IgnoreInlineSchema#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.IgnoreInlineSchema/CS/factory_rdr_cctor.cs#1)]
 [!code-vb[XmlReaderSettings.IgnoreInlineSchema#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.IgnoreInlineSchema/VB/factory_rdr_cctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidationFlags">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchemaValidationFlags ValidationFlags { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.Schema.XmlSchemaValidationFlags ValidationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.ValidationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidationFlags As XmlSchemaValidationFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Schema::XmlSchemaValidationFlags ValidationFlags { System::Xml::Schema::XmlSchemaValidationFlags get(); void set(System::Xml::Schema::XmlSchemaValidationFlags value); };" />
      <MemberSignature Language="F#" Value="member this.ValidationFlags : System.Xml.Schema.XmlSchemaValidationFlags with get, set" Usage="System.Xml.XmlReaderSettings.ValidationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaValidationFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个指示架构验证设置的值。 此设置应用于验证架构的 <see cref="T:System.Xml.XmlReader" /> 对象（<see cref="P:System.Xml.XmlReaderSettings.ValidationType" /> 属性设置为 <see langword="ValidationType.Schema" />）。</summary>
        <value>指定验证选项的枚举值的按位组合。 <see cref="F:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints" /> 和 <see cref="F:System.Xml.Schema.XmlSchemaValidationFlags.AllowXmlAttributes" /> 默认情况下启用。 <see cref="F:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema" />、<see cref="F:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation" /> 和 <see cref="F:System.Xml.Schema.XmlSchemaValidationFlags.ReportValidationWarnings" /> 默认情况下禁用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  默认情况下不设置 <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> 对象的 <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> 和 <xref:System.Xml.XmlReaderSettings> 验证标志。 设置了这些标志后，<xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象的 <xref:System.Xml.XmlReaderSettings> 用于在 <xref:System.Xml.XmlReader> 中解析实例文档中遇到的架构位置。 如果<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>对象是`null`，则不解析架构位置即使<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>和<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation>设置验证标志。  
>   
>  在验证过程中添加的架构会添加新类型，并且可能更改被验证的文档的验证结果。 因此，只应从可信的源解析外部架构。  
>   
>  禁用<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints>时验证不受信任的大型 XML 文档中实现高可用性方案中，针对具有标识约束的架构文档的很大程度上，建议使用标志 （默认情况下启用）。  
  
   
  
## Examples  
 下面的示例验证根据内联 XML 架构的 XML 文件，从而<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>设置。 XML 读取器配置为显示验证警告，sp 您还看到预期的警告上的根元素。  
  
 [!code-csharp[XmlReaderSettings.IgnoreInlineSchema#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.IgnoreInlineSchema/CS/factory_rdr_cctor.cs#1)]
 [!code-vb[XmlReaderSettings.IgnoreInlineSchema#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.IgnoreInlineSchema/VB/factory_rdr_cctor.vb#1)]  
  
## <a name="input"></a>输入  
 示例使用 inlineSchema.xml 文件作为输入。  
  
 [!code-xml[XmlReaderSettings.IgnoreInlineSchema#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReaderSettings.IgnoreInlineSchema/XML/inlineSchema.xml#3)]  
  
## <a name="output"></a>输出  
 警告： 找不到匹配的架构。 未进行任何验证。 找不到元素“root”的架构信息。  
  
 验证错误： 元素 xsdheadcount: Headcount 具有无效子元素 division。 应包含“ID”。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidationType">
      <MemberSignature Language="C#" Value="public System.Xml.ValidationType ValidationType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ValidationType ValidationType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.ValidationType" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidationType As ValidationType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::ValidationType ValidationType { System::Xml::ValidationType get(); void set(System::Xml::ValidationType value); };" />
      <MemberSignature Language="F#" Value="member this.ValidationType : System.Xml.ValidationType with get, set" Usage="System.Xml.XmlReaderSettings.ValidationType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.ValidationType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示 <see cref="T:System.Xml.XmlReader" /> 在读取时是否执行验证或类型分配。</summary>
        <value><see cref="T:System.Xml.ValidationType" /> 的一个值指示 XmlReader 是否将呈现有效或当读取的时执行验证或类型分配。 默认值为 <see langword="ValidationType.None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表描述了<xref:System.Xml.ValidationType>值。  
  
> [!NOTE]
>  <xref:System.Xml.ValidationType.Auto>和<xref:System.Xml.ValidationType.XDR>枚举的值为.NET Framework 2.0 版中已过时。  
  
|ValidationType|描述|  
|--------------------|-----------------|  
|`DTD`|使用文档类型定义 (DTD) 执行验证。 **注意：**<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>属性也必须设置为<xref:System.Xml.DtdProcessing.Parse>。|  
|`None`|<xref:System.Xml.XmlReader>不会验证数据，或执行任何类型赋值。|  
|`Schema`|使用 XML 架构定义语言 (XSD) 架构执行验证和类型分配。 读取器访问使用以下 XML 架构：<br /><br /> -使用<xref:System.Xml.XmlReaderSettings.Schemas%2A>属性来访问<xref:System.Xml.Schema.XmlSchemaSet>与此读取器关联的对象。<br />-使用 XML 实例文档中包含的内联架构。 (<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>必须启用选项。)<br />-使用指定的架构位置提示的 XML 架构 (`xsi:schemaLocation`或`xsi:noNamespaceSchemaLocation`属性) 在 XML 实例文档中找到。 (<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation>必须启用选项。)|  
  
   
  
## Examples  
 下面的示例验证使用存储在架构<xref:System.Xml.Schema.XmlSchemaSet>。  
  
 [!code-cpp[XmlReader_Validate_SchemaSet#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReader_Validate_SchemaSet/CPP/XmlReader_Validate_SchemaSet.cpp#1)]
 [!code-csharp[XmlReader_Validate_SchemaSet#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Validate_SchemaSet/CS/validschemaset.cs#1)]
 [!code-vb[XmlReader_Validate_SchemaSet#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Validate_SchemaSet/VB/validschemaset.vb#1)]  
  
 该示例使用以下输入的文件：  
  
 `booksSchemaFail.xml`  
  
 [!code-xml[XmlReader_Validate_SchemaSet#2](~/samples/snippets/xml/VS_Snippets_Data/XmlReader_Validate_SchemaSet/XML/booksschemafail.xml#2)]  
  
 `books.xsd`  
  
 [!code-xml[XmlReader_Validate_SchemaSet#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader_Validate_SchemaSet/XML/books.xsd#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
        <altmember cref="T:System.Xml.Schema.XmlSchemaValidationFlags" />
      </Docs>
    </Member>
    <Member MemberName="XmlResolver">
      <MemberSignature Language="C#" Value="public System.Xml.XmlResolver XmlResolver { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlResolver XmlResolver" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReaderSettings.XmlResolver" />
      <MemberSignature Language="VB.NET" Value="Public Property XmlResolver As XmlResolver" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlResolver ^ XmlResolver {  void set(System::Xml::XmlResolver ^ value); };" />
      <MemberSignature Language="F#" Value="member this.XmlResolver : System.Xml.XmlResolver" Usage="System.Xml.XmlReaderSettings.XmlResolver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>设置用来访问外部文档的 <see cref="T:System.Xml.XmlResolver" />。</summary>
        <value>用来访问外部文档的 <see cref="T:System.Xml.XmlResolver" />。 如果设置为 <see langword="null" />，当 <see cref="T:System.Xml.XmlException" /> 试图访问外部资源时，将引发 <see cref="T:System.Xml.XmlReader" />。 默认值为没有凭据的新 <see cref="T:System.Xml.XmlUrlResolver" />。  从.NET Framework 4.5.2 开始，此设置的默认值为<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlResolver>用于查找和打开 XML 实例文档，或找到并打开 XML 实例文档引用的任何外部资源。 这可能包括实体、 DTD 或架构。 <xref:System.Xml.XmlResolver.Credentials%2A?displayProperty=nameWithType>属性可用于指定所需的网络身份验证的任何凭据。  
  
> [!IMPORTANT]
>  因为<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>可以包含敏感信息，如用户凭据，应当小心缓存时<xref:System.Xml.XmlReaderSettings>对象，或传递时<xref:System.Xml.XmlReaderSettings>到另一个对象从一个组件。  
>   
>  <xref:System.Xml.XmlSecureResolver>可用于访问外部文档。 <xref:System.Xml.XmlSecureResolver>类可帮助保护的另一个实现<xref:System.Xml.XmlResolver>通过包装<xref:System.Xml.XmlResolver>对象和限制的资源的基础<xref:System.Xml.XmlResolver>有权访问。  
>   
>  默认情况下不设置 <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> 对象的 <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> 和 <xref:System.Xml.XmlReaderSettings> 验证标志。 设置了这些标志后，<xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象的 <xref:System.Xml.XmlReaderSettings> 用于在 <xref:System.Xml.XmlReader> 中解析实例文档中遇到的架构位置。 如果<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>对象是`null`，则不解析架构位置即使<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>和<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation>设置验证标志。  
>   
>  在验证过程中添加的架构会添加新类型，并且可能更改被验证的文档的验证结果。 因此，只应从可信的源解析外部架构。  
  
   
  
## Examples  
 下面的示例创建<xref:System.Xml.XmlReader>，它使用<xref:System.Xml.XmlSecureResolver>具有默认凭据。  
  
 [!code-csharp[XmlReader.Create#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#10)]
 [!code-vb[XmlReader.Create#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlReader.Create(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>