<Type Name="XmlTextWriter" FullName="System.Xml.XmlTextWriter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5e069a59896777c40f8f8def9c7e997570500cb1" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061552" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlTextWriter : System.Xml.XmlWriter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlTextWriter extends System.Xml.XmlWriter" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlTextWriter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlTextWriter&#xA;Inherits XmlWriter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlTextWriter : System::Xml::XmlWriter" />
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlWriter</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示提供快速、非缓存、只进方法的写入器，该方法生成包含 XML 数据（这些数据符合 W3C 可扩展标记语言 (XML) 1.0 和“XML 命名空间”建议）的流或文件。  
  
 从 .NET Framework 2.0 开始，建议改用 <see cref="T:System.Xml.XmlWriter" /> 类。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此类实现<xref:System.Xml.XmlWriter>类。  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 `XmlTextWriter` 维护对应的当前元素堆栈中定义的所有命名空间的命名空间堆栈。 使用`XmlTextWriter`可以手动声明命名空间。  
  
```csharp  
w.WriteStartElement("root");  
w.WriteAttributeString("xmlns", "x", null, "urn:1");  
 w.WriteStartElement("item","urn:1");  
 w.WriteEndElement();  
 w.WriteStartElement("item","urn:1");  
 w.WriteEndElement();  
w.WriteEndElement();  
```  
  
 上面的 C# 代码生成以下输出。 `XmlTextWriter` 提升到要避免使其重复上两个子元素的根元素的命名空间声明。 子元素选取从命名空间声明的前缀。  
  
```xml  
<root xmlns:x="urn:1">  
 <x:item/>  
 <x:item/>  
</x:root>  
```  
  
 `XmlTextWriter` 此外允许你重写当前命名空间声明。 在下面的示例中，命名空间 URI"123"已由"abc"要生成的 XML 元素`<x:node xmlns:x="abc"/>`。  
  
```csharp  
w.WriteStartElement("x","node","123");  
w.WriteAttributeString("xmlns","x",null,"abc");  
```  
  
 通过使用需要作为自变量的前缀的写入方法还可以指定的前缀，以使用。 在下面的示例中，两个不同的前缀映射到相同的命名空间 URI 以产生的 XML 文本`<x:root xmlns:x="urn:1"><y:item xmlns:y="urn:1"/></x:root>`。  
  
```csharp  
XmlTextWriter w = new XmlTextWriter(Console.Out);  
w.WriteStartElement("x","root","urn:1");  
 w.WriteStartElement("y","item","urn:1");  
 w.WriteEndElement();  
w.WriteEndElement();  
w.Close();  
```  
  
 如果有多个命名空间声明将不同的前缀映射到相同的命名空间 URI，`XmlTextWriter`向后遍历的命名空间声明堆栈并选取最近一个命名空间。  
  
```csharp  
XmlTextWriter w = new XmlTextWriter(Console.Out);  
w.Formatting = Formatting.Indented;  
w.WriteStartElement("x","root","urn:1");  
w.WriteStartElement("y","item","urn:1");  
w.WriteAttributeString("attr","urn:1","123");  
w.WriteEndElement();  
w.WriteEndElement();  
w.Close();  
```  
  
 在上面的 C# 示例，因为`WriteAttributeString`调用未指定前缀，编写器使用推送到命名空间堆栈上的最后一个前缀，并生成下面的 XML:  
  
```xml  
<x:root xmlns:x="urn:1">  
 <y:item y:attr="123" xmlns:y="urn:1" />  
</x:root>  
```  
  
 如果发生命名空间冲突，`XmlTextWriter`解析它们通过生成的备用前缀。 例如，如果属性和元素具有相同前缀但不同的命名空间，`XmlWriter`生成的属性的备用前缀。 生成的前缀命名`n{i}`其中`i`是从 1 开始的数字。 编号重置为 1。 对于每个元素。  
  
 命名空间 URI 与关联的属性必须具有的前缀 （默认值特性不适用于命名空间）。 这符合 XML 建议中的 W3C 命名空间的第 5.2 节。 如果属性引用的命名空间 URI，但未指定前缀，则编写器将生成该属性的前缀。  
  
 当编写空元素，额外的空间之间添加标记名称和结束标记，例如`<item />`。 这提供了与较旧的浏览器兼容性。  
  
 当`String`作为方法参数，使用`null`和`String.Empty`是等效的。 `String.Empty` 遵循 W3C 规则。  
  
 若要编写强类型化的数据，使用<xref:System.Xml.XmlConvert>类将数据类型转换为字符串。 例如，下面的 C# 代码将转换中的数据`Double`到`String`编写元素和`<price>19.95</price>`。  
  
```csharp  
Double price = 19.95;  
writer.WriteElementString("price", XmlConvert.ToString(price));  
```  
  
 `XmlTextWriter` 不会检查以下：  
  
-   属性和元素名称中的无效字符。  
  
-   不符合指定的编码的 Unicode 字符。 如果指定的编码，不能容纳的 Unicode 字符`XmlTextWriter`未转义的 Unicode 字符到字符实体。  
  
-   重复的属性。  
  
-   DOCTYPE 公共标识符或系统标识符中的字符。  
  
## <a name="security-considerations"></a>安全注意事项  
 以下各项是需要时使用，请考虑事项<xref:System.Xml.XmlTextWriter>类。  
  
-   引发的异常<xref:System.Xml.XmlTextWriter>可能会泄漏你不希望的路径信息冒泡由应用程序。 应用程序必须捕获异常并进行相应的处理。  
  
-   在将 <xref:System.Xml.XmlTextWriter> 传递给另一个应用程序时，基础流会公开给该应用程序。 如果需要将 <xref:System.Xml.XmlTextWriter> 传递给不完全可信的应用程序，应使用通过 <xref:System.Xml.XmlWriter> 方法创建的 <xref:System.Xml.XmlWriter.Create%2A> 对象。  
  
-   <xref:System.Xml.XmlTextWriter>不会验证传递给任何数据<xref:System.Xml.XmlTextWriter.WriteDocType%2A>或<xref:System.Xml.XmlTextWriter.WriteRaw%2A>方法。 你不应将任意数据传递给这些方法。  
  
-   如果更改默认设置，则不能保证生成的输出是格式良好的 XML 数据。  
  
-   不接受支持组件，如<xref:System.Text.Encoding>中不受信任的源对象。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建 <see langword="XmlTextWriter" /> 类的实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextWriter (System.IO.TextWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (w As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextWriter(System::IO::TextWriter ^ w);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="w" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="w">要向其中进行写入的 <see langword="TextWriter" />。 假定 <see langword="TextWriter" /> 已设置为正确的编码方式。</param>
        <summary>使用指定的 <see cref="T:System.IO.TextWriter" /> 创建 <see langword="XmlTextWriter" /> 类的实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextWriter (System.IO.Stream w, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream w, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextWriter(System::IO::Stream ^ w, System::Text::Encoding ^ encoding);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="w" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="w">要对其写入的流。</param>
        <param name="encoding">要生成的编码。 如果编码方式为 <see langword="null" />，则它以 UTF-8 的形式写出流并忽略 <see langword="ProcessingInstruction" /> 中的编码特性。</param>
        <summary>使用指定的流和编码方式创建 <see langword="XmlTextWriter" /> 类的实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该编码方式不受支持或无法写入流。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="w" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextWriter (string filename, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string filename, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.#ctor(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextWriter(System::String ^ filename, System::Text::Encoding ^ encoding);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="filename">要写入的文件名。 如果该文件存在，它将截断该文件并用新内容将其覆盖。</param>
        <param name="encoding">要生成的编码。 如果编码方式为 <see langword="null" />，它将以 UTF-8 的形式写出该文件，并忽略 <see langword="ProcessingInstruction" /> 中的编码特性。</param>
        <summary>使用指定的文件创建 <see cref="T:System.Xml.XmlTextWriter" /> 类的实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">编码方式不受支持；文件名为空；仅包含空格，或者包含一个或多个无效字符。</exception>
        <exception cref="T:System.UnauthorizedAccessException">拒绝访问。</exception>
        <exception cref="T:System.ArgumentNullException">文件名为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">未找到要写入的目录。</exception>
        <exception cref="T:System.IO.IOException">文件名中包含不正确或无效的文件名、目录名或卷标语法。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextWriter.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取基础流对象。</summary>
        <value>
          <see langword="XmlTextWriter" /> 正在向其写入的流；如果 <see langword="null" /> 是使用不从 <see cref="T:System.IO.TextWriter" /> 类继承的 <see cref="T:System.IO.StreamWriter" /> 构造的，则为 <see langword="XmlTextWriter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 如果编写器已构造的使用`TextWriter`、 派生自`StreamWriter`类，此属性等效于<xref:System.IO.StreamWriter.BaseStream%2A?displayProperty=nameWithType>属性。 如果编写器已构造的使用<xref:System.IO.Stream>，此属性返回`Stream`传递到构造函数。 如果已使用的文件名称构造编写器，此属性返回`Stream`表示该文件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭此流和基础流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 自动关闭任何元素或属性保持打开状态。  
  
 此方法不引发任何异常。  
  
   
  
## Examples  
 下面的示例将 XML 片段。  
  
 [!code-cpp[Classic WebData XmlTextWriter.Formatting Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.Formatting Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.Formatting Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.Formatting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.Formatting Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.Formatting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将缓冲区中的所有内容刷新到基础流，并同时刷新基础流。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 这称为而不是<xref:System.Xml.XmlTextWriter.Close%2A>如果想要写入基础流但不丢失仍在缓冲区中。  
  
   
  
## Examples  
 下面的示例将写出两个 XML 片段。  
  
 [!code-cpp[XmlTextWriter.Flush#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextWriter.Flush/CPP/write2docs.cpp#1)]
 [!code-csharp[XmlTextWriter.Flush#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextWriter.Flush/CS/write2docs.cs#1)]
 [!code-vb[XmlTextWriter.Flush#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextWriter.Flush/VB/write2docs.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Formatting">
      <MemberSignature Language="C#" Value="public System.Xml.Formatting Formatting { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.Formatting Formatting" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextWriter.Formatting" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatting As Formatting" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Formatting Formatting { System::Xml::Formatting get(); void set(System::Xml::Formatting value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Formatting</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示如何对输出进行格式设置。</summary>
        <value>
          <see cref="T:System.Xml.Formatting" /> 值之一。 默认值为 <see langword="Formatting.None" />（无特殊格式）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 如果`Indented`选项设置、 子元素缩进使用<xref:System.Xml.XmlTextWriter.Indentation%2A>和<xref:System.Xml.XmlTextWriter.IndentChar%2A>属性。 仅元素内容将缩进。 下面的 C# 代码写出包括混合的内容的 HTML 元素：  
  
```csharp  
XmlTextWriter w = new XmlTextWriter(Console.Out);   
 w.Formatting = Formatting.Indented;   
 w.WriteStartElement("ol");   
 w.WriteStartElement("li");   
 w.WriteString("The big "); // This means "li" now has a mixed content model.  
 w.WriteElementString("b", "E");   
 w.WriteElementString("i", "lephant");   
 w.WriteString(" walks slowly.");   
 w.WriteEndElement();   
 w.WriteEndElement();  
```  
  
 上面的代码生成以下输出：  
  
```xml  
<ol>   
  <li>The big <b>E</b><i>lephant</i> walks slowly.</li>   
</ol>  
```  
  
 这在 HTML 中查看时不出现空白粗体和斜体元素之间。 事实上，在此示例中，如果这些元素之间添加缩进"象"一词将是不正确地断开。  
  
> [!NOTE]
>  写入内容，不包括任何文本`String.Empty`将该元素放入混合内容的模式。 子元素不会继承此"混合"模式状态。 "混合"元素的子元素进行缩进，除非它是还包含"混合"的内容。 元素内容 (http://www.w3.org/TR/1998/REC-xml-19980210#sec-element-content)和混合内容 (http://www.w3.org/TR/1998/REC-xml-19980210#sec-mixed-content)根据这些术语的 XML 1.0 定义定义。  
  
   
  
## Examples  
 下面的示例将 XML 片段。  
  
 [!code-cpp[Classic WebData XmlTextWriter.Formatting Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.Formatting Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.Formatting Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.Formatting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.Formatting Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.Formatting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Formatting" />
      </Docs>
    </Member>
    <Member MemberName="Indentation">
      <MemberSignature Language="C#" Value="public int Indentation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Indentation" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextWriter.Indentation" />
      <MemberSignature Language="VB.NET" Value="Public Property Indentation As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Indentation { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当 <see cref="P:System.Xml.XmlTextWriter.Formatting" /> 设置为 <see langword="Formatting.Indented" /> 时将为层次结构中的每个级别编写多少 IndentChar。</summary>
        <value>每个级别的 <see langword="IndentChars" /> 的数目。 默认值为 2。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 缩进执行对以下节点类型： `DocumentType`， `Element`， `Comment`， `ProcessingInstruction`，和`CDATASection`。 所有其他节点类型不受影响。 `XmlTextWriter`不缩进内部的 DTD 子集。 但是，无法执行以下操作来将格式应用于内部的 DTD 子集。  
  
```csharp  
String name = "Employees";  
String pubid = null;  
String sysid = null;  
String subset =  
@"  
    <!ELEMENT Employees (Employee)+>  
    <!ELEMENT Employee EMPTY>  
    <!ATTLIST Employee firstname CDATA #REQUIRED>  
    <!ENTITY Company 'Microsoft'>]>  
";  
XmlTextWriter tw = new XmlTextWriter(Console.Out);  
tw.WriteDocType(name, pubid, sysid, subset);  
```  
  
   
  
## Examples  
 下面的示例将 XML 片段。  
  
 [!code-cpp[Classic WebData XmlTextWriter.Formatting Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.Formatting Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.Formatting Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.Formatting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.Formatting Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.Formatting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将该属性设置为负值。</exception>
        <altmember cref="P:System.Xml.XmlTextWriter.IndentChar" />
        <altmember cref="T:System.Xml.Formatting" />
      </Docs>
    </Member>
    <Member MemberName="IndentChar">
      <MemberSignature Language="C#" Value="public char IndentChar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IndentChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextWriter.IndentChar" />
      <MemberSignature Language="VB.NET" Value="Public Property IndentChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char IndentChar { char get(); void set(char value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当 <see cref="P:System.Xml.XmlTextWriter.Formatting" /> 设置为 <see langword="Formatting.Indented" /> 时哪个字符用于缩进。</summary>
        <value>用于缩进的字符。 默认为空格。  
  
 <block subset="none" type="note"><para><see langword="XmlTextWriter" /> 允许您将该属性设置为任意字符。 为了确保 XML 有效，你必须指定有效的空格字符 0x9、0x10、0x13 或 0x20。  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.XmlTextWriter.Indentation" />
        <altmember cref="T:System.Xml.Formatting" />
      </Docs>
    </Member>
    <Member MemberName="LookupPrefix">
      <MemberSignature Language="C#" Value="public override string LookupPrefix (string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string LookupPrefix(string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.LookupPrefix(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function LookupPrefix (ns As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ LookupPrefix(System::String ^ ns);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ns">要查找其前缀的命名空间 URI。</param>
        <summary>返回在当前命名空间范围中为该命名空间 URI 定义的最近的前缀。</summary>
        <returns>匹配的前缀。 如果当前范围内未找到匹配的命名空间 URI，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
   
  
## Examples  
 下面的示例将写出一本书。  
  
 [!code-cpp[Classic WebData XmlTextWriter.WriteStartElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.WriteStartElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.WriteStartElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="ns" /> 为 <see langword="null" /> 或 <see langword="String.Empty" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Namespaces">
      <MemberSignature Language="C#" Value="public bool Namespaces { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Namespaces" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextWriter.Namespaces" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespaces As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Namespaces { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否进行命名空间支持。</summary>
        <value>
          如果支持命名空间，则为 <see langword="true" />；否则为 <see langword="false" />。  
  
 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 此属性确定编写器是否支持位于 www.w3.org/TR/REC-xml-names XML 建议中的 W3C 命名空间。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">只能在处于 <see langword="WriteState.Start" /> 状态时更改此属性。</exception>
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public char QuoteChar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextWriter.QuoteChar" />
      <MemberSignature Language="VB.NET" Value="Public Property QuoteChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char QuoteChar { char get(); void set(char value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要用于引用属性值的字符。</summary>
        <value>用于引用属性值的字符。 这必须是单引号 (&amp;#39;) 或双引号 (&amp;#34;)。 默认为双引号。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将该属性设置为非单引号，也非双引号。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteBase64">
      <MemberSignature Language="C#" Value="public override void WriteBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteBase64 (buffer As Byte(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">要进行编码的字节数组。</param>
        <param name="index">缓冲区中的位置，指示要写入的字节的起始位置。</param>
        <param name="count">要写入的字节数。</param>
        <summary>将指定的二进制字节编码为 Base64 并写出结果文本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
   
  
## Examples  
 下面的示例将编码输入的文件使用`WriteBase64`并生成一个临时 XML 文件。 临时 XML 文件进行解码使用<xref:System.Xml.XmlTextReader.ReadBase64%2A>方法和与原始文件进行比较。  
  
 [!code-cpp[XmlWriter.WriteBase64#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlWriter.WriteBase64/CPP/writebase64.cpp#1)]
 [!code-csharp[XmlWriter.WriteBase64#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlWriter.WriteBase64/CS/writebase64.cs#1)]
 [!code-vb[XmlWriter.WriteBase64#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlWriter.WriteBase64/VB/writebase64.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">缓冲区长度减去 <paramref name="index" /> 小于 <paramref name="count" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Xml.XmlTextWriter.WriteState" /> 为 <see langword="Closed" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteBinHex">
      <MemberSignature Language="C#" Value="public override void WriteBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteBinHex (buffer As Byte(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">要进行编码的字节数组。</param>
        <param name="index">缓冲区中指示要写入字节的起始位置的位置。</param>
        <param name="count">要写入的字节数。</param>
        <summary>将指定的二进制字节编码为 BinHex 并写出结果文本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">缓冲区长度减去 <paramref name="index" /> 小于 <paramref name="count" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Xml.XmlTextWriter.WriteState" /> 为 Closed。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteCData">
      <MemberSignature Language="C#" Value="public override void WriteCData (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteCData(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteCData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteCData (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteCData(System::String ^ text);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">要放置在 CDATA 块中的文本。</param>
        <summary>写出包含指定文本的 &lt;![CDATA[...]]&gt; 块。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 如果`text`是`null`或`String.Empty`，此方法将写入到空 CDATA 块中，例如\<！ [CDATA []]] >< ！[CDATA [] >。  
  
   
  
## Examples  
 下面的示例编写一个表示书的 XML 文件。  
  
 [!code-cpp[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该文本将导致格式不正确的 XML 文档。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Xml.XmlTextWriter.WriteState" /> 为 <see langword="Closed" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteCharEntity">
      <MemberSignature Language="C#" Value="public override void WriteCharEntity (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteCharEntity(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteCharEntity(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteCharEntity (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteCharEntity(char ch);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">为其生成字符实体的 Unicode 字符。</param>
        <summary>为指定的 Unicode 字符值强制生成字符实体。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 此方法以十六进制字符实体引用格式写入的 Unicode 字符。  
  
   
  
## Examples  
 下面的示例使用`WriteCharEntity`方法写入电子邮件地址。  
  
 [!code-cpp[Classic WebData XmlTextWriter.WriteTimeSpan Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteTimeSpan Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.WriteTimeSpan Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteTimeSpan Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.WriteTimeSpan Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteTimeSpan Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该字符应处于代理项对字符范围 <see langword="0xd800" /> - <see langword="0xdfff" /> 内；否则该文本将导致格式不正确的 XML 文档。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Xml.XmlTextWriter.WriteState" /> 为 <see langword="Closed" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteChars">
      <MemberSignature Language="C#" Value="public override void WriteChars (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteChars(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteChars(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteChars (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteChars(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">包含要写入的文本的字符数组。</param>
        <param name="index">缓冲区中指示要写入文本的起始位置的位置。</param>
        <param name="count">要写入的字符数。</param>
        <summary>以每次一个缓冲区的方式写入文本。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 此方法可以用于一次写入大量的文本一个缓冲区。  
  
 必须进行特殊处理以确保`WriteChars`方法没有将代理项对字符拆分跨多个缓冲区写入。 XML 规范定义的有效范围为代理项对。  
  
 如果这将导致代理项对字符进行 split 缓冲区中写入代理项对字符，将引发异常。  
  
   
  
## Examples  
 [!code-csharp[XmlTextWriter.WriteChars#1](~/samples/snippets/csharp/VS_Snippets_Data/xmltextwriter.writechars/cs/xmlwriterwritecharsexample.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小于零。  
  
 或  
  
 缓冲区长度减去 <paramref name="index" /> 小于 <paramref name="count" />；此调用导致代理项对字符被拆分或写入无效的代理项对。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Xml.XmlTextWriter.WriteState" /> 为 Closed。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteComment">
      <MemberSignature Language="C#" Value="public override void WriteComment (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteComment(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteComment(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteComment (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteComment(System::String ^ text);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">要放在注释内的文本。</param>
        <summary>写出包含指定文本的注释 &lt;!--...--&gt;。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 如果`text`是`null`或`String.Empty`，此方法将写入`Comment`没有数据内容，例如\<！--->。  
  
   
  
## Examples  
 下面的示例编写一个表示书的 XML 文件。  
  
 [!code-cpp[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该文本将导致格式不正确的 XML 文档。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Xml.XmlTextWriter.WriteState" /> 为 <see langword="Closed" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteDocType">
      <MemberSignature Language="C#" Value="public override void WriteDocType (string name, string pubid, string sysid, string subset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteDocType(string name, string pubid, string sysid, string subset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteDocType(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteDocType (name As String, pubid As String, sysid As String, subset As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteDocType(System::String ^ name, System::String ^ pubid, System::String ^ sysid, System::String ^ subset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="pubid" Type="System.String" />
        <Parameter Name="sysid" Type="System.String" />
        <Parameter Name="subset" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">DOCTYPE 的名称。 它必须是非空的。</param>
        <param name="pubid">如果非 null，则它还写入 PUBLIC "pubid" "sysid"，这里的 <c>pubid</c> 和 <c>sysid</c> 用给定参数的值替换。</param>
        <param name="sysid">如果 <c>pubid</c> 为 null 而 <c>sysid</c> 非 null，则它编写 SYSTEM "sysid"，这里的 <c>sysid</c> 用此参数的值替换。</param>
        <param name="subset">如果非 null，则它写入 [subset]，其中 subset 替换为此自变量的值。</param>
        <summary>写出具有指定名称和可选属性的 DOCTYPE 声明。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 此方法不会检查中的无效字符`pubid`，`sysid`或`subset`。 它也不会检查内部子集的格式正确。  
  
> [!IMPORTANT]
>  <xref:System.Xml.XmlTextWriter>不会验证传递给任何数据<xref:System.Xml.XmlTextWriter.WriteDocType%2A>方法。 你不应将任意数据传递给此方法。  
  
   
  
## Examples  
 下面的示例编写一个表示书的 XML 文件。  
  
 [!code-cpp[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在序言码外部（根元素之后）调用了此方法。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 为 <see langword="null" /> 或 <see langword="String.Empty" />  
  
 或  
  
 <paramref name="name" /> 的值将导致无效的 XML。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEndAttribute">
      <MemberSignature Language="C#" Value="public override void WriteEndAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteEndAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteEndAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteEndAttribute ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteEndAttribute();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭上一个 <see cref="M:System.Xml.XmlTextWriter.WriteStartAttribute(System.String,System.String,System.String)" /> 调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 如果调用`WriteStartAttribute`，你可以使用此方法关闭该属性。  
  
 你还可以通过调用关闭属性`WriteStartAttribute`同样，调用<xref:System.Xml.XmlWriter.WriteAttributeString%2A>，或调用<xref:System.Xml.XmlTextWriter.WriteEndElement%2A>。  
  
   
  
## Examples  
 下面的示例将写出一本书。  
  
 [!code-cpp[Classic WebData XmlTextWriter.WriteStartElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.WriteStartElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.WriteStartElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEndDocument">
      <MemberSignature Language="C#" Value="public override void WriteEndDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteEndDocument() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteEndDocument" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteEndDocument ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteEndDocument();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭任何打开的元素或特性并将写入器重新设置为起始状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
   
  
## Examples  
 下面的示例编写一个表示书的 XML 文件。  
  
 [!code-cpp[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">XML 文档无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEndElement">
      <MemberSignature Language="C#" Value="public override void WriteEndElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteEndElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteEndElement" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteEndElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteEndElement();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭一个元素并弹出相应的命名空间范围。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 如果元素不包含内容短结束标记"/ >"写入;否则写入完整的结束标记。  
  
   
  
## Examples  
 下面的示例编写一个表示书的 XML 文件。  
  
 [!code-cpp[Classic WebData XmlTextWriter.WriteEndElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteEndElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.WriteEndElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteEndElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.WriteEndElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteEndElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEntityRef">
      <MemberSignature Language="C#" Value="public override void WriteEntityRef (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteEntityRef(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteEntityRef(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteEntityRef (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteEntityRef(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">实体引用的名称。</param>
        <summary>按 <see langword="&amp;name;" /> 写出实体引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
   
  
## Examples  
 下面的示例编写一个表示书的 XML 文件。  
  
 [!code-cpp[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该文本将导致格式不正确的 XML 文档；或者 <paramref name="name" /> 为 <see langword="null" /> 或 <see langword="String.Empty" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFullEndElement">
      <MemberSignature Language="C#" Value="public override void WriteFullEndElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteFullEndElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteFullEndElement" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteFullEndElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteFullEndElement();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭一个元素并弹出相应的命名空间范围。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 此方法始终写入完整的结束标记。 必须包括完整的结束标记的元素在处理时，这非常有用。 例如，浏览器要求 HTML 脚本块与要关闭" \< />"。  
  
   
  
## Examples  
 下面的示例将写出具有任何内容的元素。 它使用 WriteFullEndElement 写入完整的结束元素标记。  
  
 [!code-cpp[Classic WebData XmlTextWriter.WriteFullEndElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteFullEndElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.WriteFullEndElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteFullEndElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.WriteFullEndElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteFullEndElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteName">
      <MemberSignature Language="C#" Value="public override void WriteName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要写出的名称。</param>
        <summary>写出指定的名称，确保它是符合 W3C XML 1.0 建议 (http://www.w3.org/TR/1998/REC-xml-19980210#NT-Name)) 的有效名称。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 如果<xref:System.Xml.XmlTextWriter.Namespaces%2A>设置为`true`，`WriteName`还会检查的名称也是根据 XML 建议中的 W3C 命名空间有效。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 不是有效的 XML 名称，或者 <paramref name="name" /> 为 <see langword="null" /> 或 <see langword="String.Empty" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteNmToken">
      <MemberSignature Language="C#" Value="public override void WriteNmToken (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteNmToken(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteNmToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteNmToken (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteNmToken(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要写出的名称。</param>
        <summary>写出指定的名称，确保它是符合 W3C XML 1.0 建议 (http://www.w3.org/TR/1998/REC-xml-19980210#NT-Name)) 的有效 <see langword="NmToken" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 不是有效的 <see langword="NmToken" />；或者 <paramref name="name" /> 为 <see langword="null" /> 或 <see langword="String.Empty" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteProcessingInstruction">
      <MemberSignature Language="C#" Value="public override void WriteProcessingInstruction (string name, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteProcessingInstruction(string name, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteProcessingInstruction(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteProcessingInstruction (name As String, text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteProcessingInstruction(System::String ^ name, System::String ^ text);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">处理指令的名称。</param>
        <param name="text">要包括在处理指令中的文本。</param>
        <summary>写出在名称和文本之间有空格的处理指令，如下所示：&lt;?name text?&gt;。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 如果`text`是`null`或`String.Empty`，此方法将写入`ProcessingInstruction`没有数据内容，例如\<？ 名称？ >。  
  
   
  
## Examples  
 下面的示例编写一个表示书的 XML 文件。  
  
 [!code-cpp[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该文本将导致格式不正确的 XML 文档。  
  
 <paramref name="name" /> 为 <see langword="null" /> 或 <see langword="String.Empty" />。  
  
 调用了 <see cref="M:System.Xml.XmlTextWriter.WriteStartDocument" /> 后，使用此方法创建 XML 声明。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteQualifiedName">
      <MemberSignature Language="C#" Value="public override void WriteQualifiedName (string localName, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteQualifiedName(string localName, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteQualifiedName (localName As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteQualifiedName(System::String ^ localName, System::String ^ ns);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">要写入的本地名称。</param>
        <param name="ns">与该名称关联的命名空间 URI。</param>
        <summary>写出命名空间限定的名称。 此方法查找位于给定命名空间范围内的前缀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 例如，下面的 Microsoft Visual C# 代码：  
  
```csharp  
writer.Formatting = Formatting.Indented;  
writer.WriteStartElement("root");  
 writer.WriteAttributeString("xmlns","x",null,"urn:abc");  
 writer.WriteStartElement("item");  
 writer.WriteStartAttribute("href",null);  
 writer.WriteString("#");  
 writer.WriteQualifiedName("test","urn:abc");  
 writer.WriteEndAttribute();  
 writer.WriteEndElement();  
 writer.WriteEndElement();  
 writer.Close();  
```  
  
 生成以下输出：  
  
```xml  
<root xmlns:x="urn:abc">  
 <item href="#x:test"/>  
 </root>  
```  
  
 如果`ns`生成映射到当前默认命名空间，没有前缀。  
  
 如果在编写属性值时，此方法将生成前缀`ns`找不到。 在编写元素内容时，如果引发了异常`ns`找不到。  
  
 如果此编写器支持命名空间 (<xref:System.Xml.XmlTextWriter.Namespaces%2A>设置为`true`)，此方法还检查该名称是否有效根据 XML 建议中的 W3C 命名空间 (http://www.w3.org/TR/REC-xml-names)。  
  
   
  
## Examples  
 下面的示例将写出 XSD 架构的一部分。  
  
 [!code-cpp[Classic WebData XmlTextWriter.WriteQualifiedName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteQualifiedName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.WriteQualifiedName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteQualifiedName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.WriteQualifiedName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteQualifiedName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="localName" /> 为 <see langword="null" /> 或 <see langword="String.Empty" />。  
  
 根据 W3C 命名空间规范，<paramref name="localName" /> 不是有效的名称。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteRaw">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>手动写入原始标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteRaw">
      <MemberSignature Language="C#" Value="public override void WriteRaw (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteRaw(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteRaw(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteRaw (data As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteRaw(System::String ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">包含要写入的文本的字符串。</param>
        <summary>从字符串手动写入原始标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 此方法未转义特殊字符。  
  
> [!IMPORTANT]
>  <xref:System.Xml.XmlTextWriter>不会验证传递给任何数据<xref:System.Xml.XmlTextWriter.WriteRaw%2A>方法。 你不应将任意数据传递给此方法。  
  
   
  
## Examples  
 下面的示例将字符串使用`WriteRaw`方法。  
  
 [!code-cpp[Classic WebData XmlTextWriter.WriteRaw1 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteRaw1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.WriteRaw1 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteRaw1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.WriteRaw1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteRaw1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteRaw">
      <MemberSignature Language="C#" Value="public override void WriteRaw (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteRaw(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteRaw(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteRaw (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteRaw(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">包含要写入的文本的字符数组。</param>
        <param name="index">缓冲区中的位置，指示要写入文本的起始位置。</param>
        <param name="count">要写入的字符数。</param>
        <summary>从字符缓冲区手动写入原始标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 此方法未转义特殊字符。  
  
> [!IMPORTANT]
>  <xref:System.Xml.XmlTextWriter>不会验证传递给任何数据<xref:System.Xml.XmlTextWriter.WriteRaw%2A>方法。 你不应将任意数据传递给此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 或 <paramref name="count" /> 小于零。  
  
 或  
  
 缓冲区长度减去 <paramref name="index" /> 小于 <paramref name="count" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartAttribute">
      <MemberSignature Language="C#" Value="public override void WriteStartAttribute (string prefix, string localName, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteStartAttribute(string prefix, string localName, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteStartAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteStartAttribute (prefix As String, localName As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteStartAttribute(System::String ^ prefix, System::String ^ localName, System::String ^ ns);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">
          特性的 <see langword="Namespace" /> 前缀。</param>
        <param name="localName">
          特性的 <see langword="LocalName" />。</param>
        <param name="ns">
          特性的 <see langword="NamespaceURI" /></param>
        <summary>写入属性的开头。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 这是更高级的版本<xref:System.Xml.XmlWriter.WriteAttributeString%2A>，允许您写入属性值使用多个写方法，如<xref:System.Xml.XmlTextWriter.WriteString%2A>。  
  
   
  
## Examples  
 下面的示例将写出一本书。  
  
 [!code-cpp[Classic WebData XmlTextWriter.WriteStartElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.WriteStartElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.WriteStartElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="localName" /> 为 <see langword="null" /> 或 <see langword="String.Empty" />。</exception>
        <altmember cref="M:System.Xml.XmlTextWriter.WriteEndAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteStartDocument">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>写入版本为“1.0”的 XML 声明。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteStartDocument">
      <MemberSignature Language="C#" Value="public override void WriteStartDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteStartDocument() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteStartDocument" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteStartDocument ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteStartDocument();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>写入版本为“1.0”的 XML 声明。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 由编写器的实现方式确定文档的编码级别。 例如，如果<xref:System.Text.Encoding>中指定的对象`XmlTextWriter`构造函数，这将确定编码属性的值。 此方法不创建出独立特性。  
  
 当`WriteStartDocument`称为编写器验证你正在编写是否格式良好的 XML 文档。 例如，它会检查 XML 声明是第一个节点，其中一个，并仅有一个根级元素存在，依此类推。 如果未调用此方法，该编写器将假定 XML 片段写入，则并且不应用任何根级别规则。  
  
 如果`WriteStartDocument`已调用，然后<xref:System.Xml.XmlTextWriter.WriteProcessingInstruction%2A>方法用于创建另一个 XML 声明，则会引发异常。  
  
   
  
## Examples  
 下面的示例编写一个表示书的 XML 文件。  
  
 [!code-cpp[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.WriteStartDocument Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartDocument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">这不是在构造函数后调用的第一个写方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartDocument">
      <MemberSignature Language="C#" Value="public override void WriteStartDocument (bool standalone);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteStartDocument(bool standalone) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteStartDocument(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteStartDocument (standalone As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteStartDocument(bool standalone);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="standalone" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="standalone">如果为 <see langword="true" />，则它将写入"standalone=yes"；如果为 <see langword="false" />，则它将写入"standalone=no"。</param>
        <summary>写入版本为“1.0”的 XML 声明和独立的属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 由编写器的实现方式确定文档的编码级别。 例如，如果<xref:System.Text.Encoding>中指定的对象`XmlTextWriter`构造函数，这将确定编码属性的值。  
  
 当`WriteStartDocument`称为编写器验证你正在编写是否格式良好的 XML 文档。 例如，它会检查 XML 声明是第一个节点，其中一个，并仅有一个根级元素存在，依此类推。 如果未调用此方法，该编写器将假定 XML 片段写入，则并且不应用任何根级别规则。  
  
 如果`WriteStartDocument`已调用，然后<xref:System.Xml.XmlTextWriter.WriteProcessingInstruction%2A>方法用于创建另一个 XML 声明，则会引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">这不是在构造函数后调用的第一个写方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartElement">
      <MemberSignature Language="C#" Value="public override void WriteStartElement (string prefix, string localName, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteStartElement(string prefix, string localName, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteStartElement(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteStartElement (prefix As String, localName As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteStartElement(System::String ^ prefix, System::String ^ localName, System::String ^ ns);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">元素的命名空间前缀。</param>
        <param name="localName">元素的本地名称。</param>
        <param name="ns">与元素关联的命名空间 URI。 如果此命名空间已在范围中并具有关联的前缀，则写入器还自动写入该前缀。</param>
        <summary>写入指定的开始标记并将其与给定的命名空间和前缀关联起来。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 调用此方法您可以编写属性或创建之后内容使用<xref:System.Xml.XmlTextWriter.WriteComment%2A>， <xref:System.Xml.XmlTextWriter.WriteString%2A>，或<xref:System.Xml.XmlTextWriter.WriteStartElement%2A>子元素。 你可以关闭具有元素<xref:System.Xml.XmlTextWriter.WriteEndElement%2A>哪些时间结束标记写出。  
  
   
  
## Examples  
 下面的示例将写出一本书。  
  
 [!code-cpp[Classic WebData XmlTextWriter.WriteStartElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.WriteStartElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.WriteStartElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.WriteStartElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">编写器已关闭。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteState">
      <MemberSignature Language="C#" Value="public override System.Xml.WriteState WriteState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.WriteState WriteState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextWriter.WriteState" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property WriteState As WriteState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::WriteState WriteState { System::Xml::WriteState get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.WriteState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取写入器的状态。</summary>
        <value>
          <see cref="T:System.Xml.WriteState" /> 值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteString">
      <MemberSignature Language="C#" Value="public override void WriteString (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteString(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteString (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteString(System::String ^ text);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">要写入的文本。</param>
        <summary>写入给定的文本内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 `WriteString` 执行以下  
  
-   字符`&`， `<`，和`>`使用替换`&amp;`， `&lt;`，和`&gt;`分别。  
  
-   在范围 0 x-0x1F （不包括空白字符 0x9、 0xA 和 0xD） 中的字符值替换为数字字符实体 (`&#0;`通过`&#0x1F`)。  
  
-   如果`WriteString`调用在属性值的上下文中，双引号和单引号会用替换`&quot;`和`&apos;`分别。  
  
 例如，输入字符串`test<item>test`编写为  
  
```  
test&lt;item&gt;test  
```  
  
 如果`text`是`null`或`String.Empty`，此方法将写入任何数据内容的文本节点。  
  
   
  
## Examples  
 下面的示例将 XML 片段。  
  
 [!code-cpp[Classic WebData XmlTextWriter.Formatting Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.Formatting Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.Formatting Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.Formatting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.Formatting Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.Formatting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">文本字符串包含无效的代理项对。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSurrogateCharEntity">
      <MemberSignature Language="C#" Value="public override void WriteSurrogateCharEntity (char lowChar, char highChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteSurrogateCharEntity(char lowChar, char highChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteSurrogateCharEntity(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteSurrogateCharEntity (lowChar As Char, highChar As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteSurrogateCharEntity(char lowChar, char highChar);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lowChar" Type="System.Char" />
        <Parameter Name="highChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="lowChar">低代理项。 它必须是介于 <see langword="0xDC00" /> 和 <see langword="0xDFFF" /> 之间的值。</param>
        <param name="highChar">高代理项。 它必须是介于 <see langword="0xD800" /> 和 <see langword="0xDBFF" /> 之间的值。</param>
        <summary>为代理项字符对生成并写入代理项字符实体。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 此方法仅适用于使用 utf-16 编码的系统。  
  
 以十六进制格式写入代理项字符实体。 代理项字符的范围是`#x10000`到`#x10FFFF`。 以下公式用于生成代理项字符实体: (`highChar` - `0xD800`) * `0x400` + (`lowChar` - `0xDC00`) + `0x10000`。  
  
 对于 HTML 和 XML，文档的字符集 （和数字字符引用的表示法） 基于 UCS [ISO 10646]。 源文档中的单个数字字符引用可能会因此在某些情况下对应于字符串 （一个高代理项和低代理项） 中的两个 16 位单位。 这些 16 位单位称为代理项对。  
  
 有关代理项或多个字符的详细信息，请参阅的部分 3.7 的 Unicode 标准 3.0/Unicode 2.0 位于http://www.unicode.org，或 W3C XML 1.0 建议的第 2.2 节位于http://www.w3.org/TR/REC-xml#charsets。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">传递了无效的代理项字符对。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteWhitespace">
      <MemberSignature Language="C#" Value="public override void WriteWhitespace (string ws);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteWhitespace(string ws) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextWriter.WriteWhitespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteWhitespace (ws As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteWhitespace(System::String ^ ws);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ws" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ws">空格字符的字符串。</param>
        <summary>写出给定的空白区域。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 此方法用于手动格式化文档。 使用<xref:System.Xml.XmlTextWriter.Formatting%2A>属性自动设置输出格式编写。  
  
   
  
## Examples  
 下面的示例使用`WriteWhitespace`方法可控制该文件的格式。  
  
 [!code-cpp[Classic WebData XmlTextWriter.XmlSpace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.XmlSpace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.XmlSpace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.XmlSpace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.XmlSpace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.XmlSpace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">字符串包含非空白字符。</exception>
        <altmember cref="P:System.Xml.XmlTextWriter.Formatting" />
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public override string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextWriter.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property XmlLang As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see langword="xml:lang" /> 范围。</summary>
        <value>当前 <see langword="xml:lang" />；或者如果当前范围中没有 <see langword="null" />，则为 <see langword="xml:lang" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 此属性允许要找出哪些状态另一个组件已离开的编写器中的一个组件。 例如，可能是一个组件想要告诉另一个要生成的语言帮助文本。 通过编写通信的语言信息`xml:lang`属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextWriter.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property XmlSpace As XmlSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取表示当前 <see langword="xml:space" /> 范围的 <see cref="T:System.Xml.XmlSpace" />。</summary>
        <value>一个表示当前 <see langword="XmlSpace" /> 范围的 <see langword="xml:space" />。  
  
 <list type="table"><listheader><term> 值  
  
 </term><description> 含义  
  
 </description></listheader><item><term> 无  
  
 </term><description> 这是默认值，如果没有<see langword="xml:space" />存在的作用域。  
  
 </description></item><item><term> 默认值  
  
 </term><description> 当前作用域是<see langword="xml:space" />="default"。  
  
 </description></item><item><term> 保留  
  
 </term><description> 当前作用域是<see langword="xml:space" />="preserve"。  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  从.NET Framework 2.0 开始，我们建议你创建<xref:System.Xml.XmlWriter>实例使用<xref:System.Xml.XmlWriter.Create%2A?displayProperty=nameWithType>方法和<xref:System.Xml.XmlWriterSettings>类以利用新功能。  
  
 此属性允许一个组件，若要了解在什么状态另一个组件已离开编写器。  
  
   
  
## Examples  
 下面的示例使用`WriteWhitespace`方法可控制该文件的格式。  
  
 [!code-cpp[Classic WebData XmlTextWriter.XmlSpace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextWriter.XmlSpace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextWriter.XmlSpace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextWriter.XmlSpace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextWriter.XmlSpace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextWriter.XmlSpace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>