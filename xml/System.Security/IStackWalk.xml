<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="IStackWalk.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5b37ff083eff27618aa07c0a744562f3f8a613708.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b37ff083eff27618aa07c0a744562f3f8a613708</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-2.0,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Security.IStackWalk">
          <source>Manages the stack walk that determines whether all callers in the call stack have the required permissions to access a protected resource.</source>
          <target state="translated">用于管理堆栈遍历，此堆栈遍历可确定调用堆栈中的所有调用函数是否具有访问受保护资源的所需权限。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IStackWalk">
          <source>Partially trusted code always presents a security risk.</source>
          <target state="translated">部分受信任的代码始终带来安全风险。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IStackWalk">
          <source>It can sometimes be manipulated to perform actions on behalf of malicious code that does not have permission to access a resource.</source>
          <target state="translated">有时操作可以代表有权访问的资源的恶意代码执行操作。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IStackWalk">
          <source>In this way, malicious code can achieve higher security access than it should be allowed.</source>
          <target state="translated">这种方式，恶意代码可以获得更高版本的安全访问权限，不应允许它。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IStackWalk">
          <source>The common language runtime helps protect managed code from these attacks by running a stack walk on all calls.</source>
          <target state="translated">公共语言运行时可帮助保护免受这些攻击的托管的代码，通过运行上的所有调用的堆栈审核。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IStackWalk">
          <source>The stack walk requires that all code in the call stack has permission to access a protected resource.</source>
          <target state="translated">堆栈审核要求调用堆栈中的所有代码都有权访问受保护的资源。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Security.IStackWalk">
          <source>Because the code attempting the attack will always be somewhere in the call stack, it will be unable to exceed its own security permissions.</source>
          <target state="translated">因为尝试进行攻击的代码始终调用堆栈中的某个地方，它将不能超过其自己的安全权限。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" uid="M:System.Security.IStackWalk.Assert">
          <source>Asserts that the calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.</source>
          <target state="translated">断言调用代码可以访问当前权限对象所标识的资源，即使尚未对堆栈中的高级调用方授予访问该资源的权限。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source>Calling <ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> stops the permission check on callers higher in the call stack.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph>停止对调用堆栈中的高级调用方的权限检查。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source>Therefore, even if these callers do not have the requisite permissions, they can still access resources.</source>
          <target state="translated">因此，即使这些调用方没有所需的权限，它们仍可以访问资源。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source>An assertion is effective only if the code that calls <ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> passes the security check for the permission that it is asserting.</source>
          <target state="translated">断言是仅当调用的代码的有效<ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph>将传递它断言的权限的安全检查。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source>A call to <ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> is effective until the calling code returns to its caller or until a subsequent call to <ph id="ph2">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> renders the previous assertion ineffective.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph>之前调用的代码返回到其调用方或之前的后续调用均有效<ph id="ph2">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph>呈现前一个断言无效。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source>Also, <ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph> removes a pending <ph id="ph3">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph>.</source>
          <target state="translated">此外，<ph id="ph1">&lt;xref:System.Security.CodeAccessPermission.RevertAssert%2A&gt;</ph>或<ph id="ph2">&lt;xref:System.Security.CodeAccessPermission.RevertAll%2A&gt;</ph>中移除挂起<ph id="ph3">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source><ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> 对于未授予对该权限的请求将不会成功的权限，将忽略。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source>However, if code lower on the call stack calls <ph id="ph1">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph> for that permission, a <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the stack walk reaches the code that tried to call <ph id="ph3">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph>.</source>
          <target state="translated">但是，如果调用堆栈上较低的代码调用<ph id="ph1">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph>对该权限<ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph>堆栈审核达到尝试调用代码时，将引发<ph id="ph3">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source>This happens because the code that called <ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> has not been granted the permission, even though it tried to <ph id="ph2">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> it.</source>
          <target state="translated">这是因为代码调用<ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph>未被授予权限，即使它尝试<ph id="ph2">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph>它。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source>Because calling <ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security vulnerabilities if used incorrectly or inappropriately.</source>
          <target state="translated">因为调用<ph id="ph1">&lt;xref:System.Security.IStackWalk.Assert%2A&gt;</ph>中删除所有代码调用链中的要求必须授予访问指定的资源的权限，如果使用不当会暴露安全性漏洞。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Assert">
          <source>Therefore, it should be used with great caution.</source>
          <target state="translated">因此，它应谨慎使用。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Security.IStackWalk.Assert">
          <source>The calling code does not have <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph>.</source>
          <target state="translated">调用代码没有 <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Security.IStackWalk.Demand">
          <source>Determines at run time whether all callers in the call stack have been granted the permission specified by the current permission object.</source>
          <target state="translated">在运行时确定调用堆栈中的所有调用方是否已被授予当前权限对象所指定的权限。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Demand">
          <source>This method is typically used by secure libraries to ensure that callers have permission to access a resource.</source>
          <target state="translated">安全库通常使用此方法以确保调用方有权访问的资源。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Demand">
          <source>For example, a file class in a secure class library calls <ph id="ph1">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph> for the necessary <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> before performing a file operation requested by the caller.</source>
          <target state="translated">例如，安全类库中的文件类调用<ph id="ph1">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph>为所需<ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph>之前执行由调用方请求的文件操作。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Demand">
          <source>The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</source>
          <target state="translated">调用此方法的代码的权限不会检查;检查开始从该代码的直接调用方，并在堆栈中向上继续进行。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Demand">
          <source><ph id="ph1">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph> succeeds only if no <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is raised.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph> 如果未成功<ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph>引发。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Security.IStackWalk.Demand">
          <source>A caller higher in the call stack does not have the permission specified by the current permission object.</source>
          <target state="translated">调用堆栈中处于较高位置的调用方不具有当前权限对象所指定的权限。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Security.IStackWalk.Demand">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Security.IStackWalk.Demand">
          <source>A caller in the call stack has called <ph id="ph1">&lt;see cref="M:System.Security.IStackWalk.Deny" /&gt;</ph> on the current permission object.</source>
          <target state="translated">调用堆栈中的调用方已经对当前权限对象调用了 <ph id="ph1">&lt;see cref="M:System.Security.IStackWalk.Deny" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Security.IStackWalk.Deny">
          <source>Causes every <ph id="ph1">&lt;see cref="M:System.Security.IStackWalk.Demand" /&gt;</ph> for the current object that passes through the calling code to fail.</source>
          <target state="translated">将导致通过调用代码传递的当前对象的每个 <ph id="ph1">&lt;see cref="M:System.Security.IStackWalk.Demand" /&gt;</ph> 失败。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Deny">
          <source>This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</source>
          <target state="translated">此方法会阻止调用堆栈中的高级调用方通过调用此方法的代码，访问受保护的资源，即使这些调用方已被授予权限来访问它。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Deny">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">调用堆栈通常表示为向下增长，以便对调用堆栈中调用方法中较低的调用堆栈。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Deny">
          <source><ph id="ph1">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph> can limit the liability of the programmer or help prevent accidental security vulnerabilities because it helps prevent the method that calls <ph id="ph2">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph> from being used to access the resource protected by the denied permission.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph> 可以限制了编程人员的责任或帮助防止出现意外的安全漏洞，因为它有助于防止调用的方法<ph id="ph2">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph>从用于访问被拒绝的权限所保护的资源。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Deny">
          <source>If a method calls <ph id="ph1">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph> on a permission, and if a <ph id="ph2">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <ph id="ph3">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph>.</source>
          <target state="translated">如果一个方法调用<ph id="ph1">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph>对权限，并且如果<ph id="ph2">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph>到达时，该安全检查为该权限调用方的调用堆栈中较低级别调用，将会失败<ph id="ph3">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Deny">
          <source><ph id="ph1">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph> is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph> 对于未授予对该权限的请求将不会成功的权限，将忽略。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.Deny">
          <source>You cannot override this method.</source>
          <target state="translated">不能重写此方法。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Security.IStackWalk.PermitOnly">
          <source>Causes every <ph id="ph1">&lt;see cref="M:System.Security.IStackWalk.Demand" /&gt;</ph> for all objects except the current one that passes through the calling code to fail, even if code higher in the call stack has been granted permission to access other resources.</source>
          <target state="translated">导致除当前对象（通过调用代码来传递）以外的所有对象的每个 <ph id="ph1">&lt;see cref="M:System.Security.IStackWalk.Demand" /&gt;</ph> 失败，即使调用堆栈中的高级代码已被授权访问其他资源也是如此。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.PermitOnly">
          <source><ph id="ph1">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph> is similar to <ph id="ph2">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph>, in that both cause stack walks to fail when they would otherwise succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph> 类似于<ph id="ph2">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph>，因为同时导致堆栈审核失败时它们原本应该成功。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.PermitOnly">
          <source>The difference is that <ph id="ph1">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph> specifies permissions that will cause the stack walk to fail, but <ph id="ph2">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph> specifies the only permissions that do not cause the stack walk to fail.</source>
          <target state="translated">差异在于<ph id="ph1">&lt;xref:System.Security.IStackWalk.Deny%2A&gt;</ph>指定权限将导致堆栈审核失败，但<ph id="ph2">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph>指定不会导致堆栈审核失败的唯一权限。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.PermitOnly">
          <source>Call this method to ensure that your code can be used to access only the specified resources.</source>
          <target state="translated">调用此方法，以确保你的代码可以用于访问指定的资源。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.PermitOnly">
          <source><ph id="ph1">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph> is ignored for a permission not granted because a demand for that permission will not succeed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph> 对于未授予对该权限的请求将不会成功的权限，将忽略。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.PermitOnly">
          <source>However, if code lower on the call stack later calls <ph id="ph1">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph> for that permission, a <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown when the stack walk reaches the code that tried to call <ph id="ph3">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph>.</source>
          <target state="translated">但是，如果在调用的低级代码堆栈更高版本调用<ph id="ph1">&lt;xref:System.Security.IStackWalk.Demand%2A&gt;</ph>对该权限<ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph>堆栈审核达到尝试调用代码时，将引发<ph id="ph3">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.PermitOnly">
          <source>This is because the code that called <ph id="ph1">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph> has not been granted the permission, even though it called <ph id="ph2">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph> for that permission.</source>
          <target state="translated">这是因为代码调用<ph id="ph1">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph>未被授予权限，即使它调用<ph id="ph2">&lt;xref:System.Security.IStackWalk.PermitOnly%2A&gt;</ph>对该权限。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Security.IStackWalk.PermitOnly">
          <source>The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</source>
          <target state="translated">调用堆栈通常表示为向下增长，以便对调用堆栈中调用方法中较低的调用堆栈。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>