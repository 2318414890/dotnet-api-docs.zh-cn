<Type Name="IStackWalk" FullName="System.Security.IStackWalk">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="df8c33ab7bb831c9a8d979c182a56263b8e53575" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48766767" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.IStackWalk" />
  <TypeSignature Language="VB.NET" Value="Public Interface IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public interface class IStackWalk" />
  <TypeSignature Language="F#" Value="type IStackWalk = interface" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="53bbd-101">用于管理堆栈遍历，此堆栈遍历可确定调用堆栈中的所有调用函数是否具有访问受保护资源的所需权限。</span>
      <span class="sxs-lookup">
        <span data-stu-id="53bbd-101">Manages the stack walk that determines whether all callers in the call stack have the required permissions to access a protected resource.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53bbd-102">部分受信任的代码始终会带来安全风险。</span><span class="sxs-lookup"><span data-stu-id="53bbd-102">Partially trusted code always presents a security risk.</span></span> <span data-ttu-id="53bbd-103">有时操作来代表不具有访问资源的权限的恶意代码执行操作。</span><span class="sxs-lookup"><span data-stu-id="53bbd-103">It can sometimes be manipulated to perform actions on behalf of malicious code that does not have permission to access a resource.</span></span> <span data-ttu-id="53bbd-104">这样一来，恶意代码可以实现比应允许更高版本的安全访问。</span><span class="sxs-lookup"><span data-stu-id="53bbd-104">In this way, malicious code can achieve higher security access than it should be allowed.</span></span>  
  
 <span data-ttu-id="53bbd-105">公共语言运行时可帮助保护托管的代码免受这些攻击通过运行上的所有调用堆栈遍历。</span><span class="sxs-lookup"><span data-stu-id="53bbd-105">The common language runtime helps protect managed code from these attacks by running a stack walk on all calls.</span></span> <span data-ttu-id="53bbd-106">堆栈遍历要求调用堆栈中的所有代码都有权访问受保护的资源。</span><span class="sxs-lookup"><span data-stu-id="53bbd-106">The stack walk requires that all code in the call stack has permission to access a protected resource.</span></span> <span data-ttu-id="53bbd-107">因为尝试攻击代码始终在调用堆栈中的某个地方，它将不能超过其自身的安全权限。</span><span class="sxs-lookup"><span data-stu-id="53bbd-107">Because the code attempting the attack will always be somewhere in the call stack, it will be unable to exceed its own security permissions.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Assert();" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit" Usage="iStackWalk.Assert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="53bbd-108">断言调用代码可以访问当前权限对象所标识的资源，即使尚未对堆栈中的高级调用方授予访问该资源的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="53bbd-108">Asserts that the calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53bbd-109">调用<xref:System.Security.IStackWalk.Assert%2A>停止调用堆栈中的高级调用方的权限检查。</span><span class="sxs-lookup"><span data-stu-id="53bbd-109">Calling <xref:System.Security.IStackWalk.Assert%2A> stops the permission check on callers higher in the call stack.</span></span> <span data-ttu-id="53bbd-110">因此，即使这些调用方没有必需的权限，仍可以访问资源。</span><span class="sxs-lookup"><span data-stu-id="53bbd-110">Therefore, even if these callers do not have the requisite permissions, they can still access resources.</span></span> <span data-ttu-id="53bbd-111">断言是仅当该代码调用有效<xref:System.Security.IStackWalk.Assert%2A>传递断言的权限的安全检查。</span><span class="sxs-lookup"><span data-stu-id="53bbd-111">An assertion is effective only if the code that calls <xref:System.Security.IStackWalk.Assert%2A> passes the security check for the permission that it is asserting.</span></span>  
  
 <span data-ttu-id="53bbd-112">调用<xref:System.Security.IStackWalk.Assert%2A>之前调用代码返回给调用方或直到的后续调用均有效<xref:System.Security.IStackWalk.Assert%2A>呈现上一个断言无效。</span><span class="sxs-lookup"><span data-stu-id="53bbd-112">A call to <xref:System.Security.IStackWalk.Assert%2A> is effective until the calling code returns to its caller or until a subsequent call to <xref:System.Security.IStackWalk.Assert%2A> renders the previous assertion ineffective.</span></span> <span data-ttu-id="53bbd-113">此外，<xref:System.Security.CodeAccessPermission.RevertAssert%2A>或<xref:System.Security.CodeAccessPermission.RevertAll%2A>中移除挂起<xref:System.Security.IStackWalk.Assert%2A>。</span><span class="sxs-lookup"><span data-stu-id="53bbd-113">Also, <xref:System.Security.CodeAccessPermission.RevertAssert%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> removes a pending <xref:System.Security.IStackWalk.Assert%2A>.</span></span>  
  
 <span data-ttu-id="53bbd-114"><xref:System.Security.IStackWalk.Assert%2A> 将忽略不授予，因为对该权限的请求将不会成功的权限。</span><span class="sxs-lookup"><span data-stu-id="53bbd-114"><xref:System.Security.IStackWalk.Assert%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="53bbd-115">但是，如果调用堆栈上的低级代码调用<xref:System.Security.IStackWalk.Demand%2A>对该权限<xref:System.Security.SecurityException>堆栈遍历到达尝试调用的代码时引发<xref:System.Security.IStackWalk.Assert%2A>。</span><span class="sxs-lookup"><span data-stu-id="53bbd-115">However, if code lower on the call stack calls <xref:System.Security.IStackWalk.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.IStackWalk.Assert%2A>.</span></span> <span data-ttu-id="53bbd-116">这是因为该调用的代码<xref:System.Security.IStackWalk.Assert%2A>未被授予权限，即使它试图<xref:System.Security.IStackWalk.Assert%2A>它。</span><span class="sxs-lookup"><span data-stu-id="53bbd-116">This happens because the code that called <xref:System.Security.IStackWalk.Assert%2A> has not been granted the permission, even though it tried to <xref:System.Security.IStackWalk.Assert%2A> it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="53bbd-117">因为调用<xref:System.Security.IStackWalk.Assert%2A>删除调用链中的所有代码的要求必须被授予访问指定的资源的权限，它可以打开安全漏洞，如果使用不当。</span><span class="sxs-lookup"><span data-stu-id="53bbd-117">Because calling <xref:System.Security.IStackWalk.Assert%2A> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security vulnerabilities if used incorrectly or inappropriately.</span></span> <span data-ttu-id="53bbd-118">因此，它应非常小心地使用。</span><span class="sxs-lookup"><span data-stu-id="53bbd-118">Therefore, it should be used with great caution.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="53bbd-119">调用代码没有 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="53bbd-119">The calling code does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/framework/misc/using-the-assert-method.md">
          <span data-ttu-id="53bbd-120">使用 Assert 方法</span>
          <span class="sxs-lookup">
            <span data-stu-id="53bbd-120">Using the Assert Method</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit" Usage="iStackWalk.Demand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="53bbd-121">在运行时确定调用堆栈中的所有调用方是否已被授予当前权限对象所指定的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="53bbd-121">Determines at run time whether all callers in the call stack have been granted the permission specified by the current permission object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53bbd-122">安全库通常使用此方法以确保调用方有权访问的资源。</span><span class="sxs-lookup"><span data-stu-id="53bbd-122">This method is typically used by secure libraries to ensure that callers have permission to access a resource.</span></span> <span data-ttu-id="53bbd-123">例如，安全类库中的文件类调用<xref:System.Security.IStackWalk.Demand%2A>为必需<xref:System.Security.Permissions.FileIOPermission>之前执行由调用方请求的文件操作。</span><span class="sxs-lookup"><span data-stu-id="53bbd-123">For example, a file class in a secure class library calls <xref:System.Security.IStackWalk.Demand%2A> for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller.</span></span>  
  
 <span data-ttu-id="53bbd-124">调用此方法的代码的权限不会检查;检查开始从该代码的直接调用方，并且在堆栈中向上继续进行。</span><span class="sxs-lookup"><span data-stu-id="53bbd-124">The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</span></span> <span data-ttu-id="53bbd-125"><xref:System.Security.IStackWalk.Demand%2A> 仅当没有<xref:System.Security.SecurityException>引发。</span><span class="sxs-lookup"><span data-stu-id="53bbd-125"><xref:System.Security.IStackWalk.Demand%2A> succeeds only if no <xref:System.Security.SecurityException> is raised.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="53bbd-126">调用堆栈中处于较高位置的调用方不具有当前权限对象所指定的权限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="53bbd-126">A caller higher in the call stack does not have the permission specified by the current permission object.</span>
          </span>
          <span data-ttu-id="53bbd-127">或</span>
          <span class="sxs-lookup">
            <span data-stu-id="53bbd-127">-or-</span>
          </span>
          <span data-ttu-id="53bbd-128">调用堆栈中的调用方已经对当前权限对象调用了 <see cref="M:System.Security.IStackWalk.Deny" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="53bbd-128">A caller in the call stack has called <see cref="M:System.Security.IStackWalk.Deny" /> on the current permission object.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Deny();" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit" Usage="iStackWalk.Deny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="53bbd-129">将导致通过调用代码传递的当前对象的每个 <see cref="M:System.Security.IStackWalk.Demand" /> 失败。</span>
          <span class="sxs-lookup">
            <span data-stu-id="53bbd-129">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for the current object that passes through the calling code to fail.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53bbd-130">此方法会阻止调用堆栈中的高级调用方通过调用此方法的代码访问受保护的资源，即使这些调用方已被授予权限来访问它。</span><span class="sxs-lookup"><span data-stu-id="53bbd-130">This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</span></span> <span data-ttu-id="53bbd-131">调用堆栈通常表示为向下增长，因此的调用堆栈中调用方法中较低的调用堆栈。</span><span class="sxs-lookup"><span data-stu-id="53bbd-131">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="53bbd-132"><xref:System.Security.IStackWalk.Deny%2A> 可以限制程序员的责任或帮助防止出现意外的安全漏洞，因为它有助于防止调用的方法<xref:System.Security.IStackWalk.Deny%2A>被用来访问被拒绝的权限所保护的资源。</span><span class="sxs-lookup"><span data-stu-id="53bbd-132"><xref:System.Security.IStackWalk.Deny%2A> can limit the liability of the programmer or help prevent accidental security vulnerabilities because it helps prevent the method that calls <xref:System.Security.IStackWalk.Deny%2A> from being used to access the resource protected by the denied permission.</span></span> <span data-ttu-id="53bbd-133">如果一个方法调用<xref:System.Security.IStackWalk.Deny%2A>对权限，并且如果<xref:System.Security.IStackWalk.Demand%2A>的调用堆栈中较低级别的调用方调用该权限，该安全检查将失败时达到<xref:System.Security.IStackWalk.Deny%2A>。</span><span class="sxs-lookup"><span data-stu-id="53bbd-133">If a method calls <xref:System.Security.IStackWalk.Deny%2A> on a permission, and if a <xref:System.Security.IStackWalk.Demand%2A> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <xref:System.Security.IStackWalk.Deny%2A>.</span></span>  
  
 <span data-ttu-id="53bbd-134"><xref:System.Security.IStackWalk.Deny%2A> 将忽略不授予，因为对该权限的请求将不会成功的权限。</span><span class="sxs-lookup"><span data-stu-id="53bbd-134"><xref:System.Security.IStackWalk.Deny%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="53bbd-135">不能重写此方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="53bbd-135">You cannot override this method.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PermitOnly();" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit" Usage="iStackWalk.PermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="53bbd-136">导致除当前对象（通过调用代码来传递）以外的所有对象的每个 <see cref="M:System.Security.IStackWalk.Demand" /> 失败，即使调用堆栈中的高级代码已被授权访问其他资源也是如此。</span>
          <span class="sxs-lookup">
            <span data-stu-id="53bbd-136">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for all objects except the current one that passes through the calling code to fail, even if code higher in the call stack has been granted permission to access other resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53bbd-137"><xref:System.Security.IStackWalk.PermitOnly%2A> 类似于<xref:System.Security.IStackWalk.Deny%2A>，同时会导致堆栈审核失败时它们原本应该成功。</span><span class="sxs-lookup"><span data-stu-id="53bbd-137"><xref:System.Security.IStackWalk.PermitOnly%2A> is similar to <xref:System.Security.IStackWalk.Deny%2A>, in that both cause stack walks to fail when they would otherwise succeed.</span></span> <span data-ttu-id="53bbd-138">不同之处在于<xref:System.Security.IStackWalk.Deny%2A>指定将导致失败，则堆栈审核的权限，但<xref:System.Security.IStackWalk.PermitOnly%2A>指定唯一的权限，但不会导致堆栈审核失败。</span><span class="sxs-lookup"><span data-stu-id="53bbd-138">The difference is that <xref:System.Security.IStackWalk.Deny%2A> specifies permissions that will cause the stack walk to fail, but <xref:System.Security.IStackWalk.PermitOnly%2A> specifies the only permissions that do not cause the stack walk to fail.</span></span> <span data-ttu-id="53bbd-139">调用此方法，以确保你的代码可以用于访问指定的资源。</span><span class="sxs-lookup"><span data-stu-id="53bbd-139">Call this method to ensure that your code can be used to access only the specified resources.</span></span>  
  
 <span data-ttu-id="53bbd-140"><xref:System.Security.IStackWalk.PermitOnly%2A> 将忽略不授予，因为对该权限的请求将不会成功的权限。</span><span class="sxs-lookup"><span data-stu-id="53bbd-140"><xref:System.Security.IStackWalk.PermitOnly%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="53bbd-141">但是，如果在调用的低级代码堆栈更高版本调用<xref:System.Security.IStackWalk.Demand%2A>对该权限<xref:System.Security.SecurityException>堆栈遍历到达尝试调用的代码时引发<xref:System.Security.IStackWalk.PermitOnly%2A>。</span><span class="sxs-lookup"><span data-stu-id="53bbd-141">However, if code lower on the call stack later calls <xref:System.Security.IStackWalk.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.IStackWalk.PermitOnly%2A>.</span></span> <span data-ttu-id="53bbd-142">这是因为该调用的代码<xref:System.Security.IStackWalk.PermitOnly%2A>未被授予权限，即使它调用<xref:System.Security.IStackWalk.PermitOnly%2A>对该权限。</span><span class="sxs-lookup"><span data-stu-id="53bbd-142">This is because the code that called <xref:System.Security.IStackWalk.PermitOnly%2A> has not been granted the permission, even though it called <xref:System.Security.IStackWalk.PermitOnly%2A> for that permission.</span></span> <span data-ttu-id="53bbd-143">调用堆栈通常表示为向下增长，因此的调用堆栈中调用方法中较低的调用堆栈。</span><span class="sxs-lookup"><span data-stu-id="53bbd-143">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>