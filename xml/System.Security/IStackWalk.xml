<Type Name="IStackWalk" FullName="System.Security.IStackWalk">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b37ff083eff27618aa07c0a744562f3f8a613708" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30499161" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.IStackWalk" />
  <TypeSignature Language="VB.NET" Value="Public Interface IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public interface class IStackWalk" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>用于管理堆栈遍历，此堆栈遍历可确定调用堆栈中的所有调用函数是否具有访问受保护资源的所需权限。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 部分受信任的代码始终带来安全风险。 有时操作可以代表有权访问的资源的恶意代码执行操作。 这种方式，恶意代码可以获得更高版本的安全访问权限，不应允许它。  
  
 公共语言运行时可帮助保护免受这些攻击的托管的代码，通过运行上的所有调用的堆栈审核。 堆栈审核要求调用堆栈中的所有代码都有权访问受保护的资源。 因为尝试进行攻击的代码始终调用堆栈中的某个地方，它将不能超过其自己的安全权限。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Assert();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>断言调用代码可以访问当前权限对象所标识的资源，即使尚未对堆栈中的高级调用方授予访问该资源的权限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用<xref:System.Security.IStackWalk.Assert%2A>停止对调用堆栈中的高级调用方的权限检查。 因此，即使这些调用方没有所需的权限，它们仍可以访问资源。 断言是仅当调用的代码的有效<xref:System.Security.IStackWalk.Assert%2A>将传递它断言的权限的安全检查。  
  
 调用<xref:System.Security.IStackWalk.Assert%2A>之前调用的代码返回到其调用方或之前的后续调用均有效<xref:System.Security.IStackWalk.Assert%2A>呈现前一个断言无效。 此外，<xref:System.Security.CodeAccessPermission.RevertAssert%2A>或<xref:System.Security.CodeAccessPermission.RevertAll%2A>中移除挂起<xref:System.Security.IStackWalk.Assert%2A>。  
  
 <xref:System.Security.IStackWalk.Assert%2A> 对于未授予对该权限的请求将不会成功的权限，将忽略。 但是，如果调用堆栈上较低的代码调用<xref:System.Security.IStackWalk.Demand%2A>对该权限<xref:System.Security.SecurityException>堆栈审核达到尝试调用代码时，将引发<xref:System.Security.IStackWalk.Assert%2A>。 这是因为代码调用<xref:System.Security.IStackWalk.Assert%2A>未被授予权限，即使它尝试<xref:System.Security.IStackWalk.Assert%2A>它。  
  
> [!CAUTION]
>  因为调用<xref:System.Security.IStackWalk.Assert%2A>中删除所有代码调用链中的要求必须授予访问指定的资源的权限，如果使用不当会暴露安全性漏洞。 因此，它应谨慎使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用代码没有 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在运行时确定调用堆栈中的所有调用方是否已被授予当前权限对象所指定的权限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 安全库通常使用此方法以确保调用方有权访问的资源。 例如，安全类库中的文件类调用<xref:System.Security.IStackWalk.Demand%2A>为所需<xref:System.Security.Permissions.FileIOPermission>之前执行由调用方请求的文件操作。  
  
 调用此方法的代码的权限不会检查;检查开始从该代码的直接调用方，并在堆栈中向上继续进行。 <xref:System.Security.IStackWalk.Demand%2A> 如果未成功<xref:System.Security.SecurityException>引发。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用堆栈中处于较高位置的调用方不具有当前权限对象所指定的权限。  
  
 或  
  
 调用堆栈中的调用方已经对当前权限对象调用了 <see cref="M:System.Security.IStackWalk.Deny" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Deny();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将导致通过调用代码传递的当前对象的每个 <see cref="M:System.Security.IStackWalk.Demand" /> 失败。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法会阻止调用堆栈中的高级调用方通过调用此方法的代码，访问受保护的资源，即使这些调用方已被授予权限来访问它。 调用堆栈通常表示为向下增长，以便对调用堆栈中调用方法中较低的调用堆栈。  
  
 <xref:System.Security.IStackWalk.Deny%2A> 可以限制了编程人员的责任或帮助防止出现意外的安全漏洞，因为它有助于防止调用的方法<xref:System.Security.IStackWalk.Deny%2A>从用于访问被拒绝的权限所保护的资源。 如果一个方法调用<xref:System.Security.IStackWalk.Deny%2A>对权限，并且如果<xref:System.Security.IStackWalk.Demand%2A>到达时，该安全检查为该权限调用方的调用堆栈中较低级别调用，将会失败<xref:System.Security.IStackWalk.Deny%2A>。  
  
 <xref:System.Security.IStackWalk.Deny%2A> 对于未授予对该权限的请求将不会成功的权限，将忽略。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>不能重写此方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PermitOnly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>导致除当前对象（通过调用代码来传递）以外的所有对象的每个 <see cref="M:System.Security.IStackWalk.Demand" /> 失败，即使调用堆栈中的高级代码已被授权访问其他资源也是如此。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.IStackWalk.PermitOnly%2A> 类似于<xref:System.Security.IStackWalk.Deny%2A>，因为同时导致堆栈审核失败时它们原本应该成功。 差异在于<xref:System.Security.IStackWalk.Deny%2A>指定权限将导致堆栈审核失败，但<xref:System.Security.IStackWalk.PermitOnly%2A>指定不会导致堆栈审核失败的唯一权限。 调用此方法，以确保你的代码可以用于访问指定的资源。  
  
 <xref:System.Security.IStackWalk.PermitOnly%2A> 对于未授予对该权限的请求将不会成功的权限，将忽略。 但是，如果在调用的低级代码堆栈更高版本调用<xref:System.Security.IStackWalk.Demand%2A>对该权限<xref:System.Security.SecurityException>堆栈审核达到尝试调用代码时，将引发<xref:System.Security.IStackWalk.PermitOnly%2A>。 这是因为代码调用<xref:System.Security.IStackWalk.PermitOnly%2A>未被授予权限，即使它调用<xref:System.Security.IStackWalk.PermitOnly%2A>对该权限。 调用堆栈通常表示为向下增长，以便对调用堆栈中调用方法中较低的调用堆栈。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>