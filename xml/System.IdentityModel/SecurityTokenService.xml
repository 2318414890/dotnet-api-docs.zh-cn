<Type Name="SecurityTokenService" FullName="System.IdentityModel.SecurityTokenService">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3072d0bfe35d86653ef23ec20b08a5f210b357ba" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30420351" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SecurityTokenService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.SecurityTokenService" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenService" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenService abstract" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>定义安全令牌服务 (STS) 的属性和方法的抽象基类。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要创建的 STS 必须派生自<xref:System.IdentityModel.SecurityTokenService>类。 在你自定义类必须在最低限度上，重写<xref:System.IdentityModel.SecurityTokenService.GetScope%2A>和<xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A>方法。 通过这些重写，使用的类中定义的所有其他方法的默认实现创建 STS 是能够颁发安全令牌来响应安全令牌请求 (RST)。 即，实现 Ws-trust 规范中定义的问题绑定。 在中实现此绑定<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法。 默认情况下实现的任何其他 WS 信任绑定 （续订、 取消和验证） 和相应的错误返回给调用方，如果遇到 RST 对应的这些绑定之一。 当然，可以重写适当的方法 (<xref:System.IdentityModel.SecurityTokenService.Renew%2A>， <xref:System.IdentityModel.SecurityTokenService.Cancel%2A>，和<xref:System.IdentityModel.SecurityTokenService.Validate%2A>) 在 STS 中实施这些绑定。  
  
> [!IMPORTANT]
>  实现生产就绪 STS 需要仔细的规划和相当多的资源来缓解潜在的安全风险固有在公开此类服务。 使用 Windows Identity Foundation (WIF) 的大多数开发人员将开发外包到 STS，标识管理的应用程序而不是本身开发 STS。 WIF 提供了一个 Visual Studio 扩展，标识和访问工具对于 Visual Studio 2012，以帮助开发人员在开发环境中测试解决方案。 此工具包含 STS， `LocalSTS`，你可以对其进行配置以提供到你正在开发的应用程序的特定声明。 有关标识和访问工具的详细信息，请参阅[标识和访问工具用于 Visual Studio 2012](~/docs/framework/security/identity-and-access-tool-for-vs.md)。 在某些情况下，`LocalSTS`可能无法提供充分测试你的应用程序所必需的功能; 例如，在涉及的方案中开发应用程序使用的自定义令牌处理程序。 在这些情况下，你可以派生自<xref:System.IdentityModel.SecurityTokenService>创建一个或多个简单 Sts，可以在开发环境中部署并可用来在你的应用程序中测试此类功能。 本部分的其余部分侧重于通过公开的方法<xref:System.IdentityModel.SecurityTokenService>可用于实现简单的 STS 和扩展令牌颁发管道的类。  
  
 以下列表提供最为重要的方法的简要概述向开发人员在测试或开发环境中使用。  
  
-   <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> 方法。 此方法返回<xref:System.IdentityModel.Scope>包含 RP 有关的信息的对象。 此对象使用的令牌发出管道的其余部分中，并包含有关签名和加密凭据以在响应中，使用信息以及`AppliesTo`和`ReplyTo`（如果需要） 地址。 你必须重写此方法。  
  
-   <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> 方法。 此方法返回<xref:System.Security.Claims.ClaimsIdentity>包含要返回到 RP 的声明的对象。 你必须重写此方法。  
  
-   <xref:System.IdentityModel.SecurityTokenService.Issue%2A> 方法。 此方法实现令牌请求管道，后者处理传入安全令牌请求 (RST) 并返回包含一个令牌，可用于使用 RP 进行身份验证调用方的响应 (RSTR)。 其他方法中定义的许多<xref:System.IdentityModel.SecurityTokenService>类调用此方法，包括<xref:System.IdentityModel.SecurityTokenService.GetScope%2A>和<xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A>方法。 无需重写此方法，但它实现令牌请求管道了解可能很有帮助。  
  
 通过配置 STS<xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration>类。  
  
   
  
## Examples  
 在中使用的代码示例<xref:System.IdentityModel.SecurityTokenService>主题，将从`Custom Token`示例。 此示例提供使处理的简单 Web 令牌 (SWT) 的自定义类，并包括一个实现被动 STS，能够为提供服务的 SWT 令牌。 有关如何实现活动 STS 的示例，你可以参阅`Federation Metadata`示例。 有关这些示例和信息提供其他示例的 WIF 和有关从哪里下载它们，请参阅[WIF 代码示例索引](~/docs/framework/security/wif-code-sample-index.md)。 下面的代码演示被动 STS 的实现使用<xref:System.IdentityModel.SecurityTokenService>类。  
  
 [!code-csharp[WIFCustomTokenSTS#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#3)]  
  
 下面的代码演示如何调用自定义的被动 STS 处理 WS 联合身份验证请求，通过调用<xref:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations.ProcessRequest%28System.Web.HttpRequest%2CSystem.Security.Claims.ClaimsPrincipal%2CSystem.IdentityModel.SecurityTokenService%2CSystem.Web.HttpResponse%29?displayProperty=nameWithType>方法中的代码后面`default.aspx.cs`文件。  
  
 [!code-csharp[WIFCustomTokenSTS#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/default.aspx.cs#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>你必须重写二者<see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />和<see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />方法。</para>
    </block>
    <altmember cref="T:System.IdentityModel.Scope" />
    <altmember cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
    <altmember cref="T:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenService (System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.#ctor(System.IdentityModel.Configuration.SecurityTokenServiceConfiguration)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenService(System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ securityTokenServiceConfiguration);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="securityTokenServiceConfiguration" Type="System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
      </Parameters>
      <Docs>
        <param name="securityTokenServiceConfiguration">一个 <see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />，包含 STS 设置。</param>
        <summary>已从派生的类中调用，以使用指定的配置设置初始化 <see cref="T:System.IdentityModel.SecurityTokenService" /> 类。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此构造函数初始化范围提供程序和令牌颁发者证书。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="securityTokenServiceConfiguration" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginCancel">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginCancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginCancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginCancel (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginCancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">一个 <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示令牌请求者的标识。</param>
        <param name="request">一个 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全令牌请求。 这包括请求消息和其他客户端相关信息，如授权上下文。</param>
        <param name="callback">接收异步取消操作完成通知的 <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">一个包含与异步取消操作关联的状态信息的对象。</param>
        <summary>在派生类中重写时，开始异步 WS 信任取消请求。</summary>
        <returns>引用异步取消操作的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认实现将引发<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">一个 <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示令牌请求者的标识。</param>
        <param name="request">一个 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全令牌请求。 这包括请求消息和其他客户端相关信息，如授权上下文。</param>
        <param name="scope">包含与请求相关的依赖放的信息的 <see cref="T:System.IdentityModel.Scope" />。</param>
        <param name="callback">接收异步操作完成通知的 <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">一个包含与异步操作关联的状态信息的对象。</param>
        <summary>当在派生类中重写时，开始对 <see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" /> 方法的异步调用。</summary>
        <returns>引用异步操作的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认实现将引发<xref:System.NotImplementedException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetScope">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function BeginGetScope (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">一个 <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示令牌请求者的标识。</param>
        <param name="request">一个 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全令牌请求。 这包括请求消息和其他客户端相关信息，如授权上下文。</param>
        <param name="callback">接收异步操作完成通知的 <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">一个包含与异步操作关联的状态信息的对象。</param>
        <summary>当在派生类中重写时，开始对 <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> 方法的异步调用。</summary>
        <returns>引用异步取消操作的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认实现将引发<xref:System.NotImplementedException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginIssue">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginIssue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginIssue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginIssue (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginIssue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">一个 <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示令牌请求者的标识。</param>
        <param name="request">一个 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全令牌请求。 这包括请求消息和其他客户端相关信息，如授权上下文。</param>
        <param name="callback">接收异步问题操作完成通知的 <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">一个包含与异步发布操作关联的状态信息的对象。</param>
        <summary>在派生类中重写时，开始异步 WS 信任发布请求。</summary>
        <returns>引用异步问题操作的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认实现将引发<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenew">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRenew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRenew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginRenew (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginRenew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">一个 <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示令牌请求者的标识。</param>
        <param name="request">一个 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全令牌请求。 这包括请求消息和其他客户端相关信息，如授权上下文。</param>
        <param name="callback">接收异步续预定操作完成通知的 <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">一个包含与异步续订操作关联的状态信息的对象。</param>
        <summary>在派生类中重写时，开始异步 WS 信任更新请求。</summary>
        <returns>引用异步续订操作的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认实现将引发<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginValidate">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginValidate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginValidate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginValidate (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginValidate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">一个 <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示令牌请求者的标识。</param>
        <param name="request">一个 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全令牌请求。 这包括请求消息和其他客户端相关信息，如授权上下文。</param>
        <param name="callback">可接收异步验证操作完成通知的 <see cref="T:System.AsyncCallback" /> 委托。</param>
        <param name="state">一个包含与异步验证操作关联的状态信息的对象。</param>
        <summary>在派生类中重写时，开始异步 WS 信任验证请求。</summary>
        <returns>引用异步验证操作的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认实现将引发<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Cancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Cancel (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Cancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">一个 <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示令牌请求者的标识。</param>
        <param name="request">一个 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全令牌请求。 这包括请求消息和其他客户端相关信息，如授权上下文。</param>
        <summary>在派生类中重写时，处理 WS 信任取消请求。</summary>
        <returns>表示 RSTR 返回到调用程序的 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认实现将引发<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenDescriptor ^ CreateSecurityTokenDescriptor(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">传入令牌请求。</param>
        <param name="scope">从 <see cref="P:System.IdentityModel.SecurityTokenService.Scope" /> 中返回的 <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> 对象.</param>
        <summary>创建 <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" /> 的实例。</summary>
        <returns>
          <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在后的令牌颁发过程中调用<xref:System.IdentityModel.SecurityTokenService.GetScope%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="scope" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndCancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndCancel(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndCancel (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndCancel(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，由对 <see cref="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> 方法的调用返回。</param>
        <summary>在派生类中重写时，完成异步 WS 信任取消请求。</summary>
        <returns>表示 RSTR 返回到调用程序的 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认实现将引发<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetOutputClaimsIdentity(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetOutputClaimsIdentity (result As IAsyncResult) As ClaimsIdentity" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Security::Claims::ClaimsIdentity ^ EndGetOutputClaimsIdentity(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，由对 <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" /> 方法的调用返回。</param>
        <summary>当在派生类中重写时，完成对 <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" /> 方法的异步调用。</summary>
        <returns>
          <see cref="T:System.Security.Claims.ClaimsIdentity" /> 包含放置在发布的安全标志上的声明的集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认实现将引发<xref:System.NotImplementedException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetScope">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Scope EndGetScope (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope EndGetScope(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetScope(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetScope (result As IAsyncResult) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Scope ^ EndGetScope(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，由对 <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> 方法的调用返回。</param>
        <summary>当在派生类中重写时，完成对 <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> 方法的异步调用。</summary>
        <returns>
          <see cref="T:System.IdentityModel.Scope" /> 封装在对 <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> 方法的调用中指定的与请求 (RST) 关联的依赖方 (RP) 信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认实现将引发<xref:System.NotImplementedException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndIssue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndIssue(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndIssue (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndIssue(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，由对 <see cref="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> 方法的调用返回。</param>
        <summary>在派生类中重写时，完成异步 WS 信任发布请求。</summary>
        <returns>表示 RSTR 返回到调用程序的 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认实现将引发<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRenew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndRenew(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndRenew (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndRenew(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，由对 <see cref="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> 方法的调用返回。</param>
        <summary>在派生类中重写时，完成异步 WS 信任更新请求。</summary>
        <returns>表示 RSTR 返回到调用程序的 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认实现将引发<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndValidate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndValidate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndValidate (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndValidate(IAsyncResult ^ result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" />，由对 <see cref="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> 方法的调用返回。</param>
        <summary>在派生类中重写时，完成异步 WS 信任验证请求。</summary>
        <returns>表示 RSTR 返回到调用程序的 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认实现将引发<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIssuerName">
      <MemberSignature Language="C#" Value="protected virtual string GetIssuerName ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetIssuerName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetIssuerName" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetIssuerName () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetIssuerName();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取或设置安全标记服务的 （STS） 的名称。</summary>
        <returns>发行人名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从默认的令牌颁发管道实现中调用此方法<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法。  
  
 默认实现返回<xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.TokenIssuerName%2A>从通过访问的配置属性<xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A>属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected abstract System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Security::Claims::ClaimsIdentity ^ GetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="principal">一个 <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示令牌请求者的标识。</param>
        <param name="request">一个 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全令牌请求。 这包括请求消息和其他客户端相关信息，如授权上下文。</param>
        <param name="scope">包含与请求相关的依赖放的信息的 <see cref="T:System.IdentityModel.Scope" />。 作为 <see cref="T:System.IdentityModel.Scope" /> 方法的 <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />参数返回的对象。</param>
        <summary>当在派生类中重写时，此方法将返回要包括在颁发令牌中的输出主题的集合。</summary>
        <returns>
          <see cref="T:System.Security.Claims.ClaimsIdentity" /> 包含放置在发布的安全标志上的声明的集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A>方法调用从令牌颁发管道，由实现<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法。 它将返回<xref:System.Security.Claims.ClaimsIdentity>，包含要包含在基于令牌请求者颁发的安全令牌中的声明 (`principal`参数)，传入的 RST (`request`参数)，并且该标记是为其信赖方应 （`scope`参数)。 此方法中的逻辑主要关心的回答以下问题：  
  
-   **哪种声明类型应包含在基于所针对的 RP 响应？** 这通常通过检查决定每个 RP 根据从列表中的所需的每个 RP 的声明类型或基于每个请求<xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.Claims%2A>的请求的属性。 但是的逻辑和用于确定要在响应中包含的声明的详细信息负责完全实现。  
  
-   **哪种声明值应分配到响应中的声明？** 对于标识提供程序 (IP STS)，这通常意味着在请求者的使用一个或多个声明<xref:System.Security.Claims.ClaimsPrincipal>(由`principal`参数) 来访问应用商店 （或其他实体） 以返回所需的声明类型的值。 对于联合身份验证提供程序 (R STS)，这通常意味着对请求者的传入声明，从而满足请求; 执行某种类型的处理可能对提供者，同时传递其他通过未修改某些声明执行筛选或转换。 当然，如下所示决定要在响应中包含的声明的情况下，在详细信息和如何确定这些声明的值的逻辑负责你的实现。  
  
   
  
## Examples  
 本主题中使用的代码示例摘自`Custom Token`示例。 此示例提供使处理的简单 Web 令牌 (SWT) 的自定义类，并包括一个实现被动 STS，能够为提供服务的 SWT 令牌。 有关如何实现活动 STS 的示例，你可以参阅`Federation Metadata`示例。 有关这些示例和信息提供其他示例的 WIF 和有关从哪里下载它们，请参阅[WIF 代码示例索引](~/docs/framework/security/wif-code-sample-index.md)。 下面的代码演示如何重写<xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A>方法以返回声明的 STS。 在此示例中，则忽略此请求安全令牌 (RST) 消息和返回的基于用户，在 STS 进行身份验证的声明的集合。  
  
 [!code-csharp[WIFCustomTokenSTS#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>实现该 <see cref="T:System.IdentityModel.SecurityTokenService" /> 类时，必须重写此方法。</para>
        </block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetProofToken">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.ProofDescriptor GetProofToken (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.ProofDescriptor GetProofToken(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetProofToken(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::ProofDescriptor ^ GetProofToken(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.ProofDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> 表示传入标记请求 (RST)。</param>
        <param name="scope">封装有关该依赖的一方的信息的 <see cref="T:System.IdentityModel.Scope" /> 实例。</param>
        <summary>获取要包含在响应（RETR) 内的证明标记。</summary>
        <returns>一个 <see cref="T:System.IdentityModel.Tokens.ProofDescriptor" />，表示新建的证明说明符。 在持有者令牌情况下，证明描述符可以是非对称证明描述符、一个对称证明描述符或 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从默认的令牌颁发管道实现中调用此方法<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法。  
  
 默认实现返回校验描述符或引发适当的异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> 为 <see langword="null" />。  
  
 或  
  
 <paramref name="scope" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetRequestorProofEncryptingCredentials">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetRequestorProofEncryptingCredentials(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRequestorProofEncryptingCredentials (request As RequestSecurityToken) As EncryptingCredentials" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::EncryptingCredentials ^ GetRequestorProofEncryptingCredentials(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.EncryptingCredentials</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> 表示传入标记请求 (RST)。</param>
        <summary>获取请求者的标记加密凭据。</summary>
        <returns>表示请求者的加密凭据的 <see cref="T:System.IdentityModel.Tokens.EncryptingCredentials" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法调用从<xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A>方法。  
  
 默认实现执行以下操作。 返回`null`不是否有任何请求中指定的加密令牌 (<xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.ProofEncryption%2A?displayProperty=nameWithType>属性是`null`)。 否则为如果它可以获取作为令牌<xref:System.IdentityModel.Tokens.X509SecurityToken>，它将返回基于该令牌的凭据。 如果无法解析作为令牌<xref:System.IdentityModel.Tokens.X509SecurityToken>、<xref:System.IdentityModel.RequestFailedException>引发。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetResponse(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResponse (request As RequestSecurityToken, tokenDescriptor As SecurityTokenDescriptor) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ GetResponse(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="request">包含令牌请求的 RST。</param>
        <param name="tokenDescriptor">令牌描述符包含要用于颁发的令牌的信息。</param>
        <summary>创建响应 (RSTR)，它包含使用指定请求 (RST) 和安全令牌描述符颁发的令牌。</summary>
        <returns>响应 (RSTR) 或 <see langword="null" />（如果无法从指定请求和令牌描述符创建响应）。 默认实现返回 <see langword="null" />（如果 <paramref name="tokenDescriptor" /> 参数为 <see langword="null" />）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A>从令牌颁发管道，由实现，最后一步调用方法，则<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法。 它创建，并通过使用原始的传入请求 (RST) 和令牌颁发管道中的上一个步骤期间建立的令牌描述符返回响应 (RSTR)。  
  
 默认实现将通过将传入的请求参数中指定 RST 创建 RSTR<xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse.%23ctor%28System.IdentityModel.Protocols.WSTrust.WSTrustMessage%29?displayProperty=nameWithType>构造函数中，调用<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.ApplyTo%2A?displayProperty=nameWithType>方法令牌描述符传递给<xref:System.IdentityModel.SecurityTokenService.GetResponse%2A>将其属性设置为新创建 RSTR，设置<xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.AppliesTo%2A>属性使用 RSTR<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A>令牌描述符，属性和最后设置<xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A>上按下表 RSTR 属性：  
  
|`RST.ReplyTo` 属性|<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType> 属性。|`RSTR.ReplyTo` 属性|  
|----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|Set|未设置|未设置|  
|Set|Set|<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType>|  
|未设置|Set|未设置|  
|未设置|未设置|未设置|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetScope">
      <MemberSignature Language="C#" Value="protected abstract System.IdentityModel.Scope GetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope GetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScope (principal As ClaimsPrincipal, request As RequestSecurityToken) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IdentityModel::Scope ^ GetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">一个 <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示客户发出请求。</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> 表示传入请求 (RST)。</param>
        <summary>获取包含与指定请求（RST）关联的依赖方（RP）信息的 <see cref="T:System.IdentityModel.Scope" /> 对象。 实现该 <see cref="T:System.IdentityModel.SecurityTokenService" /> 类时，必须重写此方法。</summary>
        <returns>
          <see cref="T:System.IdentityModel.Scope" /> 封装与请求关联的 RP 信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>从令牌颁发管道后调用方法<xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A>方法，应返回<xref:System.IdentityModel.Scope>为传入的请求配置的对象。 (在中实现令牌颁发管道<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法。)<xref:System.IdentityModel.Scope>对象封装有关 RP 与安全令牌请求 (RST) 相关联的信息。 这包括有关要用于 RP 和加密任何已颁发的令牌和/或响应中的对称密钥的加密和签名凭据的信息。 在中执行一些典型任务<xref:System.IdentityModel.SecurityTokenService.GetScope%2A>方法是：  
  
-   确定令牌所针对的 RP 是否识别的 RP。 如何完成此操作取决于您的实现。 如果预期的 RP 不是此 STS 有效 RP，则该方法应引发<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
-   确定要用于响应 (RSTR) 和设置的签名凭据<xref:System.IdentityModel.Scope.SigningCredentials%2A>属性相应地。  
  
-   确定是否应加密响应和/或任何包含的对称密钥以及要用于加密的凭据。 设置<xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A>， <xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A>，和<xref:System.IdentityModel.Scope.EncryptingCredentials%2A>属性相应地。  
  
    > [!IMPORTANT]
    >  默认情况下，<xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A>和<xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A>属性设置`true`以防止 STS 颁发是不安全的令牌。 建议永远不会设置这些属性`false`在生产环境中。  
  
-   确定应返回响应的地址。 设置<xref:System.IdentityModel.Scope.AppliesToAddress%2A>或<xref:System.IdentityModel.Scope.ReplyToAddress%2A>属性相应地。  
  
   
  
## Examples  
 本主题中使用的代码示例摘自`Custom Token`示例。 此示例提供使处理的简单 Web 令牌 (SWT) 的自定义类，并包括一个实现被动 STS，能够为提供服务的 SWT 令牌。 有关如何实现活动 STS 的示例，你可以参阅`Federation Metadata`示例。 有关这些示例和信息提供其他示例的 WIF 和有关从哪里下载它们，请参阅[WIF 代码示例索引](~/docs/framework/security/wif-code-sample-index.md)。  
  
 下面的代码示例演示 <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> 方法的实现。 此实现验证，RP 识别的 STS，验证<xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A>地址中的请求和集<xref:System.IdentityModel.Scope.ReplyToAddress%2A?displayProperty=nameWithType>属性相应地，并设置进行签名和加密凭据将用于 RP 根据证书在文件中采用硬编码。  
  
 [!code-csharp[WIFCustomTokenSTS#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#4)]  
[!code-csharp[WIFCustomTokenSTS#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#5)]  
[!code-csharp[WIFCustomTokenSTS#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>实现该 <see cref="T:System.IdentityModel.SecurityTokenService" /> 类时，必须重写此方法。</para>
        </block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityTokenHandler">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler (string requestedTokenType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler(string requestedTokenType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSecurityTokenHandler (requestedTokenType As String) As SecurityTokenHandler" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenHandler ^ GetSecurityTokenHandler(System::String ^ requestedTokenType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandler</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestedTokenType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="requestedTokenType">一个字符串，其中包含请求的令牌类型 URI。</param>
        <summary>获取适合保护指定类型的安全令牌的安全令牌处理程序。</summary>
        <returns>表示用于创建发布的安全标志的标志处理程序的 <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" />。 如果请求的标记类型不受支持（没有为指定的标记类型配置处理程序），则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认实现中如果`requestedTokenType`是`null`或空字符串，使用从配置的令牌类型的默认值。 这通过指定<xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenType%2A>通过访问 STS 配置对象的属性<xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A>属性。  
  
 从默认的令牌颁发管道实现中调用此方法<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetTokenLifetime">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime (System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime(class System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetTokenLifetime(System.IdentityModel.Protocols.WSTrust.Lifetime)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTokenLifetime (requestLifetime As Lifetime) As Lifetime" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::Lifetime ^ GetTokenLifetime(System::IdentityModel::Protocols::WSTrust::Lifetime ^ requestLifetime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.Lifetime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestLifetime" Type="System.IdentityModel.Protocols.WSTrust.Lifetime" />
      </Parameters>
      <Docs>
        <param name="requestLifetime">一个 <see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" />，表示所请求的生存周期。</param>
        <summary>获取颁发的令牌的生存期。</summary>
        <returns>一个表示授予生存期的 <see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与在 RST 中，传入的生存期通常调用此方法。 在默认实现中，令牌生存期是下表根据计算的。  
  
|创建 （中）|过期 （中）|创建 （中）|过期 （出）|  
|--------------------|--------------------|--------------------|---------------------|  
|`null`|`null`|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType> + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|C|`null`|C|C + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|`null`|E|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|E|  
|C|E|C|E|  
  
 从默认的令牌颁发管道实现中调用此方法<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="Issue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Issue (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Issue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">一个 <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示令牌请求者的标识。</param>
        <param name="request">一个 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全令牌请求。 这包括请求消息和其他客户端相关信息，如授权上下文。</param>
        <summary>发出安全令牌。</summary>
        <returns>包含发布的安全标识的 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法实现 Ws-trust 规范中定义的问题绑定。 默认实现<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法处理传入请求 (RST) 通过令牌颁发 （声明发出） 管道并返回任一响应 (RSTR)，其中包含具有相应声明进行身份验证的安全令牌请求者 RP 或相应的异常。 令牌颁发管道中的默认实现包含对以下方法的调用 (的<xref:System.IdentityModel.SecurityTokenService>类)。  
  
1.  <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A>方法验证请求 (RST)。  
  
2.  <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>方法以获取<xref:System.IdentityModel.Scope>包含与请求关联的信赖方 (RP) 有关的信息的对象。 你必须重写此方法。 如果<xref:System.IdentityModel.SecurityTokenService.GetScope%2A>返回`null`、<xref:System.InvalidOperationException>引发。  
  
3.  <xref:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor%2A>方法以返回安全令牌描述符基于 RST 和<xref:System.IdentityModel.Scope>上一步中返回的对象。 安全令牌描述符 (<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor>) 包含有关可由标记处理程序的窗体中的请求的信息。 <xref:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor%2A?displayProperty=nameWithType>属性设置为调用所返回的描述符。 如果`null`返回或如果<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.SigningCredentials%2A>属性的描述符是`null`、<xref:System.InvalidOperationException>引发。 如果也会引发异常<xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A?displayProperty=nameWithType>属性是`true`但<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.EncryptingCredentials%2A>属性返回的描述符`null`。  
  
4.  <xref:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler%2A>方法以获取适当的令牌处理程序根据请求标记的类型。 如果`null`返回，<xref:System.NotImplementedException>引发。  
  
5.  <xref:System.IdentityModel.SecurityTokenService.GetIssuerName%2A>方法以获取令牌的颁发者名称。 引发<xref:System.InvalidOperationException>如果名称是`null`或为空; 否则，将设置<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.TokenIssuerName%2A>有关描述符的属性。  
  
6.  <xref:System.IdentityModel.SecurityTokenService.GetTokenLifetime%2A>方法以获取的令牌和集的生存期<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Lifetime%2A>有关描述符的属性。  
  
7.  <xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A>方法以获取证明令牌包含在已颁发的令牌以及集<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Proof%2A>有关描述符的属性。  
  
8.  <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A>方法以获取要包括在颁发的令牌和集的声明<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Subject%2A>有关描述符的属性。 你必须重写此方法。  
  
9. <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A>方法来创建包含已颁发的令牌的响应 (RSTR)。  
  
 您可以重写<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法来实现一个自定义令牌颁发管道; 但是它通常不需要在开发和测试环境中的哪些最自定义实现<xref:System.IdentityModel.SecurityTokenService>类旨在。 在许多这类情况你重写<xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A>和<xref:System.IdentityModel.SecurityTokenService.GetScope%2A>方法和选择重写<xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A>方法来为你的环境提供可维修 STS。 是否需要进一步执行自定义你通常可以通过重写实现令牌颁发管道上面列出的默认值的每个阶段的方法提供它。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Principal">
      <MemberSignature Language="C#" Value="public System.Security.Claims.ClaimsPrincipal Principal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Claims.ClaimsPrincipal Principal" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Principal" />
      <MemberSignature Language="VB.NET" Value="Public Property Principal As ClaimsPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Claims::ClaimsPrincipal ^ Principal { System::Security::Claims::ClaimsPrincipal ^ get(); void set(System::Security::Claims::ClaimsPrincipal ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与当前实例关联的主体。</summary>
        <value>表示当前主体的 <see cref="T:System.Security.Claims.ClaimsPrincipal" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Renew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Renew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Renew (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Renew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">一个 <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示令牌请求者的标识。</param>
        <param name="request">一个 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全令牌请求。 这包括请求消息和其他客户端相关信息，如授权上下文。</param>
        <summary>在派生类中重写时，处理 WS 信任续订请求。</summary>
        <returns>表示 RSTR 返回到调用程序的 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认实现将引发<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Request" />
      <MemberSignature Language="VB.NET" Value="Public Property Request As RequestSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ Request { System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ get(); void set(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要与当前实例关联的安全性标记请求 （RST) 。</summary>
        <value>一个 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，包含请求。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scope">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Scope Scope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Scope Scope" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Scope" />
      <MemberSignature Language="VB.NET" Value="Public Property Scope As Scope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Scope ^ Scope { System::IdentityModel::Scope ^ get(); void set(System::IdentityModel::Scope ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与当前实例关联的范围。</summary>
        <value>
          <see cref="T:System.IdentityModel.Scope" /> 表示令牌颁发请求的配置。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />
      <MemberSignature Language="VB.NET" Value="Protected Property SecurityTokenDescriptor As SecurityTokenDescriptor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::IdentityModel::Tokens::SecurityTokenDescriptor ^ SecurityTokenDescriptor { System::IdentityModel::Tokens::SecurityTokenDescriptor ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置与当前 <see cref="T:System.IdentityModel.Tokens.SecurityTokenDescriptor" /> 实例关联的数据。</summary>
        <value>与当前实例关联的安全性标记请求 （RST) 。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">尝试将该属性设置为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenServiceConfiguration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SecurityTokenServiceConfiguration As SecurityTokenServiceConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ SecurityTokenServiceConfiguration { System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Configuration.SecurityTokenServiceConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取实例所有者的配置。</summary>
        <value>一个 <see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />，包含当前实例的配置。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Validate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Validate (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Validate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">一个 <see cref="T:System.Security.Claims.ClaimsPrincipal" />，表示令牌请求者的标识。</param>
        <param name="request">一个 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />，表示安全令牌请求。 这包括请求消息和其他客户端相关信息，如授权上下文。</param>
        <summary>在派生类中重写时，处理 WS 信任验证请求。</summary>
        <returns>表示 RSTR 返回到调用程序的 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认实现将引发<xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequest">
      <MemberSignature Language="C#" Value="protected virtual void ValidateRequest (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ValidateRequest(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.ValidateRequest(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ValidateRequest (request As RequestSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ValidateRequest(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request">一个表示请求的 <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />。</param>
        <summary>确认该事例 (RST) 封装的安全标记的请求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A>从令牌颁发管道调用方法 (<xref:System.IdentityModel.SecurityTokenService.Issue%2A>方法) 来验证传入的 RST。 RST 验证对 STS 的要求 （策略），并且如果它不是有效引发相应的异常。  
  
 默认实现<xref:System.IdentityModel.SecurityTokenService>类支持仅 RST RSTR 模式和 Ws-trust 规范的问题绑定 (<xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType%2A>的请求的属性必须设置为<xref:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue?displayProperty=nameWithType>)。 此方法的默认实现强制执行这些需求 （和其他异常部分中所述）。 如果必须强制实施不同的验证要求你自定义 STS，您可以重写此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IdentityModel.Protocols.WSTrust.InvalidRequestException">
          <paramref name="request" /> 为 <see langword="null" />。  
  
 或  
  
 请求的 <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType" /> 属性未设置为 <see cref="F:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue" />。  
  
 或  
  
 请求的 <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" /> 属性不是在 <see cref="T:System.IdentityModel.Protocols.WSTrust.KeyTypes" /> 类中定义的 <see langword="null" /> 或某个常数。  
  
 或  
  
 请求的 <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" /> 是 <see cref="F:System.IdentityModel.Protocols.WSTrust.KeyTypes.Bearer" />，并且 <see langword="KeySize" /> 元素存在，但其值不为零。</exception>
        <exception cref="T:System.IdentityModel.UnsupportedTokenTypeBadRequestException">STS 不支持请求令牌的类型 (基于请求的 <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType" /> 属性的值)。</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
  </Members>
</Type>