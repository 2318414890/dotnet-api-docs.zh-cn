<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="615425e7a431643682b3286cc26cb17aa80cb9d4" />
    <Meta Name="ms.sourcegitcommit" Value="058bfa0b75b777d3171411d35da8f11617fc06b0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="05/04/2018" />
    <Meta Name="ms.locfileid" Value="33660301" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see cref="T:System.Windows.FrameworkContentElement" /> 是 <see cref="T:System.Windows.ContentElement" /> 基类的 WPF 框架级别的实现和扩展。 <see cref="T:System.Windows.FrameworkContentElement" /> 增加了针对下列各项的支持：附加输入 API（包括工具提示和上下文菜单）、演示图板、用于数据绑定的数据上下文、格式支持和逻辑树帮助程序 API。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement> 未定义其自己的呈现行为;实例化实际<xref:System.Windows.FrameworkContentElement>在代码或标记中的类实例是可能的但显示在中为 nothing[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]应用程序[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]。 呈现逻辑必须采取的类通过提供<xref:System.Windows.FrameworkContentElement>子元素作为其内容模型的一部分或在<xref:System.Windows.FrameworkContentElement>派生类。  
  
 <xref:System.Windows.FrameworkContentElement> 有意与多个相同[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]作为<xref:System.Windows.FrameworkElement>。 请注意，某些[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]上找到<xref:System.Windows.FrameworkElement>不会<xref:System.Windows.FrameworkContentElement>等效。 多个<xref:System.Windows.FrameworkElement>[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]是的功能，如布局或几何图形表示的不相关的<xref:System.Windows.FrameworkContentElement>。  
  
 大部分现有<xref:System.Windows.FrameworkContentElement>派生的类将位于<xref:System.Windows.Documents>命名空间。 许多这些派生类实现流文档模型的元素。 某些派生的类，如<xref:System.Windows.Documents.Hyperlink>具有某些控件类似的功能，但派生自<xref:System.Windows.FrameworkContentElement>以便类似于控件的元素仍然可以参与流文档模型。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.FrameworkContentElement" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">要添加的子元素。</param>
        <summary>将提供的元素添加为此元素的子元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在另一个进程循环访问的逻辑树时调用，此方法会引发异常。  
  
 大多数<xref:System.Windows.FrameworkContentElement>派生的类公开负责包容的专用的集合 (例如，<xref:System.Windows.Documents.Span.Inlines%2A>上<xref:System.Windows.Documents.Span>类;<xref:System.Windows.Documents.Section.Blocks%2A>上<xref:System.Windows.Documents.Section>类)。 通常可以避免任何需要直接处理逻辑树，如果你改为派生自这些类。 使用内容的元素的逻辑树是一个高级的方案，可能需要一个专用的分析器或一个专用<xref:System.Windows.FrameworkElement>充当父呈现元素 （内容主机）。  
  
 有关如何使用<xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>和<xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>，请参阅[WPF 中的树](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>已在初始化元素之前调用。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>重写该方法以提供您的元素初始化将在元素中加载过程之前应发生的特殊处理。  
  
 您的实现应调用基实现，因为基 （默认） 实现设置某些内部标志来跟踪初始化。  
  
 基实现将引发异常，如果<see cref="M:System.Windows.FrameworkContentElement.BeginInit" />之前到达在同一元素上调用不止一次<see cref="M:System.Windows.FrameworkContentElement.EndInit" />。</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>开始所提供的演示图板中包含的操作序列。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">要开始的演示图板。</param>
        <summary>开始所提供的演示图板中包含的操作序列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不使用的签名`isControllable`，参数，或指定该参数时， `false`，动画与关联的时间线时钟到达"填充"期时，就会立即删除。 因此，在动画运行一次后将不能是重启。 请注意，控制动画还要求情节提要，是命名，或者在代码中对实例的可访问性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">要开始的演示图板。</param>
        <param name="handoffBehavior">一个枚举值，该值描述演示图板中描述的属性在经过动画处理后要使用的行为。</param>
        <summary>开始所提供的演示图板中包含的操作序列，其中指定了在该属性经过动画处理后要发生的行为的选项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不使用的签名`isControllable`，参数，或指定该参数时， `false`，动画与关联的时间线时钟到达"填充"期时，就会立即删除。 因此，在动画运行一次后将不能是重启。 请注意，控制动画还要求情节提要，是命名，或者在代码中对实例的可访问性。  
  
## <a name="using-the-compose-handoffbehavior"></a>使用使用  
 当你将<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>到通过使用属性<xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>、 任何<xref:System.Windows.Media.Animation.Clock>以前与该属性关联的对象可继续使用系统资源; 计时系统将执行不自动删除时钟。  
  
 若要避免性能问题时通过使用应用大量的时钟<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>，完成后，应从属性的基值移除组合时钟。 有多种方法来移除时钟：  
  
-   若要从属性中移除所有时钟，请使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>动画对象的方法。 指定正进行动画处理的第一个参数的属性和`null`为第二个。 这从属性中移除所有动画时钟。  
  
-   若要删除特定<xref:System.Windows.Media.Animation.AnimationClock>时钟的列表，从使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>属性<xref:System.Windows.Media.Animation.AnimationClock>检索<xref:System.Windows.Media.Animation.ClockController>，然后调用<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法<xref:System.Windows.Media.Animation.ClockController>。 这通常是<xref:System.Windows.Media.Animation.Clock.Completed>时钟的事件处理程序。 请注意，仅根时钟可以受<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>属性子时钟返回`null`。 另请注意，<xref:System.Windows.Media.Animation.Clock.Completed>如果时钟的有效持续时间都是永久性的则不会引发事件。  在这种情况下，用户必须确定何时调用<xref:System.Windows.Media.Animation.ClockController.Remove%2A>。  
  
 此动画问题主要出现在生存期较长的对象上。  一个对象进行垃圾回收，其时钟还断开连接，并垃圾收集。  
  
 有关时钟对象的详细信息，请参阅[动画和计时系统概述](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">要开始的演示图板。</param>
        <param name="handoffBehavior">一个枚举值，该值描述演示图板中描述的属性在经过动画处理后要使用的行为。</param>
        <param name="isControllable">声明在动画开始后是否仍可以对它进行控制（可以暂停）。</param>
        <summary>开始所提供的演示图板中包含的操作序列，其中指定了在动画开始之后动画控件的状态。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不使用的签名`isControllable`，参数，或指定该参数时， `false`，动画与关联的时间线时钟到达"填充"期时，就会立即删除。 因此，在动画运行一次后将不能是重启。 请注意，控制动画还要求情节提要，是命名，或者在代码中对实例的可访问性。  
  
## <a name="using-the-compose-handoffbehavior"></a>使用使用  
 当你将<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>到通过使用属性<xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>、 任何<xref:System.Windows.Media.Animation.Clock>以前与该属性关联的对象可继续使用系统资源; 计时系统将执行不自动删除这些时钟。  
  
 若要避免性能问题时通过使用应用大量的时钟<xref:System.Windows.Media.Animation.HandoffBehavior.Compose>，完成后，应从属性的基值移除组合时钟。 有多种方法来移除时钟：  
  
-   若要从属性中移除所有时钟，请使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>动画对象的方法。 指定正进行动画处理的第一个参数的属性和`null`为第二个。 这从属性中移除所有动画时钟。  
  
-   若要删除特定<xref:System.Windows.Media.Animation.AnimationClock>时钟的列表，从使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>属性<xref:System.Windows.Media.Animation.AnimationClock>检索<xref:System.Windows.Media.Animation.ClockController>，然后调用<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法<xref:System.Windows.Media.Animation.ClockController>。 这通常是<xref:System.Windows.Media.Animation.Clock.Completed>时钟的事件处理程序。 请注意，仅根时钟可以受<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>属性子时钟返回`null`。 另请注意，<xref:System.Windows.Media.Animation.Clock.Completed>如果时钟的有效持续时间都是永久性的则不会引发事件。  在这种情况下，用户必须确定何时调用<xref:System.Windows.Media.Animation.ClockController.Remove%2A>。  
  
 此动画问题主要出现在生存期较长的对象上。  一个对象进行垃圾回收，其时钟还断开连接，并垃圾收集。  
  
 有关时钟对象的详细信息，请参阅[动画和计时系统概述](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于该元素的 <see cref="T:System.Windows.Data.BindingGroup" />。</summary>
        <value>用于该元素的 <see cref="T:System.Windows.Data.BindingGroup" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Data.BindingGroup>可以用于验证对象的多个属性的值。 例如，假设应用程序提示用户输入地址，然后填充类型的对象`Address`，其中具有属性`Street`， `City`， `ZipCode`，和`Country`，使用值的用户提供。 应用程序具有包含四个面板<xref:System.Windows.Controls.TextBox>控件，其中每个绑定到对象的属性之一。 你可以使用<xref:System.Windows.Controls.ValidationRule>中<xref:System.Windows.Data.BindingGroup>验证`Address`对象。 例如，<xref:System.Windows.Controls.ValidationRule>可确保邮政编码的有效地址的国家/地区。  
  
 子元素继承<xref:System.Windows.Data.BindingGroup>从其父元素，就像使用任何其他可继承的属性。  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|元数据属性设置为**true**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>尝试将此元素放入其所在的任何可滚动区域内的视图中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过调用此方法，你有效地将调用<xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>在任何父可滚动区域中包含的元素 (父级可以很好地是<xref:System.Windows.FrameworkElement>，而不<xref:System.Windows.FrameworkContentElement>)。 如果此元素未包含在可滚动区域，则仍将引发该事件，但不会产生任何影响。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置每当通过[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 从此元素中请求上下文菜单时应该显示的上下文菜单元素。</summary>
        <value>此元素使用的上下文菜单。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|元数据属性设置为 `true`|无|  
  
   
  
## Examples  
 以下示例位置<xref:System.Windows.Controls.ContextMenu>上<xref:System.Windows.Documents.Paragraph>。  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在元素上的任何上下文菜单关闭之前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取消关闭上下文菜单，事件的处理程序应将其标记为已处理。  
  
 若要将此事件用作<xref:System.Windows.EventTrigger>样式，则必须引用基础服务的事件标识符：  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (此用法是必需的因为上的事件实现<xref:System.Windows.FrameworkContentElement>，公开基础的服务事件不会不会正确映射<xref:System.Windows.FrameworkContentElement.ContextMenuClosing>在触发器中使用的标识符)。  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 下面的示例实现一个处理程序，在已命名区域更改光标`DisplayArea`（未显示）。 注释可指示<xref:System.Windows.UIElement>使用情况，但事实上，此示例将是相同如果`DisplayArea`已<xref:System.Windows.FrameworkContentElement>。  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由的事件时创建事件标识符对象 (请参阅<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，然后可以使用添加类处理程序 (请参阅<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。 标识符对象包含标识名称、 所有者类型、 处理程序类型、 路由策略和添加事件所有者的实用程序方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在元素上的任何上下文菜单打开时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要手动打开上下文菜单，事件的处理程序应将相关的事件标记为已处理。 否则为的现有值<xref:System.Windows.FrameworkContentElement.ContextMenu%2A>属性将用于自动打开上下文菜单。 将标记处理的事件可有效地取消的默认操作，并且可重置的值的机会<xref:System.Windows.FrameworkContentElement.ContextMenu%2A>属性，然后打开新<xref:System.Windows.Controls.ContextMenu>。 但是，没有应该注意的计时问题。 若要完全替换通过上下文菜单<xref:System.Windows.FrameworkContentElement.ContextMenuOpening>处理程序中，初始上下文菜单不能为 null / 空。 或者，你可能需要处理该事件，然后手动打开新的上下文菜单。 有关详细信息，请参阅[如何： 处理 ContextMenuOpening 事件](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)。  
  
 若要将此事件用作<xref:System.Windows.EventTrigger>样式，则必须引用基础服务的事件标识符：  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (此用法是必需的因为上的事件实现<xref:System.Windows.FrameworkContentElement>，公开基础的服务事件不会不会正确映射<xref:System.Windows.FrameworkContentElement.ContextMenuOpening>在触发器中使用的标识符)。  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由的事件时创建事件标识符对象 (请参阅<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，然后可以使用添加类处理程序 (请参阅<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。 标识符对象包含标识名称、 所有者类型、 处理程序类型、 路由策略和添加事件所有者的实用程序方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在鼠标指针位于此元素上时显示的光标。</summary>
        <value>要显示的光标。 按此依赖属性，默认值定义为 <see langword="null" />。 但是，运行时的实际默认值将受到多种因素的影响。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置此属性时[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]处理器依赖于针对类型转换<xref:System.Windows.Input.Cursor>类来计算该字符串。 所提供的字符串的计算结果应为<xref:System.Windows.Input.CursorType>值。 有关详细信息，请参阅<xref:System.Windows.Input.Cursor>。  
  
 是否建立此属性的光标将或将不会显示在鼠标指针位于此元素时也是依赖于的值<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>属性。 此外，与事件相关的注意事项，如活动拖动、 鼠标捕获、 文本编辑控件，以此类推内, 模式还将影响光标，并且其优先级高于此属性中指定的值。  
  
 若要恢复的此属性设置为最终的默认行为，请将其设置为`null`试。  
  
 `null`默认的真正含义的实际光标值确定此处延迟，并且应从其他地方获取。 如果不存在以编程方式值来自任何源的默认光标通过[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]应用程序将是一个箭头。  
  
 每个移动的鼠标悬停[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]应用程序将引发<xref:System.Windows.ContentElement.QueryCursor>事件。 该事件将冒泡，并且在路由任何元素都有机会对事件进行处理，并将光标通过此事件的自变量的值设置。 如果发生这种情况，则表明事件进行处理，并且参数中有更改的值将优先于的值<xref:System.Windows.FrameworkContentElement.Cursor%2A>属性在任何级别，除非<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>设置。  
  
 如果不创建自定义光标，通常你设置此属性与静态属性值的<xref:System.Windows.Input.Cursors>类。  
  
 设置<xref:System.Windows.Input.Cursor>在部分信任环境中未启用为自定义值。 有关自定义的游标的详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|元数据属性设置为 `true`|无|  
  
   
  
## Examples  
 下面的示例设置为自定义值的光标。  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素参与数据绑定时的数据上下文。</summary>
        <value>要用作数据上下文的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *数据上下文*是使元素可以信息从其父元素继承有关用于绑定，以及如路径绑定的其他特征的绑定源的概念。  
  
 可以直接设置数据上下文[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]对象，并且将绑定到该对象的属性计算。 或者，可以设置的数据上下文为<xref:System.Windows.Data.DataSourceProvider>对象。  
  
 此依赖属性继承属性值。 如果有任何其他值的子元素<xref:System.Windows.FrameworkContentElement.DataContext%2A>建立通过本地值或样式，属性系统将设置此值为<xref:System.Windows.FrameworkContentElement.DataContext%2A>分配有此值最接近的父元素的值。  
  
 或者，你可以使用的以下属性之一<xref:System.Windows.Data.Binding>类显式指定绑定源： <xref:System.Windows.Data.Binding.ElementName%2A>， <xref:System.Windows.Data.Binding.Source%2A>，或<xref:System.Windows.Data.Binding.RelativeSource%2A>。 有关详细信息，请参阅[如何： 指定绑定源](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)。  
  
 在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，<xref:System.Windows.FrameworkContentElement.DataContext%2A>通常设置为<xref:System.Windows.Data.Binding>声明。 你可以使用属性元素语法或特性语法。 特性语法在此页上的示例所示。 你还可以设置<xref:System.Windows.FrameworkContentElement.DataContext%2A>在代码中。  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>XAML 值  
 *dataContextObject*  
 用作父元素内的任何绑定的数据上下文直接嵌入的对象。 通常情况下，此对象是<xref:System.Windows.Data.Binding>或另一个<xref:System.Windows.Data.BindingBase>子类。 或者，原始数据的任何[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]对象适用于绑定可能会放置在这里，与更高版本定义的实际绑定的类型。  
  
 *bindingUsage*  
 计算结果为适当的数据上下文绑定使用情况。 有关详细信息，请参阅 [Binding 标记扩展](~/docs/framework/wpf/advanced/binding-markup-extension.md)。  
  
 *resourceExtension*  
 以下项之一： `StaticResource`，或`DynamicResource`。 在引用定义为资源中的对象的原始数据时，使用这种用法。 请参阅[XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *contextResourceKey*  
 从所请求的对象的密钥标识符<xref:System.Windows.ResourceDictionary>。  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 下面的示例设置的绑定上<xref:System.Windows.Documents.Paragraph>元素，通过创建一个新的自定义数据对象，建立该对象作为<xref:System.Windows.FrameworkContentElement.DataContext%2A>，并将绑定路径设置为在其中一个属性。  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当此元素的数据上下文更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数据上下文和数据绑定的说明，请参阅[数据绑定概述](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
> [!IMPORTANT]
>  当元素的<xref:System.Windows.FrameworkContentElement.DataContext%2A>可能受影响的更改，此元素上的所有数据绑定属性。 这适用于任何是继承的数据上下文，当前元素的子代元素的元素以及当前元素本身。 此类的所有绑定都重新都解释新<xref:System.Windows.FrameworkContentElement.DataContext%2A>以反映在绑定中的新值。 有关相对于引发这些更改的顺序不能保证<xref:System.Windows.FrameworkContentElement.DataContextChanged>事件。  事件发生后, 或在任意组合，事件之前, 可以发生的更改。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于在主题中查找此控件的样式模板的键。</summary>
        <value>样式键。 为了在主题样式查找中正确工作，此值应为样式化元素的 <see cref="T:System.Type" />。 <see langword="null" /> 是一个在某些情况下的可接受的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性通常不通过其直接 setter 的任何设置。 相反，每次创建新的子类覆盖此依赖项属性的特定类型的元数据。 当你子类，请调用<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>方法依据<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>在控件子类的静态构造函数内的标识符。  
  
 例如，例如内联类<xref:System.Windows.Documents.Bold>实际上已超出重写很少实现<xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A>其静态构造函数，并公开多个实例构造函数中的元数据。 元素被事实<xref:System.Windows.Documents.Bold>标记提升<xref:System.Windows.Documents.TextElement.FontWeight%2A>属性<xref:System.Windows.FontWeights.Bold%2A>实现中设置的默认值所引用的主题样式<xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A>到`typeof(Bold)`。  
  
 如果你希望元素或控件，以防出现故意不使用主题样式，设置<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A>属性`true`。  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>已在初始化元素后立即调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 实现此方法以提供您的元素初始化期间加载过程的元素时应执行的特殊处理。  
  
 您的实现应调用基实现，因为基 （默认） 实现设置某些内部标志来跟踪初始化。  
  
 如果<xref:System.Windows.FrameworkContentElement.BeginInit%2A>之前已调用，基实现将引发<xref:System.Windows.FrameworkContentElement.Initialized>事件。 否则为如果<xref:System.Windows.FrameworkContentElement.BeginInit%2A>未调用或它无法确定是否<xref:System.Windows.FrameworkContentElement.BeginInit%2A>已调用，则不会引发该事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要搜索的元素的名称。</param>
        <summary>查找具有提供的标识符名的元素。</summary>
        <returns>请求的元素。 如果未找到匹配的元素，则可以为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此元素包含子元素，这些子元素将是所有以递归方式搜索请求的命名元素。  
  
   
  
## Examples  
 下面的示例中的引用名称所找到的元素上设置一个属性<xref:System.Windows.Documents.FlowDocument>页面上。  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要查找的资源的键标识符。</param>
        <summary>搜索具有指定键的资源，如果找不到请求的资源，则会引发异常。</summary>
        <returns>找到的资源；如果未找到任何匹配的资源，则为 <see langword="null" />（但如果为 <see langword="null" />，将同时引发异常）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  如果找不到键调用此方法，将引发异常。 如果您不想要处理这种情况下的异常，则应改为调用<xref:System.Windows.FrameworkContentElement.TryFindResource%2A>。 <xref:System.Windows.FrameworkContentElement.TryFindResource%2A> 返回`null`时没有任何资源查找，而且不会引发异常。  
  
 如果调用元素上未找到资源，使用的逻辑树搜索父树，在树的方法相同搜索资源请求时由运行时的参数。  
  
 通常将立即强制转换为已尝试用返回的资源值进行设置的属性的类型的返回值。  
  
   
  
## Examples  
 下面的示例查找标记中定义的资源，并将其应用到的路由事件的响应中的某个元素的某一属性。  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">找不到请求的资源键。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceKey" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个对象，该对象允许自定义此元素在捕获到键盘焦点时要应用于此元素的外观、效果或其他样式特征。</summary>
        <value>要应用于焦点的所需样式。 该依赖项属性中声明的默认值是一个空的静态 <see cref="T:System.Windows.Style" />。 但是，运行时的有效值通常是（但并非总是）控件的主题支持所提供的样式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置此属性时[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、 样式几乎始终定义为资源，而不是作为元素，内联和资源通常是作为引用<xref:System.Windows.StaticResourceExtension>。  
  
 请注意，此属性会影响视觉外观，但不会报告此元数据中。 这是因为可视外观更改是事件驱动的和可能不适用于在所有时间，并因此通常不应该报告元数据中的任何 visual 或布局信息。  
  
 从概念上讲，应用于控件的焦点的可视行为应为连贯从一个元素到另一个元素。 最合理的方法，来强制执行一致性是仅更改焦点视觉样式，如果你创建的整个主题。 在单个样式上，而不是主题的一部分设置此属性不是预期的用法的此属性，因为它可能会导致混乱的用户体验与键盘焦点有关。 如果你想为以防出现故意不连贯整个主题的特定元素的行为，较好的做法是使用触发器样式中的单个输入的状态属性，如<xref:System.Windows.UIElement.IsFocused%2A>或<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>，从而不一种方法中执行此操作直观地干扰任何现有的焦点视觉样式。 有关详细信息的设计意图<xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A>及替代焦点属性，请参阅[样式的焦点在控件和 FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)。  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>XAML 值  
 *resourceExtension*  
 以下项之一:，或。 请参阅[XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *styleResourceKey*  
 标识所请求的样式的键。 该键引用中的现有资源<xref:System.Windows.ResourceDictionary>。  
  
> [!NOTE]
>  属性元素语法是从技术上讲是可行的但不是建议这样做。 请参阅[内联样式和模板](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)。  绑定引用使用或<xref:System.Windows.Data.Binding>也是可行的但不常见。  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示此 <see cref="T:System.Windows.FrameworkContentElement" /> 是否应该强制[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 按照此实例的 <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> 属性所声明的方式呈现光标。</summary>
        <value>
          在光标位于此元素上时，强制光标呈现以将此实例的设置用于光标（包括在所有子元素上），则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性设置为`true`将重写建立的子元素的光标首选项。 这样做因此一般情况下应用程序[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]可能令人困惑的用户，尤其是当子元素尝试指定游标。 设置<xref:System.Windows.FrameworkElement.ForceCursor%2A>控件子类化或组合方案中更合适。  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|元数据属性设置为 `true`|无|  
  
   
  
## Examples  
 下面的示例强制上元素的光标。  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">从中获取绑定的目标 <see cref="T:System.Windows.DependencyProperty" />。</param>
        <summary>获取指定属性的绑定的 <see cref="T:System.Windows.Data.BindingExpression" />。</summary>
        <returns>如果目标为数据绑定，则返回 <see cref="T:System.Windows.Data.BindingExpression" />；否则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例通过查询属性检索的绑定。  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果没有视觉父级，则返回此元素的备用逻辑父级。 在这种情况下，<see cref="T:System.Windows.FrameworkContentElement" /> 父级始终与 <see cref="P:System.Windows.FrameworkContentElement.Parent" /> 属性具有相同值。</summary>
        <returns>当此方法的 WPF 框架级别实现具有非视觉父级连接时，即返回 <see langword="null" /> 之外的内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认实现返回预期的单个视觉父级。 自定义实现可能会返回备用父关系。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>初始化此 <see cref="T:System.Windows.FrameworkContentElement" /> 时发生。 这与 <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> 属性值从 <see langword="false" />（或未定义）更改为 <see langword="true" /> 的情况相符。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件将引发每当<xref:System.Windows.FrameworkContentElement.EndInit%2A>或<xref:System.Windows.FrameworkContentElement.OnInitialized%2A>调用方法。 对这些方法的调用可能已进行了通过故意代码，或通过[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]加载过程。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此 <see cref="T:System.Windows.FrameworkContentElement" /> 使用的输入的上下文。</summary>
        <value>解释输入范围，在该输入范围内修改从其他输入法输入的方式。 默认值为 <see langword="null" />（这导致对命令的默认处理）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此依赖属性继承属性值。 如果有任何其他值的子元素<xref:System.Windows.FrameworkElement.InputScope%2A>建立通过本地值或样式，属性系统将设置此值为<xref:System.Windows.FrameworkElement.InputScope%2A>分配有此值最接近的父元素的值。  
  
 尽管[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]语法使用情况列出和语法允许，则将此属性设置[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]并不常见。  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否已通过将此元素作为[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] 加载或显式调用它的 <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> 方法初始化此元素。</summary>
        <value>
          如果已通过上述加载或方法调用初始化了此元素，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性也可能是`true`如果此元素已在元素树中以便它有一个新的父元素，并因此重新。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否已加载此元素以供显示。</summary>
        <value>
          如果当前元素附加到元素树且已呈现，则为 <see langword="true" />；如果元素从未附加到加载的元素树中，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从新构造的实例，该属性开始`false`，并保留`true`后设置为`true`，即使随后由代码中删除。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Windows.FrameworkContentElement.IsLoaded%2A>用作条件检查，以确保函数`displayData`（未显示） 将具有有效元素上加载页后，可以针对、 按需处理程序的一部分工作。 作为事件处理程序运行时相同的逻辑<xref:System.Windows.FrameworkContentElement.Loaded>。  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置应用于单个元素的本地化/全球化语言信息。</summary>
        <value>此元素的区域性信息。 默认值是一个 <see cref="T:System.Windows.Markup.XmlLanguage" /> 实例，它的 <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> 值设置为字符串“en-US”。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字符串格式遵循 RFC 3066 标准。 例如，美国英语是"EN-US"。 请参阅<xref:System.Windows.Markup.XmlLanguage>有关详细信息的值和格式。  
  
 此依赖属性继承属性值。 如果有任何其他值的子元素<xref:System.Windows.FrameworkElement.Language%2A>建立通过本地值或样式，属性系统将设置此值为<xref:System.Windows.FrameworkElement.Language%2A>分配有此值最接近的父元素的值。  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.Language" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当对元素进行布局、呈现，且可将其用于交互时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 直接路由的事件不遵循路由，而仅处理引发它们时对同一元素中。 直接路由的事件是否支持其他路由的事件行为： 它们支持的可访问的处理程序集合，并可用作<xref:System.Windows.EventTrigger>样式。  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由的事件时创建事件标识符对象 (请参阅<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，然后可以使用添加类处理程序 (请参阅<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。 标识符对象包含标识名称、 所有者类型、 处理程序类型、 路由策略和添加事件所有者的实用程序方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此元素的逻辑子元素的一个枚举数。</summary>
        <value>此元素的逻辑子元素的一个枚举数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关详细信息如何使用<xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>和<xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>，请参阅[WPF 中的树](~/docs/framework/wpf/advanced/trees-in-wpf.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">焦点要移动的方向，作为一个枚举值。</param>
        <summary>将键盘焦点从此元素移到另一个元素。</summary>
        <returns>如果焦点成功移动，则返回 <see langword="true" />；如果指定方向上的目标元素不存在，则返回 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置元素的标识名称。 该名称提供实例引用，以便编程代码隐藏（如事件处理程序代码）可以引用曾在 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 的分析过程中构造的元素。</summary>
        <value>元素的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的最常见用法是指定时[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]标记中的元素名称。  
  
 此属性实质上是提供一个 WPF 框架级别便捷属性，以设置[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [X:name 指令](~/docs/framework/xaml-services/x-name-directive.md)。  
  
 获取<xref:System.Windows.FrameworkContentElement.Name%2A>代码中并不常用，因为如果你已在代码中具有适当的引用，你可以直接调用方法和属性的元素上引用且通常并不需要<xref:System.Windows.FrameworkContentElement.Name%2A>。 例外情况是字符串具有某些重载的含义，例如有用中显示该名称是否[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。 设置<xref:System.Windows.FrameworkContentElement.Name%2A>代码中如果原始<xref:System.Windows.FrameworkContentElement.Name%2A>已从标记中的设置也不建议，并且更改该属性不会更改对象引用。 仅当基础名称范围显式创建期间创建此类对象引用[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]加载。  
  
 你必须明确调用<xref:System.Windows.FrameworkContentElement.RegisterName%2A>以进行有效的更改上<xref:System.Windows.FrameworkContentElement.Name%2A>已加载的元素的属性。  
  
 一个值得一提设置情况<xref:System.Windows.FrameworkContentElement.Name%2A>从代码很重要的命名元素演示图板将针对运行。 你可以注册名称之前，可能还需要实例化并分配<xref:System.Windows.NameScope>实例。 请参阅示例部分中，或[情节提要概述](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。  
  
 设置<xref:System.Windows.FrameworkContentElement.Name%2A>从代码具有有限的应用程序，但按名称查找元素并更常用，尤其是在你采用一种导航模型到应用程序重新加载页面，其中的运行时代码不一定的代码隐藏相应的页。 实用工具方法<xref:System.Windows.FrameworkContentElement.FindName%2A>，这是可从任何<xref:System.Windows.FrameworkContentElement>，可以找到任何元素<xref:System.Windows.FrameworkContentElement.Name%2A>中该元素的逻辑树以递归方式。 也可以使用<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>静态方法<xref:System.Windows.LogicalTreeHelper>，其还会<xref:System.Windows.FrameworkContentElement.Name%2A>作为自变量的字符串。  
  
 常用根元素 (<xref:System.Windows.Window>，<xref:System.Windows.Controls.Page>例如) 实现的接口<xref:System.Windows.Markup.INameScope>。 此接口的实现需要强制该名称是明确在其范围内。  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.Name" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">提供与事件有关的数据。</param>
        <summary>每当 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> 路由事件在其路由中到达此类时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不具有默认实现。 继承中的中间类已经实现此方法的情况下，你仍应调用基实现。  
  
 此方法的目的是某种程度上类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 它提供了一种用而不是一个实例处理程序的类处理程序的派生类中对匹配事件进行处理。 在这种情况下匹配的事件是路由的事件。 因为路由的事件可能由一个子元素，不一定的元素，将会调用处理程序引发，On * 方法的实现模式是不同的路由事件。 因此，您的实现将需要考虑事件参数的源属性 （和不应尝试再次引发该事件在大多数情况下）。 子类<xref:System.Windows.FrameworkContentElement>可以选择在路由过程中收到事件时调用私有类处理程序方法。 一个可能的方案是事件的自变量，以防出现故意将事件标记为已处理以缩短路由。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件的事件数据。</param>
        <summary>每当 <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> 路由事件在其路由中到达此类时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不具有默认实现。 继承中的中间类已经实现此方法的情况下，你仍应调用 base （）。  
  
 此方法的目的是某种程度上类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 它提供了一种用而不是一个实例处理程序的类处理程序的派生类中对匹配事件进行处理。 在这种情况下匹配的事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为路由的事件可能遭到一个子元素，不一定的元素，将会调用处理程序，以便您的实现将需要采取的事件自变量的源引发将属性转换为帐户 （和不应尝试再次引发该事件在大多数情况下）。 子类<xref:System.Windows.FrameworkContentElement>可以选择在路由过程中收到事件时调用私有类处理程序方法。 一个可能的方案是事件的自变量，以防出现故意将事件标记为已处理以缩短路由。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件的事件数据。</param>
        <summary>
          <see cref="E:System.Windows.ContentElement.GotFocus" /> 事件的类处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果该事件来源于此元素，此类处理程序在此元素上设置相应的焦点行为。 如果事件的源树中的另一个元素，该处理程序将没有任何影响。  
  
 若要更改这些默认焦点行为元素上，重写此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">事件的事件数据。</param>
        <summary>引发 <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> 事件。 只要将 <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> 设置为 <see langword="true" />，就可以调用此方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本主题中前面所述，此虚方法的默认实现将引发事件。 重写应调用 base （） 来保留此行为。  
  
 请注意，<xref:System.Windows.FrameworkContentElement.IsInitialized%2A>属性是只读的。 因此，你不能将其设置为强制初始化行为通过这种方式。 初始化设置旨在只能由[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]framework。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">描述已更改的属性的事件数据，包括旧值和新值。</param>
        <summary>每当更新此 <see cref="T:System.Windows.FrameworkContentElement" /> 上任何依赖项属性的有效值时调用。 将在实参形参中报告已更改的特定依赖属性。 重写 <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不应通常检测属性更改或失效。 它而被旨在用于修改常规失效模式如果查阅宽分类的属性已知的某些信息。  
  
 调用此方法可能很多时候一个对象的生命周期内。 因此，你可以实现更好的性能，如果重写特定属性的元数据，然后将附加<xref:System.Windows.CoerceValueCallback>或<xref:System.Windows.PropertyChangedCallback>为各个属性的函数。 但是，如果你将使用此方法<xref:System.Windows.FrameworkContentElement>包括大量的值相关的依赖项属性，或如果它包括逻辑，如呈现行为，必须重新运行多个相关属性失效的情况。  
  
 请注意，没有具有相同名称`OnPropertyChanged`用不同的签名的方法 (该参数类型是<xref:System.ComponentModel.PropertyChangedEventArgs>)，可能出现在多个类。 `OnPropertyChanged`用于数据对象通知，并且是协定的一部分<xref:System.ComponentModel.INotifyPropertyChanged>。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>始终调用基实现中，为您的实现中的第一个操作。 如果不这样做将显著禁用整个[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]属性系统，这会导致不正确的值进行报告。</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">旧样式。</param>
        <param name="newStyle">新样式。</param>
        <summary>在此元素上使用的样式更改时调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有一个默认实现，设置一个内部标志指明样式更改条件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>始终调用基实现，否则不能应用样式。 如果你派生的类具有专用的样式选择器，或缓存样式值，可能会包括重写此方法的方案。 主题更改很可能将调用此方法。</para>
        </block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">提供与事件有关的数据。</param>
        <summary>每当 <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> 路由事件在其路由中到达此类时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不具有默认实现。 继承中的中间类已经实现此方法的情况下，你仍应调用 base （）。  
  
 此方法的目的是某种程度上类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 它提供了一种用而不是一个实例处理程序的类处理程序的派生类中对匹配事件进行处理。 在这种情况下匹配的事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为路由的事件可能遭到一个子元素，不一定的元素，将会调用处理程序，以便您的实现将需要采取的事件自变量的源引发将属性转换为帐户 （和不应尝试再次引发该事件在大多数情况下）。 子类<xref:System.Windows.FrameworkContentElement>可以选择在路由过程中收到事件时调用私有类处理程序方法。 一个可能的方案是事件的自变量，以防出现故意将事件标记为已处理以缩短路由。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">提供与事件有关的数据。</param>
        <summary>每当 <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> 路由事件在其路由中到达此类时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不具有默认实现。 继承中的中间类已经实现此方法的情况下，你仍应调用 base （）。  
  
 此方法的目的是某种程度上类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 * 方法： 它提供了一种用而不是一个实例处理程序的类处理程序的派生类中对匹配事件进行处理。 在这种情况下匹配的事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为路由的事件可能遭到一个子元素，不一定的元素，将会调用处理程序，以便您的实现将需要采取的事件自变量的源引发将属性转换为帐户 （和不应尝试再次引发该事件在大多数情况下）。 子类<xref:System.Windows.FrameworkContentElement>可以选择在路由过程中收到事件时调用私有类处理程序方法。 一个可能的方案是事件的自变量，以防出现故意将事件标记为已处理以缩短路由。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示此元素是否合并了主题样式的样式属性。</summary>
        <value>
          如果此元素不使用主题样式属性，则为 <see langword="true" />；所有源于样式的属性均来自本地应用程序样式，不会应用主题样式属性。 如果首先应用了应用程序样式，然后将主题样式应用于未在应用程序样式中专门设置的属性，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的最常见用法是一种间接使用正提供主题样式的样式的 setter 中。  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此元素的逻辑树中的父级。</summary>
        <value>此元素的逻辑父级。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请注意，具体取决于应用程序功能，可能发生更改的元素的逻辑父级，并且此属性的值保持将不会反映所做的更改。 你需要它之前，你通常应获取的值。  
  
 请参阅[WPF 中的树](~/docs/framework/wpf/advanced/trees-in-wpf.md)有关遍历其中采取针对元素发现这种方法合适的逻辑树和方案的详细信息。  
  
 属性系统将可能重新计算此元素的所有属性值时父级，因为某些属性继承值通过逻辑树。 <xref:System.Windows.FrameworkContentElement.DataContext%2A>适用于元素是父级，还可以更改绑定。  
  
 更改元素的父通常只是对集合的操作，通过使用专用添加或删除方法，或通过设置的元素的内容属性。  
  
 使用最典型的情形<xref:System.Windows.FrameworkContentElement.Parent%2A>属性是获得的引用，然后获取各种<xref:System.Windows.FrameworkContentElement>从父属性值。 对于模板，<xref:System.Windows.FrameworkContentElement.Parent%2A>模板的最终将`null`。 若要忽略这一点并扩展到实际将应用的模板的逻辑树，请使用<xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>。  
  
   
  
## Examples  
 下面的示例检查以查看是否<xref:System.Windows.FrameworkContentElement.Parent%2A>的<xref:System.Windows.Documents.TextPointer>是否属于特定类型。  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">应确定其预期焦点更改的方向。</param>
        <summary>根据提供的焦点移动方向，确定在此元素之后接收焦点的下一个元素，但不实际移动焦点。 此方法是密封的，不能对其进行重写。</summary>
        <returns>如果实际遍历了焦点，则为焦点将要移到的下一个元素。 如果焦点不能按提供的方向相对于此元素移动，则可能返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement.MoveFocus%2A> 是实际移动焦点的相关的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">在 <see cref="T:System.Windows.Input.TraversalRequest" /> 中指定了以下方向之一：<see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.First" />、<see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />。 对于 <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> 来说，这些方向是非法的（但对于 <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> 来说是合法的）。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">要在指定的名称-对象映射中使用的名称。</param>
        <param name="scopedElement">映射的对象。</param>
        <summary>提供一个可简化对 <see cref="T:System.Windows.NameScope" /> 注册方法访问的访问器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是调用的便捷方法<xref:System.Windows.NameScope.RegisterName%2A>。 该实现将检查连续的父元素，直到它找到适用<xref:System.Windows.NameScope>实现，它可以通过查找元素实现<xref:System.Windows.Markup.INameScope>。 有关名称范围的详细信息，请参阅[WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。  
  
 调用<xref:System.Windows.FrameworkContentElement.RegisterName%2A>为正确挂钩的应用程序时在代码中创建动画演示图板是必需的。 这是因为其中一个主要情节提要属性， <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>，而不是能够充分目标元素的引用中使用运行时名称查找。 即使该元素是可访问的代码中的引用，也是如此。 为何需要注册名称的情节提要目标的详细信息，请参阅[情节提要概述](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)。 为内容元素的动画并不常见上控件的动画[情节提要概述](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)重点介绍控制方案。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">要移除的元素。</param>
        <summary>从该元素的逻辑树中移除指定的元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]主要适用于类中派生方案中，添加对子集合的支持时。  
  
 大多数<xref:System.Windows.FrameworkContentElement>派生的类公开负责包容的专用的集合 (例如，<xref:System.Windows.Documents.Span.Inlines%2A>上<xref:System.Windows.Documents.Span>类;<xref:System.Windows.Documents.Section.Blocks%2A>上<xref:System.Windows.Documents.Section>类)。 派生自这些类通常可以避免任何需要直接处理逻辑树。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前本地定义的资源字典。</summary>
        <value>当前本地定义的资源。 这是一本资源字典，可通过键来访问字典中的资源。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以完全或部分中定义的资源字典[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]通常创建为一个属性元素，并且通常是根元素为任何单个页面或应用程序上。 将在此级别的资源字典便于查找从页面中的各个子元素 （或任何页上，在应用程序的情况下）。 在大多数应用程序方案中，我们建议作为对象元素使用的资源字典中定义样式或作为外部资源定义整个样式资源可以是自包含 （此方法有助于单独的设计器从开发人员通过将需要编辑物理文件分开的责任职责）。  
  
 请注意，此属性返回直接在该元素内声明仅的资源字典。 此函数不同于实际资源查找过程中，子元素可以访问任何向上递归搜索每个父元素中定义的资源。  
  
 资源在集合中，从代码也可以引用，但请注意资源创建在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]肯定不可访问，直到<xref:System.Windows.FrameworkContentElement.Loaded>引起声明该字典的元素。 事实上，资源以异步方式分析和甚至不<xref:System.Windows.FrameworkContentElement.Loaded>事件是保证可引用[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]定义资源。 因此你通常只应访问[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]定义资源作为的一部分运行时代码，或通过其他[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]技术，如样式或特性值的资源扩展引用。 通过代码访问资源时，它是实质上等同于从进行的引用[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 基础<xref:System.Windows.ResourceDictionary>支持添加、 删除或通过使用代码查询从集合中的资源所需的方法。 <xref:System.Windows.FrameworkContentElement.Resources%2A>属性是可以设置以支持以下场景： 完全替换的元素为一个新的或不同的资源集合<xref:System.Windows.ResourceDictionary>。  
  
 请注意，[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]所示的语法不包含的元素<xref:System.Windows.ResourceDictionary>。 这是隐式集合语法; 一个示例可以省略表示集合元素的标记。 改为指定为项添加到集合的元素。 有关隐式集合的详细信息和[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，请参阅[在详细信息的 XAML 语法](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)。 一种情况下其中<xref:System.Windows.ResourceDictionary>仍显式指定引入合并的字典，这种情况下是否存在通常没有子元素，该元素原样<xref:System.Windows.ResourceDictionary>。 有关详细信息，请参阅[合并资源字典](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)。  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreResourceElements*  
 一个或多个对象元素，其中每个定义的资源。 在每个每个资源属性元素<xref:System.Windows.ResourceDictionary>必须具有唯一值[X:key 指令](~/docs/framework/xaml-services/x-key-directive.md)，它用作唯一键时将从检索值<xref:System.Windows.ResourceDictionary>。  
  
   
  
## Examples  
 下面的示例建立<xref:System.Windows.FrameworkContentElement.Resources%2A>集合<xref:System.Windows.Documents.FlowDocument>根元素。 <xref:System.Windows.Documents.FlowDocument> 是一个典型的选择，因为它是一个少数<xref:System.Windows.FrameworkContentElement>根元素，以及资源有意义的类通常存储在页面根或更高级别的如应用程序。  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为指定的依赖属性向此元素附加一个绑定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">标识绑定属性。</param>
        <param name="path">源属性名称或用于绑定的属性的路径。</param>
        <summary>将提供的源属性名作为数据源的路径限定，从而将绑定附加到此元素上。</summary>
        <returns>记录绑定的条件。 此返回值可用于错误检查。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是调用的便捷方法<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>，后者将当前实例作为传递<xref:System.Windows.DependencyObject>，并创建一个新<xref:System.Windows.Data.Binding>根据所提供`path`参数。 此签名会更方便，当您要建立简单的默认绑定。 如果你需要指定任何绑定属性为非默认条件，或想要使用<xref:System.Windows.Data.MultiBinding>或<xref:System.Windows.Data.PriorityBinding>，应使用<xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>签名。  
  
   
  
## Examples  
 下面的示例设置的绑定上<xref:System.Windows.Documents.Paragraph>元素，通过创建一个新的自定义数据对象，建立该对象作为<xref:System.Windows.FrameworkContentElement.DataContext%2A>，并将绑定路径设置为在其中一个属性。  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">标识绑定属性。</param>
        <param name="binding">表示数据绑定。</param>
        <summary>基于已提供的绑定对象将一个绑定附加到此元素上。</summary>
        <returns>记录绑定的条件。 此返回值可用于错误检查。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是调用的便捷方法<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>，后者将当前实例作为传递<xref:System.Windows.DependencyObject>。  
  
   
  
## Examples  
 下面的示例设置的绑定上<xref:System.Windows.Documents.Paragraph>元素，通过创建新<xref:System.Windows.Data.Binding>和将源设置为新生成`DateTime`对象。  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">资源绑定到的属性。</param>
        <param name="name">资源的名称。</param>
        <summary>搜索具有指定名称的资源，并且为指定的属性设置一个指向该资源的资源引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 资源引用相当于使用[DynamicResource 标记扩展](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)标记中。 资源引用创建提供根据延迟特定的运行时间的指定属性的值的内部表达式。 该表达式将重新计算每当资源字典指示通过内部事件，更改的值或父级的当前元素 （父级更改会更改的字典查找路径）。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回序列化进程是否应在此类的实例上序列化 <see cref="P:System.Windows.FrameworkContentElement.Resources" /> 属性的内容。</summary>
        <returns>
          如果应当序列化 <see cref="P:System.Windows.FrameworkContentElement.Resources" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这将返回`true`只要本地没有至少一个键控的资源<xref:System.Windows.FrameworkContentElement.Resources%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回序列化进程是否应在此类的实例上序列化 <see cref="P:System.Windows.FrameworkContentElement.Style" /> 属性的内容。</summary>
        <returns>
          如果应当序列化 <see cref="P:System.Windows.FrameworkContentElement.Style" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这将返回`true`如果<xref:System.Windows.Style>本地设置。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当参与此元素上的绑定的任意关联数据源更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件曲面<xref:System.Windows.Data.Binding.SourceUpdated>引发任何事件<xref:System.Windows.Data.Binding>与此元素关联。  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此元素要使用的样式。</summary>
        <value>若存在，则为此元素适用的非默认样式。 否则为 <see langword="null" />。 默认情况下构造的 <see cref="T:System.Windows.FrameworkContentElement" /> 的默认值为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从主题，或从通常通过在页面或应用程序级别 （隐式样式） 的资源应用于该类型的对象的样式的默认样式通常提供当前样式。 此属性不未设置或返回默认值 （主题） 样式，但它返回的隐式样式或显式样式。 如果存在隐式或显式样式，它并不重要的样式是访问作为资源还是本地定义。  
  
 设置样式有一些限制。 你可以重置整个<xref:System.Windows.FrameworkContentElement.Style%2A>到新的属性<xref:System.Windows.Style>任何时候，这将强制布局重新组合。 但是，只要该样式加载的元素，置于使用<xref:System.Windows.Style>应视为密封。 尝试对正在使用样式任何单个属性进行更改 (如在集合内的任何内容<xref:System.Windows.Style.Setters%2A>) 将导致异常引发。 在标记中定义样式被视为一旦加载从资源字典 （对于资源），或包含在页面加载 （对于内联样式），可使用。  
  
 <xref:System.Windows.FrameworkContentElement.Style%2A> 是具有特殊优先级依赖项属性。 本地设置样式通常最高优先级会在运行属性系统。 如果<xref:System.Windows.FrameworkContentElement.Style%2A>属性系统检查隐式样式为指定该类型的定义资源加载期间在此情况下，为 null。 如果此步骤后，该样式为仍 null 则样式来自默认 （主题） 样式，但默认样式中将不返回<xref:System.Windows.FrameworkContentElement.Style%2A>属性值。 请参阅[依赖项属性值优先级](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>XAML 值  
 *resourceExtension*  
 以下项之一:，或。 请参阅[XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *styleResourceKey*  
 标识所请求的样式的键。 该键引用中的现有资源<xref:System.Windows.ResourceDictionary>。  
  
> [!NOTE]
>  属性元素语法是从技术上讲是可行的但不是建议这样做。 请参阅[内联样式和模板](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)。  绑定引用使用或<xref:System.Windows.Data.Binding>也是可行的但不常见。  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|元数据属性设置为 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 下面的示例建立<xref:System.Windows.FrameworkContentElement.Resources%2A>集合<xref:System.Windows.Documents.FlowDocument>根元素，且然后引用它作为为特定样式资源<xref:System.Windows.Documents.Paragraph>。  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.Style" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">请求的环境属性的名称。</param>
        <summary>有关此成员的说明，请参见 <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> 方法。</summary>
        <returns>
          如果 <paramref name="propertyName" /> 可用，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Windows.FrameworkContentElement> 实例强制转换为 <xref:System.Windows.Markup.IQueryAmbient> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置任意对象值，该值可用于存储关于此元素的自定义信息。</summary>
        <value>预期值。 此属性没有默认值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性是类似于应用程序或 Windows 窗体的 Visual Basic 等其他 Microsoft 编程模型中的标记属性。 它旨在提供一个预先存在的空间来存储而不进行强制子类化的应用程序开发人员的有关任何元素的一些基本的自定义信息。  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a>XAML 值  
 因为此属性采用对象，你需要使用以设置的属性元素用法<xref:System.Windows.FrameworkContentElement.Tag%2A>属性在 XAML 中具有已知和内置类型转换器，如字符串的对象之外的任何内容。 在这种方式中使用的对象通常并不在标准 WPF 命名空间内，并且因此可能需要将命名空间映射到外部命名空间，才能作为 XAML 元素引入。  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.Tag" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当参与此元素上的绑定的任意关联目标属性更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件曲面<xref:System.Windows.Data.Binding.TargetUpdated>引发任何事件<xref:System.Windows.Data.Binding>与此元素关联。 这通常意味着所讨论的绑定是一个双向绑定，并且绑定依赖项属性的确定每个任何验证或缓存属性支持的方案的以前属性值无效。  
  
 此事件的事件自变量会通知你绑定属性已更改。  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对此元素的模板父级的引用。 如果该元素不是通过模板创建的，则此属性无关。</summary>
        <value>元素其<see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" />导致要创建此元素。 此值通常为<see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 模板是实际共享的对象，其中仅一次创建模板的内容。 因此，如果你获取对来自模板的元素的对象引用，你可能会发现明显的逻辑树无法到达页面根。 若要连接到该页面的逻辑树这样的模板引用，则应获取<xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>值并继续根据需要该元素树中导航。  
  
 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> 将通常为`null`对常见对象，因为如果你通过常用方法的应用程序中获取对象引用从页面外的，该元素可能不根据创建模板。 情况<xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>可能不是`null`应包括处理某些低级别的输入事件，或使用枚举器，可能返回来自模板的元素命中测试、 事件等操作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中为此元素显示的工具提示对象。</summary>
        <value>工具提示对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性的值属于类型<xref:System.Windows.Controls.ToolTip>，则它就是将用于工具提示[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。  如果值为的任何其他类型，则该值将用作*内容*为<xref:System.Windows.Controls.ToolTip>提供 （构造） 系统。 有关详细信息，请参阅 <xref:System.Windows.Controls.ToolTipService>。 服务类提供了可用来进一步自定义工具提示的附加的属性。  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>XAML 值  
 *toolTipContent*  
 将成为显示的文本字符串<xref:System.Windows.FrameworkContentElement.ToolTip%2A>。  
  
 *toolTipObjectContent*  
 对象元素窗体，应该用作的内容中提供的某些对象<xref:System.Windows.FrameworkContentElement>。 通常这是<xref:System.Windows.FrameworkElement>或创建的布局组合的其他某个元素<xref:System.Windows.FrameworkContentElement.ToolTip%2A>，最终包含在该组合中的文本内容。 在这种用法，<xref:System.Windows.Controls.ToolTip>元素创建的隐式地从已分析[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，和*经过*内容设置为其<xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType>属性。  
  
 <`ToolTip` .../>  
 请参阅 <xref:System.Windows.Controls.ToolTip>。  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|元数据属性设置为 `true`|无|  
  
   
  
## Examples  
 下面的示例设置的值<xref:System.Windows.FrameworkElement.ToolTip%2A>直接为字符串的属性。  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在元素上的任何工具提示关闭之前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要取消关闭工具提示，事件的处理程序应将其标记为已处理。  
  
 此事件不能为<xref:System.Windows.EventTrigger>样式。 这是因为此事件的标识符字段重新使用从服务不会公开事件的添加/删除方法的实现。  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由的事件时创建事件标识符对象 (请参阅<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，然后可以使用添加类处理程序 (请参阅<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。 标识符对象包含标识名称、 所有者类型、 处理程序类型、 路由策略和添加事件所有者的实用程序方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在元素上的任何工具提示打开时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要手动打开工具提示，事件的处理程序应将相关的事件标记为已处理。 否则为值<xref:System.Windows.FrameworkContentElement.ToolTip%2A>属性将用于自动打开上下文菜单。 将标记处理的事件可有效地取消的默认操作，并且可重置的值的机会<xref:System.Windows.FrameworkContentElement.ToolTip%2A>属性，然后打开新<xref:System.Windows.Controls.ContextMenu>。 请注意，是否将不会引发此事件<xref:System.Windows.FrameworkContentElement.ToolTip%2A>为空引用或其他取消设置。  
  
 此事件不能为<xref:System.Windows.EventTrigger>样式。 这是因为此事件的标识符字段重新使用从服务不会公开事件的添加/删除方法的实现。  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由的事件时创建事件标识符对象 (请参阅<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，然后可以使用添加类处理程序 (请参阅<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。 标识符对象包含标识名称、 所有者类型、 处理程序类型、 路由策略和添加事件所有者的实用程序方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要查找的资源的键标识符。</param>
        <summary>搜索具有指定键的资源，如果找到，则返回该资源。</summary>
        <returns>找到的资源。 如果未找到资源，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果调用元素上未找到资源，使用在树的方法相同的逻辑树中，搜索父树由在运行时的参数请求的动态资源引用时搜索。  
  
 通常将立即强制转换为已尝试用返回的资源值进行设置的属性的类型的返回值。  
  
 <xref:System.Windows.FrameworkContentElement.FindResource%2A>方法具有类似的行为，只不过它将在不具有所提供键查找资源的情况下发生异常。  
  
   
  
## Examples  
 下面的示例查找标记中定义的资源，并将其应用到的路由事件的响应中的某个元素的某一属性。  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当从已加载元素的元素树中移除元素时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 直接路由的事件不遵循路由，而仅处理引发它们时对同一元素中。 直接路由的事件是否支持其他路由的事件行为： 它们支持的可访问的处理程序集合，并可用作<xref:System.Windows.EventTrigger>样式。  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由的事件时创建事件标识符对象 (请参阅<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，然后可以使用添加类处理程序 (请参阅<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。 标识符对象包含标识名称、 所有者类型、 处理程序类型、 路由策略和添加事件所有者的实用程序方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要从当前范围中移除的名称-对象对的名称。</param>
        <summary>简化对 <see cref="T:System.Windows.NameScope" /> 注销方法的访问。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您只需要取消注册名称到如果你想要重新注册该同名的另一个元素。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将默认样式重新应用至当前 <see cref="T:System.Windows.FrameworkContentElement" />。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>