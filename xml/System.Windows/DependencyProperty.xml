<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0129b0c47acecd870bafaaa4655db115fee937a4" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55372650" /></Metadata><TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示可通过诸如样式、数据绑定、动画和继承等方法设置的属性。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个<xref:System.Windows.DependencyProperty>支持中的以下功能[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   可以在样式中设置该属性。 有关详细信息，请参阅[样式设置和模板化](~/docs/framework/wpf/controls/styling-and-templating.md)。  
  
-   可通过数据绑定设置属性。 有关数据绑定依赖关系属性的详细信息，请参阅[如何：将两个控件的属性绑定](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)。  
  
-   可以使用动态资源引用设置属性。 有关详细信息，请参阅 [XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
-   该属性可以从元素树中的父元素自动继承它的值。 有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
-   可以对属性进行动画处理。 有关详细信息，请参阅 [动画概述](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)。  
  
-   已更改的属性的以前的值和属性值可强制转换时，可以报告属性。 有关详细信息，请参阅[依赖属性回调和验证](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。  
  
-   该属性报告信息到[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，例如更改属性值是否应需要布局系统重新编写的元素的视觉对象。  
  
-   属性接收中的支持[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]。  例如，可以在中编辑属性**属性**窗口。  
  
 若要了解有关依赖项属性的详细信息，请参阅[依赖属性概述](~/docs/framework/wpf/advanced/dependency-properties-overview.md)。 如果希望在自定义类型支持的功能与上述列表中的属性，应创建一个依赖项属性。  若要了解如何创建自定义依赖属性，请参阅[自定义依赖项属性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)。  
  
 附加的属性是属性，用于定义附加的属性的类型的报告信息的任何对象。 在中[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，继承自任何类型<xref:System.Windows.DependencyObject>可以使用附加的属性而不考虑该类型是否继承定义的属性的类型。 附加的属性是一项功能的[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]语言。  若要设置附加的属性在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，使用*ownerType*。*propertyName*语法。 附加属性的一个示例是<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>属性。 如果你想要创建一个属性，可应用于所有<xref:System.Windows.DependencyObject>类型，则应创建附加的属性。 若要详细了解附加属性，包括如何创建它们，请参阅[附加属性概述](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>XAML 值  
 `dependencyPropertyName`  
 一个字符串，指定<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>的所需的依赖项属性。 如果属性不是默认 XML 命名空间中可以按 XML 命名空间前缀前面这 (有关详细信息，请参阅[XAML 命名空间和 WPF XAML Namespace 映射](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。)  
  
 `ownerType`.`dependencyPropertyName`  
 一个字符串，指定所有者类型的依赖项属性，点 （.），则<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>。 `ownerType` 此外可以按 XML 命名空间前缀前面。 这种用法是特定于后期绑定样式和模板，必须为因为分析上下文中指定的依赖项属性的所有者`TargetType`还不知道。 有关详细信息，请参阅[样式设置和模板化](~/docs/framework/wpf/controls/styling-and-templating.md)。  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 一个字符串，指定为附加的属性、 句点 （.），然后附加的属性名称的所有者。 `attachedPropertyOwnerType` 此外可以按 XML 命名空间前缀前面。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将另一种类型添加为已注册到一种类型的依赖属性的所有者。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">要作为此依赖属性所有者添加的类型。</param>
        <summary>将另一种类型添加为已注册的依赖属性的所有者。</summary>
        <returns>一个引用，它指向可标识依赖属性的原始 <see cref="T:System.Windows.DependencyProperty" /> 标识符。 应通过将类添加为 <see langword="public static readonly" /> 字段来公开此标识符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使属性系统最初未注册该特定的依赖项属性的类型上识别依赖项属性。  
  
 通常情况下，<xref:System.Windows.DependencyProperty.AddOwner%2A>用于将依赖项属性添加到不公开通过托管的类继承该依赖项属性的类 (类继承将导致要由派生类继承的包装器属性，因此将提供常规成员表访问权限的依赖关系属性已）。 <xref:System.Windows.DependencyProperty.AddOwner%2A> 使属性系统最初未注册该依赖项属性的类型上识别依赖项属性。  
  
 此签名不允许指定元数据。  当使用此方法时，元数据自动生成的新<xref:System.Windows.DependencyProperty>和其所有者类型。 自动生成元数据是从所有已定义此属性的基类型的合并元数据的结果。 如果无合并元数据不可用，则使用该属性的默认元数据。 如果使用注册该属性<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法，则默认元数据是时创建的元数据相同<xref:System.Windows.DependencyProperty.RegisterAttached%2A>调用。 否则为<xref:System.Windows.PropertyMetadata>对象创建与<xref:System.Windows.PropertyMetadata.DefaultValue%2A>属性设置为属性类型的默认值和所有其他属性<xref:System.Windows.PropertyMetadata>设置为`null`。 使用<xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>签名，如果你想要为添加到所提供的类型的依赖项属性的版本提供元数据。  
  
 此方法的返回值通常用于声明和公开的依赖属性通过将存储依赖项属性标识符。 此标识符提供依赖项属性的访问权限，如果你想要调用属性系统[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]针对依赖项属性，尤其是当它存在添加的所有者类上。 原始所有者和所有者添加的相同属性名称应该用于指示类似的功能。 应使用<xref:System.Windows.DependencyProperty>的返回值<xref:System.Windows.DependencyProperty.AddOwner%2A>方法来定义依赖属性标识符，并还声明[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]属性的包装器，将添加到使用的类型的依赖项属性<xref:System.Windows.DependencyProperty.AddOwner%2A>。  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A>创建中声明的依赖项属性时，上面建议的方法使用[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]。 例如，同时<xref:System.Windows.Controls.Border>并<xref:System.Windows.Controls.Control>定义`BorderBrush`依赖项属性，具有类似的功能。 <xref:System.Windows.Controls.Control> 定义其`BorderBrush`属性设置为通过调用属性系统<xref:System.Windows.DependencyProperty.AddOwner%2A>基于原始所有者<xref:System.Windows.Controls.Border>且其已注册<xref:System.Windows.Controls.Border.BorderBrushProperty>依赖项属性标识符。 <xref:System.Windows.DependencyProperty.AddOwner%2A>返回值然后用于建立一个新的静态<xref:System.Windows.DependencyProperty>字段 (<xref:System.Windows.Controls.Control.BorderBrushProperty>) 上添加所有者，该属性和一个`BorderBrush`还声明属性包装器。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">要作为此依赖属性所有者添加的类型。</param>
        <param name="typeMetadata">在依赖属性存在于所提供的类型上时对其进行限定的元数据。</param>
        <summary>将其他类型添加为已注册的依赖对象所有者，从而为依赖属性提供依赖属性元数据使其存在于提供的所有者类型上。</summary>
        <returns>一个引用，它指向可标识依赖属性的原始 <see cref="T:System.Windows.DependencyProperty" /> 标识符。 应通过将类添加为 <see langword="public static readonly" /> 字段来公开此标识符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使属性系统最初未注册该特定的依赖项属性的类型上识别依赖项属性。  
  
 此方法的返回值用来声明和公开的依赖项属性，尤其是当它位于添加的所有者类。 通常情况下，应使用原始所有者和所有者添加的相同属性名称以指示类似的功能。 它是公开的标识符，以及新的好办法[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]属性的包装器，将添加到使用的类型的依赖项属性<xref:System.Windows.DependencyProperty.AddOwner%2A>。  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A>上面建议的方法使用创建时[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]中声明[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]。 例如，同时<xref:System.Windows.Controls.Border>并<xref:System.Windows.Controls.Control>定义`BorderBrush`依赖项属性，具有类似的功能。 <xref:System.Windows.Controls.Control> 定义其`BorderBrush`属性设置为通过调用属性系统<xref:System.Windows.DependencyProperty.AddOwner%2A>上原始所有者<xref:System.Windows.Controls.Border>且其已注册<xref:System.Windows.Controls.Border.BorderBrushProperty>依赖项属性标识符。 <xref:System.Windows.DependencyProperty.AddOwner%2A>返回值然后用于建立一个静态<xref:System.Windows.DependencyProperty>字段 (<xref:System.Windows.Controls.Control.BorderBrushProperty>) 上添加所有者，该属性和一个`BorderBrush`还声明属性包装器。  
  
 添加的所有者的依赖项属性标识符应使用的操作如<xref:System.Windows.DependencyObject.GetValue%2A>。 但是，涉及类型或如仍将具有不同的元数据所有者添加的类的实例的特定于类型的操作返回预期的结果，即使原始 （未添加的所有者） 中指定依赖项属性标识符调用方法如<xref:System.Windows.DependencyObject.GetValue%2A>或<xref:System.Windows.DependencyProperty.GetMetadata%2A>。 添加的所有者的元数据会保留通过<xref:System.Windows.DependencyProperty.AddOwner%2A>调用本身并不一定以独占方式引用添加的所有者类标识符字段。 不过，它是公开的标识符，以及新的好办法[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]属性的包装器，将添加到使用的类型的依赖关系属性<xref:System.Windows.DependencyProperty.AddOwner%2A>，因为如果不这样做产生之间的差异[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]和[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]您的属性的表示形式。  
  
 提供的元数据合并的依赖项属性的属性元数据存在于基所有者上。 将保留原始的基本元数据中指定的任何特征。 仅已专门在新的元数据中更改这些特性将重写的基本元数据的特征。 一些特征，如<xref:System.Windows.PropertyMetadata.DefaultValue%2A>，如果在新的元数据中指定了替换。 其他人，例如<xref:System.Windows.PropertyChangedCallback>，组合。 从根本上讲，合并行为取决于用于重写时，因此此处所述的行为是使用的现有属性的元数据类的属性元数据类型[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]依赖项属性。 有关详细信息，请参阅[依赖属性元数据](~/docs/framework/wpf/advanced/dependency-property-metadata.md)并[框架属性元数据](~/docs/framework/wpf/advanced/framework-property-metadata.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取依赖项对象的默认元数据。</summary>
        <value>依赖项对象的默认元数据。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认元数据是可供该特定对象或派生类型的对象，通过显式提供了没有备用的元数据的属性元数据<xref:System.Windows.DependencyProperty.Register%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>调用。  
  
 如果原始所有者元数据应用到第一个<xref:System.Windows.DependencyProperty.Register%2A>建立依赖关系属性，则为返回的元数据的调用<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。  
  
 如果没有元数据中原始应用<xref:System.Windows.DependencyProperty.Register%2A>调用，则默认元数据生成内<xref:System.Windows.DependencyProperty.Register%2A>调用并将此值将作为<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。  
  
 具有与关联的默认元数据的主要目的<xref:System.Windows.DependencyProperty>是提供任何上此属性的默认值<xref:System.Windows.DependencyObject>或派生的类型。  
  
 对于非附加属性，此属性返回的元数据类型不能强制转换为派生类型的<xref:System.Windows.PropertyMetadata>类型，即使该属性最初注册的派生的元数据类型。 如果您希望最初已注册的元数据，包括其原始的可能是派生的元数据类型，调用<xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>相反，传递原始注册类型用作参数。  
  
 对于附加属性，返回此属性的元数据的类型将与原始中给定的类型匹配<xref:System.Windows.DependencyProperty.RegisterAttached%2A>注册方法。  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 <see cref="T:System.Windows.DependencyProperty" /> 的哈希代码。</summary>
        <returns>此 <see cref="T:System.Windows.DependencyProperty" /> 的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性系统使用其自己的唯一标识符<xref:System.Windows.DependencyProperty.GlobalIndex%2A>，并返回该属性的值<xref:System.Windows.DependencyProperty.GetHashCode%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回与此依赖属性关联的的元数据（只要它对于特定的类型存在）。 它可以是在其中首次注册依赖属性的类型、随后将其添加到的类型，或在其中通过继承获取依赖属性而已专门重写元数据的类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">要从中检索依赖属性元数据的特定类型。</param>
        <summary>返回此依赖属性的元数据，因为它存在于指定的现有类型上。</summary>
        <returns>属性元数据对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的类型或对象引用，以用作类是必需的元数据可能会不同于最初注册原因可能是因为<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>更改依赖项属性的元数据，因为它存在于上一种类型的调用。  
  
   
  
## Examples  
 下面的示例获取基于其类型的依赖项属性的元数据。 通过使用获取类型`typeof`运算符。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">一个依赖对象，检查了其类型，以便确定元数据应来自依赖属性的哪个类型特定版本。</param>
        <summary>返回此依赖属性的元数据，因为它存在于指定的对象实例上。</summary>
        <returns>属性元数据对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的类型或对象引用必需的任何给定的依赖属性元数据可能会不同于最初注册原因可能是因为<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>可以优化属性元数据，因为它存在于上调用类型。  
  
 当请求基于实例的属性元数据时，实际上只传递该实例，以便可以在内部计算它的类型。 依赖属性元数据没有改变每个实例;它始终是一致的任意给定的类型的属性组合。  
  
   
  
## Examples  
 下面的示例获取基于特定的依赖项属性的元数据<xref:System.Windows.DependencyObject>实例。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">一个特定对象，该对象记录需要其中的依赖属性元数据的依赖项对象类型。</param>
        <summary>为此依赖属性（当它位于指定的对象实例上时）返回元数据。</summary>
        <returns>属性元数据对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的类型或对象引用必需的任何给定的依赖属性元数据可能会不同于最初注册原因可能是因为<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>可以优化属性元数据，因为它存在于上调用类型。  
  
   
  
## Examples  
 下面的示例获取基于依赖项属性的元数据其<xref:System.Windows.DependencyObjectType>。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取唯一标识依赖项对象的内部生成值。</summary>
        <value>唯一数字标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此值是一个整数，未一个全局唯一标识符 (GUID)。 通常情况下，使用此索引值不是必需的并且没有任何索引访问表的所有依赖项属性。 而是应由其标识符字段引用依赖项属性。  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> 在内部使用，更快地访问使用的数据结构<xref:System.Windows.DependencyProperty.GlobalIndex%2A>为从零开始的数组索引。 类似的使用情况可能会有应用程序设计器或工具。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要检查的值。</param>
        <summary>确定指定的值对于该依赖项对象的类型是否可接受（与原依赖项对象注册中提供的属性类型相对照）。</summary>
        <returns>如果指定的值是已注册的属性类型或可接受的派生类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值为`null`是有效类型为引用类型依赖属性，或<xref:System.Nullable%601>依赖项属性，并将返回`true`这种情况下。 在其中依赖项属性是既不是引用的情况下也不是<xref:System.Nullable%601>类型，<xref:System.Windows.DependencyProperty.IsValidType%2A>将返回`false`的 null 值，而不是引发异常。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Windows.DependencyProperty.IsValidType%2A>作为一种检查之前调用<xref:System.Windows.DependencyObject.SetValue%2A>的依赖属性。  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要检查的值。</param>
        <summary>确定所提供的值通过基本类型检查后是否被属性类型接受，以及它是否有可能在该类型的值的允许范围以内。</summary>
        <returns>如果值是可接受的，并且具有正确的类型或派生类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于依赖项属性，可以通过指定该类型的值的允许的范围<xref:System.Windows.ValidateValueCallback>依赖关系属性注册中提供的。  
  
 此方法调用<xref:System.Windows.DependencyProperty.IsValidType%2A>在内部。 如果有问题的依赖关系属性不具有<xref:System.Windows.ValidateValueCallback>，则调用此方法是有效地等效于调用<xref:System.Windows.DependencyProperty.IsValidType%2A>。 如果具有依赖关系属性<xref:System.Windows.ValidateValueCallback>，并且如果<xref:System.Windows.DependencyProperty.IsValidType%2A>将返回`true`，则在回调中实现时将返回的值。  
  
 Null 值是有效的值为引用类型依赖属性，或<xref:System.Nullable%601>依赖项属性，并将返回`true`这种情况下。 在其中依赖项属性是既不是引用的情况下也不是<xref:System.Nullable%601>类型，<xref:System.Windows.DependencyProperty.IsValidType%2A>将返回`false`的 null 值，而不是引发异常。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Windows.DependencyProperty.IsValidValue%2A>作为一种检查之前调用<xref:System.Windows.DependencyObject.SetValue%2A>的依赖属性。  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取依赖属性的名称。</summary>
        <value>属性的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性获取形式提供的名称`name`依赖关系属性注册过程的参数。 此名称是不可变的并且不能为`null`或空字符串。 重复名称注册相同的所有者类型上不允许使用，并尝试注册重复的情况下将引发异常。  
  
> [!IMPORTANT]
>  <xref:System.Windows.DependencyProperty.Name%2A>的依赖项属性必须遵循的去掉后缀"Property"其依赖项属性标识符的名称匹配的约定。 有关详细信息，请参阅[自定义依赖属性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)。  
  
   
  
## Examples  
 下面的示例查询依赖项属性标识符的各种特征包括<xref:System.Windows.DependencyProperty.Name%2A>。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>当此依赖属性位于指定类型的实例上时为其提供替换元数据（而不是在最初注册依赖属性时提供的元数据）。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">一种类型，在该类型上继承该依赖属性并将应用所提供的替换元数据。</param>
        <param name="typeMetadata">一种元数据，它将应用于重写类型上的依赖属性。</param>
        <summary>当此依赖属性位于指定类型的实例上时为其指定替换元数据，以在该依赖属性继承自基类型时重写该属性已存在的元数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应重写依赖属性元数据，然后再属性系统将使用依赖项属性。 这相当于使用注册依赖属性的类来创建特定实例的时间。 调用<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>仅在为自己提供的类型的静态构造函数中执行`forType`参数，此方法，或通过相似的实例化。 尝试更改元数据的所有者类型的实例存在之后不会引发异常，但将导致属性系统中的不一致的行为。  
  
 对于特定的派生的类重写元数据建立使用此方法后，重写此相同的派生类上的元数据的后续尝试将引发异常。  
  
 提供的元数据合并的依赖项属性的属性元数据存在于基所有者上。 原始的基本元数据中指定的任何特征将保持不变;仅已专门在新的元数据中更改这些特性将重写的基本元数据的特征。 如一些特征<xref:System.Windows.PropertyMetadata.DefaultValue%2A>如果在新的元数据中指定替换。 其他人，例如<xref:System.Windows.PropertyChangedCallback>，组合。 从根本上讲，合并行为取决于用于重写时，因此此处所述的行为是使用的现有属性的元数据类的属性元数据类型[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]依赖项属性。 有关详细信息，请参阅[依赖属性元数据](~/docs/framework/wpf/advanced/dependency-property-metadata.md)并[框架属性元数据](~/docs/framework/wpf/advanced/framework-property-metadata.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试重写只读依赖属性的元数据（不能使用此签名完成该操作）。</exception>
        <exception cref="T:System.ArgumentException">已为依赖属性建立元数据，因为它存在于所提供的类型上。</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">一种类型，在该类型上继承该依赖属性并将应用所提供的替换元数据。</param>
        <param name="typeMetadata">一种元数据，它将应用于重写类型上的依赖属性。</param>
        <param name="key">只读依赖属性的访问键。</param>
        <summary>当只读依赖属性位于指定类型的实例上时为其提供替换元数据，以便重写在最初注册依赖属性时提供的元数据。 你必须为只读依赖属性传递 <see cref="T:System.Windows.DependencyPropertyKey" />，以免引发异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此签名提供了基础实现只读依赖属性标识符 (<xref:System.Windows.DependencyPropertyKey>) 方法。 如果重写读写依赖属性元数据，使用<xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>。  
  
 应重写依赖属性元数据，然后再属性系统将使用依赖项属性。 这相当于注册依赖属性的类创建特定对象的时间。 调用<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>仅在为自己提供的类型的静态构造函数中执行`forType`参数，此方法，或通过相似的实例化。 尝试更改元数据的所有者类型的实例存在之后不会引发异常，但将导致属性系统中的不一致的行为。  
  
 对于特定的派生的类重写元数据建立使用此方法后，重写此相同的派生类上的元数据的后续尝试将引发异常。  
  
 提供的元数据合并的依赖项属性的属性元数据存在于基所有者上。 原始的基本元数据中指定的任何特征将保持不变;仅已专门在新的元数据中更改这些特性将重写的基本元数据的特征。 如一些特征<xref:System.Windows.PropertyMetadata.DefaultValue%2A>如果在新的元数据中指定替换。 其他人，例如<xref:System.Windows.PropertyChangedCallback>，组合。 合并行为取决于所使用的重写的属性元数据类型。 有关详细信息，请参阅[依赖属性元数据](~/docs/framework/wpf/advanced/dependency-property-metadata.md)并[框架属性元数据](~/docs/framework/wpf/advanced/framework-property-metadata.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取使用属性系统注册依赖属性或者将自己作为属性所有者添加的对象的类型。</summary>
        <value>注册属性或者将自己作为属性所有者添加的对象的类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册过程中未提供此值。 所有者将任一原始注册类型的情况下<xref:System.Windows.DependencyProperty>从生成标识符<xref:System.Windows.DependencyProperty.Register%2A>调用或将自己作为所有者的情况下添加的类型<xref:System.Windows.DependencyProperty>标识符从生成<xref:System.Windows.DependencyProperty.AddOwner%2A>调用。  
  
 <xref:System.Windows.DependencyProperty.OwnerType%2A>针对任何给定<xref:System.Windows.DependencyProperty>是不可变的并且不能`null`中的有效<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 下面的示例获取基于依赖项属性标识符的所有者类型`dp`，然后获取元数据所有者类型上的该相同的标识符。 此操作是实际等效于获取<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>上`dp`。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取依赖项对象用于其值的类型。</summary>
        <value>属性值的 <see cref="T:System.Type" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性报告的属性的值所声明的原始的注册属性中，通过类型`propertyType`参数。 类似于<xref:System.Windows.DependencyProperty.Name%2A>，注册后依赖项属性的属性类型是不可变。  
  
   
  
## Examples  
 下面的示例查询依赖项属性标识符的各种特征包括<xref:System.Windows.DependencyProperty.PropertyType%2A>。 类型名称字符串<xref:System.Windows.DependencyProperty.PropertyType%2A>获取从返回<xref:System.Type>。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示由此 <see cref="T:System.Windows.DependencyProperty" /> 实例标识的依赖项对象是否为只读依赖项对象。</summary>
        <value>如果该依赖项对象为只读属性，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性系统中注册只读依赖属性，应调用<xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>方法而不是<xref:System.Windows.DependencyProperty.Register%2A>方法。 此外可以将附加的属性注册为只读的;请参阅<xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>。  
  
 只读依赖属性都需要<xref:System.Windows.DependencyPropertyKey>标识符而非<xref:System.Windows.DependencyProperty>标识符执行元数据操作，如重写元数据或将值设置。 如果获取一系列<xref:System.Windows.DependencyProperty>通过调用标识符<xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>或另一个[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]公开标识符，检查<xref:System.Windows.DependencyProperty.ReadOnly%2A>前尝试调用值<xref:System.Windows.DependencyObject.SetValue%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>使用的依赖项属性标识符作为输入参数，以验证标识符表示的依赖关系属性不是只读的。 如果的值<xref:System.Windows.DependencyProperty.ReadOnly%2A>是`true`依赖项的属性是无法通过编程方式获取对引用<xref:System.Windows.DependencyPropertyKey>从元数据或从该依赖项属性标识符<xref:System.Windows.DependencyProperty>标识符; 标识符若要调用必须可用作静态字段<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>对只读依赖属性。  
  
 当您创建自定义依赖属性，并将其注册为只读的时则应定义仅一个 get 访问器为[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]包装器属性。 否则，您的类将具有与对支持依赖项属性的访问权限属性包装器的令人困惑对象模型。 有关详细信息，请参阅[自定义依赖属性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)或[只读依赖属性](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)。  
  
   
  
## Examples  
 以下示例从各种依赖项属性字段中获取的默认元数据和依赖项属性标识符属性，并使用信息来填充表，以实现"元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>注册依赖属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。 名称必须在所有者类型的注册命名空间中是唯一的。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <summary>使用指定的属性名称、属性类型和所有者类型注册依赖属性。</summary>
        <returns>一个依赖属性标识符，应使用它来设置类中 <see langword="public static readonly" /> 字段的值。 稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="typeMetadata">依赖属性的属性元数据。</param>
        <summary>使用指定的属性名称、属性类型、所有者类型和属性元数据注册依赖属性。</summary>
        <returns>一个依赖属性标识符，应使用它来设置类中 <see langword="public static readonly" /> 字段的值。 稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="typeMetadata">依赖属性的属性元数据。</param>
        <param name="validateValueCallback">对回调的引用，除了典型的类型验证之外，该引用还应执行依赖属性值的任何自定义验证。</param>
        <summary>使用指定的属性名称、属性类型、所有者类型、属性元数据和属性的值验证回叫来注册依赖属性。</summary>
        <returns>一个依赖属性标识符，应使用它来设置类中 <see langword="public static readonly" /> 字段的值。 稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 下面的示例注册依赖属性，包括验证回叫 (回调定义不显示; 回调定义的详细信息，请参阅<xref:System.Windows.ValidateValueCallback>)。  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在属性系统上注册附加属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <summary>使用指定的属性名称、属性类型和所有者类型注册附加属性。</summary>
        <returns>一个依赖属性标识符，应使用它来设置类中 <see langword="public static readonly" /> 字段的值。 稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附加的属性是通过定义的属性概念[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 将附加属性实现为依赖属性。 因为[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加的属性是依赖属性，它们可以包含应用，可用于操作，如报表布局特征的常规属性系统的元数据。 有关详细信息，请参阅[附加属性概述](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
 依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 下面的示例注册附加的属性上使用此抽象类<xref:System.Windows.DependencyProperty.RegisterAttached%2A>签名。  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="defaultMetadata">依赖属性的属性元数据。 这可以包括默认值和其他特征。</param>
        <summary>使用指定的属性名、属性类型、所有者类型和属性元数据注册附加的属性。</summary>
        <returns>一个依赖属性标识符，应使用它来设置类中 <see langword="public static readonly" /> 字段的值。 稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附加的属性是通过定义的属性概念[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 将附加属性实现为依赖属性。 因为[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加的属性是依赖属性，它们可以包含应用，可用于操作，如报表布局特征的常规属性系统的元数据。 有关详细信息，请参阅[附加属性概述](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
 依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>使用 RegisterAttached 值继承依赖属性  
 用于注册依赖属性使用一个特殊的情况<xref:System.Windows.DependencyProperty.RegisterAttached%2A>而不是<xref:System.Windows.DependencyProperty.Register%2A>是支持的属性值继承。 应注册与值继承依赖属性<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使该类定义公开该依赖属性的属性包装器访问器，即使您不打算公开 Get * 和集 * 静态方法，以提供 true 附加属性支持访问器。   虽然属性值继承看起来适用于非附加依赖项属性，但通过在运行时树中特定元素边界的非附加属性的继承行为未定义。 将属性注册为附加有效地对属性系统中，附加的属性的全局属性，并确保属性值继承，可以在元素树中的所有边界。 始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>来注册您在其中指定的属性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>元数据中。 有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="defaultMetadata">依赖属性的属性元数据。 这可以包括默认值和其他特征。</param>
        <param name="validateValueCallback">对回调的引用，除了典型的类型验证之外，该引用还应执行依赖属性值的任何自定义验证。</param>
        <summary>使用指定的属性类型、所有者类型、属性元数据和属性的值验证回调来注册附加属性。</summary>
        <returns>一个依赖属性标识符，应使用它来设置类中 <see langword="public static readonly" /> 字段的值。 稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附加的属性是通过定义的属性概念[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 将附加属性实现为依赖属性。 因为[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加的属性是依赖属性，它们可以包含应用，可用于操作，如报表布局特征的常规属性系统的元数据。 有关详细信息，请参阅[附加属性概述](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
 依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>使用 RegisterAttached 值继承依赖属性  
 用于注册依赖属性使用一个特殊的情况<xref:System.Windows.DependencyProperty.RegisterAttached%2A>而不是<xref:System.Windows.DependencyProperty.Register%2A>是支持的属性值继承。 应注册与值继承依赖属性<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使该类定义公开该依赖属性的属性包装器访问器，即使您不打算公开 Get * 和集 * 静态方法，以提供 true 附加属性支持访问器。   虽然属性值继承看起来适用于非附加依赖项属性，但通过在运行时树中特定元素边界的非附加属性的继承行为未定义。 将属性注册为附加有效地对属性系统中，附加的属性的全局属性，并确保属性值继承，可以在元素树中的所有边界。 始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>来注册您在其中指定的属性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>元数据中。 有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
   
  
## Examples  
 下面的示例注册附加的属性上使用此抽象类<xref:System.Windows.DependencyProperty.RegisterAttached%2A>签名。 此附加的属性为枚举类型属性，并注册添加一个验证回调，以验证提供的值为枚举的值。  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>注册只读附加属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="defaultMetadata">依赖属性的属性元数据。</param>
        <summary>使用指定的属性名称、所有者类型和属性元数据注册只读附加属性。</summary>
        <returns>一个依赖属性键，此键应用于设置你的类中静态只读字段的值，该值稍后被用于引用该依赖属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回的类型<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>返回的类型<xref:System.Windows.DependencyProperty>。 通常情况下，表示只读属性的密钥不会将公共的因为密钥可以用于通过调用设置依赖项属性值<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。 类设计会影响你的要求，但通常建议限制的访问权限和任何可见性<xref:System.Windows.DependencyPropertyKey>到只是那些需要将该依赖项属性设置为类或应用程序逻辑的一部分的代码部分。 此外，建议您通过公开的值来公开该只读依赖属性的依赖项属性标识符<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>作为`public static readonly`字段在类上。  
  
 只读附加的属性是少见的方案，因为附加属性的主要方案是在中的使用它[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。 没有公共 setter 的情况下附加的属性不能设置[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]语法。  
  
 依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>使用 RegisterAttached 值继承依赖属性  
 注册为依赖属性的一个特定的方案附加是支持的属性值继承。 应注册与值继承依赖属性<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使该类定义公开该依赖属性的属性包装器访问器，即使您不打算公开 Get * 和集 * 静态方法，以提供 true 附加属性支持访问器。   虽然属性值继承看起来适用于非附加依赖项属性，但通过在运行时树中特定元素边界的非附加属性的继承行为未定义。 将属性注册为附加有效地对属性系统中，附加的属性的全局属性，并确保属性值继承，可以在元素树中的所有边界。 始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>来注册您在其中指定的属性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>元数据中。 有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="defaultMetadata">依赖属性的属性元数据。</param>
        <param name="validateValueCallback">对用户创建的回调的引用，除了典型的类型验证之外，该引用还应执行依赖属性值的任何自定义验证。</param>
        <summary>使用指定的属性类型、所有者类型、属性元数据和验证回调来注册只读附加属性。</summary>
        <returns>一个依赖属性键，应使用它在类中设置静态只读字段的值，然后使用该字段的值引用依赖属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回的类型<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>返回的类型<xref:System.Windows.DependencyProperty>。 通常情况下，表示类型的密钥<xref:System.Windows.DependencyProperty>。 通常情况下，表示只读属性的密钥不会将公共的因为密钥可以用于通过调用设置依赖项属性值<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。 类设计会影响你的要求，但通常建议限制的访问权限和任何可见性<xref:System.Windows.DependencyPropertyKey>到只是那些需要将该依赖项属性设置为类或应用程序逻辑的一部分的代码部分。 此外，建议您通过公开的值来公开该只读依赖属性的依赖项属性标识符<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>作为`public static readonly`字段在类上。  
  
 只读附加的属性是少见的方案，因为附加属性的主要方案是在中的使用它[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。 没有公共 setter 的情况下附加的属性不能设置[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]语法。  
  
 依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>使用 RegisterAttached 值继承依赖属性  
 有关注册依赖项属性为附加而不是一个特殊的情况<xref:System.Windows.DependencyProperty.Register%2A>是支持的属性值继承。 应注册与值继承依赖属性<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使该类定义公开该依赖属性的属性包装器访问器，即使您不打算公开 Get * 和集 * 静态方法，以提供 true 附加属性支持访问器。   虽然属性值继承看起来适用于非附加依赖项属性，但通过在运行时树中特定元素边界的非附加属性的继承行为未定义。 将属性注册为附加有效地对属性系统中，附加的属性的全局属性，并确保属性值继承，可以在元素树中的所有边界。 始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>来注册您在其中指定的属性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>元数据中。 有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将依赖属性注册为只读依赖属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="typeMetadata">依赖属性的属性元数据。</param>
        <summary>使用指定的属性名称、所有者类型和属性元数据注册只读依赖属性。</summary>
        <returns>一个依赖属性键，应使用它在类中设置静态只读字段的值，然后使用该字段的值引用依赖属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回的类型<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>返回的类型<xref:System.Windows.DependencyProperty>。 通常情况下，表示只读属性的密钥不会将公共的因为密钥可以用于通过调用设置依赖项属性值<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。 类设计会影响你的要求，但通常建议限制的访问权限和任何可见性<xref:System.Windows.DependencyPropertyKey>到只是那些需要将该依赖项属性设置为类或应用程序逻辑的一部分的代码部分。 此外，建议您通过公开的值来公开该只读依赖属性的依赖项属性标识符<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>作为`public static readonly`字段在类上。  
  
 只读依赖属性是相当典型的方案中的现有[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]和自定义方案，因为其他[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]功能可能需要依赖项属性，即使该属性不应可以通过设置调用方。 可用于只读依赖属性的值作为基础采用依赖项属性，如将其他属性系统操作<xref:System.Windows.Trigger>样式中的依赖属性。  
  
 依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 下面的示例注册`AquariumSize`依赖项属性为只读的。 该示例定义了`AquariumSizeKey`作为内部键 （在程序集中，以便其他类可以重写元数据） 和依赖项属性标识符基于该密钥作为公开`AquariumSizeProperty`。 此外，对于创建的包装`AquariumSize`，只有 get 访问器。  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="typeMetadata">依赖属性的属性元数据。</param>
        <param name="validateValueCallback">对用户创建的回调的引用，除了典型的类型验证之外，该引用还应执行依赖属性值的任何自定义验证。</param>
        <summary>使用指定的属性类型、所有者类型、属性元数据和验证回叫来注册只读依赖属性。</summary>
        <returns>一个依赖属性键，此键应用于设置你的类中静态只读字段的值，该值稍后被用于引用该依赖属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回的类型<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>返回的类型<xref:System.Windows.DependencyProperty>。 通常情况下，表示只读属性的密钥不会将公共的因为密钥可以用于通过调用设置依赖项属性值<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。 类设计会影响你的要求，但通常建议限制的访问权限和任何可见性<xref:System.Windows.DependencyPropertyKey>到只是那些需要将该依赖项属性设置为类或应用程序逻辑的一部分的代码部分。 此外，建议您通过公开的值来公开该只读依赖属性的依赖项属性标识符<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>作为`public static readonly`字段在类上。  
  
 只读依赖属性是相当典型的方案。 可用于只读依赖属性的值作为基础采用依赖项属性，如将其他属性系统操作<xref:System.Windows.Trigger>样式中的依赖属性。  
  
 依赖关系属性注册的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
 只读依赖属性上的验证可能不太重要。 为密钥指定的非公共访问级别可以减少对任意无效输入的可能性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回依赖属性的字符串表示形式。</summary>
        <returns>依赖属性的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现返回<xref:System.Windows.DependencyProperty.Name%2A>属性值。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定由 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 属性系统使用的静态值而非 <see langword="null" />，以指示属性存在，但其值未经属性系统设置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> 是一个 sentinel 值用于方案，其中[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]属性系统是无法确定请求<xref:System.Windows.DependencyProperty>值。 <xref:System.Windows.DependencyProperty.UnsetValue> 使用而非`null`，因为`null`可以是有效的属性值，也是有效 （和常用） <xref:System.Windows.PropertyMetadata.DefaultValue%2A>。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 永远不会返回带<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>。 当您调用<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>上的依赖项属性<xref:System.Windows.DependencyObject>实例，一个以下应用：  
  
-   依赖属性具有默认值在元数据，并返回该值。 此值可能来自<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。  
  
-   一些其他值由属性系统中，并且默认值不再适用。 有关详细信息，请参阅[依赖属性值优先级](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。  
  
 设置<xref:System.Windows.PropertyMetadata.DefaultValue%2A>的<xref:System.Windows.DependencyProperty.UnsetValue>明确不允许。  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> 返回<xref:System.Windows.DependencyProperty.UnsetValue>时请求的属性具有未在本地设置。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 具有特殊含义时使用的返回值作为<xref:System.Windows.CoerceValueCallback>。 有关详细信息，请参阅[依赖属性回调和验证](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。  
  
 如果要绑定到数据库，请注意<xref:System.Windows.DependencyProperty.UnsetValue>并不等同于<xref:System.DBNull.Value>，以及的方式类似的方式<xref:System.DBNull.Value>并不等同于 true 的为 null。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取依赖项对象的值验证回调。</summary>
        <value>最初依赖项对象注册时为 <paramref name="validateValueCallback" /> 参数提供的该依赖项对象的值验证回调。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性将包含`null`没有已注册的验证回调具有任何依赖项属性。  
  
 验证回叫的行为必须在静态意义上的值： 通过应用验证<xref:System.Windows.ValidateValueCallback>不能确定提供的值是否对任何特定实例有效。 回调仅可以确定是否具有依赖项属性的所有对象应该或不应接受为有效提供的值。 如果你需要执行依赖于知道上一个特定实例，使用的其他依赖项属性的值的验证<xref:System.Windows.CoerceValueCallback>相反。 <xref:System.Windows.CoerceValueCallback>作为依赖属性元数据，而不是直接在依赖项属性标识符的一部分进行注册。 有关详细信息，请参阅[依赖属性回调和验证](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>