<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3e36dd257b906b7c94742536f4e333ac2cac8cd0" />
    <Meta Name="ms.sourcegitcommit" Value="058bfa0b75b777d3171411d35da8f11617fc06b0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="05/04/2018" />
    <Meta Name="ms.locfileid" Value="33660015" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示可通过诸如样式、数据绑定、动画和继承等方法设置的属性。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.DependencyProperty>支持中的以下功能[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   该属性可以设置样式。 有关详细信息，请参阅[样式设置和模板化](~/docs/framework/wpf/controls/styling-and-templating.md)。  
  
-   该属性可以设置数据绑定。 有关数据绑定依赖项属性的详细信息，请参阅[如何： 将两个控件属性的绑定](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)。  
  
-   该属性可以设置的动态资源引用。 有关详细信息，请参阅 [XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
-   属性可以继承其值自动从元素树中父元素。 有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
-   属性可以进行动画处理。 有关详细信息，请参阅 [动画概述](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)。  
  
-   在以前的值的属性已更改，并且可以强制转换的属性值时，可以报告属性。 有关详细信息，请参阅[依赖属性回调和验证](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。  
  
-   该属性向报告信息[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，例如更改属性值是否应需要布局系统重新编写的元素的视觉对象。  
  
-   属性接收中的支持[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]。  例如，可以在中编辑属性**属性**窗口。  
  
 若要了解有关依赖项属性的详细信息，请参阅[依赖项属性概述](~/docs/framework/wpf/advanced/dependency-properties-overview.md)。 如果希望在你自定义的类型，上面的列表中支持的功能上的属性，则应创建一个依赖项属性。  若要了解如何创建自定义的依赖项属性，请参阅[自定义的依赖项属性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)。  
  
 附加的属性是一个属性，使报表信息传递到定义附加的属性的类型的任何对象。 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]，任何类型，继承自<xref:System.Windows.DependencyObject>可以使用附加的属性而不考虑该类型是否继承自定义属性的类型。 附加的属性是一项功能的[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]语言。  在中设置附加的属性[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]，使用*所有者类型*。*propertyName*语法。 附加属性的一个示例是<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>属性。 如果你想要创建一个属性，可以使用对所有<xref:System.Windows.DependencyObject>类型，则你应创建附加的属性。 若要了解有关附加属性，包括如何创建它们，请参阅[附加属性概述](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>XAML 值  
 `dependencyPropertyName`  
 一个字符串，指定<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>的所需的依赖属性。 这可以前面是 XML 命名空间前缀如果属性不在默认 XML 命名空间 (有关详细信息，请参阅[XAML 命名空间和 Namespace 映射为 WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。)  
  
 `ownerType`.`dependencyPropertyName`  
 一个字符串，指定的依赖项属性，一个点 （.）、 所有者类型则<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>。 `ownerType` 此外前面是 XML 命名空间前缀。 这种用法是特定于后期绑定样式和模板，其中依赖项属性的所有者必须指定用于分析上下文，因为`TargetType`来说未知。 有关详细信息，请参阅[样式设置和模板化](~/docs/framework/wpf/controls/styling-and-templating.md)。  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 一个字符串，指定附加的属性，句点 （.），然后附加的属性名称的所有者。 `attachedPropertyOwnerType` 此外前面是 XML 命名空间前缀。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将另一种类型添加为已注册到一种类型的依赖属性的所有者。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">要作为此依赖属性所有者添加的类型。</param>
        <summary>将另一种类型添加为已注册的依赖属性的所有者。</summary>
        <returns>一个引用，它指向可标识依赖属性的原始 <see cref="T:System.Windows.DependencyProperty" /> 标识符。 应通过将类添加为 <see langword="public static readonly" /> 字段来公开此标识符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使属性系统可以识别在最初未注册该特定的依赖项属性的类型上的依赖项属性。  
  
 通常情况下，<xref:System.Windows.DependencyProperty.AddOwner%2A>用于将依赖项属性添加到已不会公开通过托管的类继承该依赖项属性的类 (类继承将导致包装属性由派生类中，继承的因此将提供对依赖项属性的一般的成员表访问已）。 <xref:System.Windows.DependencyProperty.AddOwner%2A> 使属性系统可以识别在最初未注册该依赖项属性的类型上的依赖项属性。  
  
 此签名不允许用于指定元数据。  当你使用此方法时，元数据自动生成的新<xref:System.Windows.DependencyProperty>和其所有者类型。 自动生成元数据是从所有已定义此属性的基类型合并的元数据的结果。 如果未合并的元数据可用，则会使用属性的默认元数据。 如果通过使用注册属性<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法，则默认元数据是时，将创建的元数据相同<xref:System.Windows.DependencyProperty.RegisterAttached%2A>调用。 否则为<xref:System.Windows.PropertyMetadata>对象创建与<xref:System.Windows.PropertyMetadata.DefaultValue%2A>属性设置为该属性类型的默认和所有其他属性<xref:System.Windows.PropertyMetadata>设置为`null`。 使用<xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>签名，如果你想要为添加到所提供的类型的依赖项属性的版本提供元数据。  
  
 此方法的返回值通常用于声明和通过将存储一个依赖属性标识符公开的依赖属性。 此标识符提供对依赖项属性的访问，如果你想要调用属性系统[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]针对依赖项，尤其是当它上是否存在添加的所有者类。 原始所有者和添加的所有者的相同属性名称应该用于指示类似的功能。 应使用<xref:System.Windows.DependencyProperty>的返回值<xref:System.Windows.DependencyProperty.AddOwner%2A>方法来定义依赖属性标识符，并还声明[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]将添加到使用的类型的依赖项属性的属性包装， <xref:System.Windows.DependencyProperty.AddOwner%2A>。  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A>创建声明内的依赖项属性时使用了上面推荐的方法[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]。 例如，同时<xref:System.Windows.Controls.Border>和<xref:System.Windows.Controls.Control>定义`BorderBrush`具有类似的功能的依赖项属性。 <xref:System.Windows.Controls.Control> 定义其`BorderBrush`到通过调用属性系统属性<xref:System.Windows.DependencyProperty.AddOwner%2A>基于原始所有者<xref:System.Windows.Controls.Border>和其已注册<xref:System.Windows.Controls.Border.BorderBrushProperty>依赖项属性标识符。 <xref:System.Windows.DependencyProperty.AddOwner%2A>返回值然后用于建立新的静态<xref:System.Windows.DependencyProperty>字段 (<xref:System.Windows.Controls.Control.BorderBrushProperty>) 上添加的所有者，该属性的和`BorderBrush`属性包装也被声明。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">要作为此依赖属性所有者添加的类型。</param>
        <param name="typeMetadata">在依赖属性存在于所提供的类型上时对其进行限定的元数据。</param>
        <summary>将其他类型添加为已注册的依赖对象所有者，从而为依赖属性提供依赖属性元数据使其存在于提供的所有者类型上。</summary>
        <returns>一个引用，它指向可标识依赖属性的原始 <see cref="T:System.Windows.DependencyProperty" /> 标识符。 应通过将类添加为 <see langword="public static readonly" /> 字段来公开此标识符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使属性系统可以识别在最初未注册该特定的依赖项属性的类型上的依赖项属性。  
  
 此方法的返回值用于声明和公开这样的依赖项属性中，尤其当它位于添加的所有者类。 通常情况下，应使用原始所有者和添加的所有者的相同属性名称以指示类似的功能。 它是公开的标识符，也作为新的好办法[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]将添加到使用的类型的依赖项属性的属性包装， <xref:System.Windows.DependencyProperty.AddOwner%2A>。  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A>上面推荐的方法创建使用[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]内声明[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]。 例如，同时<xref:System.Windows.Controls.Border>和<xref:System.Windows.Controls.Control>定义`BorderBrush`具有类似的功能的依赖项属性。 <xref:System.Windows.Controls.Control> 定义其`BorderBrush`到通过调用属性系统属性<xref:System.Windows.DependencyProperty.AddOwner%2A>的原始所有者<xref:System.Windows.Controls.Border>和其已注册<xref:System.Windows.Controls.Border.BorderBrushProperty>依赖项属性标识符。 <xref:System.Windows.DependencyProperty.AddOwner%2A>返回值然后用于建立一个静态<xref:System.Windows.DependencyProperty>字段 (<xref:System.Windows.Controls.Control.BorderBrushProperty>) 上添加的所有者，该属性的和`BorderBrush`属性包装也被声明。  
  
 添加的所有者的依赖属性标识符应使用的操作如<xref:System.Windows.DependencyObject.GetValue%2A>。 但是，涉及类型或已添加，因为仍将使用不同的元数据的所有者的类的实例的特定类型的操作返回预期的结果，即使原始 （不是添加的所有者的） 中指定的依赖项属性标识符如调用方法<xref:System.Windows.DependencyObject.GetValue%2A>或<xref:System.Windows.DependencyProperty.GetMetadata%2A>。 添加的所有者的元数据通过永久保留<xref:System.Windows.DependencyProperty.AddOwner%2A>调用其自身，不一定是以独占方式添加的所有者类标识符字段引用。 不过，它是公开的标识符，也作为新的好办法，[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]将添加到使用的类型的依赖项属性的属性包装， <xref:System.Windows.DependencyProperty.AddOwner%2A>，因为如果不这样做创建之间的差异[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]和[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]您的属性的表示形式。  
  
 提供的元数据与依赖项属性的属性元数据合并，因为它存在于基的所有者。 将保留在原始的基本元数据中未指定任何特征。 仅已专门在新的元数据中更改这些特征将重写的基本元数据的特征。 某些特征，如<xref:System.Windows.PropertyMetadata.DefaultValue%2A>，如果在新的元数据中指定了替换。 其他，如<xref:System.Windows.PropertyChangedCallback>，将合并。 最终，合并行为取决于正在用于重写时，因此此处所述的行为是使用现有的属性元数据类的属性元数据类型[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]依赖项属性。 有关详细信息，请参阅[依赖属性元数据](~/docs/framework/wpf/advanced/dependency-property-metadata.md)和[Framework 属性元数据](~/docs/framework/wpf/advanced/framework-property-metadata.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取依赖项对象的默认元数据。</summary>
        <value>依赖项对象的默认元数据。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认元数据是通过显式提供任何替换元数据已其中将适用于该特定对象或派生类型的对象的属性元数据<xref:System.Windows.DependencyProperty.Register%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>调用。  
  
 如果原始所有者元数据应用到第一个<xref:System.Windows.DependencyProperty.Register%2A>建立依赖项属性，则为返回该元数据的调用<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。  
  
 如果没有元数据已应用在原始<xref:System.Windows.DependencyProperty.Register%2A>调用，则默认元数据生成内<xref:System.Windows.DependencyProperty.Register%2A>调用并将此值将作为<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。  
  
 具有与关联的默认元数据的主要用途<xref:System.Windows.DependencyProperty>旨在提供对任何此属性的默认值<xref:System.Windows.DependencyObject>或派生的类型。  
  
 对于非附加属性，此属性返回的元数据类型不能强制转换为派生类型的<xref:System.Windows.PropertyMetadata>键入，即使该属性最初注册了一个派生的元数据类型。 如果您需要最初已注册的元数据，包括其原始的可能派生的元数据类型，调用<xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>，传递原始注册类型作为参数。  
  
 对于附加属性，此属性返回的元数据的类型将与原始中给定的类型匹配<xref:System.Windows.DependencyProperty.RegisterAttached%2A>注册方法。  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 <see cref="T:System.Windows.DependencyProperty" /> 的哈希代码。</summary>
        <returns>此 <see cref="T:System.Windows.DependencyProperty" /> 的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性系统使用其自己的唯一标识符<xref:System.Windows.DependencyProperty.GlobalIndex%2A>，并且该属性的值由返回<xref:System.Windows.DependencyProperty.GetHashCode%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回与此依赖属性关联的的元数据（只要它对于特定的类型存在）。 它可以是在其中首次注册依赖属性的类型、随后将其添加到的类型，或在其中通过继承获取依赖属性而已专门重写元数据的类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">要从中检索依赖属性元数据的特定类型。</param>
        <summary>返回此依赖属性的元数据，因为它存在于指定的现有类型上。</summary>
        <returns>属性元数据对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的类型或对象引用以用作类是必需的元数据可能会不同于原始注册原因可能是因为<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>alter 依赖项属性的元数据，因为它存在于一种类型的调用。  
  
   
  
## Examples  
 下面的示例获取基于其类型的依赖项属性的元数据。 通过使用获取类型`typeof`运算符。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">一个依赖对象，检查了其类型，以便确定元数据应来自依赖属性的哪个类型特定版本。</param>
        <summary>返回此依赖属性的元数据，因为它存在于指定的对象实例上。</summary>
        <returns>属性元数据对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的类型或对象引用必需的任何给定的依赖项属性的元数据可能会不同于原始注册原因可能是因为<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>可以优化的属性元数据，因为它存在于调用类型。  
  
 在请求基于实例的属性元数据时，都实际上只通过实例，以便其类型可在内部计算。 依赖属性元数据不发生改变每个实例;它始终是一致的任何给定的类型属性组合。  
  
   
  
## Examples  
 下面的示例获取基于特定的依赖项属性的元数据<xref:System.Windows.DependencyObject>实例。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">一个特定对象，该对象记录需要其中的依赖属性元数据的依赖项对象类型。</param>
        <summary>为此依赖属性（当它位于指定的对象实例上时）返回元数据。</summary>
        <returns>属性元数据对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的类型或对象引用必需的任何给定的依赖项属性的元数据可能会不同于原始注册原因可能是因为<xref:System.Windows.DependencyProperty.AddOwner%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>可以优化的属性元数据，因为它存在于调用类型。  
  
   
  
## Examples  
 下面的示例获取基于的依赖项属性的元数据其<xref:System.Windows.DependencyObjectType>。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取唯一标识依赖项对象的内部生成值。</summary>
        <value>唯一数字标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此值是一个整数，不全局唯一标识符 (GUID)。 通常情况下，使用此索引值不是必需的并且没有任何索引访问的所有依赖项属性的表。 而是应由其标识符字段引用依赖项属性。  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> 可供内部使用的数据结构更快地访问用于<xref:System.Windows.DependencyProperty.GlobalIndex%2A>为从零开始的数组索引。 类似的用法可能具有的应用程序设计器或工具。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要检查的值。</param>
        <summary>确定指定的值对于该依赖项对象的类型是否可接受（与原依赖项对象注册中提供的属性类型相对照）。</summary>
        <returns>
          如果指定的值是已注册的属性类型或可接受的派生类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值为`null`是有效类型的引用类型依赖项属性，或为<xref:System.Nullable%601>依赖项属性，并将返回`true`在这些情况下。 在其中依赖项属性是既不是引用的情况下也不是<xref:System.Nullable%601>类型，<xref:System.Windows.DependencyProperty.IsValidType%2A>将返回`false`为 null 值，而不是引发异常。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Windows.DependencyProperty.IsValidType%2A>作为一种检查之前调用<xref:System.Windows.DependencyObject.SetValue%2A>的依赖属性。  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要检查的值。</param>
        <summary>确定所提供的值通过基本类型检查后是否被属性类型接受，以及它是否有可能在该类型的值的允许范围以内。</summary>
        <returns>
          如果值是可接受的，并且具有正确的类型或派生类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依赖项属性，可通过指定允许的范围内的该类型的值<xref:System.Windows.ValidateValueCallback>提供在注册依赖属性。  
  
 此方法调用<xref:System.Windows.DependencyProperty.IsValidType%2A>内部。 如果涉及的依赖项属性未包含任何<xref:System.Windows.ValidateValueCallback>，则调用此方法是有效地等效于调用<xref:System.Windows.DependencyProperty.IsValidType%2A>。 如果具有依赖项属性<xref:System.Windows.ValidateValueCallback>，并且如果<xref:System.Windows.DependencyProperty.IsValidType%2A>将返回`true`，则在回调中实现时将返回的值。  
  
 空值是有效的值对于引用类型依赖项对象，或者对于<xref:System.Nullable%601>依赖项属性，并将返回`true`在这些情况下。 在其中依赖项属性是既不是引用的情况下也不是<xref:System.Nullable%601>类型，<xref:System.Windows.DependencyProperty.IsValidType%2A>将返回`false`为 null 值，而不是引发异常。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Windows.DependencyProperty.IsValidValue%2A>作为一种检查之前调用<xref:System.Windows.DependencyObject.SetValue%2A>的依赖属性。  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取依赖属性的名称。</summary>
        <value>属性的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性获取形式提供的名称`name`期间注册依赖属性的参数。 此名称是不可变的并且不能为`null`或空字符串。 重复名称注册相同的所有者类型上不允许使用，并尝试注册重复的情况下将引发异常。  
  
> [!IMPORTANT]
>  <xref:System.Windows.DependencyProperty.Name%2A>的依赖项属性必须遵循的后缀"Property"减去其依赖项属性标识符的名称匹配的约定。 有关详细信息，请参阅[自定义依赖属性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)。  
  
   
  
## Examples  
 下面的示例查询的依赖项属性标识符，各种特征包括<xref:System.Windows.DependencyProperty.Name%2A>。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>当此依赖属性位于指定类型的实例上时为其提供替换元数据（而不是在最初注册依赖属性时提供的元数据）。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">一种类型，在该类型上继承该依赖属性并将应用所提供的替换元数据。</param>
        <param name="typeMetadata">一种元数据，它将应用于重写类型上的依赖属性。</param>
        <summary>当此依赖属性位于指定类型的实例上时为其指定替换元数据，以在该依赖属性继承自基类型时重写该属性已存在的元数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依赖属性元数据应被替代，然后再属性系统将使用依赖项属性。 这相当于使用注册的依赖项属性的类来创建特定实例的时间。 调用<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>仅应在提供本身为的类型的静态构造函数中执行`forType`参数，此方法，或通过类似实例化。 尝试更改元数据之后有所有者类型的实例, 不会引发异常，但将导致属性系统中的不一致的行为。  
  
 使用此方法建立了特定派生的类重写元数据后，重写此相同的派生类上的元数据的后续尝试将引发异常。  
  
 提供的元数据与依赖项属性的属性元数据合并，因为它存在于基的所有者。 在原始的基本元数据中未指定任何特征将保持不变;仅已专门在新的元数据中更改这些特征将重写的基本元数据的特征。 如某些特征<xref:System.Windows.PropertyMetadata.DefaultValue%2A>如果新的元数据中指定的替换。 其他，如<xref:System.Windows.PropertyChangedCallback>，将合并。 最终，合并行为取决于正在用于重写时，因此此处所述的行为是使用现有的属性元数据类的属性元数据类型[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]依赖项属性。 有关详细信息，请参阅[依赖属性元数据](~/docs/framework/wpf/advanced/dependency-property-metadata.md)和[Framework 属性元数据](~/docs/framework/wpf/advanced/framework-property-metadata.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试重写只读依赖属性的元数据（不能使用此签名完成该操作）。</exception>
        <exception cref="T:System.ArgumentException">已为依赖属性建立元数据，因为它存在于所提供的类型上。</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">一种类型，在该类型上继承该依赖属性并将应用所提供的替换元数据。</param>
        <param name="typeMetadata">一种元数据，它将应用于重写类型上的依赖属性。</param>
        <param name="key">只读依赖属性的访问键。</param>
        <summary>当只读依赖属性位于指定类型的实例上时为其提供替换元数据，以便重写在最初注册依赖属性时提供的元数据。 您必须为只读依赖项对象传递 <see cref="T:System.Windows.DependencyPropertyKey" />，以避免引发异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此签名提供了一个只读依赖属性标识符的基础实现 (<xref:System.Windows.DependencyPropertyKey>) 方法。 如果重写读写依赖项属性的元数据，使用<xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>。  
  
 依赖属性元数据应被替代，然后再属性系统将使用依赖项属性。 这相当于注册依赖属性的类创建特定对象的时间。 调用<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>仅应在提供本身为的类型的静态构造函数中执行`forType`参数，此方法，或通过类似实例化。 尝试更改元数据之后有所有者类型的实例, 不会引发异常，但将导致属性系统中的不一致的行为。  
  
 使用此方法建立了特定派生的类重写元数据后，重写此相同的派生类上的元数据的后续尝试将引发异常。  
  
 提供的元数据与依赖项属性的属性元数据合并，因为它存在于基的所有者。 在原始的基本元数据中未指定任何特征将保持不变;仅已专门在新的元数据中更改这些特征将重写的基本元数据的特征。 如某些特征<xref:System.Windows.PropertyMetadata.DefaultValue%2A>如果新的元数据中指定的替换。 其他，如<xref:System.Windows.PropertyChangedCallback>，将合并。 合并行为取决于正在使用用于重写的属性元数据类型。 有关详细信息，请参阅[依赖属性元数据](~/docs/framework/wpf/advanced/dependency-property-metadata.md)和[Framework 属性元数据](~/docs/framework/wpf/advanced/framework-property-metadata.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取使用属性系统注册依赖属性或者将自己作为属性所有者添加的对象的类型。</summary>
        <value>注册属性或者将自己作为属性所有者添加的对象的类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性注册期间提供此值。 所有者将任一原始注册类型的情况下<xref:System.Windows.DependencyProperty>从生成标识符<xref:System.Windows.DependencyProperty.Register%2A>调用，或者将自己作为所有者的情况下添加的类型<xref:System.Windows.DependencyProperty>从生成标识符<xref:System.Windows.DependencyProperty.AddOwner%2A>调用。  
  
 <xref:System.Windows.DependencyProperty.OwnerType%2A>针对任何给定<xref:System.Windows.DependencyProperty>是不可变，并且不能为`null`中是有效<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 下面的示例获取基于一个依赖属性标识符的所有者类型`dp`，然后获取元数据上的所有者类型对于该相同的标识符。 此操作在实际等效于获取<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>上`dp`。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取依赖项对象用于其值的类型。</summary>
        <value>属性值的 <see cref="T:System.Type" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性报告类型的属性的值所声明的原始的注册属性中，通过`propertyType`参数。 类似于<xref:System.Windows.DependencyProperty.Name%2A>，依赖项属性的属性类型注册后不可变。  
  
   
  
## Examples  
 下面的示例查询的依赖项属性标识符，各种特征包括<xref:System.Windows.DependencyProperty.PropertyType%2A>。 类型名称字符串<xref:System.Windows.DependencyProperty.PropertyType%2A>获取从返回<xref:System.Type>。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示由此 <see cref="T:System.Windows.DependencyProperty" /> 实例标识的依赖项对象是否为只读依赖项对象。</summary>
        <value>
          如果该依赖项对象为只读属性，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在属性系统注册只读依赖属性，应调用<xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>方法而非<xref:System.Windows.DependencyProperty.Register%2A>方法。 此外可以将附加的属性注册为只读的;请参阅<xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>。  
  
 只读依赖属性可能需要<xref:System.Windows.DependencyPropertyKey>标识符而不是<xref:System.Windows.DependencyProperty>标识符来执行元数据操作，例如重写元数据或将值设置。 如果你获得的集合<xref:System.Windows.DependencyProperty>通过调用标识符<xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>或另一个[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]公开标识符，检查<xref:System.Windows.DependencyProperty.ReadOnly%2A>尝试调用之前的值<xref:System.Windows.DependencyObject.SetValue%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>使用，这些功能依赖项属性标识符作为输入参数，以验证标识符表示的依赖项属性不是只读的。 如果值<xref:System.Windows.DependencyProperty.ReadOnly%2A>是`true`某个依赖项属性，没有获得对的引用无法通过编程方式<xref:System.Windows.DependencyPropertyKey>从元数据或从该依赖属性标识符<xref:System.Windows.DependencyProperty>标识符; 标识符若要调用必须可用作静态字段<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>针对只读依赖属性。  
  
 当你创建自定义的依赖项属性，并将其注册为只读的时应定义仅一个 get 访问器为[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]包装属性。 否则，你的类将具有相比对后备依赖项属性的访问权限属性包装令人困惑的对象模型。 有关详细信息，请参阅[自定义依赖项属性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)或[只读依赖项属性](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)。  
  
   
  
## Examples  
 下面的示例从各种依赖项属性字段，获取的默认元数据和依赖项属性标识符属性，并使用信息来填充表，以实现"元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>注册依赖属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。 名称必须在所有者类型的注册命名空间中是唯一的。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <summary>使用指定的属性名称、属性类型和所有者类型注册依赖属性。</summary>
        <returns>一个依赖项对象标识符，应使用它在您的类中设置 <see langword="public static readonly" /> 字段的值。 稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关注册依赖属性的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="typeMetadata">依赖属性的属性元数据。</param>
        <summary>使用指定的属性名称、属性类型、所有者类型和属性元数据注册依赖属性。</summary>
        <returns>一个依赖项对象标识符，应使用它在您的类中设置 <see langword="public static readonly" /> 字段的值。 稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关注册依赖属性的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="typeMetadata">依赖属性的属性元数据。</param>
        <param name="validateValueCallback">对回调的引用，除了典型的类型验证之外，该引用还应执行依赖属性值的任何自定义验证。</param>
        <summary>使用指定的属性名称、属性类型、所有者类型、属性元数据和属性的值验证回叫来注册依赖属性。</summary>
        <returns>一个依赖项对象标识符，应使用它在您的类中设置 <see langword="public static readonly" /> 字段的值。 稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关注册依赖属性的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 下面的示例注册依赖属性，包括验证回调 (回调定义不显示; 回调定义的详细信息，请参阅<xref:System.Windows.ValidateValueCallback>)。  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在属性系统上注册附加属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <summary>使用指定的属性名称、属性类型和所有者类型注册附加属性。</summary>
        <returns>一个依赖项对象标识符，应使用它在您的类中设置 <see langword="public static readonly" /> 字段的值。 稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附加的属性是由定义的属性概念[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 实现附加作为依赖项属性的属性。 因为[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加的属性都是依赖项属性，它们可以应用可以用于操作，如 reporting 布局特征的常规属性系统的元数据。 有关详细信息，请参阅[附加属性概述](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
 有关注册依赖属性的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 下面的示例注册附加的属性对使用此抽象类<xref:System.Windows.DependencyProperty.RegisterAttached%2A>签名。  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="defaultMetadata">依赖属性的属性元数据。 这可以包括默认值和其他特征。</param>
        <summary>使用指定的属性名、属性类型、所有者类型和属性元数据注册附加的属性。</summary>
        <returns>一个依赖项对象标识符，应使用它在您的类中设置 <see langword="public static readonly" /> 字段的值。 稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附加的属性是由定义的属性概念[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 实现附加作为依赖项属性的属性。 因为[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加的属性都是依赖项属性，它们可以应用可以用于操作，如 reporting 布局特征的常规属性系统的元数据。 有关详细信息，请参阅[附加属性概述](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
 有关注册依赖属性的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>值继承依赖项属性的使用 RegisterAttached  
 注册具有的依赖项属性的一个特定的方案<xref:System.Windows.DependencyProperty.RegisterAttached%2A>而不是<xref:System.Windows.DependencyProperty.Register%2A>是支持属性值继承。 你应注册将依赖项属性值继承与<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使类定义公开依赖项属性的属性包装访问器，即使你不打算公开 Get * 和集 * 静态方法，以便提供 true 附加属性支持访问器。   虽然可能会出现属性值继承，使其适用于非附加依赖项属性，通过在运行时树中的某些元素边界的非附加属性的继承行为是未定义。 将属性注册为有效地附加到属性系统，便可以附加的属性的全局属性，并且可确保属性值继承可以在元素树中的所有边界。 始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>注册你在其中指定的属性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>的元数据中。 有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="defaultMetadata">依赖属性的属性元数据。 这可以包括默认值和其他特征。</param>
        <param name="validateValueCallback">对回调的引用，除了典型的类型验证之外，该引用还应执行依赖属性值的任何自定义验证。</param>
        <summary>使用指定的属性类型、所有者类型、属性元数据和属性的值验证回调来注册附加属性。</summary>
        <returns>一个依赖项对象标识符，应使用它在您的类中设置 <see langword="public static readonly" /> 字段的值。 稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附加的属性是由定义的属性概念[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 实现附加作为依赖项属性的属性。 因为[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加的属性都是依赖项属性，它们可以应用可以用于操作，如 reporting 布局特征的常规属性系统的元数据。 有关详细信息，请参阅[附加属性概述](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
 有关注册依赖属性的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>值继承依赖项属性的使用 RegisterAttached  
 注册具有的依赖项属性的一个特定的方案<xref:System.Windows.DependencyProperty.RegisterAttached%2A>而不是<xref:System.Windows.DependencyProperty.Register%2A>是支持属性值继承。 你应注册将依赖项属性值继承与<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使类定义公开依赖项属性的属性包装访问器，即使你不打算公开 Get * 和集 * 静态方法，以便提供 true 附加属性支持访问器。   虽然可能会出现属性值继承，使其适用于非附加依赖项属性，通过在运行时树中的某些元素边界的非附加属性的继承行为是未定义。 将属性注册为有效地附加到属性系统，便可以附加的属性的全局属性，并且可确保属性值继承可以在元素树中的所有边界。 始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>注册你在其中指定的属性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>的元数据中。 有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
   
  
## Examples  
 下面的示例注册附加的属性对使用此抽象类<xref:System.Windows.DependencyProperty.RegisterAttached%2A>签名。 此附加的属性是枚举类型属性，并注册添加的验证回调，以验证提供的值为枚举的值。  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>注册只读附加属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="defaultMetadata">依赖属性的属性元数据。</param>
        <summary>使用指定的属性名称、所有者类型和属性元数据注册只读附加属性。</summary>
        <returns>一个依赖属性键，此键应用于设置你的类中静态只读字段的值，该值稍后被用于引用该依赖属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回的类型<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>返回的类型<xref:System.Windows.DependencyProperty>。 通常，表示只读属性的键不是公共的因为密钥可用于设置依赖项属性值，通过调用<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。 类设计会影响你的要求，但通常建议来限制访问和可见性的任何<xref:System.Windows.DependencyPropertyKey>到仅是那些有必要，将该依赖项属性设置为类或应用程序逻辑的一部分的代码部分。 此外，还建议通过公开的值公开只读依赖属性，一个依赖属性标识符<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>作为`public static readonly`字段上您的类。  
  
 只读附加的属性是少见的方案，因为附加属性的主要方案是在中的使用它[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。 如果公共 setter，没有附加的属性不能设置[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]语法。  
  
 有关注册依赖属性的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>值继承依赖项属性的使用 RegisterAttached  
 注册为依赖项属性的一个特定的方案附加是支持属性值继承。 你应注册将依赖项属性值继承与<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使类定义公开依赖项属性的属性包装访问器，即使你不打算公开 Get * 和集 * 静态方法，以便提供 true 附加属性支持访问器。   虽然可能会出现属性值继承，使其适用于非附加依赖项属性，通过在运行时树中的某些元素边界的非附加属性的继承行为是未定义。 将属性注册为有效地附加到属性系统，便可以附加的属性的全局属性，并且可确保属性值继承可以在元素树中的所有边界。 始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>注册你在其中指定的属性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>的元数据中。 有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="defaultMetadata">依赖属性的属性元数据。</param>
        <param name="validateValueCallback">对用户创建的回调的引用，除了典型的类型验证之外，该引用还应执行依赖属性值的任何自定义验证。</param>
        <summary>使用指定的属性类型、所有者类型、属性元数据和验证回调来注册只读附加属性。</summary>
        <returns>一个依赖属性键，应使用它在类中设置静态只读字段的值，然后使用该字段的值引用依赖属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回的类型<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>返回的类型<xref:System.Windows.DependencyProperty>。 通常情况下，代表的类型的键<xref:System.Windows.DependencyProperty>。 通常，表示只读属性的键不是公共的因为密钥可用于设置依赖项属性值，通过调用<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。 类设计会影响你的要求，但通常建议来限制访问和可见性的任何<xref:System.Windows.DependencyPropertyKey>到仅是那些有必要，将该依赖项属性设置为类或应用程序逻辑的一部分的代码部分。 此外，还建议通过公开的值公开只读依赖属性，一个依赖属性标识符<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>作为`public static readonly`字段上您的类。  
  
 只读附加的属性是少见的方案，因为附加属性的主要方案是在中的使用它[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。 如果公共 setter，没有附加的属性不能设置[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]语法。  
  
 有关注册依赖属性的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>值继承依赖项属性的使用 RegisterAttached  
 注册为附加而不是依赖项属性的一个特定的方案<xref:System.Windows.DependencyProperty.Register%2A>是支持属性值继承。 你应注册将依赖项属性值继承与<xref:System.Windows.DependencyProperty.RegisterAttached%2A>即使类定义公开依赖项属性的属性包装访问器，即使你不打算公开 Get * 和集 * 静态方法，以便提供 true 附加属性支持访问器。   虽然可能会出现属性值继承，使其适用于非附加依赖项属性，通过在运行时树中的某些元素边界的非附加属性的继承行为是未定义。 将属性注册为有效地附加到属性系统，便可以附加的属性的全局属性，并且可确保属性值继承可以在元素树中的所有边界。 始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>注册你在其中指定的属性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>的元数据中。 有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将依赖属性注册为只读依赖属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="typeMetadata">依赖属性的属性元数据。</param>
        <summary>使用指定的属性名称、所有者类型和属性元数据注册只读依赖属性。</summary>
        <returns>一个依赖属性键，应使用它在类中设置静态只读字段的值，然后使用该字段的值引用依赖属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回的类型<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>返回的类型<xref:System.Windows.DependencyProperty>。 通常，表示只读属性的键不是公共的因为密钥可用于设置依赖项属性值，通过调用<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。 类设计会影响你的要求，但通常建议来限制访问和可见性的任何<xref:System.Windows.DependencyPropertyKey>到仅是那些有必要，将该依赖项属性设置为类或应用程序逻辑的一部分的代码部分。 此外，还建议通过公开的值公开只读依赖属性，一个依赖属性标识符<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>作为`public static readonly`字段上您的类。  
  
 只读依赖属性是相当典型的方案中这两个现有[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]和自定义方案，因为其他[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]功能可能需要依赖项属性，即使该属性并非旨在成为可通过设置调用方。 你可以执行需要依赖项属性，例如使其他属性系统操作只读依赖属性的值将用作基础<xref:System.Windows.Trigger>样式中的依赖属性。  
  
 有关注册依赖属性的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
   
  
## Examples  
 下面的示例注册`AquariumSize`依赖项属性为只读。 该示例定义了`AquariumSizeKey`（在程序集中，以便其他类无法重写元数据） 的内部密钥以及依赖项属性标识符基于为该密钥的公开`AquariumSizeProperty`。 此外，为创建的包装`AquariumSize`，与仅一个 get 访问器。  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="typeMetadata">依赖属性的属性元数据。</param>
        <param name="validateValueCallback">对用户创建的回调的引用，除了典型的类型验证之外，该引用还应执行依赖属性值的任何自定义验证。</param>
        <summary>使用指定的属性类型、所有者类型、属性元数据和验证回叫来注册只读依赖属性。</summary>
        <returns>一个依赖属性键，此键应用于设置你的类中静态只读字段的值，该值稍后被用于引用该依赖属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回的类型<xref:System.Windows.DependencyPropertyKey>，而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>返回的类型<xref:System.Windows.DependencyProperty>。 通常，表示只读属性的键不是公共的因为密钥可用于设置依赖项属性值，通过调用<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>。 类设计会影响你的要求，但通常建议来限制访问和可见性的任何<xref:System.Windows.DependencyPropertyKey>到仅是那些有必要，将该依赖项属性设置为类或应用程序逻辑的一部分的代码部分。 此外，还建议通过公开的值公开只读依赖属性，一个依赖属性标识符<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>作为`public static readonly`字段上您的类。  
  
 只读依赖属性是相当典型的方案。 你可以执行需要依赖项属性，例如使其他属性系统操作只读依赖属性的值将用作基础<xref:System.Windows.Trigger>样式中的依赖属性。  
  
 有关注册依赖属性的详细信息，请参阅<xref:System.Windows.DependencyProperty>。  
  
 对只读依赖属性的验证可能不太重要。 你为密钥指定的非公共访问级别降低了对任意无效输入的可能性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回依赖属性的字符串表示形式。</summary>
        <returns>依赖属性的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现返回<xref:System.Windows.DependencyProperty.Name%2A>属性值。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定由 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 属性系统使用的静态值而非 <see langword="null" />，以指示属性存在，但其值未经属性系统设置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> 是用于方案的 sentinel 值其中[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]属性系统不能确定请求<xref:System.Windows.DependencyProperty>值。 <xref:System.Windows.DependencyProperty.UnsetValue> 使用而非`null`，这是因为`null`可能是一个有效的属性值，以及有效 （和常用） <xref:System.Windows.PropertyMetadata.DefaultValue%2A>。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 永远不会返回外<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>。 当调用<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>上的依赖项属性<xref:System.Windows.DependencyObject>适用的情况下，以下项之一：  
  
-   依赖项属性在元数据中建立的默认值，而返回该值。 此值可能来自于<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。  
  
-   一些其他值由属性系统，并且默认值不再适用。 有关详细信息，请参阅[依赖属性值优先级](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。  
  
 设置<xref:System.Windows.PropertyMetadata.DefaultValue%2A>的<xref:System.Windows.DependencyProperty.UnsetValue>明确不允许。  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> 返回<xref:System.Windows.DependencyProperty.UnsetValue>当请求的属性具有未在本地设置。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 具有特殊含义时用作的返回值<xref:System.Windows.CoerceValueCallback>。 有关详细信息，请参阅[依赖项属性的回调和验证](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。  
  
 如果你正在绑定到数据库，请注意，<xref:System.Windows.DependencyProperty.UnsetValue>不等效于<xref:System.DBNull.Value>，如何以类似方式<xref:System.DBNull.Value>不等于 true null。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取依赖项对象的值验证回调。</summary>
        <value>最初依赖项对象注册时为 <paramref name="validateValueCallback" /> 参数提供的该依赖项对象的值验证回调。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性将包含`null`对于没有注册的验证回调的任何依赖项属性。  
  
 验证回调必须在静态的意义上执行操作的值： 验证通过应用<xref:System.Windows.ValidateValueCallback>无法确定提供的值是否有效的任何特定的实例。 回调仅可以确定是否具有依赖项属性的所有对象应，或不应接受为有效提供的值。 如果你需要执行依赖于知道上一个特定实例，使用其他依赖项属性的值的验证<xref:System.Windows.CoerceValueCallback>相反。 <xref:System.Windows.CoerceValueCallback>作为一部分的依赖属性元数据，而不是直接在依赖属性标识符内注册。 有关详细信息，请参阅[依赖项属性的回调和验证](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>