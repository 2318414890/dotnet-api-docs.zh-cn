<Type Name="ContentElement" FullName="System.Windows.ContentElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3ead77d5c5a1444bb78a389f6dd17f78c4fdbd08" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32038484" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ContentElement : System.Windows.DependencyObject, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ContentElement extends System.Windows.DependencyObject implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class ContentElement&#xA;Inherits DependencyObject&#xA;Implements IAnimatable, IInputElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContentElement : System::Windows::DependencyObject, System::Windows::IInputElement, System::Windows::Media::Animation::IAnimatable" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="e7c98-101">为内容元素提供 WPF 核心级基类。</span>
      <span class="sxs-lookup">
        <span data-stu-id="e7c98-101">Provides a WPF core-level base class for content elements.</span>
      </span>
      <span data-ttu-id="e7c98-102">内容元素设计用于流样式显示，它们使用面向标记的直观布局模型和精心设计的简单对象模型。</span>
      <span class="sxs-lookup">
        <span data-stu-id="e7c98-102">Content elements are designed for flow-style presentation, using an intuitive markup-oriented layout model and a deliberately simple object model.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-103"><xref:System.Windows.ContentElement> 定义以下常见内容的特征：</span><span class="sxs-lookup"><span data-stu-id="e7c98-103"><xref:System.Windows.ContentElement> defines the following common content characteristics:</span></span>  
  
-   <span data-ttu-id="e7c98-104">输入： 所有<xref:System.Windows.ContentElement>派生的类提供用于从键盘、 鼠标、 拖放操作、 触笔控件和快捷键的基本输入捕获的支持。</span><span class="sxs-lookup"><span data-stu-id="e7c98-104">Input: All <xref:System.Windows.ContentElement> derived classes provide support for basic input capture from keyboard, mouse, drag-and-drop operations, stylus controls, and accelerators.</span></span>  
  
-   <span data-ttu-id="e7c98-105">焦点： 所有<xref:System.Windows.ContentElement>派生的类是能够获得焦点。</span><span class="sxs-lookup"><span data-stu-id="e7c98-105">Focus: All <xref:System.Windows.ContentElement> derived classes are potentially focusable.</span></span> <span data-ttu-id="e7c98-106">(但是，默认焦点状态<xref:System.Windows.ContentElement>基类是`false`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-106">(However, the default focusable state for the <xref:System.Windows.ContentElement> base class is `false`.</span></span> <span data-ttu-id="e7c98-107">有关详细信息，如何使<xref:System.Windows.ContentElement>可获得焦点，请参阅<xref:System.Windows.ContentElement.Focusable%2A>。)此外，此类包含[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]，你可将用于在相关元素中遍历焦点。</span><span class="sxs-lookup"><span data-stu-id="e7c98-107">For details on how to make a <xref:System.Windows.ContentElement> focusable, see <xref:System.Windows.ContentElement.Focusable%2A>.) In addition, this class contains [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] that you can use for traversing the focus across related elements.</span></span>  
  
-   <span data-ttu-id="e7c98-108">事件：<xref:System.Windows.ContentElement>包括事件中与输入和焦点相关; 它还包括状态中的更改的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-108">Events: <xref:System.Windows.ContentElement> includes events that are related to input and focus; it also includes events for changes in state.</span></span> <span data-ttu-id="e7c98-109">在许多情况下，<xref:System.Windows.ContentElement>事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-109">In many cases, the <xref:System.Windows.ContentElement> events are routed events.</span></span> <span data-ttu-id="e7c98-110">在某些情况下，路由的事件都具有隧道和冒泡路由策略，为同一个状态或条件的响应中不同的事件引发。</span><span class="sxs-lookup"><span data-stu-id="e7c98-110">In some cases, routed events have both tunneling and bubbling routing strategies, raised as separate events in response to the same state or condition.</span></span> <span data-ttu-id="e7c98-111">此外，<xref:System.Windows.ContentElement>定义[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]可引发路由事件以及可以添加或移除事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-111">Also, <xref:System.Windows.ContentElement> defines [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] that can raise routed events and that can add or remove handlers to events.</span></span>  
  
 <span data-ttu-id="e7c98-112"><xref:System.Windows.ContentElement> 共享许多公共[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]与<xref:System.Windows.UIElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-112"><xref:System.Windows.ContentElement> shares many common [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] with <xref:System.Windows.UIElement>.</span></span> <span data-ttu-id="e7c98-113">这些公共[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]并非来自共享的类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-113">These common [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] do not come from a shared class inheritance.</span></span> <span data-ttu-id="e7c98-114">但它们共享公共命名、 类似的行为和类似内部实现[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]在每个类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-114">But they do share common naming, similar behavior, and similar internal implementation of [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] in each class.</span></span> <span data-ttu-id="e7c98-115">相似性是因为<xref:System.Windows.ContentElement>和<xref:System.Windows.UIElement>是基，元素的每个类，尽管每个具有不同目的对其标记对象模型的行为。</span><span class="sxs-lookup"><span data-stu-id="e7c98-115">The similarity is because <xref:System.Windows.ContentElement> and <xref:System.Windows.UIElement> are each classes that are an element base, although each has different intentions for its markup object model behavior.</span></span>  
  
 <span data-ttu-id="e7c98-116">具体而言，<xref:System.Windows.UIElement>递减自<xref:System.Windows.Media.Visual>，该属性提供较低级别图形支持呈现<xref:System.Windows.ContentElement>合成窗口内的矩形区域而<xref:System.Windows.ContentElement>延迟呈现，以便详细的概念更轻松地支持对文档的方案，例如流和自动换行，都通用的。</span><span class="sxs-lookup"><span data-stu-id="e7c98-116">In particular, <xref:System.Windows.UIElement> descends from <xref:System.Windows.Media.Visual>, which provides the lower-level graphics support for rendering a <xref:System.Windows.ContentElement> to a rectangular region within a composited window, whereas <xref:System.Windows.ContentElement> defers rendering so that concepts more common to document scenarios, such as flow and wrapping, are more easily supported.</span></span> <span data-ttu-id="e7c98-117">这两个相关类还实现公共接口<xref:System.Windows.IInputElement>和<xref:System.Windows.Media.Animation.IAnimatable>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-117">These two related classes also implement the common interfaces <xref:System.Windows.IInputElement> and <xref:System.Windows.Media.Animation.IAnimatable>.</span></span>  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="e7c98-118">
          <see cref="T:System.Windows.ContentElement" />类未尚未定义流样式显示的完整内容元素的所有方面。</span>
        <span class="sxs-lookup">
          <span data-stu-id="e7c98-118">The <see cref="T:System.Windows.ContentElement" /> class does not yet define all aspects of a complete content element for flow-style presentation.</span>
        </span>
        <span data-ttu-id="e7c98-119">
          <see cref="T:System.Windows.FrameworkContentElement" /> 是的一个立即派生的类<see cref="T:System.Windows.ContentElement" />。</span>
        <span class="sxs-lookup">
          <span data-stu-id="e7c98-119">
            <see cref="T:System.Windows.FrameworkContentElement" /> is an immediately derived class of <see cref="T:System.Windows.ContentElement" />.</span>
        </span>
        <span data-ttu-id="e7c98-120">
          <see cref="T:System.Windows.FrameworkContentElement" /> 包括一组更为完整的其他成员以支持呈现<see cref="T:System.Windows.FrameworkContentElement" />内容主机和使用 WPF 框架级别布局系统中。</span>
        <span class="sxs-lookup">
          <span data-stu-id="e7c98-120">
            <see cref="T:System.Windows.FrameworkContentElement" /> includes a more complete set of additional members that support rendering a <see cref="T:System.Windows.FrameworkContentElement" /> within a content host and using the WPF framework-level layout system.</span>
        </span>
      </para>
    </block>
    <altmember cref="T:System.Windows.UIElement" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-121">初始化 <see cref="T:System.Windows.ContentElement" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-121">Initializes a new instance of the <see cref="T:System.Windows.ContentElement" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-122">为指定的路由事件添加路由事件处理程序，并将该处理程序添加到当前元素的处理程序集合中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-122">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <span data-ttu-id="e7c98-123">要处理的路由事件的标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-123">An identifier for the routed event to be handled.</span>
          </span>
        </param>
        <param name="handler">
          <span data-ttu-id="e7c98-124">对处理程序实现的引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-124">A reference to the handler implementation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-125">为指定的路由事件添加路由事件处理程序，并将该处理程序添加到当前元素的处理程序集合中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-125">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-126">可以将同一事件的同一处理程序添加多次而不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="e7c98-126">You can add the same handler for the same event multiple times without raising an exception.</span></span> <span data-ttu-id="e7c98-127">但是，该处理程序实际调用的多次处理该事件时。</span><span class="sxs-lookup"><span data-stu-id="e7c98-127">However, the handler is actually invoked multiple times when the event is handled.</span></span> <span data-ttu-id="e7c98-128">因此，请考虑如何此行为可能会产生的负面影响，应考虑在处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-128">Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</span></span>  
  
 <span data-ttu-id="e7c98-129">通常使用此方法来提供的"添加"访问器实现[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]事件的自定义的路由事件的访问模式。</span><span class="sxs-lookup"><span data-stu-id="e7c98-129">You typically use this method to provide the implementation of the "add" accessor for the [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] event access pattern of a custom routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <span data-ttu-id="e7c98-130">要处理的路由事件的标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-130">An identifier for the.routed event to be handled.</span>
          </span>
        </param>
        <param name="handler">
          <span data-ttu-id="e7c98-131">对处理程序实现的引用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-131">A reference to the handler implementation.</span>
          </span>
        </param>
        <param name="handledEventsToo">
          <span data-ttu-id="e7c98-132">如果为 <see langword="true" />，则将按以下方式注册处理程序：即使路由事件在其事件数据中标记为已处理，也会调用处理程序；如果为 <see langword="false" />，则使用默认条件注册处理程序，即当路由事件被标记为已处理时，将不调用处理程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-132">
              <see langword="true" /> to register the handler such that it is invoked even when the routed event is marked handled in its event data; <see langword="false" /> to register the handler with the default condition that it will not be invoked if the routed event is already marked handled.</span>
          </span>
          <span data-ttu-id="e7c98-133">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-133">The default is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="e7c98-134">请勿定期请求重新处理路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-134">Do not routinely ask to rehandle a routed event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-135">为指定的路由事件添加路由事件处理程序，并将该处理程序添加到当前元素的处理程序集合中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-135">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span>
          </span>
          <span data-ttu-id="e7c98-136">将 <paramref name="handledEventsToo" /> 指定为 <see langword="true" />，可为已标记为由事件路由中的其他元素处理的路由事件调用所提供的处理程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-136">Specify <paramref name="handledEventsToo" /> as <see langword="true" /> to have the provided handler be invoked for routed event that had already been marked as handled by another element along the event route.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-137">处理低级别的输入的事件中切实可行的方法是一个复杂的任务。</span><span class="sxs-lookup"><span data-stu-id="e7c98-137">Processing low-level input events in a practical way is a complex task.</span></span> <span data-ttu-id="e7c98-138">许多控件实现的行为其中特定事件被标记为已处理，而替换为另一个更直观的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-138">Many controls implement behavior where a certain event is marked as handled, and is replaced by another more intuitive event.</span></span> <span data-ttu-id="e7c98-139">通常情况下，控制为已处理某个设计意图要求这样做是否只是标注平台输入的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-139">Generally, a control will only mark a platform input event as handled if there is some design intention for doing so.</span></span> <span data-ttu-id="e7c98-140">在某些情况下，这些设计意图可能不是你的输入事件的特定处理的要求。</span><span class="sxs-lookup"><span data-stu-id="e7c98-140">In certain scenarios, those design intentions might not be what your particular handling of the input event requires.</span></span> <span data-ttu-id="e7c98-141">它为这些方案是该注册处理程序替换`handledEventsToo`作为`true`适合。</span><span class="sxs-lookup"><span data-stu-id="e7c98-141">It is for these scenarios that registering handlers with `handledEventsToo` as `true` is appropriate.</span></span> <span data-ttu-id="e7c98-142">但你不应该这样做例行。</span><span class="sxs-lookup"><span data-stu-id="e7c98-142">But you should not do this routinely.</span></span> <span data-ttu-id="e7c98-143">调用以响应所有事件处理程序，即使处理将使你自己的应用程序事件处理逻辑。</span><span class="sxs-lookup"><span data-stu-id="e7c98-143">Invoking handlers in response to all events even if handled will complicate your own application event processing logic.</span></span> <span data-ttu-id="e7c98-144">如果处理程序逻辑是庞大，可能会看到导致性能降低。</span><span class="sxs-lookup"><span data-stu-id="e7c98-144">You may see a decrease in performance if the handler logic is substantial.</span></span> <span data-ttu-id="e7c98-145">你应保留使用附加的已处理事件的情况下，你已检测到在开发过程中，某些控件正在处理你仍想要使用应用程序逻辑处理的事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-145">You should reserve the use of attaching handlers for already-handled events for situations where you have already discovered during the development process that certain controls are handling events that you still want to handle with application logic.</span></span>  
  
 <span data-ttu-id="e7c98-146">避免处理的某些事件控件组合的行为的类的另一种方法是使用该事件的预览版的替代项。</span><span class="sxs-lookup"><span data-stu-id="e7c98-146">Another technique for avoiding the class handling behavior of certain event-control combinations is to use that event's preview alternative.</span></span> <span data-ttu-id="e7c98-147">例如，如果<xref:System.Windows.ContentElement.MouseLeftButtonDown>标记为已处理类处理，你可能能够为添加处理程序<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>相反。</span><span class="sxs-lookup"><span data-stu-id="e7c98-147">For example, if <xref:System.Windows.ContentElement.MouseLeftButtonDown> is marked handled by class handling, you might be able to add handlers for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> instead.</span></span>  
  
 <span data-ttu-id="e7c98-148">可以将同一事件的同一处理程序添加多次而不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="e7c98-148">You can add the same handler for the same event multiple times without raising an exception.</span></span> <span data-ttu-id="e7c98-149">但是，该处理程序实际调用的多次处理该事件时。</span><span class="sxs-lookup"><span data-stu-id="e7c98-149">However, the handler is actually invoked multiple times when the event is handled.</span></span> <span data-ttu-id="e7c98-150">因此，请考虑如何此行为可能会产生的负面影响，应考虑在处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-150">Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</span></span>  
  
 <span data-ttu-id="e7c98-151">通常使用此方法来提供的"添加"访问器实现[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]事件的自定义的路由事件的访问模式。</span><span class="sxs-lookup"><span data-stu-id="e7c98-151">You typically use this method to provide the implementation of the "add" accessor for the [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] event access pattern of a custom routed event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e7c98-152">下面的示例实现一个处理程序调用<xref:System.Windows.FrameworkElement.Initialized>将定义处理程序附加到一个页面使用的命名元素的页面上的事件`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-152">The following example implements a handler invoked on the <xref:System.Windows.FrameworkElement.Initialized> event on a page that attaches a defined handler to one of the named elements on the page using `handledEventsToo` `true`.</span></span> <span data-ttu-id="e7c98-153">将调用此处理程序，即使在路由过程的另一个元素标记为已处理之前已到达路线中的处理元素共享的事件数据。</span><span class="sxs-lookup"><span data-stu-id="e7c98-153">This handler would be invoked even if another element along the route marked the shared event data as handled before reaching the handling element in the route.</span></span>  
  
 [!code-csharp[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml.cs#addhandlerhandledtoo)]
 [!code-vb[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/page2.xaml.vb#addhandlerhandledtoo)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToEventRoute (route As EventRoute, e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToEventRoute(System::Windows::EventRoute ^ route, System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route">
          <span data-ttu-id="e7c98-154">要向其添加处理程序的事件路由。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-154">The event route that handlers are added to.</span>
          </span>
        </param>
        <param name="e">
          <span data-ttu-id="e7c98-155">用于添加处理程序的事件数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-155">The event data that is used to add the handlers.</span>
          </span>
          <span data-ttu-id="e7c98-156">此方法使用参数的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 属性来创建处理程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-156">This method uses the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> property of the arguments to create the handlers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-157">将处理程序添加到当前 <see cref="T:System.Windows.EventRoute" /> 事件处理程序集合的指定 <see cref="T:System.Windows.ContentElement" /> 中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-157">Adds handlers to the specified <see cref="T:System.Windows.EventRoute" /> for the current <see cref="T:System.Windows.ContentElement" /> event handler collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-158">此方法用于内容主机元素 (无论它们是否实现<xref:System.Windows.IContentHost>) 才能将内容主机子元素的处理程序添加到主机<xref:System.Windows.EventRoute>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-158">Use this method for content host elements (regardless whether they implement <xref:System.Windows.IContentHost>) in order to add handlers for the content host child elements to the host <xref:System.Windows.EventRoute>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-159">获取或设置一个值，该值指示此元素能否用作拖放操作的目标。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-159">Gets or sets a value that indicates whether this element can be used as the target of a drag-and-drop operation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-160">如果此元素可用作拖放操作的目标，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-160">
              <see langword="true" /> if this element can be used as the target of a drag-and-drop operation; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="e7c98-161">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-161">The default value is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-162">拖放操作默认情况下，不启用和必须通过设置有意启用<xref:System.Windows.ContentElement.AllowDrop%2A>到`true`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-162">Drag-and-drop operations are not enabled by default, and must be enabled deliberately by setting <xref:System.Windows.ContentElement.AllowDrop%2A> to  `true`.</span></span> <span data-ttu-id="e7c98-163">除了此基本设置，拖放行为完全是特定的实现，并且未定义的<xref:System.Windows.ContentElement>或任何其他类，该类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-163">Beyond this basic setting, drag-and-drop behavior is entirely implementation specific and is not defined by <xref:System.Windows.ContentElement> or any other base element class.</span></span> <span data-ttu-id="e7c98-164">例如，某些控件<xref:System.Windows.Controls.RichTextBox>，默认行为，但不是具有<xref:System.Windows.ContentElement>派生的类具有此类行为。</span><span class="sxs-lookup"><span data-stu-id="e7c98-164">Certain controls, for example, <xref:System.Windows.Controls.RichTextBox>, do have a default behavior, but no <xref:System.Windows.ContentElement> derived classes have such a behavior.</span></span> <span data-ttu-id="e7c98-165">拖放的详细信息，请参阅[拖放概述](~/docs/framework/wpf/advanced/drag-and-drop-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-165">For more information on drag and drop, see [Drag and Drop Overview](~/docs/framework/wpf/advanced/drag-and-drop-overview.md).</span></span>  
  
 <span data-ttu-id="e7c98-166"><xref:System.Windows.FrameworkContentElement> 重写在其实现此依赖项属性的元数据。</span><span class="sxs-lookup"><span data-stu-id="e7c98-166"><xref:System.Windows.FrameworkContentElement> overrides the metadata for this dependency property in its implementation.</span></span> <span data-ttu-id="e7c98-167">具体而言，<xref:System.Windows.FrameworkContentElement>指定此属性允许属性值继承 (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>是`true`元数据中)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-167">Specifically, <xref:System.Windows.FrameworkContentElement> designates that this property allows property value inheritance (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> is `true` in metadata).</span></span> <span data-ttu-id="e7c98-168">在此上下文中的属性值继承意味着，如果有任何其他值的子元素<xref:System.Windows.ContentElement.AllowDrop%2A>通过本地值或样式，最接近的父元素的值与此值分配 （也是在样式，默认情况下分配值或本地值），则该父元素中的值通过属性系统分配给所有未分配的子元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-168">Property value inheritance in this context means that if there are child elements with no other value for <xref:System.Windows.ContentElement.AllowDrop%2A> assigned through local values or styles, the value of the nearest parent element with this value assigned (again, either in styles, by default values, or a local value), then the value from that parent element is assigned to all unassigned child elements by the property system.</span></span> <span data-ttu-id="e7c98-169">这意味着你可以指定是否允许拖放操作的根元素处，然后传播到所有的值<xref:System.Windows.FrameworkContentElement>具有不专门为其分配的值的子元素`false`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-169">This means that you can specify whether to allow drop operations at the root element and then propagate the value to all <xref:System.Windows.FrameworkContentElement> child elements that have not specifically assigned it a value of `false`.</span></span>  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="e7c98-170">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-170">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-171">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-171">Identifier field</span></span>|<xref:System.Windows.ContentElement.AllowDropProperty>|  
|<span data-ttu-id="e7c98-172">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="e7c98-172">Metadata properties set to `true`</span></span>|<span data-ttu-id="e7c98-173">无</span><span class="sxs-lookup"><span data-stu-id="e7c98-173">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="e7c98-174">下面的示例设置<xref:System.Windows.ContentElement.AllowDrop%2A>中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="e7c98-174">The following example sets <xref:System.Windows.ContentElement.AllowDrop%2A> in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#AllowDrop](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#allowdrop)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AllowDropProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowDropProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowDropProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-175">标识 <see cref="P:System.Windows.ContentElement.AllowDrop" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-175">Identifies the <see cref="P:System.Windows.ContentElement.AllowDrop" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-176">将动画应用到此元素的指定依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-176">Applies an animation to a specified dependency property on this element.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="e7c98-177">要进行动画处理的属性的标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-177">The identifier for the property to animate.</span>
          </span>
        </param>
        <param name="clock">
          <span data-ttu-id="e7c98-178">控制和声明动画的动画时钟。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-178">The animation clock that controls and declares the animation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-179">将动画应用到此元素的指定依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-179">Applies an animation to a specified dependency property on this element.</span>
          </span>
          <span data-ttu-id="e7c98-180">任何现有动画均停止并替换为新动画。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-180">Any existing animations are stopped and replaced with the new animation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-181">若要从属性中移除动画，指定为该属性的标识符`dp`并指定`clock`作为`null`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-181">To remove an animation from a property, specify the identifier for that property as `dp` and specify `clock` as `null`.</span></span> <span data-ttu-id="e7c98-182">这将删除动画和动画的属性设置为其基值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-182">This removes the animation and the animated property is set to its base value.</span></span> <span data-ttu-id="e7c98-183">但是，不会停止最初关联的动画时钟。</span><span class="sxs-lookup"><span data-stu-id="e7c98-183">However, the originally associated animation clock is not stopped.</span></span> <span data-ttu-id="e7c98-184">分配给该时钟的任何其他动画将继续运行。</span><span class="sxs-lookup"><span data-stu-id="e7c98-184">Any other animations assigned to that clock will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="e7c98-185">要进行动画处理的属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-185">The property to animate.</span>
          </span>
        </param>
        <param name="clock">
          <span data-ttu-id="e7c98-186">控制和声明动画的动画时钟。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-186">The animation clock that controls and declares the animation.</span>
          </span>
        </param>
        <param name="handoffBehavior">
          <span data-ttu-id="e7c98-187">枚举的一个值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-187">A value of the enumeration.</span>
          </span>
          <span data-ttu-id="e7c98-188">默认值为 <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />，这会停止任何现有动画并将其替换为新动画。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-188">The default is <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />, which will stop any existing animation and replace with the new one.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-189">向此元素的指定依赖属性应用动画，并且可以指定当该属性已有正在运行的动画时所要执行的操作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-189">Applies an animation to a specified dependency property on this element, with the ability to specify what happens if the property already has a running animation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-190">若要从属性中移除动画，指定为该属性的标识符`dp`并指定`clock`作为`null`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-190">To remove an animation from a property, specify the identifier for that property as `dp` and specify `clock` as `null`.</span></span> <span data-ttu-id="e7c98-191">这将删除动画和动画的属性设置为其基值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-191">This removes the animation and the animated property is set to its base value.</span></span> <span data-ttu-id="e7c98-192">但是，不会停止最初关联的动画时钟。</span><span class="sxs-lookup"><span data-stu-id="e7c98-192">However, the originally associated animation clock is not stopped.</span></span> <span data-ttu-id="e7c98-193">分配给该时钟的任何其他动画将继续运行。</span><span class="sxs-lookup"><span data-stu-id="e7c98-193">Any other animations assigned to that clock will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCaptured { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-194">获取一个值，该值指示在此元素上是否至少捕获了一次触摸。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-194">Gets a value that indicates whether at least one touch is captured to this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-195">如果在此元素上至少捕获了一次触摸，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-195">
              <see langword="true" /> if at least one touch is captured to this element; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-196">标识 <see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-196">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCapturedWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCapturedWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-197">获取一个值，该值指示在此元素或其可视化树中的任何子元素上是否至少捕获了一次触摸。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-197">Gets a value that indicates whether at least one touch is captured to this element or to any child elements in its visual tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-198">如果在此元素或其可视化树中的任何子元素上至少捕获了一次触摸，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-198">
              <see langword="true" /> if at least one touch is captured to this element or any child elements in its visual tree; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-199">标识 <see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-199">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesDirectlyOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-200">获取一个值，该值指示在此元素上是否至少按下了一次触摸设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-200">Gets a value that indicates whether at least one touch is pressed over this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-201">如果在此元素上至少按下了一次触摸设备，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-201">
              <see langword="true" /> if at least one touch is pressed over this element; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesDirectlyOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-202">标识 <see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-202">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-203">获取一个值，该值指示在此元素或其可视化树中的任何子元素上是否至少按下了一次触摸设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-203">Gets a value that indicates whether at least one touch is pressed over this element or any child elements in its visual tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-204">如果在此元素或其可视化树中的任何子元素上至少按下了一次触摸设备，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-204">
              <see langword="true" /> if at least one touch is pressed over this element or any child elements in its visual tree; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-205">标识 <see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-205">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-206">为此元素的指定要进行动画处理的属性启动动画。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-206">Starts an animation for a specified animated property on this element.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="e7c98-207">要进行动画处理的属性，它被指定为依赖项属性标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-207">The property to animate, which is specified as a dependency property identifier.</span>
          </span>
        </param>
        <param name="animation">
          <span data-ttu-id="e7c98-208">要启动的动画的时间线。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-208">The timeline of the animation to start.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-209">为此元素的指定要进行动画处理的属性启动动画。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-209">Starts an animation for a specified animated property on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-210">当你检查属性是否动画处理时，请注意动画将开始，并被视为非动画的起始点以外的第一帧呈现时进行动画处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-210">When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</span></span>  
  
 <span data-ttu-id="e7c98-211">如果<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>为`animation`是`null`，然后将删除当前的任何动画，并且保持的属性的当前值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-211">If the <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> for `animation` is `null`, then any current animations are removed and the current value of the property is held.</span></span>  
  
 <span data-ttu-id="e7c98-212">如果整个`animation`值是`null`、 从属性中移除所有动画和属性值将恢复为其基值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-212">If the entire `animation` value is `null`, all animations are removed from the property and the property value reverts to its base value.</span></span> <span data-ttu-id="e7c98-213">但是，不会停止最初关联的动画时间线。</span><span class="sxs-lookup"><span data-stu-id="e7c98-213">However, the originally associated animation timeline is not stopped.</span></span> <span data-ttu-id="e7c98-214">分配给该时间线中的任何其他动画将继续运行。</span><span class="sxs-lookup"><span data-stu-id="e7c98-214">Any other animations assigned to that timeline will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="e7c98-215">要进行动画处理的属性，它被指定为依赖项属性标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-215">The property to animate, which is specified as the dependency property identifier.</span>
          </span>
        </param>
        <param name="animation">
          <span data-ttu-id="e7c98-216">要应用的动画的时间线。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-216">The timeline of the animation to be applied.</span>
          </span>
        </param>
        <param name="handoffBehavior">
          <span data-ttu-id="e7c98-217">一个枚举值，用来指定新动画如何与已在影响属性值的任何当前（正在运行的）动画进行交互。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-217">A value of the enumeration that specifies how the new animation interacts with any current (running) animations that are already affecting the property value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-218">为此元素的指定要进行动画处理的属性启动特定的动画，并可以指定当该属性已有正在运行的动画时所要执行的操作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-218">Starts a specific animation for a specified animated property on this element, with the option of specifying what happens if the property already has a running animation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-219">当你检查属性是否动画处理时，请注意动画将开始，并被视为非动画的起始点以外的第一帧呈现时进行动画处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-219">When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</span></span>  
  
 <span data-ttu-id="e7c98-220">如果<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>为`animation`是`null`，然后将删除当前的任何动画，并且保持的属性的当前值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-220">If the <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> for `animation` is `null`, then any current animations are removed and the current value of the property is held.</span></span>  
  
 <span data-ttu-id="e7c98-221">如果整个`animation`值是`null`、 从属性中移除所有动画和属性值将恢复为其基值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-221">If the entire `animation` value is `null`, all animations are removed from the property and the property value reverts to its base value.</span></span> <span data-ttu-id="e7c98-222">但是，不会停止最初关联的动画时间线。</span><span class="sxs-lookup"><span data-stu-id="e7c98-222">However, the originally associated animation timeline is not stopped.</span></span> <span data-ttu-id="e7c98-223">分配给该时间线中的任何其他动画将继续运行。</span><span class="sxs-lookup"><span data-stu-id="e7c98-223">Any other animations assigned to that timeline will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureMouse" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureMouse () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureMouse();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureMouse</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-224">尝试将鼠标强制捕获到此元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-224">Attempts to force capture of the mouse to this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e7c98-225">如果成功捕获了鼠标，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-225">
              <see langword="true" /> if the mouse is successfully captured; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-226">若要捕获，必须启用一个元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-226">To be captured, an element must be enabled.</span></span> <span data-ttu-id="e7c98-227">检查是否<xref:System.Windows.ContentElement.IsEnabled%2A>是`true`之前调用<xref:System.Windows.ContentElement.CaptureMouse%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-227">Check whether <xref:System.Windows.ContentElement.IsEnabled%2A> is `true` before you call <xref:System.Windows.ContentElement.CaptureMouse%2A>.</span></span>  
  
 <span data-ttu-id="e7c98-228">如果调用<xref:System.Windows.ContentElement.CaptureMouse%2A>返回`true`，然后<xref:System.Windows.ContentElement.IsMouseCaptured%2A>也`true`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-228">If calling <xref:System.Windows.ContentElement.CaptureMouse%2A> returns `true`, then <xref:System.Windows.ContentElement.IsMouseCaptured%2A> is also `true`.</span></span>  
  
 <span data-ttu-id="e7c98-229">如果调用<xref:System.Windows.ContentElement.CaptureMouse%2A>返回`true`，则<xref:System.Windows.ContentElement.GotMouseCapture>和<xref:System.Windows.ContentElement.IsMouseCapturedChanged>引发的事件，与<xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType>在事件数据报告为元素其中<xref:System.Windows.ContentElement.CaptureMouse%2A>调用方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-229">If calling <xref:System.Windows.ContentElement.CaptureMouse%2A> returns `true`, then the <xref:System.Windows.ContentElement.GotMouseCapture> and <xref:System.Windows.ContentElement.IsMouseCapturedChanged> events are raised, with <xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType> in the event data reported as the element where the <xref:System.Windows.ContentElement.CaptureMouse%2A> method is called.</span></span> <span data-ttu-id="e7c98-230">如果强制捕获时，你可能干扰现有捕获-尤其是在具有与拖放与鼠标相关的捕获。</span><span class="sxs-lookup"><span data-stu-id="e7c98-230">If you force capture, you might interfere with existing captures—especially with captures that relate to drag-and-drop with the mouse.</span></span>  
  
 <span data-ttu-id="e7c98-231">若要清除从所有元素的鼠标捕获，请调用<xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType>与`element`参数作为提供`null`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-231">To clear mouse capture from all elements, call <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType> with the `element` parameter provided as `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e7c98-232">下面的示例捕获到鼠标或释放捕获，基于是否由该元素已捕获鼠标。</span><span class="sxs-lookup"><span data-stu-id="e7c98-232">The following example captures the mouse or releases capture, based on whether the mouse is already captured by the element.</span></span> <span data-ttu-id="e7c98-233">请注意此示例将转换到的潜在捕获目标元素<xref:System.Windows.IInputElement>接口，并因此最初调用<xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-233">Note that this example casts the prospective capture target element to the <xref:System.Windows.IInputElement> interface, and is thus initially calling the <xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="e7c98-234">强制转换为<xref:System.Windows.IInputElement>是一种技术，如果您不确定的元素你想要捕获鼠标是否有用<xref:System.Windows.UIElement>或<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-234">Casting to <xref:System.Windows.IInputElement> is a technique that is useful if you are unsure whether the element you want to have capture the mouse is a <xref:System.Windows.UIElement> or a <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="e7c98-235">接口 cast 和接口方法调用然后调用适当的特定类型的 CaptureMouse 实现内部而无需强制转换为一个试用版<xref:System.Windows.UIElement>或<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-235">The interface cast and the interface method call then calls the appropriate type-specific CaptureMouse implementation internally without requiring a trial cast to either <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="e7c98-236">此相同的强制转换技术适用于其他成员，<xref:System.Windows.IInputElement>定义，例如许多输入相关的事件和其他与输入相关的方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-236">This same casting technique works for other members that <xref:System.Windows.IInputElement> defines, for instance many of the input-related events, and other input-related methods.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureStylus" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureStylus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureStylus();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureStylus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-237">尝试将触笔强制捕获到此元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-237">Attempts to force capture of the stylus to this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e7c98-238">如果成功捕获了触笔，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-238">
              <see langword="true" /> if the stylus is successfully captured; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-239">始终根据基础默认触笔设备的默认实现返回`true`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-239">The default implementation based on the underlying default stylus device always returns `true`.</span></span> <span data-ttu-id="e7c98-240">但是，如果你要扩展提供在输入系统的设备实现的输入的设备，则可能与一个备用的触笔设备实现，可能会返回不同的结果中创建系统。</span><span class="sxs-lookup"><span data-stu-id="e7c98-240">However, if you are extending the input devices that provide the device implementation for the input system, it is possible to create a system with an alternative stylus device implementation that might return different results.</span></span>  
  
 <span data-ttu-id="e7c98-241">当元素捕获触笔时，它会接收触笔输入，即使触笔超出界限。</span><span class="sxs-lookup"><span data-stu-id="e7c98-241">When an element captures the stylus, it receives stylus input even if the stylus is outside its bounds.</span></span> <span data-ttu-id="e7c98-242">通常，将触笔捕获仅在拖放操作过程。</span><span class="sxs-lookup"><span data-stu-id="e7c98-242">The stylus is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="e7c98-243">调用此方法调用基础静态<xref:System.Windows.Input.Stylus>方法<xref:System.Windows.Input.Stylus.Capture%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-243">Calling this method calls an underlying static <xref:System.Windows.Input.Stylus> method <xref:System.Windows.Input.Stylus.Capture%2A>.</span></span> <span data-ttu-id="e7c98-244">由活动的触笔设备实现实现实际捕获行为。</span><span class="sxs-lookup"><span data-stu-id="e7c98-244">The actual capture behavior is implemented by the active stylus device implementation.</span></span>  
  
 <span data-ttu-id="e7c98-245">若要捕获，必须启用一个元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-245">To be captured, an element must be enabled.</span></span> <span data-ttu-id="e7c98-246">检查是否<xref:System.Windows.ContentElement.IsEnabled%2A>是`true`返回你在调用之前<xref:System.Windows.ContentElement.CaptureStylus%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-246">Check whether <xref:System.Windows.ContentElement.IsEnabled%2A> is `true` return before you call <xref:System.Windows.ContentElement.CaptureStylus%2A>.</span></span>  
  
 <span data-ttu-id="e7c98-247">如果调用<xref:System.Windows.ContentElement.CaptureStylus%2A>返回`true`，<xref:System.Windows.ContentElement.IsStylusCaptured%2A>也`true`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-247">If calling <xref:System.Windows.ContentElement.CaptureStylus%2A> returns `true`, <xref:System.Windows.ContentElement.IsStylusCaptured%2A> is also `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CaptureTouch(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">
          <span data-ttu-id="e7c98-248">要捕获的设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-248">The device to capture.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-249">尝试将触摸屏输入强制捕获到此元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-249">Attempts to force capture of a touch to this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e7c98-250">如果将指定触摸屏输入捕获到此元素，则为 <see langword="true" /> ；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-250">
              <see langword="true" /> if the specified touch is captured to this element; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-251"><xref:System.Windows.ContentElement.CaptureTouch%2A> 将返回`false`如果<xref:System.Windows.Input.TouchDevice>当前捕获到另一个元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-251"><xref:System.Windows.ContentElement.CaptureTouch%2A> will return `false` if the <xref:System.Windows.Input.TouchDevice> is currently captured to another element.</span></span>  
  
 <span data-ttu-id="e7c98-252">如果<xref:System.Windows.ContentElement.CaptureTouch%2A>返回`true`，则<xref:System.Windows.ContentElement.GotTouchCapture>引发事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-252">If <xref:System.Windows.ContentElement.CaptureTouch%2A> returns `true`, then the <xref:System.Windows.ContentElement.GotTouchCapture> event is raised.</span></span>  
  
 <span data-ttu-id="e7c98-253">若要释放的单个触摸从此元素的捕获，请使用<xref:System.Windows.ContentElement.ReleaseTouchCapture%2A>方法并指定要释放的触摸设备。</span><span class="sxs-lookup"><span data-stu-id="e7c98-253">To release capture of a single touch from this element, use the <xref:System.Windows.ContentElement.ReleaseTouchCapture%2A> method and specify the touch device to release.</span></span> <span data-ttu-id="e7c98-254">若要释放所有触摸从此元素，请使用<xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-254">To release all touches from this element, use the <xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e7c98-255">
            <paramref name="touchDevice" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-255">
              <paramref name="touchDevice" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Windows.Input.TouchDevice.Capture(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.CommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CommandBindings As CommandBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::CommandBindingCollection ^ CommandBindings { System::Windows::Input::CommandBindingCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-256">获取与此元素关联的 <see cref="T:System.Windows.Input.CommandBinding" /> 对象的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-256">Gets a collection of <see cref="T:System.Windows.Input.CommandBinding" /> objects that are associated with this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-257">所有 <see cref="T:System.Windows.Input.CommandBinding" /> 对象的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-257">The collection of all <see cref="T:System.Windows.Input.CommandBinding" /> objects.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-258">A<xref:System.Windows.Input.CommandBinding>启用此元素的特定命令的命令处理并声明命令、 其事件，以及此元素附加的处理程序之间的链接。</span><span class="sxs-lookup"><span data-stu-id="e7c98-258">A <xref:System.Windows.Input.CommandBinding> enables command handling of a specific command for this element and declares the linkage between a command, its events, and the handlers that are attached by this element.</span></span>  
  
 <span data-ttu-id="e7c98-259">另一种典型的方法来填充<xref:System.Windows.ContentElement.CommandBindings%2A>集合是使用<xref:System.Windows.Input.CommandManager>方法以编程方式。</span><span class="sxs-lookup"><span data-stu-id="e7c98-259">Another typical way to populate the <xref:System.Windows.ContentElement.CommandBindings%2A> collection is to use <xref:System.Windows.Input.CommandManager> methods programmatically.</span></span>  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="e7c98-260">XAML 属性元素用法</span><span class="sxs-lookup"><span data-stu-id="e7c98-260">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## <a name="xaml-values"></a><span data-ttu-id="e7c98-261">XAML 值</span><span class="sxs-lookup"><span data-stu-id="e7c98-261">XAML Values</span></span>  
 <span data-ttu-id="e7c98-262">*oneOrMoreCommandBindings*</span><span class="sxs-lookup"><span data-stu-id="e7c98-262">*oneOrMoreCommandBindings*</span></span>  
 <span data-ttu-id="e7c98-263">一个或多个<xref:System.Windows.Input.CommandBinding>元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-263">One or more <xref:System.Windows.Input.CommandBinding> elements.</span></span> <span data-ttu-id="e7c98-264">每个都应当有<xref:System.Windows.Input.CommandBinding.Command%2A>属性设置为所知的命令，并且属性设置为<xref:System.Windows.Input.CommandBinding.CanExecute>和<xref:System.Windows.Input.CommandBinding.Executed>处理程序实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-264">Each of these should have a <xref:System.Windows.Input.CommandBinding.Command%2A> attribute set to a known command, and attributes set for the <xref:System.Windows.Input.CommandBinding.CanExecute> and <xref:System.Windows.Input.CommandBinding.Executed> handler implementations.</span></span> <span data-ttu-id="e7c98-265">有关详细信息，请参阅 <xref:System.Windows.Input.CommandBinding>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-265">For more information see <xref:System.Windows.Input.CommandBinding>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-266">在输入系统报告出现以此元素为拖动目标的基础拖动事件时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-266">Occurs when the input system reports an underlying drag event with this element as the drag target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-267">此事件创建一个别名<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-267">This event creates an alias for the <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-268">事件处理程序附加到<xref:System.Windows.ContentElement.DragEnter>事件附加到基础<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-268">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-269">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-269">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-270">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-270">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragEnterEvent>|  
|<span data-ttu-id="e7c98-271">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-271">Routing strategy</span></span>|<span data-ttu-id="e7c98-272">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-272">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-273">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-273">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="e7c98-274">对应的隧道事件<xref:System.Windows.ContentElement.PreviewDragEnter>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-274">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDragEnter>.</span></span>  
  
-   <span data-ttu-id="e7c98-275">重写<xref:System.Windows.ContentElement.OnDragEnter%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-275">Override <xref:System.Windows.ContentElement.OnDragEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-276">标识 <see cref="E:System.Windows.ContentElement.DragEnter" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-276">Identifies the <see cref="E:System.Windows.ContentElement.DragEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-277">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-277">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-278">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-278">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-279">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-279">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-280">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-280">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-281">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-281">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-282">在输入系统报告出现以此元素为拖动起点的基础拖动事件时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-282">Occurs when the input system reports an underlying drag event with this element as the drag origin.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-283">此事件创建一个别名<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>附加此类事件，以便<xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-283">This event creates an alias for the <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-284">事件处理程序附加到<xref:System.Windows.ContentElement.DragLeave>事件附加到基础<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-284">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-285">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-285">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-286">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-286">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragLeaveEvent>|  
|<span data-ttu-id="e7c98-287">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-287">Routing strategy</span></span>|<span data-ttu-id="e7c98-288">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-288">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-289">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-289">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="e7c98-290">对应的隧道事件<xref:System.Windows.DragDrop.PreviewDragLeave>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-290">The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragLeave>.</span></span>  
  
-   <span data-ttu-id="e7c98-291">重写<xref:System.Windows.ContentElement.OnDragLeave%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-291">Override <xref:System.Windows.ContentElement.OnDragLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-292">标识 <see cref="E:System.Windows.ContentElement.DragLeave" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-292">Identifies the <see cref="E:System.Windows.ContentElement.DragLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-293">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-293">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-294">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-294">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-295">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-295">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-296">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-296">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-297">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-297">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragOver;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-298">在输入系统报告出现以此元素为可能放置目标的基础拖动事件时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-298">Occurs when the input system reports an underlying drag event with this element as the potential drop target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-299">如果即使拖动源自于元素边界，则会发生此事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-299">This event occurs even if the drag originates in the element bounds.</span></span> <span data-ttu-id="e7c98-300">如果拖动的范围之外启动，然后将移动内，也会引发此事件，以及<xref:System.Windows.ContentElement.DragEnter>和相关预览事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-300">If the drag starts outside the bounds and then moves inside, this event is also raised, as well as <xref:System.Windows.ContentElement.DragEnter> and related preview events.</span></span>  
  
 <span data-ttu-id="e7c98-301">此事件创建一个别名<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>附加此类事件，以便<xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-301">This event creates an alias for the <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-302">事件处理程序附加到<xref:System.Windows.ContentElement.DragOver>事件附加到基础<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-302">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragOver> event are attached to the underlying <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragOver"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-303">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-303">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-304">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-304">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragOverEvent>|  
|<span data-ttu-id="e7c98-305">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-305">Routing strategy</span></span>|<span data-ttu-id="e7c98-306">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-306">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-307">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-307">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="e7c98-308">对应的隧道事件<xref:System.Windows.DragDrop.PreviewDragOver>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-308">The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragOver>.</span></span>  
  
-   <span data-ttu-id="e7c98-309">重写<xref:System.Windows.ContentElement.OnDragOver%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-309">Override <xref:System.Windows.ContentElement.OnDragOver%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragOverEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-310">标识 <see cref="E:System.Windows.ContentElement.DragOver" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-310">Identifies the <see cref="E:System.Windows.ContentElement.DragOver" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-311">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-311">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-312">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-312">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-313">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-313">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-314">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-314">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-315">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-315">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.Drop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ Drop;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-316">在输入系统报告出现将此元素作为放置目标的基础放置事件时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-316">Occurs when the input system reports an underlying drop event with this element as the drop target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-317">此事件创建一个别名<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>附加此类事件，以便<xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-317">This event creates an alias for the <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-318">事件处理程序附加到<xref:System.Windows.ContentElement.Drop>事件附加到基础<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-318">Event handlers that are attached to the <xref:System.Windows.ContentElement.Drop> event are attached to the underlying <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_Drop"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-319">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-319">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-320">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-320">Identifier field</span></span>|<xref:System.Windows.ContentElement.DropEvent>|  
|<span data-ttu-id="e7c98-321">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-321">Routing strategy</span></span>|<span data-ttu-id="e7c98-322">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-322">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-323">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-323">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="e7c98-324">对应的隧道事件<xref:System.Windows.ContentElement.PreviewDrop>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-324">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDrop>.</span></span>  
  
-   <span data-ttu-id="e7c98-325">重写<xref:System.Windows.ContentElement.OnDrop%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-325">Override <xref:System.Windows.ContentElement.OnDrop%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DropEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-326">标识 <see cref="E:System.Windows.ContentElement.Drop" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-326">Identifies the <see cref="E:System.Windows.ContentElement.Drop" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-327">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-327">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-328">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-328">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-329">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-329">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-330">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-330">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-331">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-331">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Focus();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.Focus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-332">尝试将焦点设定到此元素上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-332">Attempts to set focus to this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e7c98-333">如果键盘焦点可设定到此元素上，则为 <see langword="true" />；如果此方法调用未强制设置焦点，则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-333">
              <see langword="true" /> if keyboard focus could be set to this element; <see langword="false" /> if this method call did not force focus.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-334">可获得焦点，<xref:System.Windows.ContentElement.Focusable%2A>和<xref:System.Windows.ContentElement.IsEnabled%2A>必须都是`true`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-334">To be focusable, <xref:System.Windows.ContentElement.Focusable%2A> and <xref:System.Windows.ContentElement.IsEnabled%2A> must both be `true`.</span></span> <span data-ttu-id="e7c98-335">请注意，几乎所有<xref:System.Windows.ContentElement>派生的类不是<xref:System.Windows.ContentElement.Focusable%2A>默认情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-335">Note that nearly all <xref:System.Windows.ContentElement> derived classes are not <xref:System.Windows.ContentElement.Focusable%2A> by default.</span></span>  
  
 <span data-ttu-id="e7c98-336">即使元素是特定的树中的焦点并已启用，事件处理，（例如，用于复合控件） 可能会响应预览焦点事件通过不允许焦点，因此此方法将返回`false`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-336">Even if an element is focusable and enabled, event handling within a specific tree, (such as for a composite control) might respond to the preview focus events by not allowing focus there, thus this method would return `false`.</span></span>  
  
 <span data-ttu-id="e7c98-337">焦点通常由两个不同的概念： 键盘焦点和逻辑焦点，并不总是相同。</span><span class="sxs-lookup"><span data-stu-id="e7c98-337">Focus in general is governed by two separate concepts: keyboard focus and logical focus, which are not always identical.</span></span> <span data-ttu-id="e7c98-338">此方法设置逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="e7c98-338">This method sets the logical focus.</span></span> <span data-ttu-id="e7c98-339">没有专门; 设置键盘焦点的编程方法由用户输入确定键盘焦点。</span><span class="sxs-lookup"><span data-stu-id="e7c98-339">There is no programmatic means to set keyboard focus specifically; keyboard focus is determined by user input.</span></span> <span data-ttu-id="e7c98-340">有关详细信息，请参阅[焦点概述](~/docs/framework/wpf/advanced/focus-overview.md)和[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-340">For more information, see [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md) and [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
 <span data-ttu-id="e7c98-341">如果调用<xref:System.Windows.ContentElement.Focus%2A>返回`true`，<xref:System.Windows.ContentElement.IsKeyboardFocused%2A>和<xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A>也`true`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-341">If calling <xref:System.Windows.ContentElement.Focus%2A> returns `true`, <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> and <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> are also `true`.</span></span>  
  
 <span data-ttu-id="e7c98-342">如果相关的属性不是已`true`，则在调用<xref:System.Windows.ContentElement.Focus%2A>，一个或多个以下事件将按照以下顺序引发： <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>， <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> （来源为新的焦点目标）， <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>， <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>，<xref:System.Windows.ContentElement.LostKeyboardFocus>， <xref:System.Windows.ContentElement.GotKeyboardFocus> （来源为新的焦点目标）。</span><span class="sxs-lookup"><span data-stu-id="e7c98-342">If the related properties are not already `true`, when you call <xref:System.Windows.ContentElement.Focus%2A>, one or more of the following events are raised in the following order: <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>, <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> (source is the new focus target), <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>, <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>, <xref:System.Windows.ContentElement.LostKeyboardFocus>, <xref:System.Windows.ContentElement.GotKeyboardFocus> (source is the new focus target).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e7c98-343">下面的示例查找指定的命名文档中的段落的页面加载事件处理程序，并将焦点设置到它。</span><span class="sxs-lookup"><span data-stu-id="e7c98-343">The following example is a page-loaded event handler that finds a specified named paragraph in the document and sets focus to it.</span></span> <span data-ttu-id="e7c98-344">段落不是默认设置。 可获得焦点此特定段落已应用了样式 （未显示），使用一种样式<xref:System.Windows.Setter>以使其可获得焦点。</span><span class="sxs-lookup"><span data-stu-id="e7c98-344">Paragraphs are not focusable by default; this particular paragraph had a style applied (not shown) that used a style <xref:System.Windows.Setter> to make it focusable.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#Focus](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#focus)]
 [!code-vb[ContentElementsSmorgasbord#Focus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#focus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.Focusable" />
      <MemberSignature Language="VB.NET" Value="Public Property Focusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focusable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.Focusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-345">获取或设置一个值，该值指示元素能否得到焦点。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-345">Gets or sets a value that indicates whether the element can receive focus.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-346">如果该元素可获得焦点，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-346">
              <see langword="true" /> if the element is focusable; otherwise <see langword="false" />.</span>
          </span>
          <span data-ttu-id="e7c98-347">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-347">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-348">具有焦点的元素收到键盘输入。</span><span class="sxs-lookup"><span data-stu-id="e7c98-348">Only the focused element receives keyboard input.</span></span>  
  
 <span data-ttu-id="e7c98-349">某些派生的类可能会重写此依赖项属性的元数据，以便派生的类是默认情况下可获得焦点。</span><span class="sxs-lookup"><span data-stu-id="e7c98-349">Certain derived classes might override metadata for this dependency property such that the derived class is focusable by default.</span></span>  
  
 <span data-ttu-id="e7c98-350">当通过继承<xref:System.Windows.Documents.Hyperlink>或其派生的类，<xref:System.Windows.Documents.Hyperlink>重写此依赖项属性的元数据，并重新定义为此属性的默认值`true`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-350">When inherited by <xref:System.Windows.Documents.Hyperlink> or its derived classes, <xref:System.Windows.Documents.Hyperlink> overrides the metadata for this dependency property and redefines the default value of this property to be `true`.</span></span>  
  
<a name="dependencyPropertyInfo_Focusable"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="e7c98-351">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-351">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-352">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-352">Identifier field</span></span>|<xref:System.Windows.ContentElement.FocusableProperty>|  
|<span data-ttu-id="e7c98-353">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="e7c98-353">Metadata properties set to `true`</span></span>|<span data-ttu-id="e7c98-354">无</span><span class="sxs-lookup"><span data-stu-id="e7c98-354">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="e7c98-355">下面的示例创建一种使方式<xref:System.Windows.Documents.Paragraph>默认情况下可获得焦点并在接收焦点时为其提供可视行为。</span><span class="sxs-lookup"><span data-stu-id="e7c98-355">The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e7c98-356">派生自<see cref="T:System.Windows.ContentElement" />，应考虑是否需要您可获得焦点，因为默认情况下它将不能获得焦点的元素。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-356">When you derive from <see cref="T:System.Windows.ContentElement" />, consider whether you want your element to be focusable, because by default it will not be focusable.</span>
            </span>
            <span data-ttu-id="e7c98-357">如果你想使元素可获得焦点，重写此属性在你派生的类的静态构造函数的元数据，如下所示：</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-357">If you want your element to be focusable, override the metadata for this property in your derived class static constructor as follows:</span>
            </span>  
  
 [!code-csharp[CorePseudocode#UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)]
 [!code-vb[CorePseudocode#UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)]  
  
 <span data-ttu-id="e7c98-358">其中<paramref name="myElement" />是会重写元数据值的类型的类名称。</span><span class="sxs-lookup"><span data-stu-id="e7c98-358">where <paramref name="myElement" /> is the class name of the type that you are overriding the metadata value on.</span></span></para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.FocusableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FocusableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ FocusableChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-359">当 <see cref="P:System.Windows.ContentElement.Focusable" /> 属性的值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-359">Occurs when the value of the <see cref="P:System.Windows.ContentElement.Focusable" /> property changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-360">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件中，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-360">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.FocusableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusableProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-361">标识 <see cref="P:System.Windows.ContentElement.Focusable" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-361">Identifies the <see cref="P:System.Windows.ContentElement.Focusable" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnimationBaseValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetAnimationBaseValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.GetAnimationBaseValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="e7c98-362">要选中的依赖属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-362">The.dependency property to check.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-363">为此元素上的指定属性返回基属性值，忽略任何可能来自正在运行或已停止的动画的动画值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-363">Returns the base property value for the specified property on this element, disregarding any possible animated value from a running or stopped animation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e7c98-364">就像没有动画被附加到指定的依赖属性一样的属性值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-364">The property value as if no animations are attached to the specified dependency property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-365">如果没有动画被附加到属性，则<xref:System.Windows.ContentElement.GetAnimationBaseValue%2A>返回值也始终等于<xref:System.Windows.DependencyObject.GetValue%2A>返回值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-365">If no animations are attached to the property, then the <xref:System.Windows.ContentElement.GetAnimationBaseValue%2A> return value is always identical to the <xref:System.Windows.DependencyObject.GetValue%2A> return value.</span></span> <span data-ttu-id="e7c98-366">如果没有附加的动画，然后所有可能的动画派生值包括开始和停止值将被忽略，并确定基于所有其他可能的输入属性值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-366">If there are animations attached, then all possible animation derived values including the start and stop values are ignored, and the property value is determined based on all other possible inputs.</span></span> <span data-ttu-id="e7c98-367">有关详细信息，请参阅[依赖属性值优先级](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-367">For more information, see [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-368">在派生类中重写时，如果不存在可视父级，则返回其他[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 父级。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-368">When overridden in a derived class, returns an alternative [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] parent for this element if no visual parent exists.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e7c98-369">如果派生类的实现具有要报告的替代父级连接，则为一个对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-369">An object, if implementation of a derived class has an alternate parent connection to report.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-370">此方法的默认虚拟实现返回`null`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-370">The default virtual implementation of this method returns `null`.</span></span> <span data-ttu-id="e7c98-371"><xref:System.Windows.FrameworkContentElement> 提供实际实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-371"><xref:System.Windows.FrameworkContentElement> provides a practical implementation.</span></span>  
  
 <span data-ttu-id="e7c98-372">备用父级是用于路由事件，在其中元素创建备用父级结构，以便其事件路由偏离到标准的父级的可视化树向上路由的标准模式的方式的情况下或向下预览路由策略。</span><span class="sxs-lookup"><span data-stu-id="e7c98-372">Alternative parents are used for event routing, in cases where an element creates an alternative parent structure so that its events are routed in a way that diverges from the standard pattern of routing up the visual tree to the standard parent, or downward in the preview routing strategy.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-373">在输入系统报告出现涉及此元素的基础拖放操作时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-373">Occurs when the input system reports an underlying drag-and-drop event that involves this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-374"><xref:System.Windows.ContentElement.GiveFeedback>事件允许拖动事件，以便为用户可视反馈提供拖放操作期间修改鼠标指针的外观的源。</span><span class="sxs-lookup"><span data-stu-id="e7c98-374">The <xref:System.Windows.ContentElement.GiveFeedback> event allows the source of a drag event to modify the appearance of the mouse pointer in order to give the user visual feedback during a drag-and-drop operation.</span></span> <span data-ttu-id="e7c98-375">视觉反馈用于强调拖放操作正在进行。</span><span class="sxs-lookup"><span data-stu-id="e7c98-375">The visual feedback reinforces that a drag-and-drop operation is in process.</span></span>  
  
 <span data-ttu-id="e7c98-376">此事件创建一个别名<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>附加此类事件，以便<xref:System.Windows.ContentElement.GiveFeedback>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-376">This event creates an alias for the <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.GiveFeedback> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-377">事件处理程序附加到<xref:System.Windows.ContentElement.GiveFeedback>事件附加到基础<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-377">Event handlers that are attached to the <xref:System.Windows.ContentElement.GiveFeedback> event are attached to the underlying <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-378">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-378">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-379">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-379">Identifier field</span></span>|<xref:System.Windows.ContentElement.GiveFeedbackEvent>|  
|<span data-ttu-id="e7c98-380">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-380">Routing strategy</span></span>|<span data-ttu-id="e7c98-381">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-381">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-382">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-382">Delegate</span></span>|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   <span data-ttu-id="e7c98-383">对应的隧道事件<xref:System.Windows.ContentElement.PreviewGiveFeedback>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-383">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewGiveFeedback>.</span></span>  
  
-   <span data-ttu-id="e7c98-384">重写<xref:System.Windows.ContentElement.OnGiveFeedback%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-384">Override <xref:System.Windows.ContentElement.OnGiveFeedback%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GiveFeedbackEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-385">标识 <see cref="E:System.Windows.ContentElement.GiveFeedback" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-385">Identifies the <see cref="E:System.Windows.ContentElement.GiveFeedback" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-386">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-386">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-387">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-387">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-388">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-388">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-389">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-389">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-390">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-390">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ GotFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-391">在此元素获得逻辑焦点时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-391">Occurs when this element gets logical focus.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-392">如果有意通过某个方法调用强制焦点，而前一个键盘焦点位于不同的范围内，则逻辑焦点将与键盘焦点不同。</span><span class="sxs-lookup"><span data-stu-id="e7c98-392">Logical focus differs from keyboard focus if focus is deliberately forced by using a method call but the previous keyboard focus exists in a different scope.</span></span> <span data-ttu-id="e7c98-393">在这种情况下，键盘焦点将保持其所在的元素的和其中<xref:System.Windows.ContentElement.Focus%2A>调用方法仍获取逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="e7c98-393">In this scenario, keyboard focus remains where it is and the element where a <xref:System.Windows.ContentElement.Focus%2A> method is called still gets logical focus.</span></span>  
  
 <span data-ttu-id="e7c98-394">此事件的更精确地解释是它时引发的值<xref:System.Windows.ContentElement.IsFocused%2A>路线中的元素的属性更改从`false`到`true`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-394">A more precise interpretation of this event is that it is raised when the value of the <xref:System.Windows.ContentElement.IsFocused%2A> property of an element in the route is changed from `false` to `true`.</span></span>  
  
 <span data-ttu-id="e7c98-395">由于此事件使用冒泡路由，接收到焦点的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-395">Because this event uses bubbling routing, the element that receives focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="e7c98-396">检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据以确定实际获得焦点的元素中。</span><span class="sxs-lookup"><span data-stu-id="e7c98-396">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that gained focus.</span></span>  
  
<a name="routedEventInfo_GotFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-397">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-397">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-398">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-398">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotFocusEvent>|  
|<span data-ttu-id="e7c98-399">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-399">Routing strategy</span></span>|<span data-ttu-id="e7c98-400">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-400">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-401">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-401">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
-   <span data-ttu-id="e7c98-402">没有相应隧道事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-402">There is no corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="e7c98-403">重写<xref:System.Windows.ContentElement.OnGotFocus%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-403">Override <xref:System.Windows.ContentElement.OnGotFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-404">标识 <see cref="E:System.Windows.ContentElement.GotFocus" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-404">Identifies the <see cref="E:System.Windows.ContentElement.GotFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-405">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-405">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-406">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-406">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-407">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-407">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-408">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-408">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-409">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-409">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ GotKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-410">在此元素聚焦于键盘时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-410">Occurs when the keyboard is focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-411"><xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> 是一个类似事件，跟踪中维护的一个元素; 的焦点状态的属性的状态更改<xref:System.Windows.ContentElement.GotKeyboardFocus>在很多相同的情况下引发事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-411"><xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> is a similar event that tracks status changes in a property that maintains the focus state for an element; the <xref:System.Windows.ContentElement.GotKeyboardFocus> event is raised in many of the same circumstances.</span></span>  
  
 <span data-ttu-id="e7c98-412">由于此事件使用冒泡路由，具有焦点的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-412">Because this event uses bubbling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="e7c98-413">检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据以确定实际具有焦点的元素中。</span><span class="sxs-lookup"><span data-stu-id="e7c98-413">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has focus.</span></span>  
  
 <span data-ttu-id="e7c98-414">此事件创建一个别名<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>附加此类事件，以便<xref:System.Windows.ContentElement.GotKeyboardFocus>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-414">This event creates an alias for the <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.GotKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-415">事件处理程序附加到<xref:System.Windows.ContentElement.GotKeyboardFocus>事件附加到基础<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-415">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-416">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-416">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-417">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-417">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotKeyboardFocusEvent>|  
|<span data-ttu-id="e7c98-418">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-418">Routing strategy</span></span>|<span data-ttu-id="e7c98-419">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-419">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-420">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-420">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="e7c98-421">对应的隧道事件<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-421">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="e7c98-422">重写<xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-422">Override <xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-423">标识 <see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-423">Identifies the <see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-424">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-424">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-425">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-425">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-426">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-426">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-427">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-427">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-428">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-428">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ GotMouseCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-429">在此元素捕获鼠标时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-429">Occurs when this element captures the mouse.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-430">在元素捕获鼠标，它会接收鼠标输入，即使在鼠标指针位于超出界限。</span><span class="sxs-lookup"><span data-stu-id="e7c98-430">When an element captures the mouse, it receives mouse input even if the mouse pointer is outside its bounds.</span></span> <span data-ttu-id="e7c98-431">鼠标通常仅在拖放操作期间捕获，并且将保持捕获，直到发生拖放操作。</span><span class="sxs-lookup"><span data-stu-id="e7c98-431">The mouse is typically captured only during drag-and-drop operations and remains captured until the drop action of the drag-and-drop operation occurs.</span></span>  
  
 <span data-ttu-id="e7c98-432">由于此事件使用冒泡路由，具有捕获的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-432">Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="e7c98-433">检查<xref:System.Windows.RoutedEventArgs.Source%2A>在事件数据以确定实际的元素具有鼠标捕获。</span><span class="sxs-lookup"><span data-stu-id="e7c98-433">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has mouse capture.</span></span>  
  
 <span data-ttu-id="e7c98-434">此事件创建一个别名<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>附加此类事件，以便<xref:System.Windows.ContentElement.GotMouseCapture>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-434">This event creates an alias for the <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> attached event for  this class so that <xref:System.Windows.ContentElement.GotMouseCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-435">事件处理程序附加到<xref:System.Windows.ContentElement.GotMouseCapture>事件附加到基础<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-435">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotMouseCapture> event are attached to the underlying <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-436">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-436">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-437">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-437">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotMouseCaptureEvent>|  
|<span data-ttu-id="e7c98-438">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-438">Routing strategy</span></span>|<span data-ttu-id="e7c98-439">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-439">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-440">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-440">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="e7c98-441">没有定义相应隧道事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-441">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="e7c98-442">重写<xref:System.Windows.ContentElement.OnGotMouseCapture%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-442">Override <xref:System.Windows.ContentElement.OnGotMouseCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-443">标识 <see cref="E:System.Windows.ContentElement.GotMouseCapture" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-443">Identifies the <see cref="E:System.Windows.ContentElement.GotMouseCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-444">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-444">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-445">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-445">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-446">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-446">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-447">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-447">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-448">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-448">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ GotStylusCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-449">在此元素捕获触笔时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-449">Occurs when this element captures the stylus.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-450">当元素捕获触笔时，它会接收触笔输入，即使在指针位于超出界限。</span><span class="sxs-lookup"><span data-stu-id="e7c98-450">When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="e7c98-451">触笔通常仅在拖放操作期间捕获和捕获之前发生拖放操作的状态将保持。</span><span class="sxs-lookup"><span data-stu-id="e7c98-451">The stylus is typically captured only during drag-and-drop operations and retains capture until the drop action of the drag-and-drop operation occurs.</span></span>  
  
 <span data-ttu-id="e7c98-452">由于此事件使用冒泡路由，具有捕获的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-452">Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="e7c98-453">检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据以确定已捕获的实际元素中。</span><span class="sxs-lookup"><span data-stu-id="e7c98-453">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has capture.</span></span>  
  
 <span data-ttu-id="e7c98-454">此事件创建此类的附加事件的别名，以便<xref:System.Windows.ContentElement.GotStylusCapture>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-454">This event creates an alias for the  attached event for this class so that <xref:System.Windows.ContentElement.GotStylusCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-455">事件处理程序附加到<xref:System.Windows.ContentElement.GotStylusCapture>事件附加到基础<xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-455">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotStylusCapture> event are attached to the underlying <xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-456">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-456">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-457">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-457">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotStylusCaptureEvent>|  
|<span data-ttu-id="e7c98-458">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-458">Routing strategy</span></span>|<span data-ttu-id="e7c98-459">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-459">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-460">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-460">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="e7c98-461">没有定义相应隧道事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-461">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="e7c98-462">重写<xref:System.Windows.ContentElement.OnGotStylusCapture%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-462">Override <xref:System.Windows.ContentElement.OnGotStylusCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotStylusCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-463">标识 <see cref="E:System.Windows.ContentElement.GotStylusCapture" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-463">Identifies the <see cref="E:System.Windows.ContentElement.GotStylusCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-464">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-464">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-465">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-465">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-466">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-466">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-467">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-467">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-468">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-468">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ GotTouchCapture;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-469">在此元素上捕获触摸屏输入时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-469">Occurs when a touch is captured to this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-470">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-470">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-471">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-471">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotTouchCaptureEvent>|  
|<span data-ttu-id="e7c98-472">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-472">Routing strategy</span></span>|<span data-ttu-id="e7c98-473">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-473">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-474">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-474">Delegate</span></span>|<span data-ttu-id="e7c98-475"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-475"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="e7c98-476">重写<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-476">Override <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotTouchCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-477">标识 <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-477">Identifies the <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.HasAnimatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAnimatedProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAnimatedProperties { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Media.Animation.IAnimatable.HasAnimatedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-478">获取一个值，该值指示此元素是否具有任何进行动画处理的属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-478">Gets a value that indicates whether this element has any animated properties.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-479">如果此元素具有附加到其任何属性的动画，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-479">
              <see langword="true" /> if this element has animations attached to any of its properties; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-480">此属性返回`true`为永久性 （无时间限制，始终运行） 动画或具有特定的时间线的动画。</span><span class="sxs-lookup"><span data-stu-id="e7c98-480">This property returns `true` either for persistent (unclocked, always-running) animations or for animations that have a specific timeline.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.InputBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputBindings As InputBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputBindingCollection ^ InputBindings { System::Windows::Input::InputBindingCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-481">获取与此元素关联的输入绑定的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-481">Gets the collection of input bindings that are associated with this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-482">输入绑定的集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-482">The collection of input bindings.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-483">输入的绑定支持命令来输入设备的绑定。</span><span class="sxs-lookup"><span data-stu-id="e7c98-483">Input bindings support the binding of commands to input devices.</span></span> <span data-ttu-id="e7c98-484">例如，<xref:System.Windows.Input.MouseBinding>实现的输入包括特定于鼠标设备的属性的绑定。</span><span class="sxs-lookup"><span data-stu-id="e7c98-484">For example, <xref:System.Windows.Input.MouseBinding> implements input bindings that include properties that are specific to mouse devices.</span></span>  
  
 <span data-ttu-id="e7c98-485">输入绑定的集合包括同时适用于类型的输入的绑定和输入声明的实例的绑定。</span><span class="sxs-lookup"><span data-stu-id="e7c98-485">The collection of input bindings includes both input bindings that pertain to the type and also input bindings that are declared on the instance.</span></span>  
  
 <span data-ttu-id="e7c98-486">相关的属性， <xref:System.Windows.ContentElement.CommandBindings%2A>，保持命令绑定的集合。</span><span class="sxs-lookup"><span data-stu-id="e7c98-486">A related property, <xref:System.Windows.ContentElement.CommandBindings%2A>, maintains a collection of command bindings.</span></span> <span data-ttu-id="e7c98-487">这些绑定从输入绑定不同，因为它们表示下一个级别的命令处理的操作为它们依赖于已知的命令和特定于类的处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-487">These bindings differ from input bindings in that they represent the next level down of command processing - actions that are tied to known commands and class-specific handlers for them.</span></span>  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="e7c98-488">XAML 属性元素用法</span><span class="sxs-lookup"><span data-stu-id="e7c98-488">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## <a name="xaml-values"></a><span data-ttu-id="e7c98-489">XAML 值</span><span class="sxs-lookup"><span data-stu-id="e7c98-489">XAML Values</span></span>  
 <span data-ttu-id="e7c98-490">*oneOrMoreInputBindings*</span><span class="sxs-lookup"><span data-stu-id="e7c98-490">*oneOrMoreInputBindings*</span></span>  
 <span data-ttu-id="e7c98-491">一个或多个<xref:System.Windows.Input.InputBinding>元素 (通常<xref:System.Windows.Input.KeyBinding>或<xref:System.Windows.Input.MouseBinding>派生类)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-491">One or more <xref:System.Windows.Input.InputBinding> elements (typically the <xref:System.Windows.Input.KeyBinding> or <xref:System.Windows.Input.MouseBinding> derived classes).</span></span> <span data-ttu-id="e7c98-492">其中每个都应<xref:System.Windows.Input.InputBinding.Command%2A>和<xref:System.Windows.Input.InputBinding.Gesture%2A>属性设置。</span><span class="sxs-lookup"><span data-stu-id="e7c98-492">Each of these is expected to have a <xref:System.Windows.Input.InputBinding.Command%2A> and <xref:System.Windows.Input.InputBinding.Gesture%2A> attribute set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-493">获取或设置一个值，该值指示是否在[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中启用了此元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-493">Gets or sets a value that indicates whether this element is enabled in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-494">如果启用了该元素，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-494">
              <see langword="true" /> if the element is enabled; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="e7c98-495">默认值为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-495">The default value is <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="e7c98-496">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-496">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-497">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-497">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsEnabledProperty>|  
|<span data-ttu-id="e7c98-498">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="e7c98-498">Metadata properties set to `true`</span></span>|<span data-ttu-id="e7c98-499">无</span><span class="sxs-lookup"><span data-stu-id="e7c98-499">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="e7c98-500">下面的示例创建包含提供备用 visual 行为的属性 setter 的样式时<xref:System.Windows.Documents.Hyperlink>设置为<xref:System.Windows.ContentElement.IsEnabled%2A> `false`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-500">The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> is set to <xref:System.Windows.ContentElement.IsEnabled%2A> `false`.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsEnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsEnabledChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsEnabledChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-501">在此元素的 <see cref="P:System.Windows.ContentElement.IsEnabled" /> 属性值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-501">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsEnabled" /> property on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-502">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件中，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-502">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-503">获取一个值，该值成为派生类中 <see cref="P:System.Windows.ContentElement.IsEnabled" /> 的返回值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-503">Gets a value that becomes the return value of <see cref="P:System.Windows.ContentElement.IsEnabled" /> in derived classes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-504">如果启用了该元素，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-504">
              <see langword="true" /> if the element is enabled; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e7c98-505">此属性的默认实现缓存的值，并还计算是否启用此元素的父元素。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-505">The default implementation of this property caches the value and also calculates whether the parent element of this element is enabled.</span>
            </span>
            <span data-ttu-id="e7c98-506">(如果未启用父，子元素不能有效地启用中实际[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]。)如果你选择重写此实现，请确保调用基实现来保留此行为。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-506">(If the parent is not enabled, the child element cannot be effectively enabled in practical [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].) If you choose to override this implementation, make certain that you call the base implementation to preserve this behavior.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsEnabledProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-507">标识 <see cref="P:System.Windows.ContentElement.IsEnabled" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-507">Identifies the <see cref="P:System.Windows.ContentElement.IsEnabled" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFocused { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-508">获取一个值，该值确定此元素是否具有逻辑焦点。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-508">Gets a value that determines whether this element has logical focus.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-509">如果此元素具有逻辑焦点，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-509">
              <see langword="true" /> if this element has logical focus; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-510">如果应用程序中有多个焦点分支，例如，菜单的内容和应用程序的其余部分之间，逻辑焦点将与键盘焦点可能会与不同。</span><span class="sxs-lookup"><span data-stu-id="e7c98-510">Logical focus might differ from keyboard focus if an application has multiple focus divisions, such as between menu contents and the remainder of the application.</span></span> <span data-ttu-id="e7c98-511">在此方案中，键盘焦点仅可在应用程序 UI 的一个元素，但是，其他焦点分支中的某些元素仍可能保留逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="e7c98-511">In this scenario, keyboard focus can only be on one element of the application  UI, however, certain elements in other focus divisions might still retain logical focus.</span></span> <span data-ttu-id="e7c98-512">有关逻辑焦点的详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)和[焦点概述](~/docs/framework/wpf/advanced/focus-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-512">For more information on logical focus, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md) and [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="e7c98-513">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-513">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-514">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-514">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsFocusedProperty>|  
|<span data-ttu-id="e7c98-515">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="e7c98-515">Metadata properties set to `true`</span></span>|<span data-ttu-id="e7c98-516">无</span><span class="sxs-lookup"><span data-stu-id="e7c98-516">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="e7c98-517">下面的示例创建一种使方式<xref:System.Windows.Documents.Paragraph>默认情况下可获得焦点并在接收焦点时为其提供可视行为。</span><span class="sxs-lookup"><span data-stu-id="e7c98-517">The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-518">标识 <see cref="P:System.Windows.ContentElement.IsFocused" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-518">Identifies the <see cref="P:System.Windows.ContentElement.IsFocused" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsInputMethodEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInputMethodEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInputMethodEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-519">获取一个值，该值指示是否启用一个输入法系统（如[!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)]），以便用于处理此元素的输入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-519">Gets a value that indicates whether an input method system, such as an [!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)], is enabled for processing the input to this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-520">如果输入法处于活动状态，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-520">
              <see langword="true" /> if an input method is active; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="e7c98-521">基础附加属性的默认值是<see langword="true" />; 但是，此值会影响在运行时的输入法状态。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-521">The default value of the underlying attached property is <see langword="true" />; however, this value is influenced by the state of input methods at runtime.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-522">此属性返回的附加属性返回的值<xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType>的当前已启用输入法 （键盘、 语音和其他输入的设备）。</span><span class="sxs-lookup"><span data-stu-id="e7c98-522">This property returns the value that is returned by the attached property <xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType> for the currently enabled input methods (keyboard, speech, and other input devices).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocused { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocused</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-523">获取一个值，该值表示此元素是否具有键盘焦点。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-523">Gets a value that indicates whether this element has keyboard focus.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-524">如果此元素具有键盘焦点，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-524">
              <see langword="true" /> if this element has keyboard focus; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="e7c98-525">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-525">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="e7c98-526">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-526">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-527">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-527">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsKeyboardFocusedProperty>|  
|<span data-ttu-id="e7c98-528">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="e7c98-528">Metadata properties set to `true`</span></span>|<span data-ttu-id="e7c98-529">无</span><span class="sxs-lookup"><span data-stu-id="e7c98-529">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
        <altmember cref="E:System.Windows.ContentElement.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusedChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-530">在此元素的 <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> 属性值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-530">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-531">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件中，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-531">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-532">标识 <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-532">Identifies the <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocusWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocusWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocusWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocusWithin</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-533">获取一个值，该值指示键盘焦点是否位于元素或子元素内的任意位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-533">Gets a value that indicates whether keyboard focus is anywhere within the element or child elements.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-534">如果键盘焦点在元素或其子元素上，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-534">
              <see langword="true" /> if keyboard focus is on the element or its child elements; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="e7c98-535">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-535">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-536">更改此属性的值通常引发<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>事件，除非派生的类已重写<xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A>以禁止此事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-536">Changes to the value of this property typically raise the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event, unless a derived class has overridden <xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A> to suppress the event.</span></span>  
  
 <span data-ttu-id="e7c98-537">不能直接，设置此属性，但你可以通过调用将焦点设置到元素<xref:System.Windows.ContentElement.Focus%2A>，或通过使<xref:System.Windows.ContentElement.MoveFocus%2A>请求。</span><span class="sxs-lookup"><span data-stu-id="e7c98-537">You do not set this property directly, but you can set the focus to the element by calling <xref:System.Windows.ContentElement.Focus%2A>, or by making a <xref:System.Windows.ContentElement.MoveFocus%2A> request.</span></span> <span data-ttu-id="e7c98-538">这些方法调用任一可能会更改此属性的值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-538">Either of these method calls might change this property value.</span></span>  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="e7c98-539">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-539">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-540">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-540">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsKeyboardFocusWithinProperty>|  
|<span data-ttu-id="e7c98-541">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="e7c98-541">Metadata properties set to `true`</span></span>|<span data-ttu-id="e7c98-542">无</span><span class="sxs-lookup"><span data-stu-id="e7c98-542">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusWithinChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-543">在此元素的 <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> 属性值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-543">Occurs when the value of the <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-544">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件中，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-544">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-545">标识 <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-545">Identifies the <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptured { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-546">获取一个值，该值指示此元素是否捕获了鼠标。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-546">Gets a value that indicates whether the mouse is captured by this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-547">如果元素具有鼠标捕获，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-547">
              <see langword="true" /> if the element has mouse capture; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="e7c98-548">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-548">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-549">鼠标捕获状态与相关进程内拖放操作。</span><span class="sxs-lookup"><span data-stu-id="e7c98-549">Mouse capture state is related to in-process drag-and-drop operations.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="e7c98-550">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-550">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-551">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-551">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseCapturedProperty>|  
|<span data-ttu-id="e7c98-552">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="e7c98-552">Metadata properties set to `true`</span></span>|<span data-ttu-id="e7c98-553">无</span><span class="sxs-lookup"><span data-stu-id="e7c98-553">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="e7c98-554">下面的示例打开鼠标捕获状态或关闭根据是否由该元素已捕获鼠标。</span><span class="sxs-lookup"><span data-stu-id="e7c98-554">The following example turns the mouse capture state on or off based on whether the mouse is already captured by the element.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCapturedChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-555">在此元素的 <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> 属性值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-555">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-556">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件中，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-556">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCapturedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-557">标识 <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-557">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptureWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-558">获取一个值，该值确定此元素或其元素树中的子元素是否有鼠标捕获。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-558">Gets a value that determines whether mouse capture is held by this element or by child elements in its element tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-559">如果此元素或其包含的元素具有鼠标捕获，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-559">
              <see langword="true" /> if this element or a contained element has mouse capture; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="e7c98-560">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-560">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="e7c98-561">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-561">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-562">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-562">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseCaptureWithinProperty>|  
|<span data-ttu-id="e7c98-563">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="e7c98-563">Metadata properties set to `true`</span></span>|<span data-ttu-id="e7c98-564">无</span><span class="sxs-lookup"><span data-stu-id="e7c98-564">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCaptureWithinChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-565">在此元素的 <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> 值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-565">Occurs when the value of the <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-566">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件中，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-566">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCaptureWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-567">标识 <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-567">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseDirectlyOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-568">获取一个值，该值指示在考虑元素组合的情况下，鼠标指针的位置是否与命中测试结果相对应。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-568">Gets a value that indicates whether the position of the mouse pointer corresponds to hit test results, which take element compositing into account.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-569">
            <see langword="true" /> 如果鼠标指针位于与命中测试; 相同的元素结果否则为<see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-569">
              <see langword="true" /> if the mouse pointer is over the same element result as a hit test; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="e7c98-570">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-570">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-571">与不同<xref:System.Windows.ContentElement.IsMouseOver%2A>，此属性才`true`如果鼠标指针位于 literal 元素-按原样命中测试。</span><span class="sxs-lookup"><span data-stu-id="e7c98-571">Unlike <xref:System.Windows.ContentElement.IsMouseOver%2A>, this property is only `true` if the mouse pointer is over the literal element—as it is for a hit test.</span></span> <span data-ttu-id="e7c98-572">而如果鼠标指针悬停在子元素上，具体而言，鼠标指针所包含的元素的更深层的模板和合成，元素，此属性将为`false`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-572">If the mouse pointer is instead over a child element, in particular over elements that are part of an element's deeper template and compositing, this property will be `false`.</span></span> <span data-ttu-id="e7c98-573">除非你知道如何控件的组合 （例如，你使用此属性在自定义控件模板中的控件，你定义），此属性可能会返回意外的结果。</span><span class="sxs-lookup"><span data-stu-id="e7c98-573">Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</span></span> <span data-ttu-id="e7c98-574">对于大多数情况下不创作控件的情况，使用<xref:System.Windows.ContentElement.IsMouseOver%2A>相反。</span><span class="sxs-lookup"><span data-stu-id="e7c98-574">For most scenarios where you are not authoring controls, use <xref:System.Windows.ContentElement.IsMouseOver%2A> instead.</span></span>  
  
 <span data-ttu-id="e7c98-575">如果此元素是否捕获了鼠标，并且此属性是`true`在捕获时，此属性将继续返回`true`丢失鼠标捕获并且鼠标指针不位于其边界之前。</span><span class="sxs-lookup"><span data-stu-id="e7c98-575">If the mouse is captured by this element, and this property is `true` at time of capture, this property will continue to return `true` until mouse capture is lost and the pointer is not over its bounds.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="e7c98-576">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-576">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-577">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-577">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseDirectlyOverProperty>|  
|<span data-ttu-id="e7c98-578">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="e7c98-578">Metadata properties set to `true`</span></span>|<span data-ttu-id="e7c98-579">无</span><span class="sxs-lookup"><span data-stu-id="e7c98-579">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseDirectlyOverChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-580">在此元素的 <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> 属性值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-580">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-581">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件中，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-581">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseDirectlyOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-582">标识 <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-582">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-583">获取一个值，该值指示鼠标指针是否位于此元素（包括可视子元素或其控件组合）上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-583">Gets a value that indicates whether the mouse pointer is located over this element (including visual child elements, or its control compositing).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-584">如果鼠标指针悬停于此元素或其子元素上，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-584">
              <see langword="true" /> if mouse pointer is over the element or its child elements; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="e7c98-585">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-585">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-586">尽管类似"等效于"事件不存在，将执行多个类似事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-586">Although an analogous "IsMouseOverChanged" event does not exist, several similar events do.</span></span> <span data-ttu-id="e7c98-587">例如，你可以使用<xref:System.Windows.ContentElement.MouseEnter>， <xref:System.Windows.ContentElement.MouseMove>，和<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-587">For example, you can use <xref:System.Windows.ContentElement.MouseEnter>, <xref:System.Windows.ContentElement.MouseMove>, and <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>.</span></span>  
  
 <span data-ttu-id="e7c98-588">如果此元素捕获鼠标，则此属性保持`true`丢失鼠标捕获并且鼠标指针离开元素边界之前。</span><span class="sxs-lookup"><span data-stu-id="e7c98-588">If this element captures the mouse, this property remains `true` until mouse capture is lost and the mouse pointer leaves the element bounds.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="e7c98-589">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-589">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-590">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-590">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseOverProperty>|  
|<span data-ttu-id="e7c98-591">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="e7c98-591">Metadata properties set to `true`</span></span>|<span data-ttu-id="e7c98-592">无</span><span class="sxs-lookup"><span data-stu-id="e7c98-592">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="e7c98-593">下面的示例创建包含提供备用 visual 行为的属性 setter 的样式时<xref:System.Windows.Documents.Hyperlink>报表<xref:System.Windows.ContentElement.IsMouseOver%2A> `true`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-593">The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> reports <xref:System.Windows.ContentElement.IsMouseOver%2A> `true`.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-594">标识 <see cref="P:System.Windows.ContentElement.IsMouseOver" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-594">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptured { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-595">获取一个值，该值指示是否将触笔捕获到此元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-595">Gets a value that indicates whether the stylus is captured to this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-596">如果元素具有触笔捕获，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-596">
              <see langword="true" /> if the element has stylus capture; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="e7c98-597">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-597">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-598">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-598">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-599">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-599">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="e7c98-600">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-600">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-601">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-601">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusCapturedProperty>|  
|<span data-ttu-id="e7c98-602">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="e7c98-602">Metadata properties set to `true`</span></span>|<span data-ttu-id="e7c98-603">无</span><span class="sxs-lookup"><span data-stu-id="e7c98-603">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureStylus" />
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCapturedChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-604">在此元素的 <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> 属性值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-604">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-605">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件中，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-605">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCapturedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-606">标识 <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-606">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptureWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-607">获取一个值，该值确定此元素（包括子元素和控件组合）是否具有触笔捕获。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-607">Gets a value that determines whether stylus capture is held by this element, including child elements and control compositing.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-608">如果在此元素中具有触笔捕获，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-608">
              <see langword="true" /> if stylus capture is held within this element; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-609">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-609">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-610">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-610">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="e7c98-611">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-611">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-612">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-612">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusCaptureWithinProperty>|  
|<span data-ttu-id="e7c98-613">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="e7c98-613">Metadata properties set to `true`</span></span>|<span data-ttu-id="e7c98-614">无</span><span class="sxs-lookup"><span data-stu-id="e7c98-614">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCaptureWithinChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-615">在此元素的 <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> 属性值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-615">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-616">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件中，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-616">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCaptureWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-617">标识 <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-617">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusDirectlyOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-618">获取一个值，该值指示在考虑元素组合的情况下，触笔的位置是否与命中测试结果相对应。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-618">Gets a value that indicates whether the stylus position corresponds to hit test results, which take element compositing into account.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-619">如果触笔与命中测试位于同一元素上，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-619">
              <see langword="true" /> if the stylus is over the same element as a hit test; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="e7c98-620">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-620">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-621">与不同<xref:System.Windows.ContentElement.IsStylusOver%2A>，此属性才`true`如果触笔位于元素上。</span><span class="sxs-lookup"><span data-stu-id="e7c98-621">Unlike <xref:System.Windows.ContentElement.IsStylusOver%2A>, this property is only `true` if the stylus is over the element.</span></span> <span data-ttu-id="e7c98-622">如果触笔改为通过子元素或属于某个元素的更深入地组合的元素，此属性将`false`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-622">If the stylus is instead over a child element or over elements that are part of an element's deeper compositing, this property will be `false`.</span></span>  
  
 <span data-ttu-id="e7c98-623">除非你知道如何控件的组合 （例如，你使用此属性在自定义控件模板中的控件，你定义），此属性可能会返回意外的结果。</span><span class="sxs-lookup"><span data-stu-id="e7c98-623">Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</span></span> <span data-ttu-id="e7c98-624">对于大多数情况下不创作控件的情况，使用<xref:System.Windows.ContentElement.IsStylusOver%2A>相反。</span><span class="sxs-lookup"><span data-stu-id="e7c98-624">For most scenarios where you are not authoring controls, use <xref:System.Windows.ContentElement.IsStylusOver%2A> instead.</span></span>  
  
 <span data-ttu-id="e7c98-625">如果此元素具有触笔捕获，并且此属性为`true`捕获时，此属性将保持`true`丢失触笔捕获并且触笔不到其边界之前。</span><span class="sxs-lookup"><span data-stu-id="e7c98-625">If this element has stylus capture and this property is `true` at the time of capture, this property remains `true` until stylus capture is lost and the stylus is not over its bounds.</span></span>  
  
 <span data-ttu-id="e7c98-626">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-626">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-627">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-627">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="e7c98-628">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-628">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-629">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-629">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusDirectlyOverProperty>|  
|<span data-ttu-id="e7c98-630">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="e7c98-630">Metadata properties set to `true`</span></span>|<span data-ttu-id="e7c98-631">无</span><span class="sxs-lookup"><span data-stu-id="e7c98-631">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusDirectlyOverChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-632">在此元素的 <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> 属性值更改时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-632">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-633">此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件中，不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-633">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusDirectlyOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-634">标识 <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-634">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-635">获取一个值，该值指示触笔是否位于此元素（包括可视子元素）上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-635">Gets a value that indicates whether the stylus is located over this element (including visual child elements).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-636">如果触笔位于此元素或其子元素上，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-636">
              <see langword="true" /> if the stylus is over the element or its child elements; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="e7c98-637">默认值为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-637">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-638">如果此元素具有触笔捕获，则此属性保持`true`直到触笔捕获为丢失，指针超出界限。</span><span class="sxs-lookup"><span data-stu-id="e7c98-638">If this element has stylus capture, this property remains `true` until stylus capture is lost and the pointer is out of its bounds.</span></span>  
  
 <span data-ttu-id="e7c98-639">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-639">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-640">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-640">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="e7c98-641">依赖项属性信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-641">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-642">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-642">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusOverProperty>|  
|<span data-ttu-id="e7c98-643">元数据属性设置为 `true`</span><span class="sxs-lookup"><span data-stu-id="e7c98-643">Metadata properties set to `true`</span></span>|<span data-ttu-id="e7c98-644">无</span><span class="sxs-lookup"><span data-stu-id="e7c98-644">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-645">标识 <see cref="P:System.Windows.ContentElement.IsStylusOver" /> 依赖项属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-645">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-646">当焦点在该元素上时按下某个键后发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-646">Occurs when a key is pressed while focus is on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-647">密钥处理与其他平台功能，例如发出命令和文本组合进行交互。</span><span class="sxs-lookup"><span data-stu-id="e7c98-647">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="e7c98-648"><xref:System.Windows.ContentElement.KeyDown>事件是可能无法如期出现在某些控件上的较低级别文本输入的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-648">The <xref:System.Windows.ContentElement.KeyDown> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="e7c98-649">这是文本的因为某些控件有控件组合或提供的更高级别的版本的类处理输入处理和相关事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-649">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span>  
  
 <span data-ttu-id="e7c98-650">此事件创建一个别名<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>附加此类事件，以便<xref:System.Windows.ContentElement.KeyDown>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-650">This event creates an alias for the <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.KeyDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-651">事件处理程序附加到<xref:System.Windows.ContentElement.KeyDown>事件附加到基础<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-651">Event handlers that are attached to the <xref:System.Windows.ContentElement.KeyDown> event are attached to the underlying <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_KeyDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-652">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-652">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-653">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-653">Identifier field</span></span>|<xref:System.Windows.ContentElement.KeyDownEvent>|  
|<span data-ttu-id="e7c98-654">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-654">Routing strategy</span></span>|<span data-ttu-id="e7c98-655">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-655">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-656">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-656">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="e7c98-657">对应的隧道事件<xref:System.Windows.ContentElement.PreviewKeyDown>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-657">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewKeyDown>.</span></span>  
  
-   <span data-ttu-id="e7c98-658">重写<xref:System.Windows.ContentElement.OnKeyDown%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-658">Override <xref:System.Windows.ContentElement.OnKeyDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-659">标识 <see cref="E:System.Windows.ContentElement.KeyDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-659">Identifies the <see cref="E:System.Windows.ContentElement.KeyDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-660">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-660">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-661">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-661">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-662">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-662">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-663">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-663">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-664">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-664">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-665">当焦点在该元素上时松开某个键后发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-665">Occurs when a key is released while focus is on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-666">此事件创建一个别名<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>附加此类事件，以便<xref:System.Windows.ContentElement.KeyUp>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-666">This event creates an alias for the <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> attached event for this class so that  <xref:System.Windows.ContentElement.KeyUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-667">事件处理程序附加到<xref:System.Windows.ContentElement.KeyUp>事件附加到基础<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-667">Event handlers that are attached to the <xref:System.Windows.ContentElement.KeyUp> event are attached to the underlying <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_KeyUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-668">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-668">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-669">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-669">Identifier field</span></span>|<xref:System.Windows.ContentElement.KeyUpEvent>|  
|<span data-ttu-id="e7c98-670">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-670">Routing strategy</span></span>|<span data-ttu-id="e7c98-671">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-671">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-672">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-672">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="e7c98-673">对应的隧道事件<xref:System.Windows.ContentElement.PreviewKeyUp>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-673">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewKeyUp>.</span></span>  
  
-   <span data-ttu-id="e7c98-674">重写<xref:System.Windows.ContentElement.OnKeyUp%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-674">Override <xref:System.Windows.ContentElement.OnKeyUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-675">标识 <see cref="E:System.Windows.ContentElement.KeyUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-675">Identifies the <see cref="E:System.Windows.ContentElement.KeyUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-676">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-676">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-677">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-677">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-678">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-678">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-679">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-679">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-680">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-680">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ LostFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-681">在此元素丢失逻辑焦点时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-681">Occurs when this element loses logical focus.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-682">如果有意通过某个方法调用强制失去了焦点，而前一个键盘焦点位于不同的范围内，则逻辑焦点将与键盘焦点不同。</span><span class="sxs-lookup"><span data-stu-id="e7c98-682">Logical focus differs from keyboard focus if focus is deliberately forced away by using a method call but the previous keyboard focus exists in a different scope.</span></span> <span data-ttu-id="e7c98-683">在这种情况下、 其所在的键盘焦点保持和元素其中<xref:System.Windows.ContentElement.Focus%2A>调用方法仍获取逻辑焦点。</span><span class="sxs-lookup"><span data-stu-id="e7c98-683">In this scenario, keyboard focus remains where it is, and the element where a <xref:System.Windows.ContentElement.Focus%2A> method is called still gets logical focus.</span></span>  
  
 <span data-ttu-id="e7c98-684">此事件的更精确地解释是它时引发的值<xref:System.Windows.ContentElement.IsFocused%2A>路线中的元素的属性更改从`true`到`false`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-684">A more precise interpretation of this event is that it is raised when the value of the <xref:System.Windows.ContentElement.IsFocused%2A> property of an element in the route changes from `true` to `false`.</span></span>  
  
 <span data-ttu-id="e7c98-685">由于此事件使用冒泡路由，失去焦点的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-685">Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="e7c98-686">检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据以确定实际获得焦点的元素中。</span><span class="sxs-lookup"><span data-stu-id="e7c98-686">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that gained focus.</span></span>  
  
<a name="routedEventInfo_LostFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-687">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-687">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-688">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-688">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostFocusEvent>|  
|<span data-ttu-id="e7c98-689">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-689">Routing strategy</span></span>|<span data-ttu-id="e7c98-690">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-690">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-691">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-691">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
-   <span data-ttu-id="e7c98-692">没有相应隧道事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-692">There is no corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="e7c98-693">重写<xref:System.Windows.ContentElement.OnLostFocus%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-693">Override <xref:System.Windows.ContentElement.OnLostFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-694">标识 <see cref="E:System.Windows.ContentElement.LostFocus" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-694">Identifies the <see cref="E:System.Windows.ContentElement.LostFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-695">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-695">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-696">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-696">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-697">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-697">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-698">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-698">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-699">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-699">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ LostKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-700">在此元素不再聚焦于键盘时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-700">Occurs when the keyboard is no longer focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-701">由于此事件使用冒泡路由，失去焦点的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-701">Because this event uses bubbling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="e7c98-702">检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据以确定实际失去焦点的元素中。</span><span class="sxs-lookup"><span data-stu-id="e7c98-702">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="e7c98-703">此事件创建一个别名<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.LostKeyboardFocus>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-703">This event creates an alias for the <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-704">事件处理程序附加到<xref:System.Windows.ContentElement.LostKeyboardFocus>事件附加到基础<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-704">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-705">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-705">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-706">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-706">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostKeyboardFocusEvent>|  
|<span data-ttu-id="e7c98-707">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-707">Routing strategy</span></span>|<span data-ttu-id="e7c98-708">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-708">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-709">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-709">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="e7c98-710">对应的隧道事件<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-710">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="e7c98-711">重写<xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-711">Override <xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-712">标识 <see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-712">Identifies the <see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-713">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-713">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-714">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-714">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-715">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-715">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-716">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-716">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-717">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-717">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ LostMouseCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-718">在此元素丢失鼠标捕获时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-718">Occurs when this element loses mouse capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-719">在元素捕获鼠标，它会接收鼠标输入，即使在指针位于超出界限。</span><span class="sxs-lookup"><span data-stu-id="e7c98-719">When an element captures the mouse, it receives mouse input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="e7c98-720">通常仅在拖放操作期间捕获了鼠标。</span><span class="sxs-lookup"><span data-stu-id="e7c98-720">The mouse is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="e7c98-721">由于此事件使用冒泡路由，丢失捕获的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-721">Because this event uses bubbling routing, the element that loses capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="e7c98-722">检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据以确定丢失捕获的实际元素中。</span><span class="sxs-lookup"><span data-stu-id="e7c98-722">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost capture.</span></span>  
  
 <span data-ttu-id="e7c98-723">此事件创建一个别名<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.LostMouseCapture>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-723">This event creates an alias for the <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostMouseCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-724">事件处理程序附加到<xref:System.Windows.ContentElement.LostMouseCapture>事件附加到基础<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-724">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostMouseCapture> event are attached to the underlying <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-725">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-725">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-726">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-726">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostMouseCaptureEvent>|  
|<span data-ttu-id="e7c98-727">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-727">Routing strategy</span></span>|<span data-ttu-id="e7c98-728">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-728">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-729">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-729">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="e7c98-730">没有定义相应隧道事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-730">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="e7c98-731">重写<xref:System.Windows.ContentElement.OnLostMouseCapture%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-731">Override <xref:System.Windows.ContentElement.OnLostMouseCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-732">标识 <see cref="E:System.Windows.ContentElement.LostMouseCapture" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-732">Identifies the <see cref="E:System.Windows.ContentElement.LostMouseCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-733">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-733">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-734">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-734">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-735">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-735">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-736">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-736">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-737">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-737">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ LostStylusCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-738">在此元素丢失触笔捕获时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-738">Occurs when this element loses stylus capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-739">当元素捕获触笔时，它会接收触笔输入，即使在指针位于超出界限。</span><span class="sxs-lookup"><span data-stu-id="e7c98-739">When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="e7c98-740">通常，将触笔捕获仅在拖放操作过程。</span><span class="sxs-lookup"><span data-stu-id="e7c98-740">The stylus is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="e7c98-741">由于此事件使用冒泡路由，失去焦点的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-741">Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="e7c98-742">检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据以确定实际失去焦点的元素中。</span><span class="sxs-lookup"><span data-stu-id="e7c98-742">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="e7c98-743">此事件创建一个别名<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.LostStylusCapture>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-743">This event creates an alias for the <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostStylusCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-744">事件处理程序附加到<xref:System.Windows.ContentElement.LostStylusCapture>事件附加到基础<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-744">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostStylusCapture> event are attached to the underlying <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-745">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-745">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-746">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-746">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostStylusCaptureEvent>|  
|<span data-ttu-id="e7c98-747">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-747">Routing strategy</span></span>|<span data-ttu-id="e7c98-748">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-748">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-749">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-749">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="e7c98-750">没有定义相应隧道事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-750">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="e7c98-751">重写<xref:System.Windows.ContentElement.OnLostStylusCapture%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-751">Override <xref:System.Windows.ContentElement.OnLostStylusCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostStylusCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-752">标识 <see cref="E:System.Windows.ContentElement.LostStylusCapture" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-752">Identifies the <see cref="E:System.Windows.ContentElement.LostStylusCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-753">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-753">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-754">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-754">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-755">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-755">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-756">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-756">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-757">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-757">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ LostTouchCapture;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-758">在此元素失去触摸屏输入捕获时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-758">Occurs when this element loses a touch capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-759">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-759">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-760">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-760">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostTouchCaptureEvent>|  
|<span data-ttu-id="e7c98-761">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-761">Routing strategy</span></span>|<span data-ttu-id="e7c98-762">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-762">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-763">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-763">Delegate</span></span>|<span data-ttu-id="e7c98-764"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-764"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="e7c98-765">重写<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-765">Override <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostTouchCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-766">标识 <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-766">Identifies the <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-767">在指针位于此元素上并且按下任意鼠标按钮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-767">Occurs when any mouse button is pressed while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-768">此事件创建一个别名<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.MouseDown>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-768">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-769">事件处理程序附加到<xref:System.Windows.ContentElement.MouseDown>事件附加到基础<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-769">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseDown> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-770"><xref:System.Windows.ContentElement.MouseDown>事件通常一起引发<xref:System.Windows.ContentElement.MouseLeftButtonDown>或<xref:System.Windows.ContentElement.MouseRightButtonDown>，这对应于按下的某个之一的两个标准鼠标按钮。</span><span class="sxs-lookup"><span data-stu-id="e7c98-770">The <xref:System.Windows.ContentElement.MouseDown> event is often raised together with either <xref:System.Windows.ContentElement.MouseLeftButtonDown> or <xref:System.Windows.ContentElement.MouseRightButtonDown>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="e7c98-771"><xref:System.Windows.ContentElement.MouseLeftButtonDown> 和<xref:System.Windows.ContentElement.MouseRightButtonDown>也是路由的事件，但它们是直接路由的事件，并引发相应的按钮特定事件时<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件到达事件路由中的此元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-771"><xref:System.Windows.ContentElement.MouseLeftButtonDown> and <xref:System.Windows.ContentElement.MouseRightButtonDown> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="e7c98-772">请参阅备注以<xref:System.Windows.ContentElement.MouseLeftButtonDown>或<xref:System.Windows.ContentElement.MouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-772">See Remarks for <xref:System.Windows.ContentElement.MouseLeftButtonDown> or <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e7c98-773">几个<xref:System.Windows.ContentElement>派生类具有类似于控件的行为，例如， <xref:System.Windows.Documents.Hyperlink>，可能具有固有鼠标按钮事件处理的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-773">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="e7c98-774">按下事件鼠标左键是最可能的事件，能够在控件中处理的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-774">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="e7c98-775">类通常处理标记基础<xref:System.Windows.Input.Mouse>类为已处理的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-775">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="e7c98-776">一旦事件被标记为已处理，其他实例处理程序附加到该元素通常不会引发。</span><span class="sxs-lookup"><span data-stu-id="e7c98-776">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="e7c98-777">通常也不会引发的任何其他类或实例处理程序附加到冒泡方向向 UI 树的根节点中的元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-777">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="e7c98-778">可以解决前面的重要说明中介绍了此问题，从而仍在接收<xref:System.Windows.ContentElement.MouseDown>鼠标左键按下具有类处理通过使用这些解决方案的派生类上的事件的事件：</span><span class="sxs-lookup"><span data-stu-id="e7c98-778">You can resolve the issue that is outlined in the preceding Important and still receive <xref:System.Windows.ContentElement.MouseDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="e7c98-779">附加处理程序<xref:System.Windows.ContentElement.PreviewMouseDown>未标记为已由控件处理的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-779">Attach handlers for the <xref:System.Windows.ContentElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="e7c98-780">请注意，由于这是预览事件，则路由从根开始并挖掘到控件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-780">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="e7c98-781">： 分步骤注册控件上的处理程序，通过调用<xref:System.Windows.ContentElement.AddHandler%2A>并选择使处理程序能够侦听事件，即使它们已标记为已处理路由的事件数据中的签名选项。</span><span class="sxs-lookup"><span data-stu-id="e7c98-781">Register a handler on the control procedurally by calling <xref:System.Windows.ContentElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-782">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-782">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-783">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-783">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseDownEvent>|  
|<span data-ttu-id="e7c98-784">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-784">Routing strategy</span></span>|<span data-ttu-id="e7c98-785">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-785">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-786">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-786">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="e7c98-787">对应的隧道事件<xref:System.Windows.ContentElement.PreviewMouseDown>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-787">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseDown>.</span></span>  
  
-   <span data-ttu-id="e7c98-788">重写<xref:System.Windows.ContentElement.OnMouseDown%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-788">Override <xref:System.Windows.ContentElement.OnMouseDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-789">标识 <see cref="E:System.Windows.ContentElement.MouseDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-789">Identifies the <see cref="E:System.Windows.ContentElement.MouseDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-790">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-790">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-791">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-791">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-792">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-792">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-793">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-793">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-794">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-794">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseEnter;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-795">在鼠标指针进入此元素的边界时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-795">Occurs when the mouse pointer enters the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-796"><xref:System.Windows.ContentElement.MouseEnter> 是[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)使用直接的事件处理路由策略。</span><span class="sxs-lookup"><span data-stu-id="e7c98-796"><xref:System.Windows.ContentElement.MouseEnter> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="e7c98-797">在路由过程; 不会引发直接路由的事件相反，它们是在中处理同一个元素引发它们时。</span><span class="sxs-lookup"><span data-stu-id="e7c98-797">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="e7c98-798">但是，它们启用路由的事件的行为，如样式中的事件触发器其他的方面。</span><span class="sxs-lookup"><span data-stu-id="e7c98-798">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="e7c98-799">尽管<xref:System.Windows.ContentElement.MouseEnter>跟踪何时鼠标指针进入的元素边界内，此事件能够更确切地报告<xref:System.Windows.ContentElement.IsMouseOver%2A>属性值已更改，不再`false`到`true`针对此元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-799">Although <xref:System.Windows.ContentElement.MouseEnter> tracks when the mouse pointer enters the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsMouseOver%2A> property value has changed from `false` to `true` on this element.</span></span>  
  
 <span data-ttu-id="e7c98-800">此事件创建一个别名<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.MouseEnter>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-800">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-801">事件处理程序附加到<xref:System.Windows.ContentElement.MouseEnter>事件附加到基础<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-801">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseEnter> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-802">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-802">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-803">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-803">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseEnterEvent>|  
|<span data-ttu-id="e7c98-804">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-804">Routing strategy</span></span>|<span data-ttu-id="e7c98-805">直接</span><span class="sxs-lookup"><span data-stu-id="e7c98-805">Direct</span></span>|  
|<span data-ttu-id="e7c98-806">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-806">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="e7c98-807">重写<xref:System.Windows.ContentElement.OnMouseEnter%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-807">Override <xref:System.Windows.ContentElement.OnMouseEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-808">标识 <see cref="E:System.Windows.ContentElement.MouseEnter" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-808">Identifies the <see cref="E:System.Windows.ContentElement.MouseEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-809">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-809">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-810">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-810">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-811">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-811">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-812">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-812">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-813">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-813">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseLeave;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-814">在鼠标指针离开此元素的边界时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-814">Occurs when the mouse pointer leaves the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-815"><xref:System.Windows.ContentElement.MouseLeave> 是[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)使用直接的事件处理路由策略。</span><span class="sxs-lookup"><span data-stu-id="e7c98-815"><xref:System.Windows.ContentElement.MouseLeave> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="e7c98-816">在路由过程; 不会引发直接路由的事件相反，它们是在中处理同一个元素引发它们时。</span><span class="sxs-lookup"><span data-stu-id="e7c98-816">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="e7c98-817">但是，它们启用路由的事件的行为，如样式中的事件触发器其他的方面。</span><span class="sxs-lookup"><span data-stu-id="e7c98-817">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="e7c98-818">尽管<xref:System.Windows.ContentElement.MouseLeave>跟踪何时鼠标离开元素，此事件的详细信息确切地报告<xref:System.Windows.ContentElement.IsMouseOver%2A>属性值已更改，不再`true`到`false`针对此元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-818">Although <xref:System.Windows.ContentElement.MouseLeave> tracks when the mouse leaves an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsMouseOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
 <span data-ttu-id="e7c98-819">此事件创建一个别名<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.MouseLeave>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-819">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-820">事件处理程序附加到<xref:System.Windows.ContentElement.MouseLeave>事件附加到基础<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-820">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseLeave> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-821">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-821">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-822">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-822">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeaveEvent>|  
|<span data-ttu-id="e7c98-823">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-823">Routing strategy</span></span>|<span data-ttu-id="e7c98-824">直接</span><span class="sxs-lookup"><span data-stu-id="e7c98-824">Direct</span></span>|  
|<span data-ttu-id="e7c98-825">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-825">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="e7c98-826">重写<xref:System.Windows.ContentElement.OnMouseLeave%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-826">Override <xref:System.Windows.ContentElement.OnMouseLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-827">标识 <see cref="E:System.Windows.ContentElement.MouseLeave" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-827">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-828">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-828">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-829">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-829">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-830">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-830">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-831">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-831">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-832">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-832">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-833">在鼠标指针位于此元素上并且按下鼠标左键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-833">Occurs when the left mouse button is pressed while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-834">尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循冒泡路由通过元素树，它实际上是直接的路由的事件引发和每个元素树沿遵循<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-834">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="e7c98-835">此事件是报告鼠标按钮特定信息的基础的几个相关事件之一<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件，即处理为由事件路由每个元素的附加的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-835">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="e7c98-836">此事件的自变量公开基础的自变量<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-836">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="e7c98-837">如果该事件被标记为已处理事件路由过程，则仍会引发的鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.ContentElement.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将事件侦听器。</span><span class="sxs-lookup"><span data-stu-id="e7c98-837">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="e7c98-838">从概念上讲，将此事件 (和其他鼠标按钮事件上的<xref:System.Windows.ContentElement>) 视为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-838">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="e7c98-839">事件将添加不需要检查鼠标按钮状态 （从左至右，向上向下） 的事件数据中的原始鼠标事件的便利性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-839">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="e7c98-840">对于更高级的方案，例如检查非标准按钮的状态，你可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>上类而不是那些<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-840">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e7c98-841">几个<xref:System.Windows.ContentElement>派生类具有类似于控件的行为，例如， <xref:System.Windows.Documents.Hyperlink>，可能具有固有鼠标按钮事件处理的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-841">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="e7c98-842">按下事件鼠标左键是最可能的事件，能够在控件中处理的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-842">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="e7c98-843">类通常处理标记基础<xref:System.Windows.Input.Mouse>类为已处理的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-843">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="e7c98-844">一旦事件被标记为已处理，其他实例处理程序附加到该元素通常不会引发。</span><span class="sxs-lookup"><span data-stu-id="e7c98-844">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="e7c98-845">通常也不会引发的任何其他类或实例处理程序附加到冒泡方向向 UI 树的根节点中的元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-845">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="e7c98-846">可以解决前面的重要说明中介绍了此问题，从而仍在接收<xref:System.Windows.ContentElement.MouseLeftButtonDown>鼠标左键按下具有类处理通过使用这些解决方案的派生类上的事件的事件：</span><span class="sxs-lookup"><span data-stu-id="e7c98-846">You can resolve the issue that is outlined in the preceding Important and still receive <xref:System.Windows.ContentElement.MouseLeftButtonDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="e7c98-847">附加处理程序<xref:System.Windows.ContentElement.PreviewMouseDown>未标记为已由控件处理的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-847">Attach handlers for the <xref:System.Windows.ContentElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="e7c98-848">请注意，由于这是预览事件，则路由从根开始并挖掘到控件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-848">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="e7c98-849">： 分步骤注册控件上的处理程序，通过调用<xref:System.Windows.ContentElement.AddHandler%2A>并选择使处理程序能够侦听事件，即使它们已标记为已处理路由的事件数据中的签名选项。</span><span class="sxs-lookup"><span data-stu-id="e7c98-849">Register a handler on the control procedurally by calling <xref:System.Windows.ContentElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-850">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-850">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-851">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-851">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeftButtonDownEvent>|  
|<span data-ttu-id="e7c98-852">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-852">Routing strategy</span></span>|<span data-ttu-id="e7c98-853">直接</span><span class="sxs-lookup"><span data-stu-id="e7c98-853">Direct</span></span>|  
|<span data-ttu-id="e7c98-854">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-854">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="e7c98-855">重写<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-855">Override <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-856">标识 <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-856">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-857">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-857">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-858">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-858">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-859">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-859">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-860">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-860">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-861">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-861">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-862">在鼠标指针位于此元素上并且松开鼠标左键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-862">Occurs when the left mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-863">尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循冒泡路由通过元素树，它实际上是直接的路由的事件引发和每个元素树沿遵循<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-863">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="e7c98-864">此事件是报告鼠标按钮特定信息的基础的几个相关事件之一<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件，即处理为由事件路由每个元素的附加的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-864">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="e7c98-865">此事件的自变量公开基础的自变量<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-865">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="e7c98-866">如果该事件被标记为已处理事件路由过程，则仍会引发的鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.ContentElement.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将事件侦听器。</span><span class="sxs-lookup"><span data-stu-id="e7c98-866">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="e7c98-867">从概念上讲，将此事件 (和其他鼠标按钮事件上的<xref:System.Windows.ContentElement>) 视为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-867">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="e7c98-868">事件将添加不需要检查鼠标按钮状态 （从左至右，向上向下） 的事件数据中的原始鼠标事件的便利性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-868">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="e7c98-869">对于更高级的方案，例如检查非标准按钮的状态，你可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>上类而不是那些<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-869">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-870">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-870">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-871">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-871">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeftButtonUpEvent>|  
|<span data-ttu-id="e7c98-872">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-872">Routing strategy</span></span>|<span data-ttu-id="e7c98-873">直接</span><span class="sxs-lookup"><span data-stu-id="e7c98-873">Direct</span></span>|  
|<span data-ttu-id="e7c98-874">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-874">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="e7c98-875">重写<xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-875">Override <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-876">标识 <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-876">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-877">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-877">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-878">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-878">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-879">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-879">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-880">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-880">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-881">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-881">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-882">在鼠标指针位于此元素上并且移动鼠标指针时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-882">Occurs when the mouse pointer moves while over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-883">此事件创建一个别名<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.MouseMove>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-883">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-884">事件处理程序附加到<xref:System.Windows.ContentElement.MouseMove>事件附加到基础<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-884">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-885">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-885">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-886">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-886">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseMoveEvent>|  
|<span data-ttu-id="e7c98-887">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-887">Routing strategy</span></span>|<span data-ttu-id="e7c98-888">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-888">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-889">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-889">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="e7c98-890">对应的隧道事件<xref:System.Windows.ContentElement.PreviewMouseMove>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-890">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseMove>.</span></span>  
  
-   <span data-ttu-id="e7c98-891">重写<xref:System.Windows.ContentElement.OnMouseMove%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-891">Override <xref:System.Windows.ContentElement.OnMouseMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-892">标识 <see cref="E:System.Windows.ContentElement.MouseMove" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-892">Identifies the <see cref="E:System.Windows.ContentElement.MouseMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-893">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-893">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-894">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-894">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-895">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-895">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-896">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-896">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-897">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-897">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-898">在鼠标指针位于此元素上并且按下鼠标右键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-898">Occurs when the right mouse button is pressed while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-899">尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循冒泡路由通过元素树，它实际上是直接的路由的事件引发和每个元素树沿遵循<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-899">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="e7c98-900">此事件是报告鼠标按钮特定信息的基础的几个相关事件之一<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件，即处理为由事件路由每个元素的附加的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-900">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="e7c98-901">此事件的自变量公开基础的自变量<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-901">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="e7c98-902">如果该事件被标记为已处理事件路由过程，则仍会引发的鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.ContentElement.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将事件侦听器。</span><span class="sxs-lookup"><span data-stu-id="e7c98-902">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="e7c98-903">从概念上讲，将此事件 (和其他鼠标按钮事件上的<xref:System.Windows.ContentElement>) 视为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-903">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="e7c98-904">事件将添加不需要检查鼠标按钮状态 （从左至右，向上向下） 的事件数据中的原始鼠标事件的便利性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-904">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="e7c98-905">对于更高级的方案，例如检查非标准按钮的状态，你可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>上类而不是那些<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-905">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="e7c98-906">右侧的按钮的鼠标事件，通常在应用程序方案具有本机处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-906">Right button mouse events frequently have native handling in application scenarios.</span></span> <span data-ttu-id="e7c98-907">例如，向下的鼠标右键按钮可能显示上下文菜单。</span><span class="sxs-lookup"><span data-stu-id="e7c98-907">For instance, a right mouse button down might display a context menu.</span></span> <span data-ttu-id="e7c98-908">请参阅[ContextMenu 概述](~/docs/framework/wpf/controls/contextmenu-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-908">See [ContextMenu Overview](~/docs/framework/wpf/controls/contextmenu-overview.md).</span></span>  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-909">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-909">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-910">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-910">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseRightButtonDownEvent>|  
|<span data-ttu-id="e7c98-911">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-911">Routing strategy</span></span>|<span data-ttu-id="e7c98-912">直接</span><span class="sxs-lookup"><span data-stu-id="e7c98-912">Direct</span></span>|  
|<span data-ttu-id="e7c98-913">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-913">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="e7c98-914">重写<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-914">Override <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-915">标识 <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-915">Identifies the <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-916">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-916">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-917">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-917">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-918">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-918">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-919">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-919">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-920">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-920">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-921">在鼠标指针位于此元素上并且松开鼠标右键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-921">Occurs when the right mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-922">尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循冒泡路由通过元素树，它实际上是直接的路由的事件引发和每个元素树沿遵循<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-922">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="e7c98-923">此事件是报告鼠标按钮特定信息的基础的几个相关事件之一<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件，即处理为由事件路由每个元素的附加的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-923">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="e7c98-924">此事件的自变量公开基础的自变量<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-924">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="e7c98-925">如果该事件被标记为已处理事件路由过程，则仍会引发的鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.ContentElement.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将事件侦听器。</span><span class="sxs-lookup"><span data-stu-id="e7c98-925">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="e7c98-926">从概念上讲，将此事件 (和其他鼠标按钮事件上的<xref:System.Windows.ContentElement>) 视为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-926">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="e7c98-927">事件将添加不需要检查鼠标按钮状态 （从左至右，向上向下） 的事件数据中的原始鼠标事件的便利性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-927">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="e7c98-928">对于更高级的方案，例如检查非标准按钮的状态，你可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>上类而不是那些<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-928">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-929">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-929">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-930">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-930">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseRightButtonUpEvent>|  
|<span data-ttu-id="e7c98-931">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-931">Routing strategy</span></span>|<span data-ttu-id="e7c98-932">直接</span><span class="sxs-lookup"><span data-stu-id="e7c98-932">Direct</span></span>|  
|<span data-ttu-id="e7c98-933">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-933">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="e7c98-934">重写<xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-934">Override <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-935">标识 <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-935">Identifies the <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-936">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-936">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-937">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-937">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-938">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-938">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-939">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-939">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-940">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-940">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-941">在鼠标指针位于此元素上并且松开任意鼠标按钮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-941">Occurs when any mouse button is released over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-942">此事件创建一个别名<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.MouseUp>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-942">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-943">事件处理程序附加到<xref:System.Windows.ContentElement.MouseUp>事件附加到基础<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-943">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseUp> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-944"><xref:System.Windows.ContentElement.MouseUp>事件通常一起引发<xref:System.Windows.ContentElement.MouseLeftButtonUp>或<xref:System.Windows.ContentElement.MouseRightButtonUp>，这对应于两个标准鼠标按钮之一的版本。</span><span class="sxs-lookup"><span data-stu-id="e7c98-944">The <xref:System.Windows.ContentElement.MouseUp> event is often raised together with either <xref:System.Windows.ContentElement.MouseLeftButtonUp> or <xref:System.Windows.ContentElement.MouseRightButtonUp>, which correspond to a release of one of the two standard mouse buttons.</span></span> <span data-ttu-id="e7c98-945"><xref:System.Windows.ContentElement.MouseLeftButtonUp> 和<xref:System.Windows.ContentElement.MouseRightButtonUp>也是路由的事件，但它们是直接路由的事件，并引发相应的按钮特定事件时<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件到达事件路由中的此元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-945"><xref:System.Windows.ContentElement.MouseLeftButtonUp> and <xref:System.Windows.ContentElement.MouseRightButtonUp> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="e7c98-946">请参阅备注以<xref:System.Windows.ContentElement.MouseLeftButtonUp>或<xref:System.Windows.ContentElement.MouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-946">See Remarks for <xref:System.Windows.ContentElement.MouseLeftButtonUp> or <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span>  
  
<a name="routedEventInfo_MouseUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-947">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-947">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-948">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-948">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseUpEvent>|  
|<span data-ttu-id="e7c98-949">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-949">Routing strategy</span></span>|<span data-ttu-id="e7c98-950">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-950">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-951">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-951">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="e7c98-952">对应的隧道事件<xref:System.Windows.ContentElement.PreviewMouseUp>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-952">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseUp>.</span></span>  
  
-   <span data-ttu-id="e7c98-953">重写<xref:System.Windows.ContentElement.OnMouseUp%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-953">Override <xref:System.Windows.ContentElement.OnMouseUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-954">标识 <see cref="E:System.Windows.ContentElement.MouseUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-954">Identifies the <see cref="E:System.Windows.ContentElement.MouseUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-955">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-955">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-956">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-956">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-957">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-957">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-958">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-958">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-959">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-959">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ MouseWheel;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-960">在鼠标指针位于此元素上并且用户滚动鼠标滚轮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-960">Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-961">焦点或鼠标捕获优先于其中鼠标指针位于;因此，如果你收到<xref:System.Windows.ContentElement.MouseWheel>的已设定焦点或捕获元素中的事件，鼠标指针实际上可能是通过另一个元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-961">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive the <xref:System.Windows.ContentElement.MouseWheel> event from a focused or captured element, the mouse pointer might actually be over another element.</span></span>  
  
 <span data-ttu-id="e7c98-962">此事件创建一个别名<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.MouseWheel>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-962">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseWheel> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-963">事件处理程序附加到<xref:System.Windows.ContentElement.MouseWheel>事件附加到基础<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-963">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseWheel> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-964">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-964">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-965">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-965">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseWheelEvent>|  
|<span data-ttu-id="e7c98-966">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-966">Routing strategy</span></span>|<span data-ttu-id="e7c98-967">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-967">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-968">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-968">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="e7c98-969">对应的隧道事件<xref:System.Windows.ContentElement.PreviewMouseWheel>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-969">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseWheel>.</span></span>  
  
-   <span data-ttu-id="e7c98-970">重写<xref:System.Windows.ContentElement.OnMouseWheel%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-970">Override <xref:System.Windows.ContentElement.OnMouseWheel%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-971">标识 <see cref="E:System.Windows.ContentElement.MouseWheel" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-971">Identifies the <see cref="E:System.Windows.ContentElement.MouseWheel" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-972">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-972">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-973">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-973">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-974">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-974">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-975">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-975">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-976">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-976">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">
          <span data-ttu-id="e7c98-977">一个遍历请求，其中包含一个属性，该属性指示以现有 Tab 键顺序遍历的模式或视觉移动的方向。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-977">A traversal request, which contains a property that indicates either a mode to traverse in existing tab order, or a direction to move visually.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-978">尝试将焦点从此元素移到其他元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-978">Attempts to move focus from this element to another element.</span>
          </span>
          <span data-ttu-id="e7c98-979">移动焦点的方向由指导方向指定，该方向在此元素的可视父级的组织结构中解释。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-979">The direction to move focus is specified by a guidance direction, which is interpreted within the organization of the visual parent for this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e7c98-980">如果执行了请求的遍历，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-980">
              <see langword="true" /> if the requested traversal was performed; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-981">请确保检查此方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-981">Make sure you check the return value of this method.</span></span> <span data-ttu-id="e7c98-982">返回值`false`如果遇到控件的组合所定义的制表位遍历并且遍历请求未请求包装可能会返回。</span><span class="sxs-lookup"><span data-stu-id="e7c98-982">A return value of `false` might be returned if the traversal runs into a tab stop that is defined by a control's composition, and the traversal request did not request to wrap.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-983">为 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基础结构返回特定于类的 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 实现。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-983">Returns class-specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementations for the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e7c98-984">特定于类型的 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 实现。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-984">The type-specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementation.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e7c98-985">此方法的实现是通常调用特定的构造函数<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />实现，并将其作为返回值。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-985">The implementation of this method is typically to call the constructor of a specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementation, and return it as the return value.</span>
            </span>
            <span data-ttu-id="e7c98-986">所有<see cref="T:System.Windows.ContentElement" />派生的类应实现此方法，以便提供其各自的特定<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />到实现[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]基础结构。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-986">All <see cref="T:System.Windows.ContentElement" /> derived classes should implement this method in order to provide their own specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementations to the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure.</span>
            </span>
            <span data-ttu-id="e7c98-987">有关实现此模式的详细信息，请参阅<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-987">For details on implementing this pattern, see <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-988">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-988">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-989">当某个未处理的 <see cref="E:System.Windows.DragDrop.DragEnter" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-989">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragEnter" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-990">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-990">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-991">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-991">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-992">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-992">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-993">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-993">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-994">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-994">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-995">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-995">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-996">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-996">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-997">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-997">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-998">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-998">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-999">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-999">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1000">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1000">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1001">当某个未处理的 <see cref="E:System.Windows.DragDrop.DragLeave" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1001">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragLeave" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1002">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1002">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1003">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1003">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1004">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1004">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1005">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1005">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1006">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1006">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1007">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1007">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1008">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1008">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1009">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1009">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1010">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1010">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1011">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1011">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1012">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1012">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1013">当某个未处理的 <see cref="E:System.Windows.DragDrop.DragOver" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1013">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragOver" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1014">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1014">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1015">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1015">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1016">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1016">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1017">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1017">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1018">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1018">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1019">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1019">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1020">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1020">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1021">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1021">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1022">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1022">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1023">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1023">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1024">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1024">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1025">当某个未处理的 <see cref="E:System.Windows.DragDrop.DragEnter" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1025">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragEnter" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1026">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1026">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1027">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1027">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1028">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1028">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1029">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1029">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1030">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1030">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1031">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1031">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1032">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1032">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1033">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1033">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1034">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1034">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1035">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1035">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1036">包含事件数据的 <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1036">The <see cref="T:System.Windows.GiveFeedbackEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1037">当某个未处理的 <see cref="E:System.Windows.DragDrop.GiveFeedback" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1037">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.GiveFeedback" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1038">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1038">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1039">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1039">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1040">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1040">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1041">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1041">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1042">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1042">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1043">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1043">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1044">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1044">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1045">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1045">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1046">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1046">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1047">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1047">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1048">包含事件数据的 <see cref="T:System.Windows.RoutedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1048">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains event data.</span>
          </span>
          <span data-ttu-id="e7c98-1049">此事件数据必须包含 <see cref="E:System.Windows.ContentElement.GotFocus" /> 事件的标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1049">This event data must contain the identifier for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1050">使用所提供的事件数据引发 <see cref="E:System.Windows.ContentElement.GotFocus" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1050">Raises the <see cref="E:System.Windows.ContentElement.GotFocus" /> routed event by using the event data provided.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1051">此方法，虽然但虚拟的具有引发事件的默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1051">This method, although virtual, does have a default implementation that raises the event.</span></span>  
  
 <span data-ttu-id="e7c98-1052">这在 \* 方法实现用于引发事件，并且内部调用此方法的实现来引发事件时<xref:System.Windows.ContentElement.IsFocused%2A>属性值更改。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1052">This On\* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes.</span></span> <span data-ttu-id="e7c98-1053"><xref:System.Windows.ContentElement.OnGotFocus%2A>实现不同于其他某些[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]上 \* 实现，后者只提供了一种简便方式为该事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1053">The <xref:System.Windows.ContentElement.OnGotFocus%2A> implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] On\* implementations, which only provide a convenient way to add class handling for that event.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e7c98-1054">除非有特意需求不引发焦点事件，请确保您的实现将调用基实现。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-1054">Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</span>
            </span>
            <span data-ttu-id="e7c98-1055">否则为<see cref="E:System.Windows.ContentElement.GotFocus" />在通常将焦点设置到此元素的典型用户操作期间不会引发事件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-1055">Otherwise, the <see cref="E:System.Windows.ContentElement.GotFocus" /> event is not raised during typical user operations that ordinarily set focus to this element.</span>
            </span>
            <span data-ttu-id="e7c98-1056">如果不想使用您可获得焦点的元素，你可以通过将阻止元素<see cref="P:System.Windows.ContentElement.Focusable" />到<see langword="false" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-1056">If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.ContentElement.Focusable" /> to <see langword="false" />.</span>
            </span>
            <span data-ttu-id="e7c98-1057">请注意，默认情况下<see cref="P:System.Windows.ContentElement.Focusable" />不可获得焦点，因此设置<see cref="P:System.Windows.ContentElement.Focusable" />有意可能没有必要。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-1057">Note that by default a <see cref="P:System.Windows.ContentElement.Focusable" /> is not focusable, therefore setting <see cref="P:System.Windows.ContentElement.Focusable" /> deliberately might not be necessary.</span>
            </span>
          </para>
        </block>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1058">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1058">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1059">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1059">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1060">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1060">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1061">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1061">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1062">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1062">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1063">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1063">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1064">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1064">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1065">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1065">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1066">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1066">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1067">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1067">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1068">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1068">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1069">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1069">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1070">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1070">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1071">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1071">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1072">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1072">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1073">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1073">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1074">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1074">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1075">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1075">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1076">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1076">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1077">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1077">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1078">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1078">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1079">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1079">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1080">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1080">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1081">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1081">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1082">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1082">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1083">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1083">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1084">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1084">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1085">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1085">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1086">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1086">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1087">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1087">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1088">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1088">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1089">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1089">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1090">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1090">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1091">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1091">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1092">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1092">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1093">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1093">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1094">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1094">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1095">为在此元素上捕获触摸屏输入时发生的 <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1095">Provides class handling for the <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> routed event that occurs when a touch is captured to this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1096"><xref:System.Windows.ContentElement.OnGotTouchCapture%2A>方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1096">The <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> method has no default implementation.</span></span> <span data-ttu-id="e7c98-1097">重写<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>在派生类来处理<xref:System.Windows.ContentElement.GotTouchCapture>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1097">Override <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> in a derived class to handle the <xref:System.Windows.ContentElement.GotTouchCapture> event.</span></span> <span data-ttu-id="e7c98-1098">一定要调用基类的<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>方法，从而基本类对事件进行接收。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1098">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1099">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1099">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1100">在此元素上引发未处理的 <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> 事件时，调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1100">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="e7c98-1101">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1101">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1102">此虚方法引发时的值<xref:System.Windows.ContentElement.IsKeyboardFocused%2A>依赖项属性更改。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1102">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> dependency property changes.</span></span> <span data-ttu-id="e7c98-1103">虚方法首先引发，并可以处理所需的事件数据。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1103">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="e7c98-1104">则<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>与该相同的事件数据实例引发事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1104">Then the <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="e7c98-1105">请注意，<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>事件不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1105">Notice that the  <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> event is not a routed event.</span></span> <span data-ttu-id="e7c98-1106">因此，你不能将其标记为已处理的类处理程序中。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1106">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="e7c98-1107">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1107">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1108">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1108">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="e7c98-1109">你可以调用基之前或之后你特殊的处理，具体取决于你的要求。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1109">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1110">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1110">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1111">在此元素引发 <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> 事件前的那一刻调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1111">Invoked just before the <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> event is raised by this element.</span>
          </span>
          <span data-ttu-id="e7c98-1112">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1112">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1113">此虚方法引发时的值<xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A>依赖项属性更改其值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1113">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> dependency property changes its value.</span></span> <span data-ttu-id="e7c98-1114">虚方法首先引发，并可以处理所需的事件数据。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1114">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="e7c98-1115">则<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>与该相同的事件数据实例引发事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1115">Then the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="e7c98-1116">请注意，<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>事件不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1116">Notice that the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event is not a routed event.</span></span> <span data-ttu-id="e7c98-1117">因此，你不能将其标记为已处理的类处理程序中。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1117">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="e7c98-1118">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1118">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1119">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1119">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="e7c98-1120">你可以调用基之前或之后你特殊的处理，具体取决于你的要求。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1120">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1121">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1121">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1122">在此元素上引发未处理的 <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> 事件时，调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1122">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="e7c98-1123">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1123">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1124">此虚方法引发时的值<xref:System.Windows.ContentElement.IsMouseCaptured%2A>依赖项属性更改其值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1124">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsMouseCaptured%2A> dependency property changes its value.</span></span> <span data-ttu-id="e7c98-1125">虚方法首先引发，并可以处理所需的事件数据。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1125">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="e7c98-1126">则<xref:System.Windows.ContentElement.IsMouseCapturedChanged>与该相同的事件数据实例引发事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1126">Then the <xref:System.Windows.ContentElement.IsMouseCapturedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="e7c98-1127">请注意，<xref:System.Windows.ContentElement.IsMouseCapturedChanged>事件不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1127">Notice that the <xref:System.Windows.ContentElement.IsMouseCapturedChanged> event is not a routed event.</span></span> <span data-ttu-id="e7c98-1128">因此，你不能将其标记为已处理的类处理程序中。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1128">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="e7c98-1129">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1129">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1130">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1130">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="e7c98-1131">你可以调用基之前或之后你特殊的处理，具体取决于你的要求。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1131">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1132">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1132">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1133">在此元素上引发未处理的 <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> 事件时，调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1133">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="e7c98-1134">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1134">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e7c98-1135">此虚方法引发时的值<see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" />依赖项属性更改其值。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-1135">This virtual method is raised when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property changes its value.</span>
            </span>
            <span data-ttu-id="e7c98-1136">虚方法首先引发，并可以处理所需的事件数据。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-1136">The virtual method is raised first and can manipulate the event data as necessary.</span>
            </span>
            <span data-ttu-id="e7c98-1137">则<see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />与该相同的事件数据实例引发事件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-1137">Then the <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised with that same event data instance.</span>
            </span>
            <span data-ttu-id="e7c98-1138">请注意，事件不是路由的事件。因此，你不能将其标记为已处理的类处理程序中。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-1138">Notice that the event is not a routed event; Therefore,  you cannot mark it as handled in the class handler.</span>
            </span>
            <span data-ttu-id="e7c98-1139">此方法不具有默认实现。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-1139">This method has no default implementation.</span>
            </span>
            <span data-ttu-id="e7c98-1140">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-1140">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span>
            </span>
            <span data-ttu-id="e7c98-1141">你可以调用基之前或之后你特殊的处理，具体取决于你的要求。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-1141">You may call base either before or after your special handling, depending on your requirements.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1142">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1142">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1143">在此元素上引发未处理的 <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> 事件时，调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1143">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="e7c98-1144">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1144">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1145">此虚方法引发时的值<xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A>依赖项属性更改其值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1145">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A> dependency property changes its value.</span></span> <span data-ttu-id="e7c98-1146">虚方法首先引发，并可以处理所需的事件数据。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1146">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="e7c98-1147">则<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>与该相同的事件数据实例引发事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1147">Then the <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="e7c98-1148">请注意，<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>事件不是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1148">Notice that the <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> event is not a routed event.</span></span> <span data-ttu-id="e7c98-1149">因此，你不能将其标记为已处理的类处理程序中。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1149">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="e7c98-1150">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1150">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1151">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1151">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="e7c98-1152">你可以调用基之前或之后你特殊的处理，具体取决于你的要求。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1152">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1153">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1153">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1154">在此元素上引发未处理的 <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> 事件时，调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1154">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="e7c98-1155">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1155">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1156">此虚方法引发时的值<xref:System.Windows.ContentElement.IsStylusCaptured%2A>依赖项属性更改其值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1156">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusCaptured%2A> dependency property changes its value.</span></span> <span data-ttu-id="e7c98-1157">虚方法首先引发，并可以处理所需的事件数据。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1157">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="e7c98-1158">则<xref:System.Windows.ContentElement.IsStylusCapturedChanged>与该相同的事件数据实例引发事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1158">Then the <xref:System.Windows.ContentElement.IsStylusCapturedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="e7c98-1159">请注意，事件不路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1159">Notice that the event is not a routed event.</span></span> <span data-ttu-id="e7c98-1160">因此，你不能将其标记为已处理的类处理程序中。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1160">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="e7c98-1161">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1161">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1162">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1162">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="e7c98-1163">你可以调用基之前或之后你特殊的处理，具体取决于你的要求。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1163">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1164">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1164">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1165">在此元素上引发未处理的 <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> 事件时，调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1165">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="e7c98-1166">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1166">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1167">此虚方法引发时的值<xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A>依赖项属性更改其值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1167">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A> dependency property changes its value.</span></span> <span data-ttu-id="e7c98-1168">虚方法首先引发，并可以处理所需的事件数据。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1168">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="e7c98-1169">则<xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged>与该相同的事件数据实例引发事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1169">Then the <xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="e7c98-1170">请注意，事件不路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1170">Notice that the event is not a routed event.</span></span> <span data-ttu-id="e7c98-1171">因此，你不能将其标记为已处理的类处理程序中。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1171">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="e7c98-1172">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1172">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1173">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1173">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="e7c98-1174">你可以调用基之前或之后你特殊的处理，具体取决于你的要求。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1174">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1175">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1175">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1176">在此元素上引发未处理的 <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> 事件时，调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1176">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="e7c98-1177">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1177">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1178">此虚方法引发时的值<xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A>依赖项属性更改其值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1178">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A> dependency property changes its value.</span></span> <span data-ttu-id="e7c98-1179">虚方法首先引发，并可以处理所需的事件数据。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1179">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="e7c98-1180">则<xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged>与该相同的事件数据实例引发事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1180">Then the <xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="e7c98-1181">请注意，事件不路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1181">Notice that the event is not a routed event.</span></span> <span data-ttu-id="e7c98-1182">因此你无法将其标记为已处理的类处理程序中。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1182">Therefore you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="e7c98-1183">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1183">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1184">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1184">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="e7c98-1185">你可以调用基之前或之后你特殊的处理，具体取决于你的要求。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1185">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1186">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1186">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1187">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1187">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1188">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1188">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1189">击键的专用输入管理器来处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1189">Keystrokes are handled by a dedicated input manager.</span></span> <span data-ttu-id="e7c98-1190">之前被视为常规击键公开，其他编程功能，依赖于击键，例如，输入和命令绑定，可能处理击键。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1190">Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</span></span> <span data-ttu-id="e7c98-1191">如果这些输入系统功能将事件标记为已处理，则<xref:System.Windows.ContentElement.OnKeyDown%2A>不会被调用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1191">If these input system features mark the event as handled, then <xref:System.Windows.ContentElement.OnKeyDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="e7c98-1192">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1192">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1193">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1193">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1194">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1194">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1195">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1195">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1196">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1196">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1197">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1197">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1198">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1198">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1199">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1199">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1200">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1200">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1201">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1201">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1202">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1202">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1203">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1203">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1204">击键的专用输入管理器来处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1204">Keystrokes are handled by a dedicated input manager.</span></span> <span data-ttu-id="e7c98-1205">之前被视为常规击键公开，其他编程功能，依赖于击键，例如，输入和命令绑定，可能处理击键。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1205">Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</span></span> <span data-ttu-id="e7c98-1206">如果这些输入系统功能将事件标记为已处理，则<xref:System.Windows.ContentElement.OnKeyUp%2A>不会被调用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1206">If these input system features mark the event as handled, then <xref:System.Windows.ContentElement.OnKeyUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="e7c98-1207">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1207">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1208">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1208">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1209">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1209">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1210">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1210">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1211">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1211">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1212">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1212">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1213">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1213">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1214">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1214">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1215">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1215">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1216">包含事件数据的 <see cref="T:System.Windows.RoutedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1216">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains event data.</span>
          </span>
          <span data-ttu-id="e7c98-1217">此事件数据必须包含 <see cref="E:System.Windows.ContentElement.LostFocus" /> 事件的标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1217">This event data must contain the identifier for the <see cref="E:System.Windows.ContentElement.LostFocus" /> event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1218">使用提供的事件数据引发 <see cref="E:System.Windows.ContentElement.LostFocus" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1218">Raises the <see cref="E:System.Windows.ContentElement.LostFocus" /> routed event by using the event data that is provided.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1219">此方法，虽然但虚拟的具有引发事件的默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1219">This method, although virtual, does have a default implementation that raises the event.</span></span>  
  
 <span data-ttu-id="e7c98-1220">这在 \* 方法实现用于引发事件，并且内部调用此方法的实现来引发事件时<xref:System.Windows.ContentElement.IsFocused%2A>属性值更改。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1220">This On\* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes.</span></span> <span data-ttu-id="e7c98-1221">此实现不同于其他某些[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]上 \* 实现，后者只提供了一种简便方式为该事件添加类处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1221">This implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] On\* implementations, which only provide a convenient way to add class handling for that event.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="e7c98-1222">除非有特意需求不引发焦点事件，请确保您的实现将调用基实现。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-1222">Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</span>
            </span>
            <span data-ttu-id="e7c98-1223">否则为<see cref="E:System.Windows.ContentElement.LostFocus" />在通常将焦点设置到此元素的典型用户操作期间不会引发事件。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-1223">Otherwise, the <see cref="E:System.Windows.ContentElement.LostFocus" /> event is not raised during typical user operations that ordinarily set focus to this element.</span>
            </span>
            <span data-ttu-id="e7c98-1224">如果不想使用您可获得焦点的元素，你可以通过将阻止元素<see cref="P:System.Windows.ContentElement.Focusable" />到<see langword="false" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="e7c98-1224">If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.ContentElement.Focusable" /> to <see langword="false" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1225">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1225">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1226">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1226">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1227">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1227">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1228">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1228">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1229">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1229">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1230">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1230">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1231">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1231">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1232">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1232">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1233">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1233">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1234">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1234">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1235">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1235">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1236">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1236">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1237">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1237">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1238">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1238">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1239">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1239">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1240">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1240">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1241">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1241">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1242">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1242">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1243">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1243">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1244">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1244">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1245">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1245">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1246">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1246">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1247">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1247">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1248">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1248">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1249">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1249">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1250">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1250">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1251">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1251">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1252">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1252">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1253">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1253">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1254">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1254">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1255">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1255">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1256">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1256">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1257">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1257">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1258">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1258">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1259">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1259">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1260">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1260">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1261">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1261">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1262">为在此元素失去触摸屏输入捕获时发生的 <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1262">Provides class handling for the <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> routed event that occurs when this element loses a touch capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1263"><xref:System.Windows.ContentElement.OnLostTouchCapture%2A>方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1263">The <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> method has no default implementation.</span></span> <span data-ttu-id="e7c98-1264">重写<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>在派生类来处理<xref:System.Windows.ContentElement.LostTouchCapture>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1264">Override <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> in a derived class to handle the <xref:System.Windows.ContentElement.LostTouchCapture> event.</span></span> <span data-ttu-id="e7c98-1265">一定要调用基类的<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>方法，从而基本类对事件进行接收。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1265">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1266">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1266">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="e7c98-1267">此事件数据报告有关按下鼠标按钮和已处理状态的详细信息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1267">This event data reports details about the mouse button that was pressed and the handled state.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1268">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1268">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1269">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1269">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1270">处理鼠标按钮操作也是通过一个专用的输入管理器。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1270">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="e7c98-1271">其他编程功能，依赖于鼠标按钮操作，例如输入和命令绑定，它公开作为常规鼠标按钮操作之前可能调用操作的处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1271">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="e7c98-1272">如果这些输入系统功能标记<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件为已处理，<xref:System.Windows.ContentElement.OnMouseDown%2A>不会被调用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1272">If these input system features mark the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnMouseDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="e7c98-1273">如果使用此类处理程序将该事件标记为已处理，则可能会影响以下事件：<xref:System.Windows.ContentElement.MouseLeftButtonDown>和<xref:System.Windows.ContentElement.MouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1273">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonDown> and <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="e7c98-1274">任一这些事件可能会在接收元素上引发时<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>收到。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1274">Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="e7c98-1275">如果你将标记为已处理的类中处理此事件，则仍会引发子事件;但是，它们将传递中的事件数据的处理的状态。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1275">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="e7c98-1276">如果在类处理中处理该事件，除非你显式将不会调用实例为子事件的处理程序<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>与`handledEventsToo``true`为了附加处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1276">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="e7c98-1277">类处理程序也不会调用除非这些类处理程序已注册到<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>具有签名`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1277">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="e7c98-1278">通过处理<xref:System.Windows.ContentElement.OnMouseDown%2A>，则意味着类处理负责按下操作的所有可能的鼠标按钮。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1278">By handling <xref:System.Windows.ContentElement.OnMouseDown%2A>, you are implying that your class handling accounted for all possible mouse button down actions.</span></span> <span data-ttu-id="e7c98-1279">此行为可能不需要;因此，此虚方法用于将事件标记为已处理时要小心。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1279">This behavior might be unwanted; therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="e7c98-1280">每个按钮特定直接事件也有一个虚拟 On \* 方法;请考虑是否重写这些按钮特定的类处理程序可能会更合适。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1280">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="e7c98-1281">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1281">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1282">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1282">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1283">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1283">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1284">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1284">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1285">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1285">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1286">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1286">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1287">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1287">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1288">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1288">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1289">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1289">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1290">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1290">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1291">当此元素引发未处理的 <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 附加事件时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1291">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> attached event is raised on this element.</span>
          </span>
          <span data-ttu-id="e7c98-1292">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1292">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1293">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1293">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1294">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1294">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="e7c98-1295">你可以调用基之前或之后你特殊的处理，具体取决于你的要求。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1295">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="e7c98-1296">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1296">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1297">在这种情况下匹配的事件是具有直接路由策略的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1297">In this case the matching event is a routed event, with a direct routing strategy.</span></span> <span data-ttu-id="e7c98-1298">将事件标记为已处理是仍可用于预防典型实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1298">Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1299">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1299">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1300">当此元素引发未处理的 <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 附加事件时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1300">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> attached event is raised on this element.</span>
          </span>
          <span data-ttu-id="e7c98-1301">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1301">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1302">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1302">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1303">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1303">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="e7c98-1304">你可以调用基之前或之后你特殊的处理，具体取决于你的要求。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1304">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="e7c98-1305">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1305">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1306">在这种情况下匹配的事件是具有直接路由策略的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1306">In this case the matching event is a routed event, with a direct routing strategy.</span></span> <span data-ttu-id="e7c98-1307">将事件标记为已处理是仍可用于预防典型实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1307">Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1308">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1308">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="e7c98-1309">事件数据报告称已按下鼠标左键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1309">The event data reports that the left mouse button was pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1310">当此元素引发未处理的 <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> 路由事件时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1310">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> routed event is raised on this element.</span>
          </span>
          <span data-ttu-id="e7c98-1311">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1311">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1312"><xref:System.Windows.ContentElement.MouseLeftButtonDown>事件看起来进行冒泡路由，但实际上是以的间接方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1312">The <xref:System.Windows.ContentElement.MouseLeftButtonDown> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="e7c98-1313"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 是基础是气泡，路由的事件和每个<xref:System.Windows.ContentElement>沿着事件路由将使用相同的处理对引发直接路由的事件<xref:System.Windows.ContentElement.MouseLeftButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1313"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="e7c98-1314">尽管您可以将标记<xref:System.Windows.ContentElement.MouseLeftButtonDown>为用于此元素的已处理的事件，已处理的状态不保留的其他元素为由事件路由。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1314">Although you can mark the <xref:System.Windows.ContentElement.MouseLeftButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="e7c98-1315">但是，你可能想要将事件标记为已处理为了防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1315">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="e7c98-1316">常规鼠标事件处理中的默认实现<xref:System.Windows.ContentElement>侦听<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>和将其转换为相应的本地事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1316">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="e7c98-1317">如果你想要重写此逻辑，必须创建一个派生的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1317">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="e7c98-1318">在派生类的静态构造函数中注册的替代类处理程序<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1318">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e7c98-1319">无法更改鼠标处理行为<xref:System.Windows.ContentElement>通过重写<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1319">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="e7c98-1320">或者，可以以更改处理特定鼠标状态的事件来重写此方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1320">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="e7c98-1321">你是否选择调用基实现取决于你的方案。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1321">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="e7c98-1322">无法调用基禁用基实现，也应调用该鼠标事件的默认输入的处理<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1322">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span></span> <span data-ttu-id="e7c98-1323">例如，你可以从派生<xref:System.Windows.Controls.Button>，并重写<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>在派生类而不会调用基实现中; 但是，此重写禁用<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1323">For example, you can derive from <xref:System.Windows.Controls.Button> and override <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> in your derived class without calling the base implementation; however, this override disables the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1324">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1324">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="e7c98-1325">事件数据报告称已松开鼠标左键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1325">The event data reports that the left mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1326">当某个未处理的 <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1326">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1327">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1327">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1328"><xref:System.Windows.ContentElement.MouseLeftButtonUp>事件看起来进行冒泡路由，但实际上是以的间接方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1328">The <xref:System.Windows.ContentElement.MouseLeftButtonUp> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="e7c98-1329"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 是基础是气泡，路由的事件和每个<xref:System.Windows.ContentElement>沿着事件路由将使用相同的处理对引发直接路由的事件<xref:System.Windows.ContentElement.MouseLeftButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1329"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="e7c98-1330">尽管您可以将标记<xref:System.Windows.ContentElement.MouseLeftButtonUp>为用于此元素的已处理的事件，已处理的状态不保留的其他元素为由事件路由。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1330">Although you can mark the <xref:System.Windows.ContentElement.MouseLeftButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="e7c98-1331">但是，你可能想要将事件标记为已处理为了防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1331">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="e7c98-1332">常规鼠标事件处理中的默认实现<xref:System.Windows.ContentElement>侦听<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>和将其转换为相应的本地事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1332">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="e7c98-1333">如果你想要重写此逻辑，必须创建一个派生的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1333">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="e7c98-1334">在派生类的静态构造函数中注册的替代类处理程序<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1334">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e7c98-1335">无法更改鼠标处理行为<xref:System.Windows.ContentElement>通过重写<xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1335">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1336">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1336">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1337">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1337">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1338">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1338">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1339">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1339">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1340">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1340">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1341">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1341">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1342">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1342">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1343">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1343">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1344">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1344">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1345">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1345">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1346">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1346">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1347">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1347">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1348">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1348">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="e7c98-1349">事件数据报告称已按下鼠标右键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1349">The event data reports that the right mouse button was pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1350">当某个未处理的 <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1350">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1351">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1351">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1352"><xref:System.Windows.ContentElement.MouseRightButtonDown>事件看起来进行冒泡路由，但实际上是以的间接方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1352">The <xref:System.Windows.ContentElement.MouseRightButtonDown> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="e7c98-1353"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 是基础是气泡，路由的事件和每个<xref:System.Windows.ContentElement>沿着事件路由将使用相同的处理对引发直接路由的事件<xref:System.Windows.ContentElement.MouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1353"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="e7c98-1354">尽管您可以将标记<xref:System.Windows.ContentElement.MouseRightButtonDown>为用于此元素的已处理的事件，已处理的状态不保留的其他元素为由事件路由。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1354">Although you can mark the <xref:System.Windows.ContentElement.MouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="e7c98-1355">但是，你可能想要将事件标记为已处理为了防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1355">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="e7c98-1356">常规鼠标事件处理中的默认实现<xref:System.Windows.ContentElement>侦听<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>和将其转换为相应的本地事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1356">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="e7c98-1357">如果你想要重写此逻辑，必须创建一个派生的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1357">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="e7c98-1358">在派生类的静态构造函数中注册的替代类处理程序<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1358">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e7c98-1359">无法更改鼠标处理行为<xref:System.Windows.ContentElement>通过重写<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1359">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="e7c98-1360">或者，可以以更改处理特定鼠标状态的事件来重写此方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1360">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="e7c98-1361">你是否选择调用基实现取决于你的方案。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1361">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="e7c98-1362">无法调用基禁用基实现，也应调用该鼠标事件的默认输入的处理<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1362">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span></span> <span data-ttu-id="e7c98-1363">例如，你可以从派生<xref:System.Windows.Controls.Control>，并重写<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>但是，而无需调用基实现; 在派生类中此替代禁用上下文菜单上的服务控件，都是一部分的<xref:System.Windows.Controls.Control>默认行为。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1363">For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1364">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1364">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="e7c98-1365">事件数据报告称已释放鼠标右键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1365">The event data reports that the right mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1366">当某个未处理的 <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1366">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1367">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1367">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1368"><xref:System.Windows.ContentElement.MouseRightButtonUp>事件看起来进行冒泡路由，但实际上是以的间接方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1368">The <xref:System.Windows.ContentElement.MouseRightButtonUp> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="e7c98-1369"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 是基础是气泡，路由的事件和每个<xref:System.Windows.ContentElement>沿着事件路由将使用相同的处理对引发直接路由的事件<xref:System.Windows.ContentElement.MouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1369"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="e7c98-1370">尽管您可以将标记<xref:System.Windows.ContentElement.MouseRightButtonUp>为用于此元素的已处理的事件，已处理的状态不保留的其他元素为由事件路由。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1370">Although you can mark the <xref:System.Windows.ContentElement.MouseRightButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="e7c98-1371">但是，你可能想要将事件标记为已处理为了防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1371">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="e7c98-1372">常规鼠标事件处理中的默认实现<xref:System.Windows.ContentElement>侦听<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>和将其转换为相应的本地事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1372">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="e7c98-1373">如果你想要重写此逻辑，必须创建一个派生的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1373">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="e7c98-1374">在派生类的静态构造函数中注册的替代类处理程序<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1374">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e7c98-1375">无法更改鼠标处理行为<xref:System.Windows.ContentElement>通过重写<xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1375">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1376">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1376">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="e7c98-1377">事件数据将报告已松开了鼠标按钮。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1377">The event data reports that the mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1378">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1378">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1379">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1379">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1380">处理鼠标按钮操作也是通过一个专用的输入管理器。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1380">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="e7c98-1381">其他编程功能，依赖于鼠标按钮操作，例如输入和命令绑定，它公开作为常规鼠标按钮操作之前可能调用操作的处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1381">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="e7c98-1382">如果这些输入系统功能标记<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件为已处理，<xref:System.Windows.ContentElement.OnMouseUp%2A>不会被调用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1382">If these input system features mark the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnMouseUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="e7c98-1383">如果使用此类处理程序将该事件标记为已处理，则可能会影响以下事件：<xref:System.Windows.ContentElement.MouseLeftButtonUp>和<xref:System.Windows.ContentElement.MouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1383">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonUp> and <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="e7c98-1384">上述任一事件，可能会引发接收元素上时<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>收到。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1384">Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="e7c98-1385">如果你将标记为已处理的类中处理此事件，则仍会引发子事件;但是，它们将传递中的事件数据的处理的状态。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1385">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="e7c98-1386">如果在类处理中处理该事件，除非你显式将不会调用实例为子事件的处理程序<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>与`handledEventsToo``true`为了附加处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1386">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="e7c98-1387">类处理程序也不会调用除非这些类处理程序已注册到<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>具有签名`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1387">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="e7c98-1388">通过处理<xref:System.Windows.ContentElement.OnMouseUp%2A>，则意味着，在类处理说明进行操作的所有可能的鼠标按钮。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1388">By handling <xref:System.Windows.ContentElement.OnMouseUp%2A>, you are implying that your class handling accounted for all possible mouse button up actions.</span></span> <span data-ttu-id="e7c98-1389">此行为可能不需要;因此，此虚方法用于将事件标记为已处理时要小心。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1389">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="e7c98-1390">每个按钮特定直接事件也有一个虚拟 On \* 方法;请考虑是否重写这些按钮特定的类处理程序可能会更合适。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1390">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="e7c98-1391">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1391">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1392">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1392">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1393">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1393">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1394">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1394">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1395">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1395">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1396">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1396">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1397">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1397">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1398">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1398">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1399">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1399">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1400">包含事件数据的 <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1400">The <see cref="T:System.Windows.Input.MouseWheelEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1401">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1401">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1402">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1402">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1403">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1403">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1404">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1404">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1405">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1405">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1406">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1406">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1407">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1407">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1408">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1408">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1409">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1409">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1410">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1410">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1411">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1411">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1412">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1412">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1413">当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1413">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1414">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1414">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1415">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1415">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1416">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1416">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1417">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1417">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1418">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1418">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1419">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1419">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1420">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1420">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1421">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1421">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1422">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1422">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1423">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1423">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1424">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1424">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1425">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1425">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1426">当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1426">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1427">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1427">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1428">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1428">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1429">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1429">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1430">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1430">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1431">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1431">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1432">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1432">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1433">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1433">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1434">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1434">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1435">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1435">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1436">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1436">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1437">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1437">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1438">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1438">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1439">当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1439">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1440">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1440">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1441">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1441">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1442">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1442">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1443">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1443">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1444">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1444">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1445">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1445">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1446">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1446">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1447">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1447">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1448">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1448">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1449">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1449">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1450">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1450">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1451">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1451">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1452">当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDrop" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1452">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDrop" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1453">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1453">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1454">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1454">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1455">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1455">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1456">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1456">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1457">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1457">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1458">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1458">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1459">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1459">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1460">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1460">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1461">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1461">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1462">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1462">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1463">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1463">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1464">包含事件数据的 <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1464">The <see cref="T:System.Windows.GiveFeedbackEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1465">当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1465">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1466">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1466">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1467">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1467">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1468">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1468">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1469">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1469">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1470">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1470">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1471">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1471">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1472">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1472">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1473">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1473">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1474">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1474">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1475">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1475">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1476">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1476">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1477">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1477">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1478">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1478">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1479">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1479">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1480">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1480">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1481">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1481">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1482">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1482">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1483">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1483">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1484">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1484">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1485">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1485">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1486">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1486">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1487">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1487">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1488">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1488">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1489">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1489">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1490">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1490">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1491">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1491">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1492">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1492">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1493">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1493">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1494">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1494">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1495">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1495">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1496">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1496">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1497">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1497">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1498">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1498">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1499">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1499">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1500">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1500">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1501">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1501">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1502">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1502">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1503">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1503">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1504">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1504">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1505">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1505">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1506">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1506">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1507">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1507">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1508">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1508">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1509">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1509">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1510">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1510">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1511">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1511">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1512">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1512">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1513">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1513">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1514">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1514">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1515">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1515">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1516">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1516">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1517">当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1517">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1518">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1518">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1519">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1519">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1520">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1520">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1521">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1521">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1522">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1522">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1523">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1523">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1524">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1524">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1525">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1525">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1526">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1526">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1527">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1527">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1528">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1528">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1529">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1529">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="e7c98-1530">事件数据报告称已按下一个或多个鼠标按钮。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1530">The event data reports that one or more mouse buttons were pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1531">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 附加路由事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1531">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> attached routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1532">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1532">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1533">处理鼠标按钮操作也是通过一个专用的输入管理器。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1533">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="e7c98-1534">其他编程功能，依赖于鼠标按钮操作，例如输入和命令绑定，它公开作为常规鼠标按钮操作之前可能调用操作的处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1534">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="e7c98-1535">如果这些输入系统功能标记<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件为已处理，<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>不会被调用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1535">If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="e7c98-1536">如果使用此类处理程序将该事件标记为已处理，则可能会影响以下事件：<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>和<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1536">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span></span> <span data-ttu-id="e7c98-1537">任一这些事件可能会在接收元素上引发时<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>收到。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1537">Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="e7c98-1538">如果你将标记为已处理的类中处理此事件，则仍会引发子事件;但是，它们将传递中的事件数据的处理的状态。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1538">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="e7c98-1539">如果在类处理中处理该事件，除非你显式将不会调用实例为子事件的处理程序<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>与`handledEventsToo``true`为了附加处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1539">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="e7c98-1540">类处理程序也不会调用除非这些类处理程序已注册到<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>具有签名`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1540">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="e7c98-1541">通过处理<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>，则意味着类处理负责按下操作的所有可能的鼠标按钮。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1541">By handling <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>, you are implying that your class handling accounted for all possible mouse button down actions.</span></span> <span data-ttu-id="e7c98-1542">此行为可能不需要;因此，此虚方法用于将事件标记为已处理时要小心。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1542">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="e7c98-1543">每个按钮特定直接事件也有一个虚拟 On \* 方法;请考虑是否重写这些按钮特定的类处理程序可能会更合适。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1543">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="e7c98-1544">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1544">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1545">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1545">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1546">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1546">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1547">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1547">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1548">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1548">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1549">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1549">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1550">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1550">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1551">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1551">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1552">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1552">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1553">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1553">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1554">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1554">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="e7c98-1555">事件数据报告称已按下鼠标左键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1555">The event data reports that the left mouse button was pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1556">当某个未处理的 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1556">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1557">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1557">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1558"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>事件看起来进行隧道路由，但实际上是以的间接方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1558">The <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="e7c98-1559"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 是为隧道路由，并且每个基础事件<xref:System.Windows.ContentElement>沿着事件路由将使用相同的处理对引发直接路由的事件<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1559"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>.</span></span> <span data-ttu-id="e7c98-1560">尽管您可以将标记<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>为用于此元素的已处理的事件，已处理的状态不保留的其他元素为由事件路由。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1560">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="e7c98-1561">但是，你可能想要将事件标记为已处理为了防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1561">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="e7c98-1562">常规鼠标事件处理中的默认实现<xref:System.Windows.ContentElement>侦听<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>和将其转换为相应的本地事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1562">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="e7c98-1563">如果你想要重写此逻辑，必须创建一个派生的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1563">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="e7c98-1564">在派生类的静态构造函数中注册的替代类处理程序<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1564">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e7c98-1565">无法更改鼠标处理行为<xref:System.Windows.ContentElement>通过重写<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1565">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="e7c98-1566">或者，可以以更改处理特定鼠标状态的事件来重写此方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1566">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="e7c98-1567">你是否选择调用基实现取决于你的方案。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1567">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="e7c98-1568">无法调用基禁用基实现，也应调用该鼠标事件的默认输入的处理<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1568">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span></span> <span data-ttu-id="e7c98-1569">例如，你可以从派生<xref:System.Windows.Controls.Button>，并重写<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>在派生类而不会调用基实现中; 但是，此重写禁用<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1569">For example, you can derive from <xref:System.Windows.Controls.Button> and override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> in your derived class without calling the base implementation; however, this override disables the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1570">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1570">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="e7c98-1571">事件数据报告称已松开鼠标左键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1571">The event data reports that the left mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1572">当某个未处理的 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1572">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1573">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1573">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1574"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>事件看起来进行隧道路由，但实际上是以的间接方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1574">The <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="e7c98-1575"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 是为隧道路由，并且每个基础事件<xref:System.Windows.ContentElement>沿着事件路由将使用相同的处理对引发直接路由的事件<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1575"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>.</span></span> <span data-ttu-id="e7c98-1576">尽管您可以将标记<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>为用于此元素的已处理的事件，已处理的状态不保留的其他元素为由事件路由。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1576">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="e7c98-1577">但是，你可能想要将事件标记为已处理为了防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1577">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="e7c98-1578">常规鼠标事件处理中的默认实现<xref:System.Windows.ContentElement>侦听<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>和将其转换为相应的本地事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1578">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="e7c98-1579">如果你想要重写此逻辑，必须创建一个派生的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1579">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="e7c98-1580">在派生类的静态构造函数中注册的替代类处理程序<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1580">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e7c98-1581">无法更改鼠标处理行为<xref:System.Windows.ContentElement>通过重写<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1581">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1582">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1582">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1583">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1583">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1584">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1584">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1585">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1585">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1586">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1586">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1587">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1587">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1588">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1588">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1589">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1589">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1590">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1590">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1591">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1591">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1592">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1592">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1593">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1593">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1594">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1594">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1595">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1595">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="e7c98-1596">事件数据报告称已按下鼠标右键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1596">The event data reports that the right mouse button was pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1597">当某个未处理的 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1597">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1598">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1598">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1599"><xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>事件看起来进行隧道路由，但实际上是以的间接方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1599">The <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="e7c98-1600"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 是为隧道路由，并且每个基础事件<xref:System.Windows.ContentElement>沿着事件路由将使用相同的处理对引发直接路由的事件<xref:System.Windows.ContentElement.MouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1600"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="e7c98-1601">尽管您可以将标记<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>为用于此元素的已处理的事件，已处理的状态不保留的其他元素为由事件路由。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1601">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="e7c98-1602">但是，你可能想要将事件标记为已处理为了防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1602">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="e7c98-1603">常规鼠标事件处理中的默认实现<xref:System.Windows.ContentElement>侦听<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>和将其转换为相应的本地事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1603">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="e7c98-1604">如果你想要重写此逻辑，必须创建一个派生的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1604">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="e7c98-1605">在派生类的静态构造函数中注册的替代类处理程序<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1605">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e7c98-1606">无法更改鼠标处理行为<xref:System.Windows.ContentElement>通过重写<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1606">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="e7c98-1607">或者，可以以更改处理特定鼠标状态的事件来重写此方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1607">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="e7c98-1608">你是否选择调用基实现取决于你的方案。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1608">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="e7c98-1609">无法调用基禁用基实现，也应调用该鼠标事件的默认输入的处理<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1609">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span></span> <span data-ttu-id="e7c98-1610">例如，你可以从派生<xref:System.Windows.Controls.Control>，并重写<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>但是，而无需调用基实现; 在派生类中此替代禁用上下文菜单上的服务控件，都是一部分的<xref:System.Windows.Controls.Control>默认行为。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1610">For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1611">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1611">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="e7c98-1612">事件数据报告称已释放鼠标右键。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1612">The event data reports that the right mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1613">当某个未处理的 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1613">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1614">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1614">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1615"><xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>事件看起来进行隧道路由，但实际上是以的间接方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1615">The <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="e7c98-1616"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 是为隧道路由，并且每个基础事件<xref:System.Windows.ContentElement>沿着事件路由将使用相同的处理对引发直接路由的事件<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1616"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="e7c98-1617">尽管您可以将标记<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>为用于此元素的已处理的事件，已处理的状态不保留的其他元素为由事件路由。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1617">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="e7c98-1618">但是，你可能想要将事件标记为已处理为了防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1618">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="e7c98-1619">常规鼠标事件处理中的默认实现<xref:System.Windows.ContentElement>侦听<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>和将其转换为相应的本地事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1619">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="e7c98-1620">如果你想要重写此逻辑，必须创建一个派生的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1620">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="e7c98-1621">在派生类的静态构造函数中注册的替代类处理程序<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1621">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e7c98-1622">无法更改鼠标处理行为<xref:System.Windows.ContentElement>通过重写<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1622">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1623">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1623">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="e7c98-1624">事件数据将报告已释放了一个或多个鼠标按钮。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1624">The event data reports that one or more mouse buttons were released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1625">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1625">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1626">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1626">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1627">处理鼠标按钮操作也是通过一个专用的输入管理器。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1627">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="e7c98-1628">其他编程功能，依赖于鼠标按钮操作，例如输入和命令绑定，它公开作为常规鼠标按钮操作之前可能调用操作的处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1628">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="e7c98-1629">如果这些输入系统功能标记<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件为已处理，<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>不会被调用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1629">If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="e7c98-1630">如果使用此类处理程序将该事件标记为已处理，则可能会影响以下事件：<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>和<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1630">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="e7c98-1631">上述任一事件，可能会引发接收元素上时<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>收到。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1631">Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="e7c98-1632">如果你将标记为已处理的类中处理此事件，则仍会引发子事件;但是，它们将传递中的事件数据的处理的状态。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1632">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="e7c98-1633">如果在类处理中处理该事件，除非你显式将不会调用实例为子事件的处理程序<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>与`handledEventsToo``true`为了附加处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1633">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="e7c98-1634">类处理程序也不会调用除非这些类处理程序已注册到<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>具有签名`handledEventsToo` `true`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1634">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="e7c98-1635">通过处理<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>，则意味着，在类处理说明进行操作的所有可能的鼠标按钮。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1635">By handling <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>, you are implying that your class handling accounted for all possible mouse button up actions.</span></span> <span data-ttu-id="e7c98-1636">此行为可能不需要;因此，此虚方法用于将事件标记为已处理时要小心。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1636">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="e7c98-1637">每个按钮特定直接事件也有一个虚拟 On \* 方法;请考虑是否重写这些按钮特定的类处理程序可能会更合适。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1637">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="e7c98-1638">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1638">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1639">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1639">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1640">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1640">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1641">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1641">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1642">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1642">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1643">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1643">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1644">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1644">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1645">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1645">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1646">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1646">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1647">包含事件数据的 <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1647">The <see cref="T:System.Windows.Input.MouseWheelEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1648">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1648">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1649">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1649">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1650">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1650">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1651">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1651">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1652">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1652">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1653">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1653">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1654">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1654">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1655">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1655">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1656">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1656">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1657">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1657">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1658">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1658">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1659">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1659">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1660">包含事件数据的 <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1660">The <see cref="T:System.Windows.QueryContinueDragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1661">当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1661">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1662">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1662">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1663">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1663">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1664">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1664">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1665">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1665">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1666">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1666">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1667">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1667">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1668">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1668">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1669">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1669">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1670">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1670">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1671">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1671">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1672">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1672">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1673">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1673">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1674">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1674">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1675">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1675">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1676">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1676">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1677">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1677">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1678">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1678">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1679">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1679">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1680">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1680">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1681">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1681">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1682">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1682">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1683">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1683">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1684">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1684">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1685">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1685">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1686">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1686">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1687">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1687">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1688">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1688">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1689">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1689">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1690">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1690">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1691">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1691">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1692">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1692">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1693">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1693">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1694">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1694">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1695">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1695">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1696">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1696">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1697">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1697">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1698">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1698">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1699">包含事件数据的 <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1699">The <see cref="T:System.Windows.Input.StylusDownEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1700">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1700">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1701">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1701">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1702">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1702">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1703">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1703">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1704">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1704">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1705">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1705">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1706">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1706">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1707">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1707">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1708">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1708">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1709">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1709">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1710">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1710">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1711">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1711">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1712">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1712">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1713">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1713">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1714">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1714">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1715">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1715">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1716">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1716">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1717">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1717">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1718">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1718">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1719">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1719">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1720">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1720">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1721">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1721">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1722">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1722">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1723">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1723">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1724">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1724">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1725">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1725">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1726">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1726">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1727">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1727">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1728">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1728">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1729">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1729">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1730">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1730">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1731">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1731">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1732">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1732">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1733">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1733">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1734">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1734">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1735">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1735">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1736">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1736">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1737">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1737">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1738">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1738">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1739">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1739">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1740">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1740">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1741">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1741">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1742">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1742">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1743">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1743">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1744">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1744">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1745">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1745">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1746">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1746">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1747">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1747">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1748">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1748">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1749">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1749">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1750">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1750">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1751">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1751">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1752">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1752">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1753">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1753">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1754">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1754">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1755">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1755">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1756">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1756">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1757">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1757">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1758">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1758">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1759">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1759">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1760">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1760">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1761">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1761">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1762">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1762">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1763">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1763">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1764">包含事件数据的 <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1764">The <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1765">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1765">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1766">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1766">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1767">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1767">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1768">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1768">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1769">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1769">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1770">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1770">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1771">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1771">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1772">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1772">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1773">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1773">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1774">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1774">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1775">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1775">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1776">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1776">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1777">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1777">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1778">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1778">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1779">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1779">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1780">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1780">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1781">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1781">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1782">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1782">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1783">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1783">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1784">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1784">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1785">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1785">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1786">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1786">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1787">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1787">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1788">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1788">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1789">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1789">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1790">包含事件数据的 <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1790">The <see cref="T:System.Windows.Input.TextCompositionEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1791">当某个未处理的 <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1791">Invoked when an unhandled <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1792">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1792">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1793">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1793">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1794">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1794">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1795">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1795">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1796">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1796">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1797">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1797">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1798">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1798">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1799">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1799">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1800">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1800">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1801">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1801">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="e7c98-1802">另一个专用于预览事件的情况是将已处理，以便匹配冒泡类处理程序不会调用其标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1802">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
        <altmember cref="E:System.Windows.ContentElement.PreviewTextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1803">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1803">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1804">为在触摸屏输入按下此元素时发生的 <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1804">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> routed event that occurs when a touch presses this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1805"><xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1805">The <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> method has no default implementation.</span></span> <span data-ttu-id="e7c98-1806">重写<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>在派生类来处理<xref:System.Windows.ContentElement.PreviewTouchDown>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1806">Override <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchDown> event.</span></span> <span data-ttu-id="e7c98-1807">一定要调用基类的<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>方法，从而基本类对事件进行接收。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1807">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1808">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1808">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1809">为在此元素内部移动触摸屏输入时发生的 <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1809">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> routed event that occurs when a touch moves while inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1810"><xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1810">The <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> method has no default implementation.</span></span> <span data-ttu-id="e7c98-1811">重写<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>在派生类来处理<xref:System.Windows.ContentElement.PreviewTouchMove>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1811">Override <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchMove> event.</span></span> <span data-ttu-id="e7c98-1812">一定要调用基类的<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>方法，从而基本类对事件进行接收。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1812">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1813">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1813">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1814">为在此元素内部释放触摸屏输入时发生的 <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1814">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> routed event that occurs when a touch is released inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1815"><xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1815">The <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> method has no default implementation.</span></span> <span data-ttu-id="e7c98-1816">重写<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>在派生类来处理<xref:System.Windows.ContentElement.PreviewTouchUp>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1816">Override <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchUp> event.</span></span> <span data-ttu-id="e7c98-1817">一定要调用基类的<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>方法，从而基本类对事件进行接收。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1817">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1818">包含事件数据的 <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1818">The <see cref="T:System.Windows.QueryContinueDragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1819">当某个未处理的 <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1819">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1820">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1820">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1821">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1821">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1822">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1822">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1823">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1823">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1824">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1824">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1825">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1825">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1826">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1826">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1827">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1827">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1828">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1828">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1829">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1829">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryCursor (e As QueryCursorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryCursor(System::Windows::Input::QueryCursorEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1830">包含事件数据的 <see cref="T:System.Windows.Input.QueryCursorEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1830">The <see cref="T:System.Windows.Input.QueryCursorEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1831">当某个未处理的 <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1831">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1832">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1832">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1833">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1833">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1834">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1834">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1835">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1835">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1836">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1836">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1837">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1837">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1838">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1838">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1839">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1839">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1840">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1840">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1841">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1841">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1842">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1842">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1843">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1843">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1844">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1844">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1845">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1845">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1846">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1846">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1847">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1847">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1848">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1848">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1849">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1849">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1850">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1850">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1851">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1851">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1852">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1852">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1853">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1853">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1854">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1854">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1855">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1855">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1856">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1856">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1857">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1857">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1858">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1858">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1859">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1859">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1860">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1860">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1861">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1861">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1862">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1862">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1863">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1863">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1864">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1864">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1865">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1865">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1866">包含事件数据的 <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1866">The <see cref="T:System.Windows.Input.StylusDownEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1867">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1867">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1868">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1868">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1869">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1869">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1870">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1870">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1871">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1871">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1872">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1872">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1873">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1873">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1874">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1874">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1875">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1875">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1876">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1876">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1877">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1877">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusEnter (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusEnter(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1878">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1878">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1879">当此元素引发未处理的 <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> 附加事件时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1879">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> attached event is raised by this element.</span>
          </span>
          <span data-ttu-id="e7c98-1880">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1880">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1881">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1881">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1882">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1882">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="e7c98-1883">你可以调用基之前或之后你特殊的处理，具体取决于你的要求。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1883">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="e7c98-1884">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1884">The purpose of this method is similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1885">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1885">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1886">将事件标记为已处理是仍可用于预防典型实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1886">Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1887">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1887">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1888">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1888">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1889">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1889">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1890">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1890">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1891">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1891">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1892">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1892">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1893">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1893">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1894">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1894">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1895">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1895">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1896">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1896">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1897">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1897">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1898">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1898">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1899">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1899">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1900">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1900">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1901">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1901">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1902">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1902">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1903">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1903">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1904">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1904">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1905">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1905">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1906">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1906">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1907">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1907">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1908">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1908">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1909">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1909">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1910">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1910">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusLeave (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusLeave(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1911">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1911">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1912">当此元素引发未处理的 <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> 附加事件时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1912">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> attached event is raised by this element.</span>
          </span>
          <span data-ttu-id="e7c98-1913">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1913">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1914">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1914">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1915">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1915">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="e7c98-1916">你可以调用基之前或之后你特殊的处理，具体取决于你的要求。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1916">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="e7c98-1917">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1917">The purpose of this method is similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1918">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1918">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1919">将事件标记为已处理是仍可用于预防典型实例处理程序 (未指定的那些`handledEventsToo`) 调用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1919">Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1920">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1920">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1921">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1921">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1922">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1922">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1923">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1923">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1924">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1924">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1925">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1925">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1926">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1926">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1927">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1927">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1928">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1928">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1929">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1929">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1930">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1930">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1931">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1931">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1932">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1932">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1933">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1933">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1934">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1934">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1935">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1935">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1936">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1936">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1937">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1937">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1938">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1938">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1939">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1939">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1940">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1940">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1941">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1941">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1942">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1942">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1943">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1943">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1944">包含事件数据的 <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1944">The <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1945">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1945">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1946">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1946">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1947">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1947">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1948">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1948">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1949">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1949">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1950">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1950">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1951">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1951">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1952">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1952">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1953">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1953">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1954">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1954">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1955">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1955">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1956">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1956">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1957">当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1957">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1958">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1958">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1959">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1959">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1960">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1960">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1961">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1961">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1962">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1962">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1963">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1963">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1964">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1964">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1965">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1965">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1966">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1966">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1967">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1967">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1968">包含事件数据的 <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1968">The <see cref="T:System.Windows.Input.TextCompositionEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1969">当某个未处理的 <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> 附加事件在其路由中到达派生自此类的某个元素时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1969">Invoked when an unhandled <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="e7c98-1970">实现此方法可为此事件添加类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1970">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1971">此方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1971">This method has no default implementation.</span></span> <span data-ttu-id="e7c98-1972">由于继承的中间类可能会实现此方法，我们建议在实现中调用基实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1972">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="e7c98-1973">此方法的目的是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]上的事件模式 \* 方法： 此方法提供了一种通过建立类处理程序而不是一个实例处理程序来处理来自派生类匹配的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1973">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="e7c98-1974">在这种情况下匹配的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1974">In this case the matching event is a routed event.</span></span> <span data-ttu-id="e7c98-1975">On \* 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定的元素，将会调用处理程序引发路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1975">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="e7c98-1976">因此，您的实现需要检查的事件数据的源属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1976">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="e7c98-1977">它不应尝试再次引发该事件在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1977">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="e7c98-1978">通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.ContentElement>为由事件路由收到事件时，可以调用私有类处理程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1978">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="e7c98-1979">一个类处理适合的方案是处理的事件数据并将路由的事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1979">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.TextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1980">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1980">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1981">为在此元素内按下触摸屏输入时发生的 <see cref="E:System.Windows.ContentElement.TouchDown" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1981">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchDown" /> routed event that occurs when a touch presses inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1982"><xref:System.Windows.ContentElement.OnTouchDown%2A>方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1982">The <xref:System.Windows.ContentElement.OnTouchDown%2A> method has no default implementation.</span></span> <span data-ttu-id="e7c98-1983">重写<xref:System.Windows.ContentElement.OnTouchDown%2A>在派生类来处理<xref:System.Windows.ContentElement.TouchDown>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1983">Override <xref:System.Windows.ContentElement.OnTouchDown%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchDown> event.</span></span> <span data-ttu-id="e7c98-1984">一定要调用基类的<xref:System.Windows.ContentElement.OnTouchDown%2A>方法，从而基本类对事件进行接收。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1984">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchDown%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchEnter (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchEnter(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1985">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1985">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1986">为在触摸屏输入从此元素边界外部移动到其内部时发生的 <see cref="E:System.Windows.ContentElement.TouchEnter" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1986">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchEnter" /> routed event that occurs when a touch moves from outside to inside the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1987"><xref:System.Windows.ContentElement.OnTouchEnter%2A>方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1987">The <xref:System.Windows.ContentElement.OnTouchEnter%2A> method has no default implementation.</span></span> <span data-ttu-id="e7c98-1988">重写<xref:System.Windows.ContentElement.OnTouchEnter%2A>在派生类来处理<xref:System.Windows.ContentElement.TouchEnter>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1988">Override <xref:System.Windows.ContentElement.OnTouchEnter%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchEnter> event.</span></span> <span data-ttu-id="e7c98-1989">一定要调用基类的<xref:System.Windows.ContentElement.OnTouchEnter%2A>方法，从而基本类对事件进行接收。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1989">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchEnter%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchLeave (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchLeave(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1990">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1990">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1991">为在触摸屏输入从此元素边界内部移动到其外部时发生的 <see cref="E:System.Windows.ContentElement.TouchLeave" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1991">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchLeave" /> routed event that occurs when a touch moves from inside to outside the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1992"><xref:System.Windows.ContentElement.OnTouchLeave%2A>方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1992">The <xref:System.Windows.ContentElement.OnTouchLeave%2A> method has no default implementation.</span></span> <span data-ttu-id="e7c98-1993">重写<xref:System.Windows.ContentElement.OnTouchLeave%2A>在派生类来处理<xref:System.Windows.ContentElement.TouchLeave>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1993">Override <xref:System.Windows.ContentElement.OnTouchLeave%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchLeave> event.</span></span> <span data-ttu-id="e7c98-1994">一定要调用基类的<xref:System.Windows.ContentElement.OnTouchLeave%2A>方法，从而基本类对事件进行接收。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1994">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchLeave%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-1995">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1995">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-1996">为在此元素内部移动触摸屏输入时发生的 <see cref="E:System.Windows.ContentElement.TouchMove" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-1996">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchMove" /> routed event that occurs when a touch moves while inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-1997"><xref:System.Windows.ContentElement.OnTouchMove%2A>方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1997">The <xref:System.Windows.ContentElement.OnTouchMove%2A> method has no default implementation.</span></span> <span data-ttu-id="e7c98-1998">重写<xref:System.Windows.ContentElement.OnTouchMove%2A>在派生类来处理<xref:System.Windows.ContentElement.TouchMove>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1998">Override <xref:System.Windows.ContentElement.OnTouchMove%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchMove> event.</span></span> <span data-ttu-id="e7c98-1999">一定要调用基类的<xref:System.Windows.ContentElement.OnTouchMove%2A>方法，从而基本类对事件进行接收。</span><span class="sxs-lookup"><span data-stu-id="e7c98-1999">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchMove%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-2000">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2000">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-2001">为在此元素内部释放触摸屏输入时发生的 <see cref="E:System.Windows.ContentElement.TouchUp" /> 路由事件提供类处理。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2001">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchUp" /> routed event that occurs when a touch is released inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2002"><xref:System.Windows.ContentElement.OnTouchUp%2A>方法不具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2002">The <xref:System.Windows.ContentElement.OnTouchUp%2A> method has no default implementation.</span></span> <span data-ttu-id="e7c98-2003">重写<xref:System.Windows.ContentElement.OnTouchUp%2A>在派生类来处理<xref:System.Windows.ContentElement.TouchUp>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2003">Override <xref:System.Windows.ContentElement.OnTouchUp%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchUp> event.</span></span> <span data-ttu-id="e7c98-2004">一定要调用基类的<xref:System.Windows.ContentElement.OnTouchUp%2A>方法，从而基本类对事件进行接收。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2004">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchUp%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">
          <span data-ttu-id="e7c98-2005">请求的焦点遍历的方向。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2005">The direction of the requested focus traversal.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-2006">当在派生类中重写时，返回将按指定焦点遍历方向接收焦点的元素，而不用实际将焦点移至该元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2006">When overridden in a derived class, returns the element that would receive focus for a specified focus traversal direction, without actually moving focus to that element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e7c98-2007">如果实际调用了 <see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />，则为接收焦点的元素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2007">The element that would have received focus if <see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> were actually invoked.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2008">此方法在此类的默认实现是不完整且始终返回`null`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2008">The default implementation of this method in this class is incomplete and always returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2009">在输入系统报告出现以此元素为拖动目标的基础拖动事件时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2009">Occurs when the input system reports an underlying drag event with this element as the drag target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2010">此事件创建一个别名<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewDragEnter>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2010">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2011">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewDragEnter>事件附加到基础<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2011">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2012">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2012">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2013">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2013">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragEnterEvent>|  
|<span data-ttu-id="e7c98-2014">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2014">Routing strategy</span></span>|<span data-ttu-id="e7c98-2015">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2015">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2016">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2016">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="e7c98-2017">对应的冒泡事件<xref:System.Windows.ContentElement.DragEnter>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2017">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragEnter>.</span></span>  
  
-   <span data-ttu-id="e7c98-2018">重写<xref:System.Windows.ContentElement.OnPreviewDragEnter%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2018">Override <xref:System.Windows.ContentElement.OnPreviewDragEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2019">标识 <see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2019">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2020">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2020">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2021">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2021">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2022">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2022">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2023">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2023">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2024">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2024">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2025">在输入系统报告出现以此元素为拖动起点的基础拖动事件时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2025">Occurs when the input system reports an underlying drag event with this element as the drag origin.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2026">此事件创建一个别名<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewDragLeave>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2026">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2027">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewDragLeave>事件附加到基础<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2027">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2028">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2028">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2029">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2029">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragLeaveEvent>|  
|<span data-ttu-id="e7c98-2030">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2030">Routing strategy</span></span>|<span data-ttu-id="e7c98-2031">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2031">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2032">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2032">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="e7c98-2033">对应的冒泡事件<xref:System.Windows.ContentElement.DragLeave>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2033">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragLeave>.</span></span>  
  
-   <span data-ttu-id="e7c98-2034">重写<xref:System.Windows.ContentElement.OnPreviewDragLeave%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2034">Override <xref:System.Windows.ContentElement.OnPreviewDragLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2035">标识 <see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2035">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2036">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2036">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2037">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2037">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2038">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2038">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2039">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2039">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2040">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2040">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragOver;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2041">在输入系统报告出现以此元素为可能放置目标的基础拖动事件时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2041">Occurs when the input system reports an underlying drag event with this element as the potential drop target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2042">此事件创建一个别名<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewDragOver>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2042">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragOver> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2043">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewDragOver>事件附加到基础<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2043">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragOver> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2044">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2044">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2045">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2045">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragOverEvent>|  
|<span data-ttu-id="e7c98-2046">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2046">Routing strategy</span></span>|<span data-ttu-id="e7c98-2047">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2047">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2048">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2048">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="e7c98-2049">对应的冒泡事件<xref:System.Windows.ContentElement.DragOver>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2049">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragOver>.</span></span>  
  
-   <span data-ttu-id="e7c98-2050">重写<xref:System.Windows.ContentElement.OnPreviewDragOver%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2050">Override <xref:System.Windows.ContentElement.OnPreviewDragOver%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragOverEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2051">标识 <see cref="E:System.Windows.ContentElement.PreviewDragOver" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2051">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragOver" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2052">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2052">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2053">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2053">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2054">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2054">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2055">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2055">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2056">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2056">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDrop;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2057">在输入系统报告出现将此元素作为放置目标的基础放置事件时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2057">Occurs when the input system reports an underlying drop event with this element as the drop target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2058">此事件创建一个别名<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewDrop>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2058">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDrop> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2059">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewDrop>事件附加到基础<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2059">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDrop> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2060">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2060">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2061">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2061">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDropEvent>|  
|<span data-ttu-id="e7c98-2062">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2062">Routing strategy</span></span>|<span data-ttu-id="e7c98-2063">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2063">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2064">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2064">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="e7c98-2065">对应的冒泡事件<xref:System.Windows.ContentElement.Drop>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2065">The corresponding bubbling event is <xref:System.Windows.ContentElement.Drop>.</span></span>  
  
-   <span data-ttu-id="e7c98-2066">重写<xref:System.Windows.ContentElement.OnPreviewDrop%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2066">Override <xref:System.Windows.ContentElement.OnPreviewDrop%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDropEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2067">标识 <see cref="E:System.Windows.ContentElement.PreviewDrop" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2067">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDrop" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2068">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2068">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2069">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2069">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2070">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2070">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2071">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2071">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2072">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2072">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ PreviewGiveFeedback;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2073">在开始拖放操作时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2073">Occurs when a drag-and-drop operation is started.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2074"><xref:System.Windows.ContentElement.PreviewGiveFeedback>事件允许拖动事件，以修改鼠标指针的外观，以便为用户可视反馈提供拖放操作期间的源。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2074">The <xref:System.Windows.ContentElement.PreviewGiveFeedback> event enables the source of a drag event to modify the appearance of the mouse pointer, in order to give the user visual feedback during a drag-and-drop operation.</span></span>  
  
 <span data-ttu-id="e7c98-2075">此事件创建一个别名<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewGiveFeedback>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2075">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewGiveFeedback> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2076">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewGiveFeedback>事件附加到基础<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2076">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewGiveFeedback> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2077">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2077">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2078">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2078">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewGiveFeedbackEvent>|  
|<span data-ttu-id="e7c98-2079">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2079">Routing strategy</span></span>|<span data-ttu-id="e7c98-2080">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2080">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2081">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2081">Delegate</span></span>|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   <span data-ttu-id="e7c98-2082">对应的冒泡事件<xref:System.Windows.ContentElement.GiveFeedback>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2082">The corresponding bubbling event is <xref:System.Windows.ContentElement.GiveFeedback>.</span></span>  
  
-   <span data-ttu-id="e7c98-2083">重写<xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2083">Override <xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGiveFeedbackEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2084">标识 <see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2084">Identifies the <see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2085">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2085">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2086">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2086">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2087">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2087">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2088">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2088">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2089">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2089">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewGotKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewGotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2090">在此元素聚焦于键盘时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2090">Occurs when the keyboard is focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2091">由于此事件使用隧道路由，具有焦点的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2091">Because this event uses tunneling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="e7c98-2092">检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据以确定实际具有焦点的元素中。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2092">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has focus.</span></span>  
  
 <span data-ttu-id="e7c98-2093">此事件创建一个别名<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2093">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2094">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>事件附加到基础<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2094">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2095">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2095">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2096">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2096">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent>|  
|<span data-ttu-id="e7c98-2097">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2097">Routing strategy</span></span>|<span data-ttu-id="e7c98-2098">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2098">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2099">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2099">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="e7c98-2100">对应的冒泡事件<xref:System.Windows.ContentElement.GotKeyboardFocus>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2100">The corresponding bubbling event is <xref:System.Windows.ContentElement.GotKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="e7c98-2101">重写<xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2101">Override <xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGotKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2102">标识 <see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2102">Identifies the <see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2103">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2103">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2104">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2104">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2105">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2105">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2106">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2106">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2107">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2107">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2108">在此元素聚焦于键盘并且按下某个键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2108">Occurs when a key is pressed while the keyboard is focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2109">密钥处理与其他平台功能，例如发出命令和文本组合进行交互。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2109">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="e7c98-2110"><xref:System.Windows.ContentElement.KeyDown>事件是可能无法如期出现在某些控件上的较低级别文本输入的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2110">The <xref:System.Windows.ContentElement.KeyDown> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="e7c98-2111">这是文本的因为某些控件有控件组合或提供的更高级别的版本的类处理输入处理和相关事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2111">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span>  
  
 <span data-ttu-id="e7c98-2112">此事件创建一个别名<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewKeyDown>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2112">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewKeyDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2113">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewKeyDown>事件附加到基础<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2113">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewKeyDown> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2114">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2114">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2115">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2115">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewKeyDownEvent>|  
|<span data-ttu-id="e7c98-2116">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2116">Routing strategy</span></span>|<span data-ttu-id="e7c98-2117">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2117">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2118">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2118">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="e7c98-2119">对应的冒泡事件<xref:System.Windows.ContentElement.KeyDown>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2119">The corresponding bubbling event is <xref:System.Windows.ContentElement.KeyDown>.</span></span>  
  
-   <span data-ttu-id="e7c98-2120">重写<xref:System.Windows.ContentElement.OnPreviewKeyDown%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2120">Override <xref:System.Windows.ContentElement.OnPreviewKeyDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2121">标识 <see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2121">Identifies the <see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2122">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2122">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2123">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2123">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2124">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2124">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2125">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2125">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2126">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2126">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2127">在此元素聚焦于键盘并且松开某个键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2127">Occurs when a key is released while the keyboard is focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2128">密钥处理与其他平台功能，例如发出命令和文本组合进行交互。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2128">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="e7c98-2129"><xref:System.Windows.ContentElement.KeyUp>事件是可能无法如期出现在某些控件上的较低级别文本输入的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2129">The <xref:System.Windows.ContentElement.KeyUp> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="e7c98-2130">这是文本的因为某些控件有控件组合或提供的更高级别的版本的类处理输入处理和相关事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2130">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span> <span data-ttu-id="e7c98-2131">有关详细信息，请检查单个控件的文档。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2131">For details, check the documentation for individual controls.</span></span>  
  
 <span data-ttu-id="e7c98-2132">此事件创建一个别名<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewKeyUp>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2132">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewKeyUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2133">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewKeyUp>事件附加到基础<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2133">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewKeyUp> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2134">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2134">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2135">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2135">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewKeyUpEvent>|  
|<span data-ttu-id="e7c98-2136">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2136">Routing strategy</span></span>|<span data-ttu-id="e7c98-2137">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2137">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2138">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2138">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="e7c98-2139">对应的冒泡事件<xref:System.Windows.ContentElement.KeyUp>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2139">The corresponding bubbling event is <xref:System.Windows.ContentElement.KeyUp>.</span></span>  
  
-   <span data-ttu-id="e7c98-2140">重写<xref:System.Windows.ContentElement.OnPreviewKeyUp%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2140">Override <xref:System.Windows.ContentElement.OnPreviewKeyUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2141">标识 <see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2141">Identifies the <see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2142">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2142">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2143">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2143">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2144">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2144">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2145">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2145">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2146">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2146">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewLostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewLostKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewLostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2147">在此元素不再聚焦于键盘时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2147">Occurs when the keyboard is no longer focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2148">由于此事件使用隧道路由，失去焦点的元素可能是而不是元素的子元素实际附加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2148">Because this event uses tunneling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="e7c98-2149">检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据以确定实际失去焦点的元素中。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2149">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="e7c98-2150">此事件创建一个别名<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2150">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2151">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>事件附加到基础<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2151">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2152">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2152">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2153">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2153">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent>|  
|<span data-ttu-id="e7c98-2154">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2154">Routing strategy</span></span>|<span data-ttu-id="e7c98-2155">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2155">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2156">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2156">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="e7c98-2157">对应的冒泡事件<xref:System.Windows.ContentElement.LostKeyboardFocus>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2157">The corresponding bubbling event is <xref:System.Windows.ContentElement.LostKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="e7c98-2158">重写<xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2158">Override <xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewLostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewLostKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2159">标识 <see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2159">Identifies the <see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2160">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2160">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2161">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2161">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2162">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2162">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2163">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2163">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2164">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2164">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2165">在指针位于此元素上并且按下任意鼠标按钮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2165">Occurs when any mouse button is pressed while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2166">此事件创建一个别名<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewMouseDown>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2166">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2167">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewMouseDown>事件附加到基础<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2167">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseDown> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2168"><xref:System.Windows.ContentElement.PreviewMouseDown>事件通常一起引发<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>或<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>，这对应于按下的某个之一的两个标准鼠标按钮。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2168">The <xref:System.Windows.ContentElement.PreviewMouseDown> event is often raised together with either <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="e7c98-2169"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> 和<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>也是路由的事件，但它们是直接路由的事件，并引发相应的按钮特定事件时<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件到达事件路由中的此元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2169"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="e7c98-2170">请参阅备注以<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>或<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2170">See Remarks for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2171">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2171">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2172">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2172">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseDownEvent>|  
|<span data-ttu-id="e7c98-2173">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2173">Routing strategy</span></span>|<span data-ttu-id="e7c98-2174">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2174">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2175">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2175">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="e7c98-2176">对应的冒泡事件<xref:System.Windows.ContentElement.MouseDown>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2176">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseDown>.</span></span>  
  
-   <span data-ttu-id="e7c98-2177">重写<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2177">Override <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2178">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2178">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2179">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2179">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2180">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2180">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2181">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2181">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2182">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2182">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2183">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2183">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2184">在鼠标指针位于此元素上并且按下鼠标左键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2184">Occurs when the left mouse button is pressed while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2185">尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循隧道路由通过元素树，它实际上是直接的路由的事件引发和每个元素树沿遵循<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2185">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="e7c98-2186">此事件是报告鼠标按钮特定信息的基础的几个相关事件之一<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件，即处理为由事件路由每个元素的附加的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2186">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="e7c98-2187">此事件的自变量公开基础的自变量<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2187">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="e7c98-2188">如果该事件被标记为已处理事件路由过程，则仍会引发的鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.ContentElement.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将事件侦听器。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2188">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="e7c98-2189">从概念上讲，将此事件 (和其他鼠标按钮事件上的<xref:System.Windows.ContentElement>) 视为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2189">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="e7c98-2190">事件将添加不需要检查鼠标按钮状态 （从左至右，向上向下） 的事件数据中的原始鼠标事件的便利性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2190">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="e7c98-2191">对于更高级的方案，例如检查非标准按钮的状态，你可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>上类而不是那些<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2191">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2192">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2192">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2193">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2193">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent>|  
|<span data-ttu-id="e7c98-2194">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2194">Routing strategy</span></span>|<span data-ttu-id="e7c98-2195">直接</span><span class="sxs-lookup"><span data-stu-id="e7c98-2195">Direct</span></span>|  
|<span data-ttu-id="e7c98-2196">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2196">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="e7c98-2197">重写<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2197">Override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2198">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2198">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2199">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2199">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2200">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2200">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2201">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2201">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2202">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2202">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2203">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2203">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2204">在鼠标指针位于此元素上并且松开鼠标左键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2204">Occurs when the left mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2205">尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循隧道路由通过元素树，它实际上是直接的路由的事件引发和每个元素树沿遵循<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2205">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="e7c98-2206">此事件是报告鼠标按钮特定信息的基础的几个相关事件之一<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件，即处理为由事件路由每个元素的附加的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2206">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="e7c98-2207">此事件的自变量公开基础的自变量<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2207">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="e7c98-2208">如果该事件被标记为已处理事件路由过程，则仍会引发的鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.ContentElement.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将事件侦听器。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2208">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="e7c98-2209">从概念上讲，将此事件 (和其他鼠标按钮事件上的<xref:System.Windows.ContentElement>) 视为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2209">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="e7c98-2210">事件将添加不需要检查鼠标按钮状态 （从左至右，向上向下） 的事件数据中的原始鼠标事件的便利性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2210">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="e7c98-2211">对于更高级的方案，例如检查非标准按钮的状态，你可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>上类而不是那些<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2211">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2212">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2212">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2213">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2213">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent>|  
|<span data-ttu-id="e7c98-2214">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2214">Routing strategy</span></span>|<span data-ttu-id="e7c98-2215">直接</span><span class="sxs-lookup"><span data-stu-id="e7c98-2215">Direct</span></span>|  
|<span data-ttu-id="e7c98-2216">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2216">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="e7c98-2217">重写<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2217">Override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2218">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2218">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2219">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2219">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2220">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2220">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2221">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2221">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2222">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2222">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2223">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2223">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ PreviewMouseMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2224">在鼠标指针位于此元素上并且移动鼠标指针时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2224">Occurs when the mouse pointer moves while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2225">都会发生此事件当鼠标指针首次进入入元素边界，并还鼠标指针移动时仍剩余元素的边界内。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2225">This event occurs both when the mouse pointer first enters into the element bounds, and also when the mouse pointer moves while still remaining within the element bounds.</span></span>  
  
 <span data-ttu-id="e7c98-2226">此事件创建一个别名<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewMouseMove>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2226">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2227">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewMouseMove>事件附加到基础<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2227">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2228">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2228">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2229">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2229">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseMoveEvent>|  
|<span data-ttu-id="e7c98-2230">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2230">Routing strategy</span></span>|<span data-ttu-id="e7c98-2231">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2231">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2232">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2232">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="e7c98-2233">对应的冒泡事件<xref:System.Windows.ContentElement.MouseMove>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2233">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseMove>.</span></span>  
  
-   <span data-ttu-id="e7c98-2234">重写<xref:System.Windows.ContentElement.OnPreviewMouseMove%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2234">Override <xref:System.Windows.ContentElement.OnPreviewMouseMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2235">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2235">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2236">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2236">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2237">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2237">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2238">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2238">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2239">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2239">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2240">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2240">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2241">在鼠标指针位于此元素上并且按下鼠标右键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2241">Occurs when the right mouse button is pressed while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2242">尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循隧道路由通过元素树，它实际上是直接的路由的事件引发和每个元素树沿遵循<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2242">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="e7c98-2243">此事件是报告鼠标按钮特定信息的基础的几个相关事件之一<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件，即处理为由事件路由每个元素的附加的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2243">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="e7c98-2244">此事件的自变量公开基础的自变量<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2244">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="e7c98-2245">如果该事件被标记为已处理事件路由过程，则仍会引发的鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.ContentElement.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将事件侦听器。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2245">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="e7c98-2246">从概念上讲，将此事件 (和其他鼠标按钮事件上的<xref:System.Windows.ContentElement>) 视为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2246">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="e7c98-2247">事件将添加不需要检查鼠标按钮状态 （从左至右，向上向下） 的事件数据中的原始鼠标事件的便利性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2247">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="e7c98-2248">对于更高级的方案，例如检查非标准按钮的状态，你可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>上类而不是那些<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2248">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2249">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2249">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2250">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2250">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent>|  
|<span data-ttu-id="e7c98-2251">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2251">Routing strategy</span></span>|<span data-ttu-id="e7c98-2252">直接</span><span class="sxs-lookup"><span data-stu-id="e7c98-2252">Direct</span></span>|  
|<span data-ttu-id="e7c98-2253">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2253">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="e7c98-2254">重写<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2254">Override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2255">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2255">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2256">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2256">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2257">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2257">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2258">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2258">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2259">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2259">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2260">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2260">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2261">在鼠标指针位于此元素上并且松开鼠标右键时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2261">Occurs when the right mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2262">尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循隧道路由通过元素树，它实际上是直接的路由的事件引发和每个元素树沿遵循<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2262">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="e7c98-2263">此事件是报告鼠标按钮特定信息的基础的几个相关事件之一<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件，即处理为由事件路由每个元素的附加的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2263">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="e7c98-2264">此事件的自变量公开基础的自变量<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2264">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="e7c98-2265">如果该事件被标记为已处理事件路由过程，则仍会引发的鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.ContentElement.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将事件侦听器。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2265">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="e7c98-2266">从概念上讲，将此事件 (和其他鼠标按钮事件上的<xref:System.Windows.ContentElement>) 视为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2266">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="e7c98-2267">事件将添加不需要检查鼠标按钮状态 （从左至右，向上向下） 的事件数据中的原始鼠标事件的便利性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2267">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="e7c98-2268">对于更高级的方案，例如检查非标准按钮的状态，你可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>上类而不是那些<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2268">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2269">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2269">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2270">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2270">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent>|  
|<span data-ttu-id="e7c98-2271">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2271">Routing strategy</span></span>|<span data-ttu-id="e7c98-2272">直接</span><span class="sxs-lookup"><span data-stu-id="e7c98-2272">Direct</span></span>|  
|<span data-ttu-id="e7c98-2273">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2273">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="e7c98-2274">重写<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2274">Override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2275">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2275">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2276">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2276">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2277">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2277">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2278">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2278">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2279">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2279">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2280">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2280">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2281">在鼠标指针位于此元素上并且松开任意鼠标按钮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2281">Occurs when any mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2282">此事件创建一个别名<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewMouseUp>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2282">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2283">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewMouseUp>事件附加到基础<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2283">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseUp> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2284"><xref:System.Windows.ContentElement.PreviewMouseUp>事件通常一起引发<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>或<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>，这对应于按下的某个之一的两个标准鼠标按钮。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2284">The <xref:System.Windows.ContentElement.PreviewMouseUp> event is often raised together with either <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="e7c98-2285"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> 和<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>也是路由的事件，但它们是直接路由的事件，并引发相应的按钮特定事件时<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件到达事件路由中的此元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2285"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="e7c98-2286">请参阅备注以<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>或<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2286">See Remarks for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2287">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2287">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2288">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2288">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseUpEvent>|  
|<span data-ttu-id="e7c98-2289">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2289">Routing strategy</span></span>|<span data-ttu-id="e7c98-2290">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2290">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2291">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2291">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="e7c98-2292">对应的冒泡事件<xref:System.Windows.ContentElement.MouseUp>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2292">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseUp>.</span></span>  
  
-   <span data-ttu-id="e7c98-2293">重写<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2293">Override <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2294">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2294">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2295">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2295">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2296">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2296">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2297">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2297">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2298">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2298">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2299">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2299">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ PreviewMouseWheel;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2300">在鼠标指针位于此元素上并且用户滚动鼠标滚轮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2300">Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2301">焦点或鼠标捕获优先于其中鼠标指针位于;因此，如果您收到此事件来自的已设定焦点或捕获元素，鼠标指针实际上可能通过另一个元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2301">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive this event from a focused or captured element, the mouse pointer might actually be over another element.</span></span>  
  
 <span data-ttu-id="e7c98-2302">此事件创建一个别名<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewMouseMove>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2302">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2303">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewMouseMove>事件附加到基础<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2303">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2304">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2304">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2305">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2305">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseWheelEvent>|  
|<span data-ttu-id="e7c98-2306">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2306">Routing strategy</span></span>|<span data-ttu-id="e7c98-2307">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2307">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2308">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2308">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="e7c98-2309">对应的冒泡事件<xref:System.Windows.ContentElement.MouseWheel>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2309">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseWheel>.</span></span>  
  
-   <span data-ttu-id="e7c98-2310">重写<xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2310">Override <xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2311">标识 <see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2311">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2312">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2312">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2313">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2313">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2314">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2314">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2315">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2315">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2316">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2316">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewQueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ PreviewQueryContinueDrag;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2317">在拖放操作期间键盘或鼠标按钮的状态改变时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2317">Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2318"><xref:System.Windows.ContentElement.PreviewQueryContinueDrag>事件允许拖动源来声明是否应取消拖放操作。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2318">The <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> event enables the drag source to declare whether the drag-and-drop operation should be canceled.</span></span>  
  
 <span data-ttu-id="e7c98-2319">此事件创建一个别名<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2319">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2320">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>事件附加到基础<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2320">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2321">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2321">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2322">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2322">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewQueryContinueDragEvent>|  
|<span data-ttu-id="e7c98-2323">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2323">Routing strategy</span></span>|<span data-ttu-id="e7c98-2324">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2324">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2325">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2325">Delegate</span></span>|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   <span data-ttu-id="e7c98-2326">对应的冒泡事件<xref:System.Windows.ContentElement.QueryContinueDrag>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2326">The corresponding bubbling event is <xref:System.Windows.ContentElement.QueryContinueDrag>.</span></span>  
  
-   <span data-ttu-id="e7c98-2327">重写<xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2327">Override <xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewQueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewQueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewQueryContinueDragEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2328">标识 <see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2328">Identifies the <see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2329">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2329">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2330">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2330">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2331">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2331">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2332">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2332">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2333">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2333">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2334">在指针位于此元素上并且按下触笔按钮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2334">Occurs when the stylus button is pressed while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2335">此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewStylusButtonDown>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2335">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusButtonDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2336">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewStylusButtonDown>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2336">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusButtonDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2337">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2337">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2338">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2338">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2339">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2339">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2340">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2340">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusButtonDownEvent>|  
|<span data-ttu-id="e7c98-2341">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2341">Routing strategy</span></span>|<span data-ttu-id="e7c98-2342">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2342">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2343">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2343">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="e7c98-2344">对应的冒泡事件<xref:System.Windows.ContentElement.StylusButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2344">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusButtonDown>.</span></span>  
  
-   <span data-ttu-id="e7c98-2345">重写<xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2345">Override <xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2346">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2346">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2347">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2347">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2348">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2348">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2349">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2349">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2350">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2350">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2351">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2351">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2352">在指针位于此元素上并且松开触笔按钮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2352">Occurs when the stylus button is released while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2353">此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewStylusButtonUp>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2353">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusButtonUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2354">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewStylusButtonUp>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2354">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusButtonUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2355">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2355">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2356">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2356">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2357">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2357">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2358">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2358">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusButtonUpEvent>|  
|<span data-ttu-id="e7c98-2359">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2359">Routing strategy</span></span>|<span data-ttu-id="e7c98-2360">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2360">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2361">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2361">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="e7c98-2362">对应的冒泡事件<xref:System.Windows.ContentElement.StylusButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2362">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusButtonUp>.</span></span>  
  
-   <span data-ttu-id="e7c98-2363">重写<xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2363">Override <xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2364">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2364">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2365">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2365">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2366">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2366">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2367">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2367">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2368">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2368">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2369">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2369">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ PreviewStylusDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2370">当触笔位于元素上且触及数字化器时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2370">Occurs when the stylus touches the digitizer while it is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2371">此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewStylusDown>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2371">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2372">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewStylusDown>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2372">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2373">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2373">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2374">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2374">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2375">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2375">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2376">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2376">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusDownEvent>|  
|<span data-ttu-id="e7c98-2377">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2377">Routing strategy</span></span>|<span data-ttu-id="e7c98-2378">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2378">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2379">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2379">Delegate</span></span>|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   <span data-ttu-id="e7c98-2380">对应的冒泡事件<xref:System.Windows.ContentElement.StylusDown>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2380">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusDown>.</span></span>  
  
-   <span data-ttu-id="e7c98-2381">重写<xref:System.Windows.ContentElement.OnPreviewStylusDown%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2381">Override <xref:System.Windows.ContentElement.OnPreviewStylusDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2382">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2382">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2383">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2383">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2384">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2384">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2385">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2385">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2386">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2386">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2387">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2387">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInAirMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2388">在触笔掠过元素但并未实际接触数字化器时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2388">Occurs when the stylus moves over an element without actually touching the digitizer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2389">此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewStylusInAirMove>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2389">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusInAirMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2390">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewStylusInAirMove>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2390">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusInAirMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2391">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2391">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2392">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2392">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2393">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2393">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2394">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2394">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusInAirMoveEvent>|  
|<span data-ttu-id="e7c98-2395">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2395">Routing strategy</span></span>|<span data-ttu-id="e7c98-2396">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2396">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2397">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2397">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="e7c98-2398">对应的冒泡事件<xref:System.Windows.ContentElement.StylusInAirMove>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2398">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusInAirMove>.</span></span>  
  
-   <span data-ttu-id="e7c98-2399">重写<xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2399">Override <xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInAirMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2400">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2400">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2401">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2401">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2402">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2402">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2403">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2403">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2404">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2404">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2405">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2405">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2406">在触笔位于此元素上并且触笔与数字化器之间的距离近到足以检测到触笔时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2406">Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2407">此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewStylusInRange>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2407">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusInRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2408">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewStylusInRange>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2408">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusInRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2409">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2409">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2410">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2410">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2411">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2411">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2412">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2412">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusInRangeEvent>|  
|<span data-ttu-id="e7c98-2413">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2413">Routing strategy</span></span>|<span data-ttu-id="e7c98-2414">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2414">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2415">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2415">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="e7c98-2416">对应的冒泡事件<xref:System.Windows.ContentElement.StylusInRange>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2416">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusInRange>.</span></span>  
  
-   <span data-ttu-id="e7c98-2417">重写<xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2417">Override <xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2418">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2418">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2419">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2419">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2420">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2420">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2421">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2421">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2422">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2422">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2423">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2423">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2424">在触笔位于元素上并且移动触笔时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2424">Occurs when the stylus moves while over the element.</span>
          </span>
          <span data-ttu-id="e7c98-2425">数字化器在检测触笔时，触笔必须处于移动状态才会引发此事件，否则将改为引发 <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2425">The stylus must move while being detected by the  digitizer  to raise this event, otherwise, <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> is raised instead.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2426">此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewStylusMove>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2426">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2427">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewStylusMove>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2427">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2428">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2428">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2429">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2429">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2430">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2430">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2431">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2431">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusMoveEvent>|  
|<span data-ttu-id="e7c98-2432">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2432">Routing strategy</span></span>|<span data-ttu-id="e7c98-2433">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2433">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2434">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2434">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="e7c98-2435">对应的冒泡事件<xref:System.Windows.ContentElement.StylusMove>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2435">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusMove>.</span></span>  
  
-   <span data-ttu-id="e7c98-2436">重写<xref:System.Windows.ContentElement.OnPreviewStylusMove%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2436">Override <xref:System.Windows.ContentElement.OnPreviewStylusMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2437">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2437">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2438">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2438">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2439">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2439">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2440">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2440">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2441">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2441">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2442">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2442">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusOutOfRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2443">在触笔与数字化仪之间的距离太远以致无法检测到触笔时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2443">Occurs when the stylus is too far from the digitizer to be detected.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2444">此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2444">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2445">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2445">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2446">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2446">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2447">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2447">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2448">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2448">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2449">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2449">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent>|  
|<span data-ttu-id="e7c98-2450">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2450">Routing strategy</span></span>|<span data-ttu-id="e7c98-2451">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2451">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2452">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2452">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="e7c98-2453">对应的冒泡事件<xref:System.Windows.ContentElement.StylusOutOfRange>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2453">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusOutOfRange>.</span></span>  
  
-   <span data-ttu-id="e7c98-2454">重写<xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2454">Override <xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusOutOfRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2455">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2455">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2456">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2456">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2457">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2457">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2458">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2458">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2459">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2459">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2460">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2460">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ PreviewStylusSystemGesture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2461">在用户采用某一种触笔笔势时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2461">Occurs when a user performs one of several stylus gestures.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2462">有关触笔笔势的信息，请参阅<xref:System.Windows.Input.SystemGesture>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2462">For information about stylus gestures, see <xref:System.Windows.Input.SystemGesture>.</span></span>  
  
 <span data-ttu-id="e7c98-2463">此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2463">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2464">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2464">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2465">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2465">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2466">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2466">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2467">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2467">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2468">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2468">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusSystemGestureEvent>|  
|<span data-ttu-id="e7c98-2469">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2469">Routing strategy</span></span>|<span data-ttu-id="e7c98-2470">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2470">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2471">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2471">Delegate</span></span>|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   <span data-ttu-id="e7c98-2472">对应的冒泡事件<xref:System.Windows.ContentElement.StylusSystemGesture>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2472">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusSystemGesture>.</span></span>  
  
-   <span data-ttu-id="e7c98-2473">重写<xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2473">Override <xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusSystemGestureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2474">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2474">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2475">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2475">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2476">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2476">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2477">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2477">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2478">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2478">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2479">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2479">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2480">当触笔位于此元素上并且用户将触笔抬离数字化器时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2480">Occurs when the user raises the stylus off the digitizer while the stylus is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2481">此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewStylusDown>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2481">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2482">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewStylusDown>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2482">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2483">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2483">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2484">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2484">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2485">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2485">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2486">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2486">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusUpEvent>|  
|<span data-ttu-id="e7c98-2487">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2487">Routing strategy</span></span>|<span data-ttu-id="e7c98-2488">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2488">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2489">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2489">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="e7c98-2490">对应的冒泡事件<xref:System.Windows.ContentElement.StylusUp>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2490">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusUp>.</span></span>  
  
-   <span data-ttu-id="e7c98-2491">重写<xref:System.Windows.ContentElement.OnPreviewStylusUp%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2491">Override <xref:System.Windows.ContentElement.OnPreviewStylusUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2492">标识 <see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2492">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2493">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2493">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2494">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2494">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2495">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2495">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2496">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2496">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2497">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2497">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ PreviewTextInput;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewTextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2498">在此元素以设备无关模式获取文本时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2498">Occurs when this element gets text in a device-independent manner.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2499"><xref:System.Windows.ContentElement.PreviewTextInput>事件允许组件或应用程序侦听的文本输入以独立于设备的方式。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2499">The <xref:System.Windows.ContentElement.PreviewTextInput> event allows a component or application to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="e7c98-2500">键盘是主种<xref:System.Windows.ContentElement.PreviewTextInput>; 但语音、 手写和其他输入的设备还可以生成<xref:System.Windows.ContentElement.PreviewTextInput>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2500">The keyboard is the primary means of <xref:System.Windows.ContentElement.PreviewTextInput>; but speech, handwriting, and other input devices can also generate <xref:System.Windows.ContentElement.PreviewTextInput>.</span></span>  
  
 <span data-ttu-id="e7c98-2501">由于键组合 — 默认键盘或输入的法编辑器-多个键事件可能会引发一个文本输入的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2501">Because of key combinations—either in default keyboards or through input method editors—multiple key events may raise just one text input event.</span></span>  
  
 <span data-ttu-id="e7c98-2502">此事件创建一个别名<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.PreviewTextInput>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2502">This event creates an alias for the <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewTextInput> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2503">事件处理程序附加到<xref:System.Windows.ContentElement.PreviewTextInput>事件附加到基础<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2503">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewTextInput> event are attached to the underlying <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2504">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2504">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2505">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2505">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTextInputEvent>|  
|<span data-ttu-id="e7c98-2506">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2506">Routing strategy</span></span>|<span data-ttu-id="e7c98-2507">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2507">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2508">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2508">Delegate</span></span>|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   <span data-ttu-id="e7c98-2509">对应的冒泡事件<xref:System.Windows.ContentElement.TextInput>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2509">The corresponding bubbling event is <xref:System.Windows.ContentElement.TextInput>.</span></span>  
  
-   <span data-ttu-id="e7c98-2510">重写<xref:System.Windows.ContentElement.OnPreviewTextInput%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2510">Override <xref:System.Windows.ContentElement.OnPreviewTextInput%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTextInputEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2511">标识 <see cref="E:System.Windows.ContentElement.PreviewTextInput" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2511">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTextInput" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2512">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2512">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2513">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2513">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2514">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2514">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2515">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2515">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2516">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2516">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2517">当悬停在此元素上方的手指触摸屏幕时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2517">Occurs when a finger touches the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2518">默认情况下，<xref:System.Windows.ContentElement.PreviewTouchDown>和<xref:System.Windows.ContentElement.TouchDown>事件手指触摸屏幕并移动之前不会发生。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2518">By default, the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events do not occur until a finger touches the screen and moves.</span></span> <span data-ttu-id="e7c98-2519">手指在屏幕上按住但不移动会导致按并保存行为<xref:System.Windows.Input.Stylus>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2519">Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <xref:System.Windows.Input.Stylus>.</span></span> <span data-ttu-id="e7c98-2520">按下并保持行为相当于鼠标右键单击。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2520">The press and hold behavior is equivalent to a mouse right-click.</span></span>  
  
 <span data-ttu-id="e7c98-2521">若要使<xref:System.Windows.ContentElement.PreviewTouchDown>和<xref:System.Windows.ContentElement.TouchDown>事件发生只要的手指触摸屏幕上，设置<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>附加到属性`false`此元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2521">To cause the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events to occur as soon as a finger touches the screen, set the <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> attached property to `false` for this element.</span></span>  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2522">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2522">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2523">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2523">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchDownEvent>|  
|<span data-ttu-id="e7c98-2524">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2524">Routing strategy</span></span>|<span data-ttu-id="e7c98-2525">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2525">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2526">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2526">Delegate</span></span>|<span data-ttu-id="e7c98-2527"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2527"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="e7c98-2528">对应的冒泡事件<xref:System.Windows.ContentElement.TouchDown>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2528">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchDown>.</span></span>  
  
-   <span data-ttu-id="e7c98-2529">重写<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2529">Override <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2530">标识 <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2530">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchMove;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2531">当悬停在此元素上方的手指在屏幕上移动时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2531">Occurs when a finger moves on the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2532">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2532">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2533">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2533">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchMoveEvent>|  
|<span data-ttu-id="e7c98-2534">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2534">Routing strategy</span></span>|<span data-ttu-id="e7c98-2535">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2535">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2536">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2536">Delegate</span></span>|<span data-ttu-id="e7c98-2537"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2537"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="e7c98-2538">对应的冒泡事件<xref:System.Windows.ContentElement.TouchMove>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2538">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchMove>.</span></span>  
  
-   <span data-ttu-id="e7c98-2539">重写<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2539">Override <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2540">标识 <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2540">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2541">当悬停在此元素上方的手指从屏幕上移开时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2541">Occurs when a finger is raised off of the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2542">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2542">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2543">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2543">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchUpEvent>|  
|<span data-ttu-id="e7c98-2544">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2544">Routing strategy</span></span>|<span data-ttu-id="e7c98-2545">隧道</span><span class="sxs-lookup"><span data-stu-id="e7c98-2545">Tunneling</span></span>|  
|<span data-ttu-id="e7c98-2546">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2546">Delegate</span></span>|<span data-ttu-id="e7c98-2547"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2547"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="e7c98-2548">对应的冒泡事件<xref:System.Windows.ContentElement.TouchUp>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2548">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchUp>.</span></span>  
  
-   <span data-ttu-id="e7c98-2549">重写<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2549">Override <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2550">标识 <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2550">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2551">在拖放操作期间键盘或鼠标按钮的状态改变时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2551">Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2552"><xref:System.Windows.ContentElement.QueryContinueDrag>事件允许拖动源确定是否应取消拖放操作。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2552">The <xref:System.Windows.ContentElement.QueryContinueDrag> event enables the drag source to determine whether the drag-and-drop operation should be canceled.</span></span>  
  
 <span data-ttu-id="e7c98-2553">此事件创建一个别名<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.QueryContinueDrag>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2553">This event creates an alias for the <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.QueryContinueDrag> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2554">事件处理程序附加到<xref:System.Windows.ContentElement.QueryContinueDrag>事件附加到基础<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2554">Event handlers that are attached to the <xref:System.Windows.ContentElement.QueryContinueDrag> event are attached to the underlying <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2555">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2555">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2556">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2556">Identifier field</span></span>|<xref:System.Windows.ContentElement.QueryContinueDragEvent>|  
|<span data-ttu-id="e7c98-2557">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2557">Routing strategy</span></span>|<span data-ttu-id="e7c98-2558">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-2558">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-2559">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2559">Delegate</span></span>|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   <span data-ttu-id="e7c98-2560">对应的隧道事件<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2560">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewQueryContinueDrag>.</span></span>  
  
-   <span data-ttu-id="e7c98-2561">重写<xref:System.Windows.ContentElement.OnQueryContinueDrag%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2561">Override <xref:System.Windows.ContentElement.OnQueryContinueDrag%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryContinueDragEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2562">标识 <see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2562">Identifies the <see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2563">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2563">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2564">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2564">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2565">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2565">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2566">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2566">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2567">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2567">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryCursor As QueryCursorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::QueryCursorEventHandler ^ QueryCursor;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2568">当请求显示光标时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2568">Occurs when the cursor is requested to display.</span>
          </span>
          <span data-ttu-id="e7c98-2569">每次鼠标指针移至新位置时都会在一个元素上引发此事件，这意味着光标对象可能需要根据其新位置进行更改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2569">This event is raised on an element each time that the mouse pointer moves to a new location, which means the cursor object might need to be changed based on its new position.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2570">此事件创建一个别名<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.QueryCursor>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2570">This event creates an alias for the <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.QueryCursor> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2571">事件处理程序附加到<xref:System.Windows.ContentElement.QueryCursor>事件附加到基础<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2571">Event handlers that are attached to the <xref:System.Windows.ContentElement.QueryCursor> event are attached to the underlying <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2572">此事件名称引用光标不一定是文本光标 （有时称为插入点）。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2572">The cursor being referred to by this event name is not necessarily the text cursor (sometimes known as the insertion point).</span></span> <span data-ttu-id="e7c98-2573">相反，此上下文中的光标是声明的屏幕的图形显示与多个可能的输入相关的设备或 Windows 编程中的概念相关的对象。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2573">Instead, the cursor in this context is the object that declares the onscreen graphical display related to several possible input-related devices or concepts in Windows programming.</span></span> <span data-ttu-id="e7c98-2574">该对象表示由<xref:System.Windows.Input.Cursor>WPF 中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2574">That object is represented by the <xref:System.Windows.Input.Cursor> class in WPF.</span></span> <span data-ttu-id="e7c98-2575">WPF 输入的系统可以更改此光标时它表示鼠标指针的屏幕位置。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2575">The WPF input system enables you to change this cursor when it represents the onscreen position of the mouse pointer.</span></span> <span data-ttu-id="e7c98-2576">你可以使用从的预定义的值<xref:System.Windows.Input.Cursors>枚举，也可以声明自定义光标以图像文件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2576">You can use predefined values from the <xref:System.Windows.Input.Cursors> enumeration, or you can declare a custom cursor as an image file.</span></span>  
  
 <span data-ttu-id="e7c98-2577">侦听<xref:System.Windows.ContentElement.QueryCursor>事件不是游标管理的有效技术。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2577">Listening for the <xref:System.Windows.ContentElement.QueryCursor> event is not an efficient technique for cursor management.</span></span> <span data-ttu-id="e7c98-2578">相反，每个元素应定义其自己的游标行为与<xref:System.Windows.FrameworkContentElement.Cursor%2A>和<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2578">Instead, each element should define its own cursor behavior with <xref:System.Windows.FrameworkContentElement.Cursor%2A> and <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>.</span></span> <span data-ttu-id="e7c98-2579">你应仅依赖于<xref:System.Windows.ContentElement.QueryCursor>如果你不使用 WPF 框架级别基元素，或中的特殊情况下，基于每个元素中定义的游标行为不满足你的需求。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2579">You should only rely on <xref:System.Windows.ContentElement.QueryCursor> if you are not using the WPF framework-level base elements, or in extraordinary circumstances where defining cursor behavior on a per-element basis does not meet your needs.</span></span> <span data-ttu-id="e7c98-2580">有关详细信息在响应中实现的游标行为<xref:System.Windows.ContentElement.QueryCursor>，请参阅<xref:System.Windows.Input.QueryCursorEventHandler>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2580">For more information on implementing cursor behavior in response to <xref:System.Windows.ContentElement.QueryCursor>, see <xref:System.Windows.Input.QueryCursorEventHandler>.</span></span>  
  
<a name="routedEventInfo_QueryCursor"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2581">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2581">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2582">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2582">Identifier field</span></span>|<xref:System.Windows.ContentElement.QueryCursorEvent>|  
|<span data-ttu-id="e7c98-2583">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2583">Routing strategy</span></span>|<span data-ttu-id="e7c98-2584">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-2584">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-2585">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2585">Delegate</span></span>|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   <span data-ttu-id="e7c98-2586">没有定义相应隧道事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2586">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="e7c98-2587">重写<xref:System.Windows.ContentElement.OnQueryCursor%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2587">Override <xref:System.Windows.ContentElement.OnQueryCursor%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2588">标识 <see cref="E:System.Windows.ContentElement.QueryCursor" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2588">Identifies the <see cref="E:System.Windows.ContentElement.QueryCursor" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2589">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2589">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2590">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2590">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2591">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2591">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2592">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2592">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2593">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2593">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RaiseEvent(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RaiseEvent(System.Windows.RoutedEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="e7c98-2594">一个 <see cref="T:System.Windows.RoutedEventArgs" />，其中包含事件数据并标识要引发的事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2594">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains the event data and also identifies the event to raise.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-2595">引发特定路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2595">Raises a specific routed event.</span>
          </span>
          <span data-ttu-id="e7c98-2596">在提供的 <see cref="T:System.Windows.RoutedEvent" /> 实例中标识要引发的 <see cref="T:System.Windows.RoutedEventArgs" />（作为该事件数据的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 属性）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2596">The <see cref="T:System.Windows.RoutedEvent" /> to be raised is identified within the <see cref="T:System.Windows.RoutedEventArgs" /> instance that is provided (as the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> property of that event data).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2597">`e`参数被类型化为所有路由的事件数据的公共基类型; 但是，应作为最特定的事件数据类型，则使用有关要引发事件，因为给定的事件数据<xref:System.Windows.RoutedEventArgs>派生的类包含适用于特定事件时将引发此事件的实际的特定数据属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2597">The `e` parameter is typed as the common base type for all routed event data; however, the event data should be given as the most specific event data type that is available for the event being raised, because <xref:System.Windows.RoutedEventArgs> derived classes contain the actual specific data properties that are intended for the specific event when it is raised.</span></span>  
  
 <span data-ttu-id="e7c98-2598"><xref:System.Windows.RoutedEventArgs> 不只是事件; 的状态属性它还标识要引发的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2598"><xref:System.Windows.RoutedEventArgs> is not just the state properties for the event; it also identifies which routed event to raise.</span></span> <span data-ttu-id="e7c98-2599">此事件引发模式和路由的事件数据均不同于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件和数据类，该类通常只包含与事件相关的属性。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2599">This event-raising pattern and the routed event data both differ from [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] events and data classes, which typically just contain properties that are related to the event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e7c98-2600">下面的示例创建事件数据，将事件标识符追加到数据，然后使用事件数据实例引发自定义的路由的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2600">The following example creates event data, appends the event identifier to the data, and then uses the event data instance to raise a custom routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#raiseevent)]
 [!code-vb[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseAllTouchCaptures" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseAllTouchCaptures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseAllTouchCaptures();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2601">从此元素中释放所有捕获的触摸设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2601">Releases all captured touch devices from this element.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMouseCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseMouseCapture();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2602">如果此元素具有鼠标捕获，则释放该捕获。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2602">Releases the mouse capture, if this element held the capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2603">如果此元素未持有捕获，调用此方法无效。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2603">If this element did not hold the capture, calling this method has no effect.</span></span> <span data-ttu-id="e7c98-2604">请考虑在检查的值<xref:System.Windows.ContentElement.IsMouseCaptured%2A>之前调用此方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2604">Consider checking the value of <xref:System.Windows.ContentElement.IsMouseCaptured%2A> before you call this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e7c98-2605">下面的处理程序捕获或释放鼠标按钮状态根据鼠标捕获。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2605">The following handler captures or releases mouse capture according to mouse button states.</span></span> <span data-ttu-id="e7c98-2606">该示例演示如何使用捕获的鼠标移动进行其他比移动鼠标指针用途[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2606">The example shows how to use captured mouse movement for alternative purposes other than moving the mouse pointer in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseStylusCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseStylusCapture();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2607">如果此元素具有触笔设备捕获，则释放该捕获。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2607">Releases the stylus device capture, if this element held the capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2608">如果此元素未持有捕获，调用此方法无效。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2608">If this element did not hold the capture, calling this method has no effect.</span></span> <span data-ttu-id="e7c98-2609">请考虑在检查的值<xref:System.Windows.ContentElement.IsStylusCaptured%2A>之前调用此方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2609">Consider checking the value of <xref:System.Windows.ContentElement.IsStylusCaptured%2A> before you call this method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReleaseTouchCapture(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">
          <span data-ttu-id="e7c98-2610">要释放的设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2610">The device to release.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-2611">尝试从此元素释放指定触摸设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2611">Attempts to release the specified touch device from this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e7c98-2612">如果释放了触摸设备，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2612">
              <see langword="true" /> if the touch device is released; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e7c98-2613">
            <paramref name="touchDevice" /> 为 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2613">
              <paramref name="touchDevice" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <span data-ttu-id="e7c98-2614">附加处理程序的路由事件的标识符。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2614">The identifier of the.routed event for which the handler is attached.</span>
          </span>
        </param>
        <param name="handler">
          <span data-ttu-id="e7c98-2615">要从此元素的事件处理程序集合中删除的特定处理程序实现。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2615">The specific handler implementation to remove from the event handler collection on this element.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e7c98-2616">从此元素中删除指定的路由事件处理程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2616">Removes the specified routed event handler from this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2617">最常见的方案使用此[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]，在实现[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]"包装器"自定义的路由事件，特别是，当你实现处理程序的"删除"逻辑与关联的事件[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]级别。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2617">The most common scenario for using this [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] is when you implement the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] "wrapper" event that is associated with a custom routed event, specifically when you implement the "remove" logic for handlers at the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] level.</span></span> <span data-ttu-id="e7c98-2618">下面的示例中这部分阐释了这种情况下的备注。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2618">The example that follows this remarks section illustrates this scenario.</span></span>  
  
 <span data-ttu-id="e7c98-2619">如果没有注册的使用匹配方法调用的输入的参数的条件没有处理程序，则调用此方法起任何作用。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2619">Calling this method has no effect if there were no handlers registered with criteria that match the input parameters for the method call.</span></span>  
  
 <span data-ttu-id="e7c98-2620">如果多个处理程序附加条件相匹配，仅第一个处理程序事件删除处理程序存储区中。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2620">If more than one handler is attached that matched the criteria, only the first handler in the event handler store is removed.</span></span> <span data-ttu-id="e7c98-2621">此行为是与一致[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]行为`-=`运算符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2621">This behavior is consistent with [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] behavior of the `-=` operator.</span></span>  
  
 <span data-ttu-id="e7c98-2622">既不`routedEvent`也不`handler`可能`null`。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2622">Neither `routedEvent` nor `handler` may be `null`.</span></span> <span data-ttu-id="e7c98-2623">尝试提供上述任意值作为`null`将引发的异常。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2623">Attempting to provide either value as `null` will raise an exception.</span></span>  
  
 <span data-ttu-id="e7c98-2624">此方法将忽略`handledEventsToo`参数信息，如果处理程序最初提供添加与<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>启用的已处理事件的处理的签名。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2624">This method ignores the `handledEventsToo` parameter information, which is provided if the handler was first added with the <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that enables handling of already-handled events.</span></span> <span data-ttu-id="e7c98-2625">删除任一类型的处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2625">Either type of handler is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeCommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeCommandBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeCommandBindings();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2626">返回序列化进程是否应在此类的实例上序列化 <see cref="P:System.Windows.ContentElement.CommandBindings" /> 属性的内容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2626">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.ContentElement.CommandBindings" /> property on instances of this class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e7c98-2627">如果应当序列化 <see cref="P:System.Windows.ContentElement.CommandBindings" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2627">
              <see langword="true" /> if the <see cref="P:System.Windows.ContentElement.CommandBindings" /> property value should be serialized; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2628">这将返回`true`如果<xref:System.Windows.ContentElement.CommandBindings%2A>本地设置。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2628">This will return `true` if <xref:System.Windows.ContentElement.CommandBindings%2A> is locally set.</span></span>  
  
 <span data-ttu-id="e7c98-2629">这`ShouldSerialize`提供方法，因为<xref:System.Windows.UIElement.CommandBindings%2A>属性不具有简单的默认值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2629">This `ShouldSerialize` method is provided because the <xref:System.Windows.UIElement.CommandBindings%2A> property does not have a simple default value.</span></span> <span data-ttu-id="e7c98-2630">此方法指示属性是否已从其默认值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2630">This method indicates whether the property has changed from its default value.</span></span> <span data-ttu-id="e7c98-2631">如果你正在开发的设计器，或可以开发自己的控件包含通常调用此方法<xref:System.Windows.UIElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2631">You typically invoke this method if you are either developing a designer or developing your own control incorporating a <xref:System.Windows.UIElement>.</span></span>  
  
 <span data-ttu-id="e7c98-2632">有关详细信息，请参阅[使用 ShouldSerialize 和重置方法定义默认值](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2632">For more information, see [Defining Default Values with the ShouldSerialize and Reset Methods](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeInputBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInputBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInputBindings();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2633">返回序列化进程是否应在此类的实例上序列化 <see cref="P:System.Windows.ContentElement.InputBindings" /> 属性的内容。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2633">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.ContentElement.InputBindings" /> property on instances of this class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e7c98-2634">如果应当序列化 <see cref="P:System.Windows.ContentElement.InputBindings" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2634">
              <see langword="true" /> if the <see cref="P:System.Windows.ContentElement.InputBindings" /> property value should be serialized; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2635">这将返回`true`如果<xref:System.Windows.ContentElement.InputBindings%2A>本地设置。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2635">This will return `true` if <xref:System.Windows.ContentElement.InputBindings%2A> is locally set.</span></span>  
  
 <span data-ttu-id="e7c98-2636">这`ShouldSerialize`提供方法，因为<xref:System.Windows.UIElement.InputBindings%2A>属性不具有简单的默认值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2636">This `ShouldSerialize` method is provided because the <xref:System.Windows.UIElement.InputBindings%2A> property does not have a simple default value.</span></span> <span data-ttu-id="e7c98-2637">此方法指示属性是否已从其默认值。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2637">This method indicates whether the property has changed from its default value.</span></span> <span data-ttu-id="e7c98-2638">如果你正在开发的设计器，或可以开发自己的控件包含通常调用此方法<xref:System.Windows.UIElement>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2638">You typically invoke this method if you are either developing a designer or developing your own control incorporating a <xref:System.Windows.UIElement>.</span></span>  
  
 <span data-ttu-id="e7c98-2639">有关详细信息，请参阅[使用 ShouldSerialize 和重置方法定义默认值](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2639">For more information, see [Defining Default Values with the ShouldSerialize and Reset Methods](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2640">在指针位于此元素上并且按下触笔按钮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2640">Occurs when the stylus button is pressed while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2641">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusButtonDown>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2641">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusButtonDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2642">事件处理程序附加到<xref:System.Windows.ContentElement.StylusButtonDown>事件附加到基础<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2642">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusButtonDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2643">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2643">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2644">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2644">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2645">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2645">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2646">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2646">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusButtonDownEvent>|  
|<span data-ttu-id="e7c98-2647">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2647">Routing strategy</span></span>|<span data-ttu-id="e7c98-2648">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-2648">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-2649">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2649">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="e7c98-2650">对应的隧道事件<xref:System.Windows.ContentElement.PreviewStylusButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2650">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusButtonDown>.</span></span>  
  
-   <span data-ttu-id="e7c98-2651">重写<xref:System.Windows.ContentElement.OnStylusButtonDown%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2651">Override <xref:System.Windows.ContentElement.OnStylusButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2652">标识 <see cref="E:System.Windows.ContentElement.StylusButtonDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2652">Identifies the <see cref="E:System.Windows.ContentElement.StylusButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2653">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2653">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2654">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2654">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2655">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2655">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2656">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2656">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2657">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2657">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2658">在指针位于此元素上并且松开触笔按钮时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2658">Occurs when the stylus button is released while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2659">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusButtonUp>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2659">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusButtonUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2660">事件处理程序附加到<xref:System.Windows.ContentElement.StylusButtonUp>事件附加到基础<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2660">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusButtonUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2661">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2661">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2662">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2662">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2663">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2663">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2664">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2664">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusButtonUpEvent>|  
|<span data-ttu-id="e7c98-2665">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2665">Routing strategy</span></span>|<span data-ttu-id="e7c98-2666">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-2666">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-2667">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2667">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="e7c98-2668">对应的隧道事件<xref:System.Windows.ContentElement.PreviewStylusButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2668">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusButtonUp>.</span></span>  
  
-   <span data-ttu-id="e7c98-2669">重写<xref:System.Windows.ContentElement.OnStylusButtonUp%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2669">Override <xref:System.Windows.ContentElement.OnStylusButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2670">标识 <see cref="E:System.Windows.ContentElement.StylusButtonUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2670">Identifies the <see cref="E:System.Windows.ContentElement.StylusButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2671">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2671">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2672">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2672">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2673">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2673">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2674">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2674">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2675">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2675">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ StylusDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2676">在触笔位于此元素上且同时触及数字化器时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2676">Occurs when the stylus touches the digitizer while the stylus is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2677">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusDown>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2677">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2678">事件处理程序附加到<xref:System.Windows.ContentElement.StylusDown>事件附加到基础<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2678">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2679">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2679">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2680">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2680">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2681">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2681">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2682">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2682">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusDownEvent>|  
|<span data-ttu-id="e7c98-2683">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2683">Routing strategy</span></span>|<span data-ttu-id="e7c98-2684">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-2684">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-2685">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2685">Delegate</span></span>|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   <span data-ttu-id="e7c98-2686">对应的隧道事件<xref:System.Windows.ContentElement.PreviewStylusDown>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2686">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusDown>.</span></span>  
  
-   <span data-ttu-id="e7c98-2687">重写<xref:System.Windows.ContentElement.OnStylusDown%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2687">Override <xref:System.Windows.ContentElement.OnStylusDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2688">标识 <see cref="E:System.Windows.ContentElement.StylusDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2688">Identifies the <see cref="E:System.Windows.ContentElement.StylusDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2689">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2689">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2690">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2690">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2691">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2691">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2692">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2692">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2693">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2693">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusEnter As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusEnter;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2694">在触笔进入此元素的边界时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2694">Occurs when the stylus enters the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2695"><xref:System.Windows.ContentElement.StylusEnter> 是[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)使用直接的事件处理路由策略。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2695"><xref:System.Windows.ContentElement.StylusEnter> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="e7c98-2696">在路由过程; 不会引发直接路由的事件相反，它们是在中处理同一个元素引发它们时。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2696">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="e7c98-2697">但是，它们启用路由的事件的行为，如样式中的事件触发器其他的方面。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2697">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="e7c98-2698">尽管<xref:System.Windows.ContentElement.StylusEnter>跟踪何时触笔进入的元素边界内，此事件能够更确切地报告<xref:System.Windows.ContentElement.IsStylusOver%2A>属性值已更改，不再`false`到`true`针对此元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2698">Although <xref:System.Windows.ContentElement.StylusEnter> tracks when the stylus enters the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsStylusOver%2A> property value has changed from `false` to `true` on this element.</span></span>  
  
 <span data-ttu-id="e7c98-2699">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusEnter>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2699">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2700">事件处理程序附加到<xref:System.Windows.ContentElement.StylusEnter>事件附加到基础<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2700">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusEnter> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2701">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2701">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2702">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2702">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2703">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2703">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2704">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2704">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusEnterEvent>|  
|<span data-ttu-id="e7c98-2705">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2705">Routing strategy</span></span>|<span data-ttu-id="e7c98-2706">直接</span><span class="sxs-lookup"><span data-stu-id="e7c98-2706">Direct</span></span>|  
|<span data-ttu-id="e7c98-2707">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2707">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="e7c98-2708">重写<xref:System.Windows.ContentElement.OnStylusEnter%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2708">Override <xref:System.Windows.ContentElement.OnStylusEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2709">标识 <see cref="E:System.Windows.ContentElement.StylusEnter" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2709">Identifies the <see cref="E:System.Windows.ContentElement.StylusEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2710">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2710">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2711">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2711">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2712">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2712">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2713">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2713">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2714">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2714">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInAirMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2715">在触笔掠过元素但并未实际接触数字化器时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2715">Occurs when the stylus moves over an element without actually touching the digitizer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2716">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusInAirMove>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2716">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusInAirMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2717">事件处理程序附加到<xref:System.Windows.ContentElement.StylusInAirMove>事件附加到基础<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2717">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusInAirMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2718">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2718">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2719">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2719">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2720">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2720">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2721">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2721">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusInAirMoveEvent>|  
|<span data-ttu-id="e7c98-2722">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2722">Routing strategy</span></span>|<span data-ttu-id="e7c98-2723">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-2723">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-2724">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2724">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="e7c98-2725">对应的隧道事件<xref:System.Windows.ContentElement.PreviewStylusInAirMove>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2725">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusInAirMove>.</span></span>  
  
-   <span data-ttu-id="e7c98-2726">重写<xref:System.Windows.ContentElement.OnStylusInAirMove%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2726">Override <xref:System.Windows.ContentElement.OnStylusInAirMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInAirMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2727">标识 <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2727">Identifies the <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2728">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2728">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2729">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2729">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2730">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2730">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2731">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2731">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2732">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2732">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2733">在触笔位于此元素上并且触笔与数字化器之间的距离近到足以检测到触笔时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2733">Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2734">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusInRange>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2734">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusInRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2735">事件处理程序附加到<xref:System.Windows.ContentElement.StylusInRange>事件附加到基础<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2735">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusInRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2736">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2736">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2737">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2737">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusInRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2738">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2738">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2739">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2739">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusInRangeEvent>|  
|<span data-ttu-id="e7c98-2740">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2740">Routing strategy</span></span>|<span data-ttu-id="e7c98-2741">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-2741">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-2742">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2742">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="e7c98-2743">对应的隧道事件<xref:System.Windows.ContentElement.PreviewStylusInRange>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2743">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusInRange>.</span></span>  
  
-   <span data-ttu-id="e7c98-2744">重写<xref:System.Windows.ContentElement.OnStylusInRange%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2744">Override <xref:System.Windows.ContentElement.OnStylusInRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2745">标识 <see cref="E:System.Windows.ContentElement.StylusInRange" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2745">Identifies the <see cref="E:System.Windows.ContentElement.StylusInRange" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2746">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2746">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2747">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2747">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2748">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2748">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2749">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2749">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2750">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2750">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusLeave As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusLeave;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2751">在触笔离开元素的边界时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2751">Occurs when the stylus leaves the bounds of the element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2752"><xref:System.Windows.ContentElement.StylusLeave> 是[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)使用直接的事件处理路由策略。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2752"><xref:System.Windows.ContentElement.StylusLeave> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="e7c98-2753">在路由过程; 不会引发直接路由的事件相反，它们是在中处理同一个元素引发它们时。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2753">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="e7c98-2754">但是，它们启用路由的事件的行为，如样式中的事件触发器其他的方面。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2754">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="e7c98-2755">尽管<xref:System.Windows.ContentElement.StylusLeave>触笔离开元素，此事件的边界的详细信息时，跟踪确切地报告<xref:System.Windows.ContentElement.IsStylusOver%2A>属性值已更改，不再`true`到`false`针对此元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2755">Although <xref:System.Windows.ContentElement.StylusLeave> tracks when the stylus leaves the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsStylusOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
 <span data-ttu-id="e7c98-2756">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusLeave>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2756">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2757">事件处理程序附加到<xref:System.Windows.ContentElement.StylusLeave>事件附加到基础<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2757">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusLeave> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2758">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2758">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2759">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2759">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2760">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2760">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2761">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2761">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusLeaveEvent>|  
|<span data-ttu-id="e7c98-2762">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2762">Routing strategy</span></span>|<span data-ttu-id="e7c98-2763">直接</span><span class="sxs-lookup"><span data-stu-id="e7c98-2763">Direct</span></span>|  
|<span data-ttu-id="e7c98-2764">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2764">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="e7c98-2765">重写<xref:System.Windows.ContentElement.OnStylusLeave%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2765">Override <xref:System.Windows.ContentElement.OnStylusLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2766">标识 <see cref="E:System.Windows.ContentElement.StylusLeave" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2766">Identifies the <see cref="E:System.Windows.ContentElement.StylusLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2767">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2767">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2768">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2768">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2769">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2769">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2770">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2770">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2771">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2771">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2772">在触笔移到此元素上时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2772">Occurs when the stylus moves over this element.</span>
          </span>
          <span data-ttu-id="e7c98-2773">触笔必须在位于数字化器上时移动，才会引发此事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2773">The stylus must move while on the digitizer to raise this event.</span>
          </span>
          <span data-ttu-id="e7c98-2774">否则，将改为引发 <see cref="E:System.Windows.ContentElement.StylusInAirMove" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2774">Otherwise, <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> is raised instead.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2775">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusMove>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2775">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2776">事件处理程序附加到<xref:System.Windows.ContentElement.StylusMove>事件附加到基础<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2776">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2777">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2777">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2778">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2778">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2779">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2779">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2780">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2780">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusMoveEvent>|  
|<span data-ttu-id="e7c98-2781">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2781">Routing strategy</span></span>|<span data-ttu-id="e7c98-2782">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-2782">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-2783">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2783">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="e7c98-2784">对应的隧道事件<xref:System.Windows.ContentElement.PreviewStylusMove>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2784">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusMove>.</span></span>  
  
-   <span data-ttu-id="e7c98-2785">重写<xref:System.Windows.ContentElement.OnStylusMove%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2785">Override <xref:System.Windows.ContentElement.OnStylusMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2786">标识 <see cref="E:System.Windows.ContentElement.StylusMove" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2786">Identifies the <see cref="E:System.Windows.ContentElement.StylusMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2787">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2787">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2788">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2788">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2789">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2789">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2790">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2790">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2791">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2791">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusOutOfRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2792">在触笔位于此元素上并且触笔与数字化器之间的距离太远以致无法检测到触笔时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2792">Occurs when the stylus is too far from the digitizer to be detected, while over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2793">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusOutOfRange>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2793">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusOutOfRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2794">事件处理程序附加到<xref:System.Windows.ContentElement.StylusOutOfRange>事件附加到基础<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2794">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusOutOfRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2795">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2795">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2796">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2796">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2797">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2797">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2798">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2798">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusOutOfRangeEvent>|  
|<span data-ttu-id="e7c98-2799">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2799">Routing strategy</span></span>|<span data-ttu-id="e7c98-2800">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-2800">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-2801">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2801">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="e7c98-2802">对应的隧道事件<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2802">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusOutOfRange>.</span></span>  
  
-   <span data-ttu-id="e7c98-2803">重写<xref:System.Windows.ContentElement.OnStylusOutOfRange%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2803">Override <xref:System.Windows.ContentElement.OnStylusOutOfRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusOutOfRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2804">标识 <see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2804">Identifies the <see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2805">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2805">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2806">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2806">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2807">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2807">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2808">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2808">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2809">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2809">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ StylusSystemGesture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2810">在用户采用某一种触笔笔势时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2810">Occurs when a user performs one of several stylus gestures.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2811">有关触笔笔势的详细信息，请参阅<xref:System.Windows.Input.SystemGesture>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2811">For more information about stylus gestures, see <xref:System.Windows.Input.SystemGesture>.</span></span>  
  
 <span data-ttu-id="e7c98-2812">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusSystemGesture>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2812">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusSystemGesture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2813">事件处理程序附加到<xref:System.Windows.ContentElement.StylusSystemGesture>事件附加到基础<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2813">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusSystemGesture> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2814">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2814">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2815">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2815">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2816">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2816">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2817">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2817">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusSystemGestureEvent>|  
|<span data-ttu-id="e7c98-2818">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2818">Routing strategy</span></span>|<span data-ttu-id="e7c98-2819">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-2819">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-2820">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2820">Delegate</span></span>|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   <span data-ttu-id="e7c98-2821">对应的隧道事件<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2821">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusSystemGesture>.</span></span>  
  
-   <span data-ttu-id="e7c98-2822">重写<xref:System.Windows.ContentElement.OnStylusSystemGesture%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2822">Override <xref:System.Windows.ContentElement.OnStylusSystemGesture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusSystemGestureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2823">标识 <see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2823">Identifies the <see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2824">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2824">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2825">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2825">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2826">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2826">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2827">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2827">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2828">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2828">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2829">当触笔位于此元素上并且用户将触笔抬离数字化器时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2829">Occurs when the user raises the stylus off the digitizer while it is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2830">此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.StylusUp>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2830">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2831">事件处理程序附加到<xref:System.Windows.ContentElement.StylusUp>事件附加到基础<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2831">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="e7c98-2832">触摸、 鼠标和触笔输入存在特定的关系。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2832">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="e7c98-2833">有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2833">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2834">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2834">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2835">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2835">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusUpEvent>|  
|<span data-ttu-id="e7c98-2836">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2836">Routing strategy</span></span>|<span data-ttu-id="e7c98-2837">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-2837">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-2838">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2838">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="e7c98-2839">对应的隧道事件<xref:System.Windows.ContentElement.PreviewStylusUp>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2839">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusUp>.</span></span>  
  
-   <span data-ttu-id="e7c98-2840">重写<xref:System.Windows.ContentElement.OnStylusUp%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2840">Override <xref:System.Windows.ContentElement.OnStylusUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2841">标识 <see cref="E:System.Windows.ContentElement.StylusUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2841">Identifies the <see cref="E:System.Windows.ContentElement.StylusUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2842">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2842">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2843">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2843">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2844">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2844">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2845">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2845">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2846">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2846">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ TextInput;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.TextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2847">在此元素以设备无关模式获取文本时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2847">Occurs when this element gets text in a device-independent manner.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="e7c98-2848">处理的复合控件的内部实现，此事件可能已被标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2848">This event might already be marked as handled by the internal implementations of composited controls.</span></span> <span data-ttu-id="e7c98-2849">请参阅下面的备注。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2849">See Remark below.</span></span>  
  
 <span data-ttu-id="e7c98-2850"><xref:System.Windows.ContentElement.TextInput>事件可能已被处理的复合控件的内部实现标记。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2850">The <xref:System.Windows.ContentElement.TextInput> event may already be marked as handled by the internal implementations of composited controls.</span></span> <span data-ttu-id="e7c98-2851">例如，<xref:System.Windows.Controls.TextBox>是一个复合控件，其中<xref:System.Windows.ContentElement.TextInput>事件已被标记为处理; 中其组合。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2851">For example, a <xref:System.Windows.Controls.TextBox> is a composited control where the <xref:System.Windows.ContentElement.TextInput> event is already marked as handled; within its compositing.</span></span> <span data-ttu-id="e7c98-2852">这么做是因为在控件需要解释某些类型的输入，如箭头键，为具有对该控件的特殊含义。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2852">Controls do this because the control needs to interpret some types of input, such as arrow keys, as having special meaning to that control.</span></span> <span data-ttu-id="e7c98-2853">如果你使用<xref:System.Windows.ContentElement.PreviewTextInput>附加处理程序文本输入的位置的事件，你可能会收到更好的结果。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2853">If you use <xref:System.Windows.ContentElement.PreviewTextInput> as the event where you attach handlers for text input, you may receive better results.</span></span> <span data-ttu-id="e7c98-2854">该技术可以应对大多数情况下，其中控件组合已经此事件标记为已处理和防止接收为由事件路由事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2854">This technique circumvents most cases where control composition has already marked this event as handled and prevents your handler from receiving the event along the event route.</span></span>  
  
 <span data-ttu-id="e7c98-2855"><xref:System.Windows.ContentElement.TextInput>事件允许组件或应用程序侦听的文本输入以独立于设备的方式。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2855">The <xref:System.Windows.ContentElement.TextInput> event allows a component or application to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="e7c98-2856">键盘是主种<xref:System.Windows.ContentElement.TextInput>，但语音、 手写和其他输入的设备也可以引发<xref:System.Windows.ContentElement.TextInput>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2856">The keyboard is the primary means of <xref:System.Windows.ContentElement.TextInput>, but speech, handwriting, and other input devices can also raise <xref:System.Windows.ContentElement.TextInput>.</span></span>  
  
 <span data-ttu-id="e7c98-2857">由于键组合 — 默认键盘或输入的法编辑器-多个键事件可能会引发一个文本输入的事件。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2857">Because of key combinations—either in default keyboards or through input method editors—multiple key events might raise just one text input event.</span></span>  
  
 <span data-ttu-id="e7c98-2858">此事件创建一个别名<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.ContentElement.TextInput>摘自类的成员列出时<xref:System.Windows.ContentElement>为该类继承。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2858">This event creates an alias for the <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.TextInput> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="e7c98-2859">事件处理程序附加到<xref:System.Windows.ContentElement.TextInput>事件附加到基础<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2859">Event handlers that are attached to the <xref:System.Windows.ContentElement.TextInput> event are attached to the underlying <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_TextInput"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2860">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2860">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2861">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2861">Identifier field</span></span>|<xref:System.Windows.ContentElement.TextInputEvent>|  
|<span data-ttu-id="e7c98-2862">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2862">Routing strategy</span></span>|<span data-ttu-id="e7c98-2863">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-2863">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-2864">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2864">Delegate</span></span>|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   <span data-ttu-id="e7c98-2865">对应的隧道事件<xref:System.Windows.ContentElement.PreviewTextInput>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2865">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTextInput>.</span></span>  
  
-   <span data-ttu-id="e7c98-2866">重写<xref:System.Windows.ContentElement.OnTextInput%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2866">Override <xref:System.Windows.ContentElement.OnTextInput%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TextInputEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2867">标识 <see cref="E:System.Windows.ContentElement.TextInput" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2867">Identifies the <see cref="E:System.Windows.ContentElement.TextInput" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2868">在注册路由事件时创建路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2868">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="e7c98-2869">这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2869">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="e7c98-2870">可以使用这些标识符添加类处理程序。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2870">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="e7c98-2871">有关注册路由事件的更多信息，请参见 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2871">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="e7c98-2872">有关使用路由事件标识符添加类处理程序的更多信息，请参见 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2872">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2873">当悬停在此元素上方的手指触摸屏幕时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2873">Occurs when a finger touches the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2874">默认情况下，<xref:System.Windows.ContentElement.PreviewTouchDown>和<xref:System.Windows.ContentElement.TouchDown>事件手指触摸屏幕并移动之前不会发生。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2874">By default, the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events do not occur until a finger touches the screen and moves.</span></span> <span data-ttu-id="e7c98-2875">手指在屏幕上按住但不移动会导致按并保存行为<xref:System.Windows.Input.Stylus>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2875">Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <xref:System.Windows.Input.Stylus>.</span></span> <span data-ttu-id="e7c98-2876">按下并保持行为相当于鼠标右键单击。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2876">The press and hold behavior is equivalent to a mouse right-click.</span></span>  
  
 <span data-ttu-id="e7c98-2877">若要使<xref:System.Windows.ContentElement.PreviewTouchDown>和<xref:System.Windows.ContentElement.TouchDown>事件发生只要的手指触摸屏幕上，设置<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>附加到属性`false`此元素。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2877">To cause the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events to occur as soon as a finger touches the screen, set the <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> attached property to `false` for this element.</span></span>  
  
<a name="routedEventInfo_TouchDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2878">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2878">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2879">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2879">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchDownEvent>|  
|<span data-ttu-id="e7c98-2880">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2880">Routing strategy</span></span>|<span data-ttu-id="e7c98-2881">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-2881">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-2882">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2882">Delegate</span></span>|<span data-ttu-id="e7c98-2883"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2883"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="e7c98-2884">对应的隧道事件<xref:System.Windows.ContentElement.PreviewTouchDown>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2884">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchDown>.</span></span>  
  
-   <span data-ttu-id="e7c98-2885">重写<xref:System.Windows.ContentElement.OnTouchDown%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2885">Override <xref:System.Windows.ContentElement.OnTouchDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2886">标识 <see cref="E:System.Windows.ContentElement.TouchDown" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2886">Identifies the <see cref="E:System.Windows.ContentElement.TouchDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchEnter As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2887">在触摸屏输入从此元素边界外部移动到其内部时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2887">Occurs when a touch moves from outside to inside the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e7c98-2888">始终引发此事件，指示为此 UI 元素捕获了触摸设备。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2888">This event is always raised, whether or not the touch device is captured to this UI element.</span></span>  
  
<a name="routedEventInfo_TouchEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2889">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2889">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2890">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2890">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchEnterEvent>|  
|<span data-ttu-id="e7c98-2891">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2891">Routing strategy</span></span>|<span data-ttu-id="e7c98-2892">直接</span><span class="sxs-lookup"><span data-stu-id="e7c98-2892">Direct</span></span>|  
|<span data-ttu-id="e7c98-2893">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2893">Delegate</span></span>|<span data-ttu-id="e7c98-2894"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2894"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="e7c98-2895">重写<xref:System.Windows.ContentElement.OnTouchEnter%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2895">Override <xref:System.Windows.ContentElement.OnTouchEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2896">标识 <see cref="E:System.Windows.ContentElement.TouchEnter" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2896">Identifies the <see cref="E:System.Windows.ContentElement.TouchEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCaptured As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCaptured { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2897">获取在此元素上捕获的所有触摸设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2897">Gets all touch devices that are captured to this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-2898">在此元素上捕获的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2898">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are captured to this element.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCapturedWithin As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCapturedWithin { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2899">获取在此元素或其可视化树中的任何子元素上捕获的所有触摸设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2899">Gets all touch devices that are captured to this element or any child elements in its visual tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-2900">在此元素或其可视化树中的任何子元素上捕获的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2900">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are captured to this element or any child elements in its visual tree.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesDirectlyOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesDirectlyOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2901">获取此元素上的所有触摸设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2901">Gets all touch devices that are over this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-2902">位于此元素上的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2902">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are over this element.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2903">获取在此元素或其可视化树中的任何子元素上的所有触摸设备。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2903">Gets all touch devices that are over this element or any child elements in its visual tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="e7c98-2904">在此元素或其可视化树中的任何子元素上的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2904">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are over this element or any child elements in its visual tree.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchLeave As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2905">在触摸屏输入从此元素边界内部移动到其外部时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2905">Occurs when a touch moves from inside to outside the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2906">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2906">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2907">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2907">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchLeaveEvent>|  
|<span data-ttu-id="e7c98-2908">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2908">Routing strategy</span></span>|<span data-ttu-id="e7c98-2909">直接</span><span class="sxs-lookup"><span data-stu-id="e7c98-2909">Direct</span></span>|  
|<span data-ttu-id="e7c98-2910">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2910">Delegate</span></span>|<span data-ttu-id="e7c98-2911"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2911"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="e7c98-2912">重写<xref:System.Windows.ContentElement.OnTouchLeave%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2912">Override <xref:System.Windows.ContentElement.OnTouchLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2913">标识 <see cref="E:System.Windows.ContentElement.TouchLeave" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2913">Identifies the <see cref="E:System.Windows.ContentElement.TouchLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchMove;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2914">当悬停在此元素上方的手指在屏幕上移动时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2914">Occurs when a finger moves on the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2915">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2915">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2916">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2916">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchMoveEvent>|  
|<span data-ttu-id="e7c98-2917">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2917">Routing strategy</span></span>|<span data-ttu-id="e7c98-2918">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-2918">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-2919">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2919">Delegate</span></span>|<span data-ttu-id="e7c98-2920"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2920"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="e7c98-2921">对应的隧道事件<xref:System.Windows.ContentElement.PreviewTouchMove>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2921">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchMove>.</span></span>  
  
-   <span data-ttu-id="e7c98-2922">重写<xref:System.Windows.ContentElement.OnTouchMove%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2922">Override <xref:System.Windows.ContentElement.OnTouchMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2923">标识 <see cref="E:System.Windows.ContentElement.TouchMove" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2923">Identifies the <see cref="E:System.Windows.ContentElement.TouchMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2924">当悬停在此元素上方的手指从屏幕上移开时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2924">Occurs when a finger is raised off of the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="e7c98-2925">路由事件信息</span><span class="sxs-lookup"><span data-stu-id="e7c98-2925">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="e7c98-2926">标识符字段</span><span class="sxs-lookup"><span data-stu-id="e7c98-2926">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchUpEvent>|  
|<span data-ttu-id="e7c98-2927">路由策略</span><span class="sxs-lookup"><span data-stu-id="e7c98-2927">Routing strategy</span></span>|<span data-ttu-id="e7c98-2928">冒泡</span><span class="sxs-lookup"><span data-stu-id="e7c98-2928">Bubbling</span></span>|  
|<span data-ttu-id="e7c98-2929">委托</span><span class="sxs-lookup"><span data-stu-id="e7c98-2929">Delegate</span></span>|<span data-ttu-id="e7c98-2930"><xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2930"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="e7c98-2931">对应的隧道事件<xref:System.Windows.ContentElement.PreviewTouchUp>。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2931">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchUp>.</span></span>  
  
-   <span data-ttu-id="e7c98-2932">重写<xref:System.Windows.ContentElement.OnTouchUp%2A>实现处理此事件在派生类中的类。</span><span class="sxs-lookup"><span data-stu-id="e7c98-2932">Override <xref:System.Windows.ContentElement.OnTouchUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="e7c98-2933">标识 <see cref="E:System.Windows.ContentElement.TouchUp" /> 路由事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e7c98-2933">Identifies the <see cref="E:System.Windows.ContentElement.TouchUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>