<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DependencyPropertyKey.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac59a12e407bc5345e416145c390f8fcd6f8262c445.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9a12e407bc5345e416145c390f8fcd6f8262c445</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyPropertyKey">
          <source>Provides a dependency property identifier for limited write access to a read-only dependency property.</source>
          <target state="translated">提供依赖项对象标识符，以便对只读依赖项对象进行有限的写访问。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> instances are obtained as the return value of a dependency property registration call using the methods <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> 实例作为依赖项属性注册调用使用方法的返回值中获得的<ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph>或<ph id="ph3">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>The types that register a dependency property can use the <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> in calls to <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph> that adjust the property's value as part of class logic.</source>
          <target state="translated">注册一个依赖项属性的类型可以使用<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>调用<ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph>和<ph id="ph3">&lt;xref:System.Windows.DependencyObject.ClearValue%2A&gt;</ph>，调整属性的值作为类逻辑的一部分。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>If permitted by the access level of the key, related classes can use the key and the dependency property also.</source>
          <target state="translated">如果允许密钥的访问级别，相关的类也可以使用的密钥和依赖项属性。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>For instance, you can declare the key as internal, and other types within the same assembly can also set that dependency property.</source>
          <target state="translated">例如，可以声明为内部，密钥，而同一程序集内的其他类型还可以设置该依赖项属性。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> returned by read-only dependency property registration should not be made public, because exposing the key makes the property settable, thus defeating the point of registering it as a read-only dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>返回的只读依赖属性注册不应成为公共的因为公开键将使该属性可设置，从而与将它注册为只读依赖属性的点。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>Also, exposing the key causes a mismatch between the available dependency property behaviors and its <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> property wrapper implementations, which is bad class design.</source>
          <target state="translated">此外，公开密钥还会使可用依赖项对象之间的不匹配属性行为并将其<ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph>属性包装实现，这是不好的类设计。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>Instead of exposing the key itself, you should instead expose the <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> value of the <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> as a <ph id="ph3">`public static readonly`</ph><ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> on your class.</source>
          <target state="translated">而不是公开密钥本身，而是应公开<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph>值<ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>作为<ph id="ph3">`public static readonly`</ph><ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph>上您的类。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>This enables the property to return a valid dependency property identifier for certain property system operations such as enumerating locally set values.</source>
          <target state="translated">这样，要返回一个有效的依赖属性标识符，对于某些属性系统操作，如枚举本地设置值的属性。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>However, the identifier thus obtained does not have the full capabilities of a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> for many property system operations.</source>
          <target state="translated">但是，从而获取的标识符不具有的全部功能<ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>对于许多属性系统操作。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyPropertyKey">
          <source>The following example registers a read-only dependency property, and also uses the key for two purposes in other class members: implementing the get "wrapper", and as the identifier for a protected determination operation that sets the value based on calculations of other property values.</source>
          <target state="translated">下面的示例来注册只读依赖属性，并还会将密钥用于在其他类成员的两个用途： 实现 get"包装"，并设置的值的受保护的确定操作的标识符作为基于计算其他属性值。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Gets the dependency property identifier associated with this specialized read-only dependency property identifier.</source>
          <target state="translated">获取与此专用只读依赖项对象标识符关联的依赖项对象标识符。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The relevant dependency property identifier.</source>
          <target state="translated">相关的依赖项对象标识符。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> value enables a read-only property's identifier to participate in common property system operations using some of the same interfaces as used for read-write dependency properties.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph>值，将启用要参与到公共使用的相同的接口部分所使用的读写依赖项属性的属性系统操作的只读属性的标识符。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>In order to implement the get property accessor for a read-only dependency property, you should create and expose a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier on your class.</source>
          <target state="translated">为了实现只读依赖属性的 get 属性访问器，你应创建和公开<ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>在类上的标识符。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>This serves two purposes:</source>
          <target state="translated">这有两个用途：</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Your own class needs the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier in order to implement the get accessor for the property wrapper.</source>
          <target state="translated">你自己的类需要<ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>为了实现属性包装了 get 访问器的标识符。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>You use the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> as a parameter for the <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> call that implements the get accessor.</source>
          <target state="translated">你使用<ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>的参数<ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph>实现 get 访问器的调用。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifiers expose your dependency property to the property system such that other methods that rely on metadata can access it in a standard form.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> 标识符公开到属性系统依赖项属性，以便其他依赖于元数据的方法可以在标准窗体中访问它。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>For instance, if you called <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> on some <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> and obtained an enumeration of locally set properties (values and identifiers) the identifier returned for a read-only dependency property would be your <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> value rather than the key.</source>
          <target state="translated">例如，如果调用<ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph>上某些<ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>和标识符获取本地设置的属性 （值和标识符） 的枚举为只读依赖属性将返回你<ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>值而不是键。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Not exposing a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier does not increase the security of your read-only dependency property in any way, it just makes operations that involve your property more awkward both for subsequent derived classes and class instances.</source>
          <target state="translated">不公开<ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>标识符不会增加的安全性以任何方式你只读依赖属性，它只是使牵涉到属性更繁琐后续派生的类和类实例的操作。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>To expose the  <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier on your class, you call <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> directly on your key.</source>
          <target state="translated">若要公开<ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>调用您的类的标识符，<ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph>直接在你的密钥。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>Use this value to create a <ph id="ph1">`public static readonly`</ph><ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier on the class, which parallels the <ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>.</source>
          <target state="translated">使用此值来创建<ph id="ph1">`public static readonly`</ph><ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph>中指的类标识符<ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The following example calls <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph> to expose the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier (<ph id="ph3">`AquariumGraphicProperty`</ph>) for the <ph id="ph4">`AquariumGraphic`</ph> read-only dependency property on a class.</source>
          <target state="translated">下面的示例调用<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A&gt;</ph>公开<ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph>标识符 (<ph id="ph3">`AquariumGraphicProperty`</ph>) 为<ph id="ph4">`AquariumGraphic`</ph>的类上的只读依赖属性。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyPropertyKey.DependencyProperty">
          <source>The example also shows the <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> creation (as an internal member) and the get accessor for <ph id="ph2">`AquariumGraphic`</ph>.</source>
          <target state="translated">该示例还演示<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>（作为内部的成员） 的创建和 get 访问器<ph id="ph2">`AquariumGraphic`</ph>。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The type on which this dependency property exists and metadata should be overridden.</source>
          <target state="translated">作为此依赖项对象存在基础以及应依据其重写元数据的类型。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Metadata supplied for this type.</source>
          <target state="translated">为此类型提供的元数据。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Overrides the metadata of a read-only dependency property that is represented by this dependency property identifier.</source>
          <target state="translated">重写由此依赖项对象标识符表示的只读依赖项对象的元数据。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Overriding metadata on a read-only dependency property is done for similar reasons as overriding metadata on a read-write dependency property, and is restricted to access at the key level because behaviors specified in the metadata can change the set behavior (the default value, for instance).</source>
          <target state="translated">重写只读依赖属性上的元数据出于类似重写上读写依赖项属性的元数据的原因，因为元数据中指定的行为可能会更改的组行为 (仅限于密钥级别的访问权限默认值，例如）。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>As with read-write dependency properties, overriding metadata on a read-only dependency property should only be done prior to that property being placed in use by the property system (this equates to the time that specific instances of objects that register the property are instantiated).</source>
          <target state="translated">为具有读写依赖项属性重写只读依赖属性的元数据应仅在之前完成通过属性系统正在放入使用该属性 (这相当于时间注册的对象的该特定实例属性是实例化）。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Calls to <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph> should only be performed within the static constructors of the type that provides itself as the <ph id="ph2">`forType`</ph> parameter of this method, or equivalent initialization for that class.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A&gt;</ph>仅应在提供本身为的类型的静态构造函数中执行<ph id="ph2">`forType`</ph>此方法或为该类的等效初始化参数。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>This method effectively forwards to the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> method, passing the <ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> instance as the key parameter.</source>
          <target state="translated">此方法有效地将转发到<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>方法，并传递<ph id="ph2">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>作为按键参数的实例。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The following example overrides metadata for an existing read-only dependency property that a class inherits.</source>
          <target state="translated">下面的示例重写现有只读依赖属性的一个类继承的元数据。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>In this case, the scenario goal was to add a coerce value callback that the base property metadata did not have.</source>
          <target state="translated">在这种情况下，方案的目标是要添加的基属性元数据没有强制值回调。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>You could also override metadata for any of the other reasons that overriding metadata is typically appropriate (changing default value, adding <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> values, etc.)</source>
          <target state="translated">任何其他原因，重写元数据通常是适当无法还重写元数据 (更改默认值、 添加<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph>值，等等。)</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Attempted metadata override on a read-write dependency property (cannot be done using this signature).</source>
          <target state="translated">尝试在读写依赖项对象上进行元数据重写（无法使用此签名完成该操作）。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Metadata was already established for the property as it exists on the provided type.</source>
          <target state="translated">当属性存在于提供的类型上时，已为该属性建立元数据。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>