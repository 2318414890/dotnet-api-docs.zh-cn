<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5c5dfef7a02e9b858a22854c1ef79b198ef1d9bc" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30680011" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>定义依赖属性在应用于特定类型（包括该属性向其注册的条件）时行为的某些方面。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以定义的属性元数据，并将其在注册依赖属性过程中调用时使用<xref:System.Windows.DependencyProperty.Register%2A>方法 （或附加的属性或只读依赖属性的变化形式），或调用时的原始所有者注册后<xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>方法。 <xref:System.Windows.DependencyProperty.AddOwner%2A> 此外接受属性元数据。  
  
 此类是一个具体基类，该类可以在其中每一个调用中使用。 但是，它是很常见，用于指定元数据使用的派生类之一如<xref:System.Windows.FrameworkPropertyMetadata>。 这些派生的类支持更多详细的元数据作为可用于检测或启用仅实现在某些属性系统和布局行为的布尔属性值来传输[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]framework 级别。  
  
 此类的几个属性是读写的对对象模型中，但只能之前正在如属性系统操作中使用的实例写入<xref:System.Windows.DependencyProperty.Register%2A>或<xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>。 每个这些属性还可能已设置构造函数，但公开，以便<xref:System.Windows.PropertyMetadata.Merge%2A>方法实现可以设置它们。  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类型，此类型的成员不通常使用和中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.PropertyMetadata" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.PropertyMetadata" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">要为依赖项对象指定的默认值，通常作为某种特定类型的值提供。</param>
        <summary>使用此元数据将应用于的依赖项对象的指定默认值，初始化 <see cref="T:System.Windows.PropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。 因为在 （不匹配会引发运行时异常） 的编译期间不能检测到不匹配，是，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。  
  
 尽管每个无参数构造函数中，默认`defaultValue`的<xref:System.Windows.DependencyProperty.UnsetValue>不能指定。 尝试这样做将引发的异常。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 不能设置为值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都将调用该处理程序实现。</param>
        <summary>用指定的 <see cref="T:System.Windows.PropertyMetadata" /> 实现引用初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项对象的默认值，通常作为某种特定类型的值提供。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都将调用该处理程序实现。</param>
        <summary>用指定的默认值和 <see cref="T:System.Windows.PropertyMetadata" /> 实现引用初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供的值的类型`defaultValue`必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。 因为在 （不匹配会引发运行时异常） 的编译期间不能检测到不匹配，是，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。  
  
 尽管每个无参数构造函数中，默认`defaultValue`的<xref:System.Windows.DependencyProperty.UnsetValue>不能指定。 尝试这样做将引发的异常。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 不能设置为值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项对象的默认值，通常作为某种特定类型的值提供。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都将调用该处理程序实现。</param>
        <param name="coerceValueCallback">对处理程序实现的引用，每当属性系统对该属性调用 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时都将调用此处理程序实现。</param>
        <summary>用指定的默认值和回调初始化 <see cref="T:System.Windows.PropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你想要指定<xref:System.Windows.CoerceValueCallback>但不是<xref:System.Windows.PropertyChangedCallback>，可以将传递`null`为`propertyChangedCallback`参数。  
  
 为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。 因为在 （不匹配会引发运行时异常） 的编译期间不能检测到不匹配，是，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。  
  
 尽管每个无参数构造函数中，默认`defaultValue`的<xref:System.Windows.DependencyProperty.UnsetValue>不能指定。 尝试这样做将引发的异常。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> 不能设置为值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置对此元数据中所指定 <see cref="T:System.Windows.CoerceValueCallback" /> 实现的引用。</summary>
        <value>一个 <see cref="T:System.Windows.CoerceValueCallback" /> 实现引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性元数据中的回调不是上包含的类型，通常公共成员，因此此属性的值并不重要仅仅使用现有依赖项属性的元数据的大多数情况下。 此属性公开的一个原因是，因此，元数据子类可以执行其所需的合并逻辑，如果基本元数据和重写/添加元数据指定<xref:System.Windows.CoerceValueCallback>。 但是，默认值合并逻辑<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>是替换前一个。  
  
 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> 是在对象模型中定义为读写。 也是如此<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>可以初始化后调整<xref:System.Windows.PropertyMetadata>对象本身。 但是，作为对的调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和属性都被视为不可变。 正在尝试设置<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>后<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发的异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">将元数据属性应用于依赖属性操作后，无法设置该属性。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置依赖属性的默认值。</summary>
        <value>属性的默认值。 上的默认值<see cref="T:System.Windows.PropertyMetadata" />使用无参数构造函数创建的实例将<see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 是在对象模型中定义为读写。 也是如此<xref:System.Windows.PropertyMetadata.DefaultValue%2A>可以初始化后调整<xref:System.Windows.PropertyMetadata>对象本身。 但是，作为对的调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和属性都被视为不可变。 正在尝试设置<xref:System.Windows.PropertyMetadata.DefaultValue%2A>后<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发的异常。  
  
 尽管每个无参数构造函数中，默认`defaultValue`的<xref:System.Windows.DependencyProperty.UnsetValue>无法使用设置<xref:System.Windows.PropertyMetadata.DefaultValue%2A>或构造函数。 尝试这样做将引发的异常。  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类型的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">创建之后不能设置为值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <exception cref="T:System.InvalidOperationException">将元数据属性应用于依赖属性操作后，无法设置该属性。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值确定是否已通过某种方式将元数据应用于属性，从而导致该元数据实例变为不可变状态。</summary>
        <value>
          如果元数据实例不可变，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各种属性<xref:System.Windows.PropertyMetadata>，如<xref:System.Windows.PropertyMetadata.DefaultValue%2A>，在为读写模式的对象模型中定义。 这是以便这些属性可进行调整后的初始化<xref:System.Windows.PropertyMetadata>对象本身。 但是，作为对的调用的一部分应用于依赖属性元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和属性都被视为不可变。 在这些调用之一时<xref:System.Windows.PropertyMetadata.OnApply%2A>调用时，此属性的值设置为`true`。  
  
   
  
## Examples  
 下面的示例检查<xref:System.Windows.PropertyMetadata.IsSealed%2A>之前设置操作中的自定义元数据属性。  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">要与此实例的值合并的基元数据。</param>
        <param name="dp">要应用此元数据的依赖项对象。</param>
        <summary>将此元数据与基元数据合并。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重写元数据时在内部使用此方法 (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>方法)。  
  
   
  
## Examples  
 下面的示例实现将附加属性添加到的属性元数据的自定义元数据类型的合并。  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>类实现派生自<see cref="T:System.Windows.PropertyMetadata" />应重写此方法，以考虑它们在其实现中添加任何元数据属性。 例如，您的实现可能会添加新的标志枚举值，与<see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />实现应该能够正确组合这些标志。  
  
 始终调用实现代码中之前, 的基实现，因为基实现负责合并已在上定义的所有属性<see cref="T:System.Windows.PropertyMetadata" />类型。  
  
 由你决定是合并的具体的行为。 你可以选择具有值的组合，请恢复为基的值，如果派生的元数据保留在默认情况下或基于类型的属性已添加到您特定的元数据的类，以及它们的含义的许多其他行为。</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">已应用了元数据的依赖项对象。</param>
        <param name="targetType">与此元数据关联的类型（如果这是特定于类型的元数据）。 如果这是默认元数据，则此值为 null 引用。</param>
        <summary>当此元数据已经应用到一个属性时（这表明正在密封元数据）调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 子类应确保： 数据结构的任何可变性<xref:System.Windows.PropertyMetadata>子类应标记为不可变一次<xref:System.Windows.PropertyMetadata.OnApply%2A>调用。 这将调用后对属性系统操作应用了元数据 （注册、 将所有者添加、 重写元数据）。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置对此元数据中所指定 <see cref="T:System.Windows.PropertyChangedCallback" /> 实现的引用。</summary>
        <value>一个 <see cref="T:System.Windows.PropertyChangedCallback" /> 实现引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性元数据中的回调不是上定义的类型，通常公共成员，因此此属性的值并不重要仅仅使用现有依赖项属性的元数据的大多数情况下。 此属性公开的一个原因是，因此，元数据类可以执行其所需的合并逻辑，如果基本元数据和重写/添加元数据指定<xref:System.Windows.PropertyChangedCallback>。 默认合并逻辑是保持所有<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>表并调用每个联系人，与回调建立由运行第一个层次结构中最深的类的实现。  
  
 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> 是在对象模型中定义为读写。 也是如此<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>可以初始化后调整<xref:System.Windows.PropertyMetadata>对象本身。 但是，作为对的调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和属性都被视为不可变。 正在尝试设置<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>后<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发的异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">将元数据属性应用于依赖属性操作后，无法设置该属性。</exception>
      </Docs>
    </Member>
  </Members>
</Type>