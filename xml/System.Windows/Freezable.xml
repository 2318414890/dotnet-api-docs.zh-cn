<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="973c346f1874ce6fbdd0454e4370d678d8bcf9de" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39786879" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="9d131-101">定义具有可修改状态和只读（冻结）状态的对象。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9d131-101">Defines an object that has a modifiable state and a read-only (frozen) state.</span>
      </span>
      <span data-ttu-id="9d131-102">派生自 <see cref="T:System.Windows.Freezable" /> 的类提供详细的更改通知，可以是不可变的，并且可以进行自我克隆。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9d131-102">Classes that derive from <see cref="T:System.Windows.Freezable" /> provide detailed change notification, can be made immutable, and can clone themselves.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-103"><xref:System.Windows.Freezable>类提供了特殊功能，可帮助提高应用程序性能时使用的成本要修改或复制对象。</span><span class="sxs-lookup"><span data-stu-id="9d131-103">The <xref:System.Windows.Freezable> class provides special features that can help improve application performance when using objects that are expensive to modify or copy.</span></span> <span data-ttu-id="9d131-104">示例<xref:System.Windows.Freezable>对象包括以下项目：</span><span class="sxs-lookup"><span data-stu-id="9d131-104">Examples of <xref:System.Windows.Freezable> objects include the following:</span></span>  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a><span data-ttu-id="9d131-105">从 Freezable 派生</span><span class="sxs-lookup"><span data-stu-id="9d131-105">Deriving From Freezable</span></span>  
 <span data-ttu-id="9d131-106">从派生的类<xref:System.Windows.Freezable>可以获得以下功能：</span><span class="sxs-lookup"><span data-stu-id="9d131-106">A class that derives from <xref:System.Windows.Freezable> gains the following features:</span></span>  
  
-   <span data-ttu-id="9d131-107">特殊状态： 只读 （冻结） 状态和可写状态。</span><span class="sxs-lookup"><span data-stu-id="9d131-107">Special states: a read-only (frozen) state and a writable state.</span></span>  
  
-   <span data-ttu-id="9d131-108">线程安全： 的冻结<xref:System.Windows.Freezable>对象可以在线程之间共享。</span><span class="sxs-lookup"><span data-stu-id="9d131-108">Thread safety: a frozen <xref:System.Windows.Freezable> object can be shared across threads.</span></span>  
  
-   <span data-ttu-id="9d131-109">详细的更改通知： 与其他不同<xref:System.Windows.DependencyObject>对象，<xref:System.Windows.Freezable>子属性值更改时，对象提供更改通知。</span><span class="sxs-lookup"><span data-stu-id="9d131-109">Detailed change notification: Unlike other <xref:System.Windows.DependencyObject> objects, a <xref:System.Windows.Freezable> object provides change notifications when sub-property values change.</span></span>  
  
-   <span data-ttu-id="9d131-110">简单克隆： Freezable 类已经实现生成深层克隆的几种方法。</span><span class="sxs-lookup"><span data-stu-id="9d131-110">Easy cloning: the Freezable class has already implemented several methods that produce deep clones.</span></span>  
  
 <span data-ttu-id="9d131-111">有关使用和创建你自己<xref:System.Windows.Freezable>对象，请参阅[Freezable 对象概述](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="9d131-111">For information on using and creating your own <xref:System.Windows.Freezable> objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="9d131-112">任何公共<see langword="static" />此类型的成员是线程安全。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9d131-112">Any public <see langword="static" /> members of this type are thread safe.</span>
      </span>
      <span data-ttu-id="9d131-113">但不保证所有实例成员都是线程安全的。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9d131-113">Any instance members are not guaranteed to be thread safe.</span>
      </span>
      <span data-ttu-id="9d131-114">当<see cref="P:System.Windows.Freezable.IsFrozen" />属性是<see langword="false" />、<see cref="T:System.Windows.Freezable" />可以仅从其创建的线程访问对象。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9d131-114">When the <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" />, a <see cref="T:System.Windows.Freezable" /> object can be accessed only from the thread on which it was created.</span>
      </span>
      <span data-ttu-id="9d131-115">尝试从另一个线程，则会引发访问<see cref="T:System.InvalidOperationException" />。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9d131-115">Attempting to access it from another thread throws an <see cref="T:System.InvalidOperationException" />.</span>
      </span>
      <span data-ttu-id="9d131-116">
        <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" />和<see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />方法为封送到正确的线程提供支持。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9d131-116">The <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> and <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> methods provide support for marshalling to the correct thread.</span>
      </span>
      <span data-ttu-id="9d131-117">当他们<see cref="P:System.Windows.Freezable.IsFrozen" />属性是<see langword="true" />，<see cref="T:System.Windows.Freezable" />对象是自由线程。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9d131-117">When their <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true" />, <see cref="T:System.Windows.Freezable" /> objects are free-threaded.</span>
      </span>
      <span data-ttu-id="9d131-118">有关详细信息，请参阅 [Freezable 对象概述](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9d131-118">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9d131-119">初始化 <see cref="T:System.Windows.Freezable" /> 派生类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-119">Initializes a new instance of a <see cref="T:System.Windows.Freezable" /> derived class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-120">这是一个抽象类的受保护的可访问性构造函数。</span><span class="sxs-lookup"><span data-stu-id="9d131-120">This is the protected-accessibility constructor of an abstract class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9d131-121">获取一个值，该值指示是否可将对象变为不可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-121">Gets a value that indicates whether the object can be made unmodifiable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9d131-122">如果当前对象可以变为不可修改，或者已经不可修改，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-122">
              <see langword="true" /> if the current object can be made unmodifiable or is already unmodifiable; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="9d131-123">
            <para>此方法的实现使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法替换<paramref name="isChecking" />设置为<see langword="true" />来确定是否<see cref="T:System.Windows.Freezable" />可变为不可修改。若要修改此属性在派生类中的行为的方式，请重写<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-123">
              <para>This method implementation uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method with <paramref name="isChecking" /> set to <see langword="true" /> to determine whether a <see cref="T:System.Windows.Freezable" /> can be made unmodifiable. To modify the way this property behaves in a derived class, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9d131-124">在修改 <see cref="T:System.Windows.Freezable" /> 或其包含的对象时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-124">Occurs when the <see cref="T:System.Windows.Freezable" /> or an object it contains is modified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-125">如果你尝试添加或删除事件处理程序时它不能修改当前对象 (当<xref:System.Windows.Freezable.IsFrozen%2A>属性是`true`)，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="9d131-125">If you attempt to add or remove event handlers when the current object is not modifiable (when the <xref:System.Windows.Freezable.IsFrozen%2A> property is `true`), an exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9d131-126">创建 <see cref="T:System.Windows.Freezable" /> 的一个可修改复本，从而制作该对象的值的深层副本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-126">Creates a modifiable clone of the <see cref="T:System.Windows.Freezable" />, making deep copies of the object's values.</span>
          </span>
          <span data-ttu-id="9d131-127">在复制此对象的依赖属性时，此方法会复制表达式（可能不再解析），但不复制动画或其当前值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-127">When copying the object's dependency properties, this method copies expressions (which might no longer resolve) but not animations or their current values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d131-128">当前对象的可修改复本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-128">A modifiable clone of the current object.</span>
          </span>
          <span data-ttu-id="9d131-129">即使源的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性为 <see langword="true." />，所克隆对象的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性也为 <see langword="false" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-129">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-130"><xref:System.Windows.Freezable.Clone%2A>并<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法将产生的可修改克隆冻结<xref:System.Windows.Freezable>对象 (方法还克隆<xref:System.Windows.Freezable>未被冻结的对象)。</span><span class="sxs-lookup"><span data-stu-id="9d131-130">The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects (the methods also clone <xref:System.Windows.Freezable> objects that are not frozen).</span></span> <span data-ttu-id="9d131-131">复本实际上是当前对象的深层副本。</span><span class="sxs-lookup"><span data-stu-id="9d131-131">The clone is effectively a deep copy of the current object.</span></span>  
  
 <span data-ttu-id="9d131-132">下表总结了之间的差异<xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9d131-132">The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.</span></span>  
  
|<span data-ttu-id="9d131-133">操作</span><span class="sxs-lookup"><span data-stu-id="9d131-133">Action</span></span>|<span data-ttu-id="9d131-134">克隆方法行为</span><span class="sxs-lookup"><span data-stu-id="9d131-134">Clone method behavior</span></span>|<span data-ttu-id="9d131-135">CloneCurrentValue 方法行为</span><span class="sxs-lookup"><span data-stu-id="9d131-135">CloneCurrentValue method behavior</span></span>|  
|------------|---------------------------|---------------------------------------|  
|<span data-ttu-id="9d131-136">复制包含的表达式的依赖项属性</span><span class="sxs-lookup"><span data-stu-id="9d131-136">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="9d131-137">表达式复制，但可能不再解析。</span><span class="sxs-lookup"><span data-stu-id="9d131-137">The expression is copied, but might no longer resolve.</span></span> <span data-ttu-id="9d131-138">有关详细信息，请参阅 [Freezable 对象概述](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="9d131-138">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>|<span data-ttu-id="9d131-139">复制当前表达式的值，但不是表达式本身。</span><span class="sxs-lookup"><span data-stu-id="9d131-139">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="9d131-140">复制一个动画的依赖项属性</span><span class="sxs-lookup"><span data-stu-id="9d131-140">Copying an animated dependency property</span></span>|<span data-ttu-id="9d131-141">复制属性的基 （非动画的） 值。</span><span class="sxs-lookup"><span data-stu-id="9d131-141">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="9d131-142">不复制动画。</span><span class="sxs-lookup"><span data-stu-id="9d131-142">Animations are not copied.</span></span>|<span data-ttu-id="9d131-143">复制属性的当前动画的值。</span><span class="sxs-lookup"><span data-stu-id="9d131-143">The property's current animated value is copied.</span></span> <span data-ttu-id="9d131-144">不复制动画。</span><span class="sxs-lookup"><span data-stu-id="9d131-144">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="9d131-145">请注意，取消设置的属性将不会复制。</span><span class="sxs-lookup"><span data-stu-id="9d131-145">Note that unset properties are not copied.</span></span> <span data-ttu-id="9d131-146">如果未设置的属性的默认值，则冻结<xref:System.Windows.Freezable>，属性值保持在其他可修改复本冻结状态。</span><span class="sxs-lookup"><span data-stu-id="9d131-146">If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
## <a name="move-a-freezable-between-threads"></a><span data-ttu-id="9d131-147">Freezable 在线程间移动</span><span class="sxs-lookup"><span data-stu-id="9d131-147">Move a Freezable Between Threads</span></span>  
 <span data-ttu-id="9d131-148">此方法也可用于移动<xref:System.Windows.Freezable>线程之间。</span><span class="sxs-lookup"><span data-stu-id="9d131-148">This method can be useful for moving a <xref:System.Windows.Freezable> between threads.</span></span> <span data-ttu-id="9d131-149">首先，请<xref:System.Windows.Freezable>变为不可修改通过调用其<xref:System.Windows.Freezable.Freeze%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9d131-149">First, make the <xref:System.Windows.Freezable> unmodifiable by calling its <xref:System.Windows.Freezable.Freeze%2A> method.</span></span> <span data-ttu-id="9d131-150">现在，另一个线程可以访问<xref:System.Windows.Freezable>并进行本地<xref:System.Windows.Freezable.Clone%2A>，它可以访问。</span><span class="sxs-lookup"><span data-stu-id="9d131-150">Now another thread can access the <xref:System.Windows.Freezable> and make a local <xref:System.Windows.Freezable.Clone%2A> that it can access.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="9d131-151">
            <para>此方法使用<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />生成复本。若要修改此方法在派生类中的行为，请重写<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />方法。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-151">
              <para>This method uses <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> to produce the clone. To modify the behavior of this method in a derived class, override the <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="9d131-152">要克隆的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-152">The object to clone.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d131-153">使用基（未经过动画处理的）属性值使该实例成为指定 <see cref="T:System.Windows.Freezable" /> 的克隆（深层复制）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-153">Makes the instance a clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-154">调用此方法<xref:System.Windows.Freezable.Clone%2A>方法应不直接从代码中，除非调用在调用时重写此方法的基实现。</span><span class="sxs-lookup"><span data-stu-id="9d131-154">This method is called by the <xref:System.Windows.Freezable.Clone%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="9d131-155">若要创建当前对象的可修改副本，请调用<xref:System.Windows.Freezable.Clone%2A>而不是直接调用此方法。</span><span class="sxs-lookup"><span data-stu-id="9d131-155">To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.Clone%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="9d131-156">
            <para>如果从其中派生<see cref="T:System.Windows.Freezable" />，可能需要重写此方法。重写的原因包括以下:-派生的类具有未通过依赖关系属性公开的数据。 -在派生的类必须执行额外的初始化工作，不能通过仅重写<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。例如，这适用于你的派生的类实现<see cref="T:System.ComponentModel.ISupportInitialize" />。依赖项属性中存储其所有数据且，不需要执行额外的初始化工作的类无需重写<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />。所有实现，都调用此方法的基实现至关重要。实现才应执行的默认实现不执行工作。默认实现使所有可写入的本地设置的属性，包括内部的表达式的深层副本。如果对象具有数据绑定依赖关系属性，表达式被复制，但可能不再解析。有关克隆数据绑定对象的详细信息，请参阅[Freezable 对象概述](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。如果对象具有动画的依赖属性，复制这些属性的基 （非动画的） 值。不复制动画。请注意，取消设置的属性不会复制，也不是只读的属性。如果此类属性的默认值，则冻结<see cref="T:System.Windows.Freezable" />，属性值保持在其他可修改复本冻结状态。以下列表总结了此方法的预期的行为:-生成的副本包含的所有副本<see cref="T:System.Windows.Freezable" />子对象。 -不复制取消设置和只读属性。 的复制表达式。 -None 这些子对象的已冻结上创建。 的本身副本未被冻结。 的不会复制动画。 -仅属性基值是复制而非当前的动画的值。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-156">
              <para>If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation makes deep copies of all writable, locally set properties, including internal expressions.  If the object has data-bound dependency properties, the expressions are copied but might no longer resolve. For more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). If the object has animated dependency properties, the base (non-animated) value of those properties is copied. Animations are not copied.  Note that unset properties are not copied, nor are read-only properties. If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.  The following list summarizes the expected behavior for this method:  -   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.  -   Unset and read-only properties are not copied.  -   Expressions are copied.  -   None of these sub-objects are frozen on creation.  -   The copy itself is not frozen.  -   Animations are not copied.  -   Only property base values are copied, not current animated values.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9d131-157">使用 <see cref="T:System.Windows.Freezable" /> 的当前值创建其可修改复本（深层副本）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-157">Creates a modifiable clone (deep copy) of the <see cref="T:System.Windows.Freezable" /> using its current values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d131-158">当前对象的可修改复本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-158">A modifiable clone of the current object.</span>
          </span>
          <span data-ttu-id="9d131-159">即使源的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性为 <see langword="true." />，所克隆对象的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性也为 <see langword="false" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-159">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-160"><xref:System.Windows.Freezable.Clone%2A>并<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法将产生的可修改克隆冻结<xref:System.Windows.Freezable>对象 (方法还克隆<xref:System.Windows.Freezable>未被冻结的对象)。</span><span class="sxs-lookup"><span data-stu-id="9d131-160">The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects (the methods also clone <xref:System.Windows.Freezable> objects that are not frozen).</span></span> <span data-ttu-id="9d131-161">复本实际上是当前对象的深层副本。</span><span class="sxs-lookup"><span data-stu-id="9d131-161">The clone is effectively a deep copy of the current object.</span></span>  
  
 <span data-ttu-id="9d131-162">下表总结了之间的差异<xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9d131-162">The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.</span></span>  
  
|<span data-ttu-id="9d131-163">操作</span><span class="sxs-lookup"><span data-stu-id="9d131-163">Action</span></span>|<span data-ttu-id="9d131-164">克隆方法行为</span><span class="sxs-lookup"><span data-stu-id="9d131-164">Clone method behavior</span></span>|<span data-ttu-id="9d131-165">CloneCurrentValue 方法行为</span><span class="sxs-lookup"><span data-stu-id="9d131-165">CloneCurrentValue method behavior</span></span>|  
|------------|---------------------------|---------------------------------------|  
|<span data-ttu-id="9d131-166">复制包含的表达式的依赖项属性</span><span class="sxs-lookup"><span data-stu-id="9d131-166">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="9d131-167">表达式复制，但可能不再解析。</span><span class="sxs-lookup"><span data-stu-id="9d131-167">The expression is copied, but might no longer resolve.</span></span> <span data-ttu-id="9d131-168">有关详细信息，请参阅 [Freezable 对象概述](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="9d131-168">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>|<span data-ttu-id="9d131-169">复制当前表达式的值，但不是表达式本身。</span><span class="sxs-lookup"><span data-stu-id="9d131-169">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="9d131-170">复制一个动画的依赖项属性</span><span class="sxs-lookup"><span data-stu-id="9d131-170">Copying an animated dependency property</span></span>|<span data-ttu-id="9d131-171">复制属性的基 （非动画的） 值。</span><span class="sxs-lookup"><span data-stu-id="9d131-171">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="9d131-172">不复制动画。</span><span class="sxs-lookup"><span data-stu-id="9d131-172">Animations are not copied.</span></span>|<span data-ttu-id="9d131-173">复制属性的当前动画的值。</span><span class="sxs-lookup"><span data-stu-id="9d131-173">The property's current animated value is copied.</span></span> <span data-ttu-id="9d131-174">不复制动画。</span><span class="sxs-lookup"><span data-stu-id="9d131-174">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="9d131-175">请注意，取消设置的属性将不会复制。</span><span class="sxs-lookup"><span data-stu-id="9d131-175">Note that unset properties are not copied.</span></span> <span data-ttu-id="9d131-176">如果未设置的属性的默认值，则冻结<xref:System.Windows.Freezable>，属性值保持在其他可修改复本冻结状态。</span><span class="sxs-lookup"><span data-stu-id="9d131-176">If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
## <a name="move-a-freezable-between-threads"></a><span data-ttu-id="9d131-177">Freezable 在线程间移动</span><span class="sxs-lookup"><span data-stu-id="9d131-177">Move a Freezable Between Threads</span></span>  
 <span data-ttu-id="9d131-178">此方法也可用于移动<xref:System.Windows.Freezable>线程之间。</span><span class="sxs-lookup"><span data-stu-id="9d131-178">This method can be useful for moving a <xref:System.Windows.Freezable> between threads.</span></span> <span data-ttu-id="9d131-179">首先，请<xref:System.Windows.Freezable>变为不可修改通过使用其<xref:System.Windows.Freezable.Freeze%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9d131-179">First, make the <xref:System.Windows.Freezable> unmodifiable by using its <xref:System.Windows.Freezable.Freeze%2A> method.</span></span> <span data-ttu-id="9d131-180">现在，另一个线程可以访问<xref:System.Windows.Freezable>并使它可以访问的本地克隆。</span><span class="sxs-lookup"><span data-stu-id="9d131-180">Now another thread can access the <xref:System.Windows.Freezable> and make a local clone that it can access.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="9d131-181">
            <para>此方法使用<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />方法以生成克隆;<see cref="T:System.Windows.Freezable" />实施者，他们重写<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />必须确保副本上创建未被冻结。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-181">
              <para>This method uses the <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> method to produce the clone; <see cref="T:System.Windows.Freezable" /> implementers who override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> must ensure that the copy is not frozen on creation.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="9d131-182">要克隆的 <see cref="T:System.Windows.Freezable" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-182">The <see cref="T:System.Windows.Freezable" /> to be cloned.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d131-183">使用当前属性值使该实例成为指定 <see cref="T:System.Windows.Freezable" /> 的可修改克隆（深层复制）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-183">Makes the instance a modifiable clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using current property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-184">调用此方法<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法应不直接从代码中，除非调用在调用时重写此方法的基实现。</span><span class="sxs-lookup"><span data-stu-id="9d131-184">This method is called by the <xref:System.Windows.Freezable.CloneCurrentValue%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="9d131-185">若要创建当前对象的可修改副本，请调用<xref:System.Windows.Freezable.CloneCurrentValue%2A>而不是直接调用此方法。</span><span class="sxs-lookup"><span data-stu-id="9d131-185">To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.CloneCurrentValue%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="9d131-186">
            <para>如果从其中派生<see cref="T:System.Windows.Freezable" />，可能需要重写此方法。重写的原因包括以下:-派生的类具有未通过依赖关系属性公开的数据。 -在派生的类必须执行额外的初始化工作，不能通过仅重写<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。例如，这适用于你的派生的类实现<see cref="T:System.ComponentModel.ISupportInitialize" />。依赖项属性中存储其所有数据且，不需要执行额外的初始化工作的类无需重写<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />。所有实现，都调用此方法的基实现至关重要。实现才应执行的默认实现不执行工作。默认实现使所有可写入的本地设置属性的深层副本。如果对象包含与表达式 （如数据绑定） 的依赖项属性，该表达式的当前值被复制但不是表达式本身。如果该对象具有经过动画处理的依赖项属性，复制这些属性经过动画处理的当前值，但动画不是。请注意，取消设置的属性不会复制，也不是只读的属性。如果此类属性的默认值，则冻结<see cref="T:System.Windows.Freezable" />，属性值保持在其他可修改复本冻结状态。以下列表总结了此方法的预期的行为。 的生成副本包含的所有副本<see cref="T:System.Windows.Freezable" />子对象。 -不复制取消设置和只读属性。 -如果某个属性进行动画处理，复制其当前值，但动画本身不是。 -None 这些子对象的已冻结上创建。 的本身副本未被冻结。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-186">
              <para>If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation makes deep copies of all writable, locally set properties. If the object contains dependency properties with expressions (such as a data binding), the current value of the expression is copied but not the expression itself.  If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.  Note that unset properties are not copied, nor are read-only properties. If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.  The following list summarizes the expected behavior for this method.  -   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.  -   Unset and read-only properties are not copied.  -   If a property is animated, its current value is copied, but the animation itself is not.  -   None of these sub-objects are frozen on creation.  -   The copy itself is not frozen.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9d131-187">初始化 <see cref="T:System.Windows.Freezable" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-187">Initializes a new instance of the <see cref="T:System.Windows.Freezable" /> class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d131-188">新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-188">The new instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-189">这是一个受保护的方法，并实际对象特定于实现的行为依赖于的重写实现<xref:System.Windows.Freezable.CreateInstanceCore%2A>方法，此方法在内部调用。</span><span class="sxs-lookup"><span data-stu-id="9d131-189">This is a protected method, and the actual object-specific implementations for the behavior are dependent on the override implementation of the <xref:System.Windows.Freezable.CreateInstanceCore%2A> method, which this method calls internally.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9d131-190">在派生类中实现时，创建 <see cref="T:System.Windows.Freezable" /> 派生类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-190">When implemented in a derived class, creates a new instance of the <see cref="T:System.Windows.Freezable" /> derived class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d131-191">新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-191">The new instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-192">请勿调用此方法，直接 （但调用基实现中）。</span><span class="sxs-lookup"><span data-stu-id="9d131-192">Do not call this method directly (except when calling base in an implementation).</span></span> <span data-ttu-id="9d131-193">在内部调用此方法<xref:System.Windows.Freezable.CreateInstance%2A>方法时的新实例<xref:System.Windows.Freezable>创建。</span><span class="sxs-lookup"><span data-stu-id="9d131-193">This method is called internally by the <xref:System.Windows.Freezable.CreateInstance%2A> method whenever a new instance of the <xref:System.Windows.Freezable> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9d131-194">下面的示例演示的典型实现<xref:System.Windows.Freezable.CreateInstanceCore%2A>。</span><span class="sxs-lookup"><span data-stu-id="9d131-194">The following example shows a typical implementation of <xref:System.Windows.Freezable.CreateInstanceCore%2A>.</span></span>  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="9d131-195">
            <para>每个<see cref="T:System.Windows.Freezable" />派生的类必须实现此方法。一个典型的实现是只需调用默认构造函数，并返回结果。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-195">
              <para>Every <see cref="T:System.Windows.Freezable" /> derived class must implement this method. A typical implementation is to simply call the default constructor and return the result.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9d131-196">使 <see cref="T:System.Windows.Freezable" /> 对象变为不可修改并将其 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性设置为 <see langword="true" />，或测试是否可将 <see cref="T:System.Windows.Freezable" /> 对象变为不可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-196">Makes a <see cref="T:System.Windows.Freezable" /> object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />, or tests whether a <see cref="T:System.Windows.Freezable" /> object can be made unmodifiable.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9d131-197">使当前对象变为不可修改并将其 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性设置为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-197">Makes the current object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-198">若要避免错误的可能性<xref:System.InvalidOperationException>调用此方法时，检查<xref:System.Windows.Freezable.CanFreeze%2A>属性来确定是否<xref:System.Windows.Freezable>可以成为不可修改之前调用此方法。</span><span class="sxs-lookup"><span data-stu-id="9d131-198">To avoid the possibility of an <xref:System.InvalidOperationException> when calling this method, check the <xref:System.Windows.Freezable.CanFreeze%2A> property to determine whether the <xref:System.Windows.Freezable> can be made unmodifiable before calling this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9d131-199">无法使 <see cref="T:System.Windows.Freezable" /> 变为不可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-199">The <see cref="T:System.Windows.Freezable" /> cannot be made unmodifiable.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="9d131-200">
            <para>此方法使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法，使<see cref="T:System.Windows.Freezable" />变为不可修改。若要修改冻结行为，请重写<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-200">
              <para>This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable. To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">
          <span data-ttu-id="9d131-201">要检查或要变为不可修改的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-201">The object to check or make unmodifiable.</span>
          </span>
          <span data-ttu-id="9d131-202">如果 <c>isChecking</c> 为 <see langword="true" />，则检查此对象，以确定是否可将其变为不可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-202">If <c>isChecking</c> is <see langword="true" />, the object is checked to determine whether it can be made unmodifiable.</span>
          </span>
          <span data-ttu-id="9d131-203">如果 <c>isChecking</c> 为 <see langword="false" />，则在可能的情况下将此对象变为不可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-203">If <c>isChecking</c> is <see langword="false" />, the object is made unmodifiable, if possible.</span>
          </span>
        </param>
        <param name="isChecking">
          <span data-ttu-id="9d131-204">若为 <see langword="true" />，则返回是否可冻结对象的指示（不实际冻结对象）；若为 <see langword="false" />，则实际冻结对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-204">
              <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d131-205">如果 <paramref name="isChecking" /> 参数为 <see langword="true" />，则此方法指示是否可将指定的 <see cref="T:System.Windows.Freezable" /> 变为不可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-205">If the <paramref name="isChecking" /> parameter is <see langword="true" />, this method indicates whether the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable.</span>
          </span>
          <span data-ttu-id="9d131-206">如果 <paramref name="isChecking" /> 参数为 <see langword="false" />，则此方法尝试将指定的 <see cref="T:System.Windows.Freezable" /> 变为不可修改，并指示操作是否成功。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-206">If the <paramref name="isChecking" /> parameter is <see langword="false" />, this method attempts to make the specified <see cref="T:System.Windows.Freezable" /> unmodifiable and indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d131-207">当 <paramref name="isChecking" /> 为 <see langword="true" /> 时，如果可以将指定的 <see cref="T:System.Windows.Freezable" /> 变为不可修改，则此方法返回 <see langword="true" />；如果无法将其变为不可修改，则返回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-207">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
          <span data-ttu-id="9d131-208">当 <paramref name="isChecking" /> 为 <see langword="false" /> 时，如果指定的 <see cref="T:System.Windows.Freezable" /> 目前已经不可修改，则此方法返回 <see langword="true" />；如果无法将其变为不可修改，则返回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-208">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-209">不要调用此方法，除非派生自<xref:System.Windows.Freezable>并重写<xref:System.Windows.Freezable.FreezeCore%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9d131-209">Do not call this method unless you are deriving from <xref:System.Windows.Freezable> and overriding the <xref:System.Windows.Freezable.FreezeCore%2A> method.</span></span>  <span data-ttu-id="9d131-210">此方法可在<xref:System.Windows.Freezable.FreezeCore%2A>方法冻结类数据成员本身是<xref:System.Windows.Freezable>对象。</span><span class="sxs-lookup"><span data-stu-id="9d131-210">This method may be used in the <xref:System.Windows.Freezable.FreezeCore%2A> method to freeze class data members that are themselves <xref:System.Windows.Freezable> objects.</span></span>  
  
 <span data-ttu-id="9d131-211">在再次调用此方法是好<xref:System.Windows.Freezable>已被冻结 （不可修改） 的对象。</span><span class="sxs-lookup"><span data-stu-id="9d131-211">It is alright to call this method again on a <xref:System.Windows.Freezable> object that is already frozen (unmodifiable).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9d131-212">如果 <paramref name="isChecking" /> 为 <see langword="false" />，则表明将 <paramref name="freezable" /> 变为不可修改的尝试已失败；对象目前处于未知状态（可能已将其部分冻结）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-212">When <paramref name="isChecking" /> is <see langword="false" />, the attempt to make <paramref name="freezable" /> unmodifiable was unsuccessful; the object is now in an unknown state (it might be partially frozen).</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="9d131-213">
            <para>此方法使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法，使<see cref="T:System.Windows.Freezable" />变为不可修改。若要修改冻结行为，请重写<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-213">
              <para>This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable. To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          <span data-ttu-id="9d131-214">若为 <see langword="true" />，则返回是否可冻结对象的指示（不实际冻结对象）；若为 <see langword="false" />，则实际冻结对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-214">
              <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d131-215">使 <see cref="T:System.Windows.Freezable" /> 对象变为不可修改或测试是否可将其变为不可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-215">Makes the <see cref="T:System.Windows.Freezable" /> object unmodifiable or tests whether it can be made unmodifiable.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d131-216">当 <paramref name="isChecking" /> 为 <see langword="true" /> 时，如果可以将 <see cref="T:System.Windows.Freezable" /> 变为不可修改，则此方法返回 <see langword="true" />；如果无法将其变为不可修改，则返回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-216">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
          <span data-ttu-id="9d131-217">当 <paramref name="isChecking" /> 为 <see langword="false" /> 时，如果指定的 <see cref="T:System.Windows.Freezable" /> 目前已经不可修改，则此方法返回 <see langword="true" />，如果无法将其变为不可修改，则返回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-217">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-218">请勿调用此方法，直接 （但调用基实现中）。</span><span class="sxs-lookup"><span data-stu-id="9d131-218">Do not call this method directly (except when calling base in an implementation).</span></span> <span data-ttu-id="9d131-219">在内部调用此方法<xref:System.Windows.Freezable.CanFreeze%2A>属性 (与`isChecking`等于`true`) 和<xref:System.Windows.Freezable.Freeze%2A>方法 (与`isChecking`等于`false`)。</span><span class="sxs-lookup"><span data-stu-id="9d131-219">This method is called internally by the <xref:System.Windows.Freezable.CanFreeze%2A> property (with `isChecking` equal to `true`) and the <xref:System.Windows.Freezable.Freeze%2A> method (with `isChecking` equal to `false`).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="9d131-220">
            <para>
              <see cref="T:System.Windows.Freezable" /> 此类包含不使用依赖项属性存储的数据时，实施者必须重写此方法。一个典型的实现应调用基类，然后调用静态<see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />方法对所有<see cref="T:System.Windows.Freezable" />类型的类包含，返回的属性<see langword="true" />仅当所有属性都被冻结 （或可能已被冻结，在指定的情况下<see langword="true" />为<paramref name="isChecking" />)。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-220">
              <para>
                <see cref="T:System.Windows.Freezable" /> implementers must override this method when the class contains data that is not stored using dependency properties.  A typical implementation would call base, then call the static <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> method on all <see cref="T:System.Windows.Freezable" /> typed properties that the class contains, returning <see langword="true" /> only if all properties were frozen (or could have been frozen, in the case of specifying <see langword="true" /> for <paramref name="isChecking" />).</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9d131-221">使用基（未经过动画处理的）属性值创建 <see cref="T:System.Windows.Freezable" /> 的冻结副本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-221">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" />, using base (non-animated) property values.</span>
          </span>
          <span data-ttu-id="9d131-222">由于副本已冻结，因此将通过引用复制任何冻结的子对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-222">Because the copy is frozen, any frozen sub-objects are copied by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d131-223">
            <see cref="T:System.Windows.Freezable" /> 的冻结副本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-223">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="9d131-224">副本的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性设置为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-224">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-225">应检查<xref:System.Windows.Freezable.CanFreeze%2A>之前调用此方法以验证属性<xref:System.Windows.Freezable>可以冻结。</span><span class="sxs-lookup"><span data-stu-id="9d131-225">You should check the <xref:System.Windows.Freezable.CanFreeze%2A> property before calling this method to verify that the <xref:System.Windows.Freezable> can be frozen.</span></span> <span data-ttu-id="9d131-226">使用此方法是创建副本都使用类似<xref:System.Windows.Freezable.Clone%2A>，然后将其与冻结<xref:System.Windows.Freezable.Freeze%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9d131-226">Using this method is similar to creating a copy using the <xref:System.Windows.Freezable.Clone%2A> and then freezing it with the <xref:System.Windows.Freezable.Freeze%2A> method.</span></span>  
  
 <span data-ttu-id="9d131-227"><xref:System.Windows.Freezable.GetAsFrozen%2A>并<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法可以提高复制性能，因为它们不会克隆<xref:System.Windows.Freezable>子对象的已冻结; 它们仅将它们复制按引用。</span><span class="sxs-lookup"><span data-stu-id="9d131-227">The <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods can improve copying performance because they do not clone <xref:System.Windows.Freezable> sub-objects that are already frozen; they only copy them by reference.</span></span>  
  
 <span data-ttu-id="9d131-228">下表总结了之间的差异<xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9d131-228">The following table summarizes the differences between the <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods.</span></span>  
  
|<span data-ttu-id="9d131-229">操作</span><span class="sxs-lookup"><span data-stu-id="9d131-229">Action</span></span>|<span data-ttu-id="9d131-230">GetAsFrozen 方法行为</span><span class="sxs-lookup"><span data-stu-id="9d131-230">GetAsFrozen method behavior</span></span>|<span data-ttu-id="9d131-231">GetCurrentValueAsFrozen 方法行为</span><span class="sxs-lookup"><span data-stu-id="9d131-231">GetCurrentValueAsFrozen method behavior</span></span>|  
|------------|---------------------------------|---------------------------------------------|  
|<span data-ttu-id="9d131-232">复制包含的表达式的依赖项属性</span><span class="sxs-lookup"><span data-stu-id="9d131-232">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="9d131-233">该方法将引发<xref:System.InvalidOperationException>因为它不能<xref:System.Windows.Freezable.Freeze%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="9d131-233">The method throws an <xref:System.InvalidOperationException> because it cannot <xref:System.Windows.Freezable.Freeze%2A> the property.</span></span>|<span data-ttu-id="9d131-234">复制当前表达式的值，但不是表达式本身。</span><span class="sxs-lookup"><span data-stu-id="9d131-234">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="9d131-235">复制一个动画的依赖项属性</span><span class="sxs-lookup"><span data-stu-id="9d131-235">Copying an animated dependency property</span></span>|<span data-ttu-id="9d131-236">复制属性的基 （非动画的） 值。</span><span class="sxs-lookup"><span data-stu-id="9d131-236">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="9d131-237">不复制动画。</span><span class="sxs-lookup"><span data-stu-id="9d131-237">Animations are not copied.</span></span>|<span data-ttu-id="9d131-238">复制属性的当前动画的值。</span><span class="sxs-lookup"><span data-stu-id="9d131-238">The property's current animated value is copied.</span></span> <span data-ttu-id="9d131-239">不复制动画。</span><span class="sxs-lookup"><span data-stu-id="9d131-239">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="9d131-240">请注意，取消设置的属性不会复制，也不是只读的属性。</span><span class="sxs-lookup"><span data-stu-id="9d131-240">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
 <span data-ttu-id="9d131-241">若要创建一份<xref:System.Windows.Freezable>，它是未被冻结，使用<xref:System.Windows.Freezable.Clone%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9d131-241">To create a copy of the <xref:System.Windows.Freezable> that is not frozen, use the <xref:System.Windows.Freezable.Clone%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9d131-242">无法冻结此 <see cref="T:System.Windows.Freezable" />，因为它包含表达式或经过动画处理的属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-242">The <see cref="T:System.Windows.Freezable" /> cannot be frozen because it contains expressions or animated properties.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="9d131-243">
            <para>此方法使用的虚拟<see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />方法以生成克隆。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-243">
              <para>This method uses the virtual <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="9d131-244">要复制的实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-244">The instance to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d131-245">使用基（未经过动画处理的）属性值使该实例成为指定的 <see cref="T:System.Windows.Freezable" /> 的冻结复本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-245">Makes the instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-246">调用此方法<xref:System.Windows.Freezable.GetAsFrozen%2A>方法应不直接从代码中，除非调用在调用时重写此方法的基实现。</span><span class="sxs-lookup"><span data-stu-id="9d131-246">This method is called by the <xref:System.Windows.Freezable.GetAsFrozen%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="9d131-247">若要创建当前对象的冻结的副本，请调用<xref:System.Windows.Freezable.GetAsFrozen%2A>而不是直接调用此方法。</span><span class="sxs-lookup"><span data-stu-id="9d131-247">To create a frozen copy of the current object, call <xref:System.Windows.Freezable.GetAsFrozen%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="9d131-248">
            <para>如果从其中派生<see cref="T:System.Windows.Freezable" />可能需要重写此方法。重写的原因包括以下:-派生的类具有未通过依赖关系属性公开的数据。 -在派生的类必须执行额外的初始化工作，不能通过仅重写<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。例如，这适用于你的派生的类实现<see cref="T:System.ComponentModel.ISupportInitialize" />。依赖项属性中存储其所有数据且，不需要执行额外的初始化工作的类无需重写<see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />。所有实现，都调用此方法的基实现至关重要。实现才应执行的默认实现不执行工作。默认实现使任何的可冻结的对象的所有其他可写的浅表副本，本地设置属性，它包含深层的副本。如果对象具有数据绑定依赖关系属性，表达式被复制，但可能不再解析;有关克隆数据绑定对象的详细信息，请参阅[Freezable 对象概述](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。如果对象具有动画的依赖属性，会复制这些属性的基 （非动画的） 值。不复制动画。请注意，取消设置的属性不会复制，也不是只读的属性。如果你重写此方法，则必须调用基实现。不需要<see cref="M:System.Windows.Freezable.Freeze" />值的复制。结果被冻结<see cref="M:System.Windows.Freezable.GetAsFrozen" />之前返回。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-248">
              <para>If you derive from <see cref="T:System.Windows.Freezable" /> you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation makes deep copies of any unfrozen freezables and shallow copies of all other writable, locally set properties it contains. If the object has data-bound dependency properties, the expressions are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). If the object has animated dependency properties, the base (non-animated) values of those properties are copied. Animations are not copied.  Note that unset properties are not copied, nor are read-only properties.  If you do override this method, you must call the base implementation.  You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.  The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9d131-249">使用当前属性值创建 <see cref="T:System.Windows.Freezable" /> 的冻结副本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-249">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" /> using current property values.</span>
          </span>
          <span data-ttu-id="9d131-250">由于副本已冻结，因此将通过引用复制任何冻结的子对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-250">Because the copy is frozen, any frozen sub-objects are copied by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9d131-251">
            <see cref="T:System.Windows.Freezable" /> 的冻结副本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-251">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="9d131-252">副本的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性设置为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-252">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-253">使用此方法是创建副本都使用类似<xref:System.Windows.Freezable.CloneCurrentValue%2A>，然后将其与冻结<xref:System.Windows.Freezable.Freeze%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9d131-253">Using this method is similar to creating a copy using the <xref:System.Windows.Freezable.CloneCurrentValue%2A> and then freezing it with the <xref:System.Windows.Freezable.Freeze%2A> method.</span></span>  
  
 <span data-ttu-id="9d131-254"><xref:System.Windows.Freezable.GetAsFrozen%2A>并<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法可以提高复制性能，因为它们不会克隆<xref:System.Windows.Freezable>子对象的已冻结; 它们仅将它们复制按引用。</span><span class="sxs-lookup"><span data-stu-id="9d131-254">The <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods can improve copying performance because they do not clone <xref:System.Windows.Freezable> sub-objects that are already frozen; they only copy them by reference.</span></span>  
  
 <span data-ttu-id="9d131-255">下表总结了之间的差异<xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9d131-255">The following table summarizes the differences between the <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods.</span></span>  
  
|<span data-ttu-id="9d131-256">操作</span><span class="sxs-lookup"><span data-stu-id="9d131-256">Action</span></span>|<span data-ttu-id="9d131-257">GetAsFrozen 方法行为</span><span class="sxs-lookup"><span data-stu-id="9d131-257">GetAsFrozen method behavior</span></span>|<span data-ttu-id="9d131-258">GetCurrentValueAsFrozen 方法行为</span><span class="sxs-lookup"><span data-stu-id="9d131-258">GetCurrentValueAsFrozen method behavior</span></span>|  
|------------|---------------------------------|---------------------------------------------|  
|<span data-ttu-id="9d131-259">复制包含的表达式的依赖项属性</span><span class="sxs-lookup"><span data-stu-id="9d131-259">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="9d131-260">该方法将引发<xref:System.InvalidOperationException>因为它不能<xref:System.Windows.Freezable.Freeze%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="9d131-260">The method throws an <xref:System.InvalidOperationException> because it cannot <xref:System.Windows.Freezable.Freeze%2A> the property.</span></span>|<span data-ttu-id="9d131-261">复制当前表达式的值，但不是表达式本身。</span><span class="sxs-lookup"><span data-stu-id="9d131-261">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="9d131-262">复制一个动画的依赖项属性</span><span class="sxs-lookup"><span data-stu-id="9d131-262">Copying an animated dependency property</span></span>|<span data-ttu-id="9d131-263">复制属性的基 （非动画的） 值。</span><span class="sxs-lookup"><span data-stu-id="9d131-263">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="9d131-264">不复制动画。</span><span class="sxs-lookup"><span data-stu-id="9d131-264">Animations are not copied.</span></span>|<span data-ttu-id="9d131-265">复制属性的当前动画的值。</span><span class="sxs-lookup"><span data-stu-id="9d131-265">The property's current animated value is copied.</span></span> <span data-ttu-id="9d131-266">不复制动画。</span><span class="sxs-lookup"><span data-stu-id="9d131-266">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="9d131-267">请注意，取消设置的属性不会复制，也不是只读的属性。</span><span class="sxs-lookup"><span data-stu-id="9d131-267">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
 <span data-ttu-id="9d131-268">若要创建一份<xref:System.Windows.Freezable>，它是未被冻结，使用<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9d131-268">To create a copy of the <xref:System.Windows.Freezable> that is not frozen, use the <xref:System.Windows.Freezable.CloneCurrentValue%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="9d131-269">
            <para>此方法使用的虚拟<see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />方法以生成克隆。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-269">
              <para>This method uses the virtual <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="9d131-270">要复制和冻结的 <see cref="T:System.Windows.Freezable" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-270">The <see cref="T:System.Windows.Freezable" /> to copy and freeze.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d131-271">使当前实例成为指定的 <see cref="T:System.Windows.Freezable" /> 的冻结复本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-271">Makes the current instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="9d131-272">如果对象具有动画依赖属性，则复制其当前的动画值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-272">If the object has animated dependency properties, their current animated values are copied.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-273">调用此方法<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法应不直接从代码中，除非调用在调用时重写此方法的基实现。</span><span class="sxs-lookup"><span data-stu-id="9d131-273">This method is called by the <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="9d131-274">若要创建当前对象的冻结的副本，请调用<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>而不是直接调用此方法。</span><span class="sxs-lookup"><span data-stu-id="9d131-274">To create a frozen copy of the current object, call <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="9d131-275">
            <para>如果从其中派生<see cref="T:System.Windows.Freezable" />，可能需要重写此方法。重写的原因包括以下:-派生的类具有未通过依赖关系属性公开的数据。 -在派生的类必须执行额外的初始化工作，不能通过仅重写<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。例如，这适用于你的派生的类实现<see cref="T:System.ComponentModel.ISupportInitialize" />。依赖项属性中存储其所有数据且，不需要执行额外的初始化工作的类无需重写<see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />。所有实现，都调用此方法的基实现至关重要。实现才应执行的默认实现不执行工作。默认实现将创建一个新<see cref="T:System.Windows.Freezable" />使用<see cref="M:System.Windows.Freezable.CreateInstance" />可冻结对象的方法，并使深层副本和卷影副本的所有其他可写本地设置它包含的属性。如果对象具有数据绑定依赖关系属性，复制的数据绑定，但可能不再解析;有关克隆数据绑定对象的详细信息，请参阅[Freezable 对象概述](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。如果该对象具有经过动画处理的依赖项属性，复制这些属性经过动画处理的当前值，但动画不是。中的只读依赖属性<see cref="T:System.Windows.Freezable" />不复制此默认实现。如果你重写此方法，则必须调用基实现。不需要<see cref="M:System.Windows.Freezable.Freeze" />值的复制。结果被冻结<see cref="M:System.Windows.Freezable.GetAsFrozen" />之前返回。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-275">
              <para>If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation creates a new <see cref="T:System.Windows.Freezable" /> using the <see cref="M:System.Windows.Freezable.CreateInstance" /> method and makes deep copies of unfrozen freezables and shallow copies of all other writable, locally set properties it contains. If the object has data-bound dependency properties, the data bindings are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.  Read-only dependency properties within a <see cref="T:System.Windows.Freezable" /> are not copied by this default implementation.  If you do override this method, you must call the base implementation.  You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.  The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9d131-276">获取一个值，该值指示对象当前是否可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-276">Gets a value that indicates whether the object is currently modifiable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9d131-277">如果对象已被冻结且不可修改，则为 <see langword="true" />；如果对象可修改，则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-277">
              <see langword="true" /> if the object is frozen and cannot be modified; <see langword="false" /> if the object can be modified.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-278">尝试修改对象时其<xref:System.Windows.Freezable.IsFrozen%2A>属性是`true`引发<xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="9d131-278">Attempting to modify an object when its <xref:System.Windows.Freezable.IsFrozen%2A> property is `true` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="9d131-279">此属性是只读的对象模型透视。</span><span class="sxs-lookup"><span data-stu-id="9d131-279">This property is read-only from the object model perspective.</span></span> <span data-ttu-id="9d131-280">有关文档的一些<xref:System.Windows.Freezable>行为可能涉及"设置<xref:System.Windows.Freezable.IsFrozen%2A>到`true`"或类似语言时讨论的其他方法的行为<xref:System.Windows.Freezable>，但此行为中发生的情况在内部类的实例，当实例方法操作的抽象类中存在的私有变量。</span><span class="sxs-lookup"><span data-stu-id="9d131-280">Some of the documentation about <xref:System.Windows.Freezable> behaviors may mention "sets <xref:System.Windows.Freezable.IsFrozen%2A> to `true`" or similar language when discussing the behavior of other methods of <xref:System.Windows.Freezable>, but this behavior is happening internally in the class instances, when methods of the instance manipulate the private variables that exist within the abstract class.</span></span> <span data-ttu-id="9d131-281">若要设置此属性的值，应调用<xref:System.Windows.Freezable.Freeze%2A>。</span><span class="sxs-lookup"><span data-stu-id="9d131-281">To set the value of this property, you should call <xref:System.Windows.Freezable.Freeze%2A>.</span></span> <span data-ttu-id="9d131-282">这实际上是一次性的操作来更改<xref:System.Windows.Freezable.IsFrozen%2A>属性从默认的初始`false`状态转换`true`状态。</span><span class="sxs-lookup"><span data-stu-id="9d131-282">This effectively is a one-time operation to change the <xref:System.Windows.Freezable.IsFrozen%2A> property from the initial default `false` state to the `true` state.</span></span> <span data-ttu-id="9d131-283">没有可用的方法将值返回到`false`。</span><span class="sxs-lookup"><span data-stu-id="9d131-283">There is no available means to set the value back to `false`.</span></span> <span data-ttu-id="9d131-284">相反，可以将更改从原始制作的深层副本 (请参阅<xref:System.Windows.Freezable.Clone%2A>方法)。</span><span class="sxs-lookup"><span data-stu-id="9d131-284">Instead, you could change any deep copy made from the original (see the <xref:System.Windows.Freezable.Clone%2A> method).</span></span> <span data-ttu-id="9d131-285">这是设计使然，任何派生的类的行为方式时应用于事例其中<xref:System.Windows.Freezable>模式非常有用。</span><span class="sxs-lookup"><span data-stu-id="9d131-285">This is by design and is how any derived class should behave when applied to the cases where the <xref:System.Windows.Freezable> pattern is useful.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9d131-286">修改当前 <see cref="T:System.Windows.Freezable" /> 对象时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-286">Called when the current <see cref="T:System.Windows.Freezable" /> object is modified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-287">调用此方法时<xref:System.Windows.Freezable.Changed>事件发生。</span><span class="sxs-lookup"><span data-stu-id="9d131-287">This method is called whenever the <xref:System.Windows.Freezable.Changed> event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="9d131-288">
            <para>当实现派生自的类<see cref="T:System.Windows.Freezable" />，你可以重写此方法以执行任务。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-288">
              <para>When you implement a class that derives from <see cref="T:System.Windows.Freezable" />, you may override this method to perform tasks.</para>
            </span>
          </span>
        </block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9d131-289">确保为刚刚修改的类型 <see cref="T:System.Windows.DependencyObject" /> 的数据成员建立适当的上下文指针。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-289">Ensures that appropriate context pointers are established for a data member of type <see cref="T:System.Windows.DependencyObject" /> that has just been modified.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">
          <span data-ttu-id="9d131-290">数据成员以前的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-290">The previous value of the data member.</span>
          </span>
        </param>
        <param name="newValue">
          <span data-ttu-id="9d131-291">数据成员当前的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-291">The current value of the data member.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d131-292">确保为刚刚设置的 <see cref="T:System.Windows.DependencyObjectType" /> 数据成员建立适当的上下文指针。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-292">Ensures that appropriate context pointers are established for a <see cref="T:System.Windows.DependencyObjectType" /> data member that has just been set.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-293">此方法应由调用<xref:System.Windows.Freezable>继承者每次<xref:System.Windows.DependencyObject>不作为存储的数据成员<xref:System.Windows.DependencyProperty>设置。</span><span class="sxs-lookup"><span data-stu-id="9d131-293">This method should be called by <xref:System.Windows.Freezable> inheritors each time a <xref:System.Windows.DependencyObject> data member that is not stored as a <xref:System.Windows.DependencyProperty> is set.</span></span>  
  
 <span data-ttu-id="9d131-294">此方法不需要为其调用<xref:System.Windows.DependencyObject>使用存储的数据成员<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="9d131-294">This method does not need to be called for <xref:System.Windows.DependencyObject> data members that are stored using a <xref:System.Windows.DependencyProperty>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">
          <span data-ttu-id="9d131-295">数据成员以前的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-295">The previous value of the data member.</span>
          </span>
        </param>
        <param name="newValue">
          <span data-ttu-id="9d131-296">数据成员当前的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-296">The current value of the data member.</span>
          </span>
        </param>
        <param name="property">
          <span data-ttu-id="9d131-297">已更改的属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-297">The property that changed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d131-298">此成员支持 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基础结构，但不能在代码中直接使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-298">This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="9d131-299">包含有关已更改的属性的信息及其旧值和新值的事件数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-299">Event data that contains information about which property changed, and its old and new values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9d131-300">重写 <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> 的 <see cref="T:System.Windows.DependencyObject" /> 实现，以同时调用任何响应类型 <see cref="T:System.Windows.Freezable" /> 不断变化的依赖属性的 <see cref="E:System.Windows.Freezable.Changed" /> 处理程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-300">Overrides the <see cref="T:System.Windows.DependencyObject" /> implementation of <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> to also invoke any <see cref="E:System.Windows.Freezable.Changed" /> handlers in response to a changing dependency property of type <see cref="T:System.Windows.Freezable" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-301">事件数据包含以下信息仅<xref:System.Windows.Freezable>本身。</span><span class="sxs-lookup"><span data-stu-id="9d131-301">The event data contains information about only the <xref:System.Windows.Freezable> itself.</span></span> <span data-ttu-id="9d131-302">子属性的任何信息必须通过获得<xref:System.Windows.Freezable.Changed>处理程序。</span><span class="sxs-lookup"><span data-stu-id="9d131-302">Any sub-property information must be obtained through the <xref:System.Windows.Freezable.Changed> handlers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9d131-303">确保正在从有效的线程访问 <see cref="T:System.Windows.Freezable" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-303">Ensures that the <see cref="T:System.Windows.Freezable" /> is being accessed from a valid thread.</span>
          </span>
          <span data-ttu-id="9d131-304">
            <see cref="T:System.Windows.Freezable" /> 的继承者必须在任何 [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] 一开始读取不属于依赖项对象的数据成员时调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-304">Inheritors of <see cref="T:System.Windows.Freezable" /> must call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that reads data members that are not dependency properties.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="9d131-305">
            <para>派生的类<see cref="T:System.Windows.Freezable" />应调用<see cref="M:System.Windows.Freezable.ReadPreamble" />方法之前尝试访问不依赖项属性的任何成员。<see cref="M:System.Windows.Freezable.WritePreamble" />任何此类成员写入前，应调用方法。此方法实际上不执行任何操作多个调用<see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-305">
              <para>Classes that derive from <see cref="T:System.Windows.Freezable" /> should call the <see cref="M:System.Windows.Freezable.ReadPreamble" /> method before they attempt to access any members that are not dependency properties. The <see cref="M:System.Windows.Freezable.WritePreamble" /> method should be called before any such members are written to.  This method effectively does nothing more than call <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9d131-306">为 <see cref="E:System.Windows.Freezable.Changed" /> 引发 <see cref="T:System.Windows.Freezable" /> 事件并调用其 <see cref="M:System.Windows.Freezable.OnChanged" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-306">Raises the <see cref="E:System.Windows.Freezable.Changed" /> event for the <see cref="T:System.Windows.Freezable" /> and invokes its <see cref="M:System.Windows.Freezable.OnChanged" /> method.</span>
          </span>
          <span data-ttu-id="9d131-307">从 <see cref="T:System.Windows.Freezable" /> 派生的类应在修改的类成员不存储为依赖属性的任何 API 的末尾调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-307">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies class members that are not stored as dependency properties.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="9d131-308">
            <para>派生的类<see cref="T:System.Windows.Freezable" />应调用此方法修改不存储为一个类成员的任何 API 结束时<see cref="T:System.Windows.DependencyProperty" />。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-308">
              <para>Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies a class member that is not stored as a <see cref="T:System.Windows.DependencyProperty" />.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9d131-309">验证 <see cref="T:System.Windows.Freezable" /> 是否未被冻结，并且是否正在从有效的线程上下文中访问它。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-309">Verifies that the <see cref="T:System.Windows.Freezable" /> is not frozen and that it is being accessed from a valid threading context.</span>
          </span>
          <span data-ttu-id="9d131-310">
            <see cref="T:System.Windows.Freezable" /> 的继承项应当在任何 [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] 一开始写入不属于依赖项属性的数据成员时调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-310">
              <see cref="T:System.Windows.Freezable" /> inheritors should call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that writes to data members that are not dependency properties.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9d131-311">此方法调用<xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>若要验证的线程上下文可访问，并且如果引发了异常<xref:System.Windows.Freezable>实例已冻结。</span><span class="sxs-lookup"><span data-stu-id="9d131-311">This method calls <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> to verify the threading context is accessible, and it throws an exception if the <xref:System.Windows.Freezable> instance is already frozen.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="9d131-312">
            <see cref="T:System.Windows.Freezable" /> 实例已冻结，并且无法写入其成员。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-312">The <see cref="T:System.Windows.Freezable" /> instance is frozen and cannot have its members written to.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="9d131-313">
            <para>派生的类<see cref="T:System.Windows.Freezable" />应调用<see cref="M:System.Windows.Freezable.WritePreamble" />前尝试写入不属于依赖项属性的任何成员。如果您调用<see cref="M:System.Windows.Freezable.WritePreamble" />中[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]，则可以省略调用<see cref="M:System.Windows.Freezable.ReadPreamble" />。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="9d131-313">
              <para>Classes that derive from <see cref="T:System.Windows.Freezable" /> should call <see cref="M:System.Windows.Freezable.WritePreamble" /> before attempting to write to any members that are not dependency properties. If you call <see cref="M:System.Windows.Freezable.WritePreamble" /> in an [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], you can omit a call to <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>