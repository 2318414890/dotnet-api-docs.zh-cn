<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e1d1529115d328a1d811aa8b586bd2a77931b537" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36460236" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Defines an object that has a modifiable state and a read-only (frozen) state. Classes that derive from <see cref="T:System.Windows.Freezable" /> provide detailed change notification, can be made immutable, and can clone themselves.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable>类提供特殊功能，可帮助提高应用程序性能，使用非常昂贵修改或复制的对象时。 示例<xref:System.Windows.Freezable>对象包括以下：  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>派生自可冻结  
 派生自的类<xref:System.Windows.Freezable>可以获得以下功能：  
  
-   特殊的状态： 只读 （冻结） 状态和可写状态。  
  
-   线程安全： 冻结<xref:System.Windows.Freezable>可以跨线程共享对象。  
  
-   详细的更改通知： 与其他不同<xref:System.Windows.DependencyObject>对象，<xref:System.Windows.Freezable>对子属性值更改时，对象提供更改通知。  
  
-   轻松克隆： 可冻结类已实现生成深层克隆的几种方法。  
  
 有关如何使用和创建你自己<xref:System.Windows.Freezable>对象，请参阅[可冻结对象概述](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。  
  
 ]]></format>
    </remarks>
    <threadsafe>任何公共<see langword="static" />此类型的成员都是线程安全。 但不保证所有实例成员都是线程安全的。  当<see cref="P:System.Windows.Freezable.IsFrozen" />属性是<see langword="false" />、<see cref="T:System.Windows.Freezable" />可以仅从在其创建的线程访问对象。 尝试访问从另一个线程引发<see cref="T:System.InvalidOperationException" />。 <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" />和<see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />方法封送处理到正确的线程提供支持。  当其<see cref="P:System.Windows.Freezable.IsFrozen" />属性是<see langword="true" />，<see cref="T:System.Windows.Freezable" />对象是自由线程。  有关详细信息，请参阅 [可冻结对象 Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of a <see cref="T:System.Windows.Freezable" /> derived class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个抽象类的受保护的可访问性构造函数。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the object can be made unmodifiable.</summary>
        <value>如果当前对象可以变为不可修改，或者已经不可修改，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>此方法实现使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法替换<paramref name="isChecking" />设置为<see langword="true" />以确定是否<see cref="T:System.Windows.Freezable" />可变为不可修改。若要修改此属性在派生类中的行为的方式，重写<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the <see cref="T:System.Windows.Freezable" /> or an object it contains is modified.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你尝试添加或移除事件处理程序时的当前对象不是可修改 (时<xref:System.Windows.Freezable.IsFrozen%2A>属性是`true`)，将引发异常。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a modifiable clone of the <see cref="T:System.Windows.Freezable" />, making deep copies of the object's values. When copying the object's dependency properties, this method copies expressions (which might no longer resolve) but not animations or their current values.</summary>
        <returns>A modifiable clone of the current object. The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法生成的可修改克隆冻结<xref:System.Windows.Freezable>对象 (方法还可用于克隆<xref:System.Windows.Freezable>未冻结的对象)。 复本实际上是当前对象的深层副本。  
  
 下表总结了之间的差异<xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。  
  
|操作|克隆方法行为|CloneCurrentValue 方法行为|  
|------------|---------------------------|---------------------------------------|  
|复制一个依赖项属性，包含的表达式|该表达式被复制，但可能不再解析。 有关详细信息，请参阅 [Freezable 对象概述](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。|复制该表达式的当前值，但不是表达式本身。|  
|复制一个动画的依赖项属性|该属性的基 （非经过动画处理的） 该值被复制。 不复制动画。|该属性的当前动画的该值被复制。 不复制动画。|  
  
 请注意，将不会复制取消设置的属性。 如果未设置的属性具有默认值为冻结<xref:System.Windows.Freezable>，属性的值保持在否则为可修改复本冻结。  
  
## <a name="move-a-freezable-between-threads"></a>线程之间移动可冻结  
 此方法可用于移动<xref:System.Windows.Freezable>线程之间。 首先，请<xref:System.Windows.Freezable>不可修改通过调用其<xref:System.Windows.Freezable.Freeze%2A>方法。 现在，可以访问另一个线程<xref:System.Windows.Freezable>和使本地<xref:System.Windows.Freezable.Clone%2A>，它可以访问。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>此方法使用<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />生成克隆。若要修改此方法在派生类中的行为，请重写<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />方法。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">The object to clone.</param>
        <summary>Makes the instance a clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法<xref:System.Windows.Freezable.Clone%2A>方法应不直接从代码中，除非调用时调用时重写此方法的基实现。 若要创建当前对象的可修改副本，请调用<xref:System.Windows.Freezable.Clone%2A>而不是直接调用此方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果派生自<see cref="T:System.Windows.Freezable" />，你可能需要重写此方法。重写的原因包括:-在派生的类具有未通过依赖项属性公开的数据。 -您派生的类必须执行额外的初始化工作不能通过只需重写来完成<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。例如，这一点适用如果派生的类实现<see cref="T:System.ComponentModel.ISupportInitialize" />。依赖项属性中存储所有数据且，不需要执行额外的初始化工作的类无需重写<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />。这一点至关重要所有实现都调用此方法的基实现。实现才应执行的默认实现不执行工作。默认实现制作所有可写入的本地设置的属性，包括内部的表达式的深层的副本。如果对象具有数据绑定依赖项属性，表达式将被复制，但可能不再解析。克隆绑定到数据的对象有关的详细信息，请参阅 [可冻结对象 Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。如果该对象具有动画的依赖属性，这些属性的基 （非经过动画处理的） 值将复制。不复制动画。请注意，取消设置的属性将不会复制，也不是只读的属性。如果此属性具有默认值为冻结<see cref="T:System.Windows.Freezable" />，属性的值保持在否则为可修改复本冻结。以下列表总结了此方法的预期的行为:-生成的副本包含的所有副本<see cref="T:System.Windows.Freezable" />子对象。 -取消设置和只读属性不会复制。 的复制表达式。 -无这些子对象的已冻结上创建。 的未冻结本身副本。 的不会复制动画。 -仅属性基值是复制、 没有最新的动画的值。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a modifiable clone (deep copy) of the <see cref="T:System.Windows.Freezable" /> using its current values.</summary>
        <returns>A modifiable clone of the current object. The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法生成的可修改克隆冻结<xref:System.Windows.Freezable>对象 (方法还可用于克隆<xref:System.Windows.Freezable>未冻结的对象)。 复本实际上是当前对象的深层副本。  
  
 下表总结了之间的差异<xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。  
  
|操作|克隆方法行为|CloneCurrentValue 方法行为|  
|------------|---------------------------|---------------------------------------|  
|复制一个依赖项属性，包含的表达式|该表达式被复制，但可能不再解析。 有关详细信息，请参阅 [Freezable 对象概述](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。|复制该表达式的当前值，但不是表达式本身。|  
|复制一个动画的依赖项属性|该属性的基 （非经过动画处理的） 该值被复制。 不复制动画。|该属性的当前动画的该值被复制。 不复制动画。|  
  
 请注意，将不会复制取消设置的属性。 如果未设置的属性具有默认值为冻结<xref:System.Windows.Freezable>，属性的值保持在否则为可修改复本冻结。  
  
## <a name="move-a-freezable-between-threads"></a>线程之间移动可冻结  
 此方法可用于移动<xref:System.Windows.Freezable>线程之间。 首先，请<xref:System.Windows.Freezable>不可通过使用修改其<xref:System.Windows.Freezable.Freeze%2A>方法。 现在，可以访问另一个线程<xref:System.Windows.Freezable>并使它可以访问的本地克隆。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>此方法使用<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />方法来生成克隆;<see cref="T:System.Windows.Freezable" />实施者，他们重写<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />必须确保副本未冻结上创建。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">The <see cref="T:System.Windows.Freezable" /> to be cloned.</param>
        <summary>Makes the instance a modifiable clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using current property values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法应不直接从代码中，除非调用时调用时重写此方法的基实现。 若要创建当前对象的可修改副本，请调用<xref:System.Windows.Freezable.CloneCurrentValue%2A>而不是直接调用此方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果派生自<see cref="T:System.Windows.Freezable" />，你可能需要重写此方法。重写的原因包括:-在派生的类具有未通过依赖项属性公开的数据。 -您派生的类必须执行额外的初始化工作不能通过只需重写来完成<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。例如，这一点适用如果派生的类实现<see cref="T:System.ComponentModel.ISupportInitialize" />。依赖项属性中存储所有数据且，不需要执行额外的初始化工作的类无需重写<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />。这一点至关重要所有实现都调用此方法的基实现。实现才应执行的默认实现不执行工作。默认实现使所有可写入的本地设置属性的深层副本。如果对象包含与表达式 （例如数据绑定） 的依赖项属性，但不是表达式本身复制该表达式的当前值。如果对象具有动画依赖项属性，这些属性的当前的动画的该值被复制，但动画不。请注意，取消设置的属性将不会复制，也不是只读的属性。如果此属性具有默认值为冻结<see cref="T:System.Windows.Freezable" />，属性的值保持在否则为可修改复本冻结。以下列表总结了此方法的预期的行为。 生成的副本包含的所有副本<see cref="T:System.Windows.Freezable" />子对象。 -取消设置和只读属性不会复制。 -如果某个属性进行动画处理，复制其当前值，但动画本身不是。 -无这些子对象的已冻结上创建。 的未冻结本身副本。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Freezable" /> class.</summary>
        <returns>The new instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是受保护的方法，并且行为的实际特定于对象的实现依赖于重写实现<xref:System.Windows.Freezable.CreateInstanceCore%2A>方法，此方法在内部调用。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When implemented in a derived class, creates a new instance of the <see cref="T:System.Windows.Freezable" /> derived class.</summary>
        <returns>The new instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请勿调用此方法，直接 （但调用基实现中）。 内部调用此方法<xref:System.Windows.Freezable.CreateInstance%2A>方法时的新实例<xref:System.Windows.Freezable>创建。  
  
   
  
## Examples  
 下面的示例演示的典型实现<xref:System.Windows.Freezable.CreateInstanceCore%2A>。  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>每个<see cref="T:System.Windows.Freezable" />派生的类必须实现此方法。典型的实现是只需调用默认构造函数并返回结果。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Makes a <see cref="T:System.Windows.Freezable" /> object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />, or tests whether a <see cref="T:System.Windows.Freezable" /> object can be made unmodifiable.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Makes the current object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要避免错误的可能性<xref:System.InvalidOperationException>调用此方法时，检查<xref:System.Windows.Freezable.CanFreeze%2A>属性来确定是否<xref:System.Windows.Freezable>可以变为不可修改之前调用此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Windows.Freezable" /> cannot be made unmodifiable.</exception>
        <block subset="none" type="overrides">
          <para>此方法使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法来执行<see cref="T:System.Windows.Freezable" />不可修改。若要修改冻结行为，请重写<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">The object to check or make unmodifiable. If <c>isChecking</c> is <see langword="true" />, the object is checked to determine whether it can be made unmodifiable. If <c>isChecking</c> is <see langword="false" />, the object is made unmodifiable, if possible.</param>
        <param name="isChecking">
          <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</param>
        <summary>If the <paramref name="isChecking" /> parameter is <see langword="true" />, this method indicates whether the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable. If the <paramref name="isChecking" /> parameter is <see langword="false" />, this method attempts to make the specified <see cref="T:System.Windows.Freezable" /> unmodifiable and indicates whether the operation succeeded.</summary>
        <returns>If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable. If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请勿调用此方法，除非派生自<xref:System.Windows.Freezable>和重写<xref:System.Windows.Freezable.FreezeCore%2A>方法。  此方法可能会使用在<xref:System.Windows.Freezable.FreezeCore%2A>方法冻结类数据成员本身是<xref:System.Windows.Freezable>对象。  
  
 它为保险上再次调用此方法<xref:System.Windows.Freezable>已冻结 （不可修改） 的对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">When <paramref name="isChecking" /> is <see langword="false" />, the attempt to make <paramref name="freezable" /> unmodifiable was unsuccessful; the object is now in an unknown state (it might be partially frozen).</exception>
        <block subset="none" type="overrides">
          <para>此方法使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法来执行<see cref="T:System.Windows.Freezable" />不可修改。若要修改冻结行为，请重写<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</param>
        <summary>Makes the <see cref="T:System.Windows.Freezable" /> object unmodifiable or tests whether it can be made unmodifiable.</summary>
        <returns>If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable. If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请勿调用此方法，直接 （但调用基实现中）。 内部调用此方法<xref:System.Windows.Freezable.CanFreeze%2A>属性 (与`isChecking`等于`true`) 和<xref:System.Windows.Freezable.Freeze%2A>方法 (与`isChecking`等于`false`)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.Freezable" /> 当类包含不存储使用依赖项属性的数据时，实施者必须重写此方法。典型实现应调用基类，然后调用静态<see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />方法对所有<see cref="T:System.Windows.Freezable" />类型的类包含，返回的属性<see langword="true" />仅当所有属性都被冻结 （或可能已被冻结，在指定的情况下<see langword="true" />为<paramref name="isChecking" />)。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a frozen copy of the <see cref="T:System.Windows.Freezable" />, using base (non-animated) property values. Because the copy is frozen, any frozen sub-objects are copied by reference.</summary>
        <returns>A frozen copy of the <see cref="T:System.Windows.Freezable" />. The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应检查<xref:System.Windows.Freezable.CanFreeze%2A>属性在调用此方法以验证之前<xref:System.Windows.Freezable>可以冻结。 使用此方法是类似于创建副本都使用<xref:System.Windows.Freezable.Clone%2A>，然后冻结其与<xref:System.Windows.Freezable.Freeze%2A>方法。  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法可以提高复制性能，因为它们不会克隆<xref:System.Windows.Freezable>子对象的已冻结; 它们仅将其复制通过引用。  
  
 下表总结了之间的差异<xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法。  
  
|操作|GetAsFrozen 方法行为|GetCurrentValueAsFrozen 方法行为|  
|------------|---------------------------------|---------------------------------------------|  
|复制一个依赖项属性，包含的表达式|该方法将引发<xref:System.InvalidOperationException>因为它不能<xref:System.Windows.Freezable.Freeze%2A>属性。|复制该表达式的当前值，但不是表达式本身。|  
|复制一个动画的依赖项属性|该属性的基 （非经过动画处理的） 该值被复制。 不复制动画。|该属性的当前动画的该值被复制。 不复制动画。|  
  
 请注意，取消设置的属性将不会复制，也不是只读的属性。  
  
 若要创建一份<xref:System.Windows.Freezable>，它是未被冻结，使用<xref:System.Windows.Freezable.Clone%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Windows.Freezable" /> cannot be frozen because it contains expressions or animated properties.</exception>
        <block subset="none" type="overrides">
          <para>此方法使用的虚拟<see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />方法来生成克隆。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">The instance to copy.</param>
        <summary>Makes the instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法<xref:System.Windows.Freezable.GetAsFrozen%2A>方法应不直接从代码中，除非调用时调用时重写此方法的基实现。 若要创建当前对象的冻结的副本，请调用<xref:System.Windows.Freezable.GetAsFrozen%2A>而不是直接调用此方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果派生自<see cref="T:System.Windows.Freezable" />可能需要重写此方法。重写的原因包括:-在派生的类具有未通过依赖项属性公开的数据。 -您派生的类必须执行额外的初始化工作不能通过只需重写来完成<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。例如，这一点适用如果派生的类实现<see cref="T:System.ComponentModel.ISupportInitialize" />。依赖项属性中存储所有数据且，不需要执行额外的初始化工作的类无需重写<see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />。这一点至关重要所有实现都调用此方法的基实现。实现才应执行的默认实现不执行工作。默认实现制作任何可冻结的对象和的所有其他可写的浅表副本、 本地设置属性，它包含的深层的副本。如果对象具有数据绑定依赖项属性，表达式将被复制，但可能不再解析;克隆绑定到数据的对象有关的详细信息，请参阅 [可冻结对象 Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。如果对象具有动画的依赖属性，将复制这些属性的基 （非经过动画处理的） 值。不复制动画。请注意，取消设置的属性将不会复制，也不是只读的属性。如果你重写此方法，必须调用基实现。不需要<see cref="M:System.Windows.Freezable.Freeze" />值的复制。结果冻结<see cref="M:System.Windows.Freezable.GetAsFrozen" />之前返回。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a frozen copy of the <see cref="T:System.Windows.Freezable" /> using current property values. Because the copy is frozen, any frozen sub-objects are copied by reference.</summary>
        <returns>A frozen copy of the <see cref="T:System.Windows.Freezable" />. The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法是类似于创建副本都使用<xref:System.Windows.Freezable.CloneCurrentValue%2A>，然后冻结其与<xref:System.Windows.Freezable.Freeze%2A>方法。  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法可以提高复制性能，因为它们不会克隆<xref:System.Windows.Freezable>子对象的已冻结; 它们仅将其复制通过引用。  
  
 下表总结了之间的差异<xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法。  
  
|操作|GetAsFrozen 方法行为|GetCurrentValueAsFrozen 方法行为|  
|------------|---------------------------------|---------------------------------------------|  
|复制一个依赖项属性，包含的表达式|该方法将引发<xref:System.InvalidOperationException>因为它不能<xref:System.Windows.Freezable.Freeze%2A>属性。|复制该表达式的当前值，但不是表达式本身。|  
|复制一个动画的依赖项属性|该属性的基 （非经过动画处理的） 该值被复制。 不复制动画。|该属性的当前动画的该值被复制。 不复制动画。|  
  
 请注意，取消设置的属性将不会复制，也不是只读的属性。  
  
 若要创建一份<xref:System.Windows.Freezable>，它是未被冻结，使用<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>此方法使用的虚拟<see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />方法来生成克隆。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">The <see cref="T:System.Windows.Freezable" /> to copy and freeze.</param>
        <summary>Makes the current instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" />. If the object has animated dependency properties, their current animated values are copied.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法应不直接从代码中，除非调用时调用时重写此方法的基实现。 若要创建当前对象的冻结的副本，请调用<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>而不是直接调用此方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>如果派生自<see cref="T:System.Windows.Freezable" />，你可能需要重写此方法。重写的原因包括:-在派生的类具有未通过依赖项属性公开的数据。 -您派生的类必须执行额外的初始化工作不能通过只需重写来完成<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。例如，这一点适用如果派生的类实现<see cref="T:System.ComponentModel.ISupportInitialize" />。依赖项属性中存储所有数据且，不需要执行额外的初始化工作的类无需重写<see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />。这一点至关重要所有实现都调用此方法的基实现。实现才应执行的默认实现不执行工作。默认实现将创建一个新<see cref="T:System.Windows.Freezable" />使用<see cref="M:System.Windows.Freezable.CreateInstance" />方法和使的深层副本，可冻结对象的浅表副本的所有其他可写本地设置和它包含的属性。如果该对象具有数据绑定依赖项属性，将复制的数据绑定，但是可能不再解析;克隆绑定到数据的对象有关的详细信息，请参阅 [可冻结对象 Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。如果对象具有动画依赖项属性，这些属性的当前的动画的该值被复制，但动画不。中的只读依赖属性<see cref="T:System.Windows.Freezable" />不复制此默认实现。如果你重写此方法，必须调用基实现。不需要<see cref="M:System.Windows.Freezable.Freeze" />值的复制。结果冻结<see cref="M:System.Windows.Freezable.GetAsFrozen" />之前返回。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the object is currently modifiable.</summary>
        <value>
          <see langword="true" /> 如果对象已被冻结且无法修改;，<see langword="false" />如果可以修改该对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尝试修改的对象时其<xref:System.Windows.Freezable.IsFrozen%2A>属性是`true`引发<xref:System.InvalidOperationException>。  
  
 此属性是只读从对象模型透视。 有关文档的某些<xref:System.Windows.Freezable>行为可能涉及"设置<xref:System.Windows.Freezable.IsFrozen%2A>到`true`"或类似的语言时讨论的其他方法的行为<xref:System.Windows.Freezable>，但此行为中发生的情况内部类的实例，当该实例的方法操作的抽象类中存在的私有变量。 若要设置此属性的值，应调用<xref:System.Windows.Freezable.Freeze%2A>。 这实际上是一次性的操作，以更改<xref:System.Windows.Freezable.IsFrozen%2A>属性从默认的初始`false`状态`true`状态。 没有可用的方法来设置的值返回到`false`。 相反，你无法更改与原始制作的深层副本 (请参阅<xref:System.Windows.Freezable.Clone%2A>方法)。 这是设计使然，任何派生的类的行为方式时应用于事例其中<xref:System.Windows.Freezable>模式会很有用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called when the current <see cref="T:System.Windows.Freezable" /> object is modified.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法时<xref:System.Windows.Freezable.Changed>事件发生。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>当你实现派生自的类<see cref="T:System.Windows.Freezable" />，你可以重写此方法以执行任务。</para>
        </block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ensures that appropriate context pointers are established for a data member of type <see cref="T:System.Windows.DependencyObject" /> that has just been modified.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">The previous value of the data member.</param>
        <param name="newValue">The current value of the data member.</param>
        <summary>Ensures that appropriate context pointers are established for a <see cref="T:System.Windows.DependencyObjectType" /> data member that has just been set.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法应由调用<xref:System.Windows.Freezable>继承者每次<xref:System.Windows.DependencyObject>不作为存储的数据成员<xref:System.Windows.DependencyProperty>设置。  
  
 此方法不需要为调用<xref:System.Windows.DependencyObject>使用存储的数据成员<xref:System.Windows.DependencyProperty>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">The previous value of the data member.</param>
        <param name="newValue">The current value of the data member.</param>
        <param name="property">The property that changed.</param>
        <summary>This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Event data that contains information about which property changed, and its old and new values.</param>
        <summary>Overrides the <see cref="T:System.Windows.DependencyObject" /> implementation of <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> to also invoke any <see cref="E:System.Windows.Freezable.Changed" /> handlers in response to a changing dependency property of type <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件数据包含以下信息仅<xref:System.Windows.Freezable>本身。 必须通过获取子属性的任何信息<xref:System.Windows.Freezable.Changed>处理程序。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ensures that the <see cref="T:System.Windows.Freezable" /> is being accessed from a valid thread. Inheritors of <see cref="T:System.Windows.Freezable" /> must call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that reads data members that are not dependency properties.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>派生自的类<see cref="T:System.Windows.Freezable" />应调用<see cref="M:System.Windows.Freezable.ReadPreamble" />方法之前尝试访问不是依赖项属性的任意成员。<see cref="M:System.Windows.Freezable.WritePreamble" />在任何此类成员写入到之前应该调用方法。此方法有效地不执行任何操作多个调用<see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Raises the <see cref="E:System.Windows.Freezable.Changed" /> event for the <see cref="T:System.Windows.Freezable" /> and invokes its <see cref="M:System.Windows.Freezable.OnChanged" /> method. Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies class members that are not stored as dependency properties.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>派生自的类<see cref="T:System.Windows.Freezable" />应调用此方法在修改类成员不存储为任何 API 的末尾<see cref="T:System.Windows.DependencyProperty" />。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verifies that the <see cref="T:System.Windows.Freezable" /> is not frozen and that it is being accessed from a valid threading context. <see cref="T:System.Windows.Freezable" /> inheritors should call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that writes to data members that are not dependency properties.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法调用<xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>若要验证的线程上下文可访问，并且如果引发了异常<xref:System.Windows.Freezable>已冻结实例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Windows.Freezable" /> instance is frozen and cannot have its members written to.</exception>
        <block subset="none" type="overrides">
          <para>派生自的类<see cref="T:System.Windows.Freezable" />应调用<see cref="M:System.Windows.Freezable.WritePreamble" />之前尝试写入不是依赖项属性的任意成员。如果调用<see cref="M:System.Windows.Freezable.WritePreamble" />中 [！INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]，则可以省略调用<see cref="M:System.Windows.Freezable.ReadPreamble" />。</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>