<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="97fc92af0ea25eec6f71bb4a67579fbfd994f7b4" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52214100" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="a0f4d-101">定义具有可修改状态和只读（冻结）状态的对象。</span>
      <span class="sxs-lookup">
        <span data-stu-id="a0f4d-101">Defines an object that has a modifiable state and a read-only (frozen) state.</span>
      </span>
      <span data-ttu-id="a0f4d-102">从 <see cref="T:System.Windows.Freezable" /> 派生的类提供详细更改通知，可以设置为不可变，并且可以克隆自身。</span>
      <span class="sxs-lookup">
        <span data-stu-id="a0f4d-102">Classes that derive from <see cref="T:System.Windows.Freezable" /> provide detailed change notification, can be made immutable, and can clone themselves.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-103"><xref:System.Windows.Freezable>类提供了特殊功能，可帮助提高应用程序性能时使用的成本要修改或复制对象。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-103">The <xref:System.Windows.Freezable> class provides special features that can help improve application performance when using objects that are expensive to modify or copy.</span></span> <span data-ttu-id="a0f4d-104">示例<xref:System.Windows.Freezable>对象包括以下项目：</span><span class="sxs-lookup"><span data-stu-id="a0f4d-104">Examples of <xref:System.Windows.Freezable> objects include the following:</span></span>  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a><span data-ttu-id="a0f4d-105">从 Freezable 派生</span><span class="sxs-lookup"><span data-stu-id="a0f4d-105">Deriving From Freezable</span></span>  
 <span data-ttu-id="a0f4d-106">从派生的类<xref:System.Windows.Freezable>可以获得以下功能：</span><span class="sxs-lookup"><span data-stu-id="a0f4d-106">A class that derives from <xref:System.Windows.Freezable> gains the following features:</span></span>  
  
-   <span data-ttu-id="a0f4d-107">特殊状态： 只读 （冻结） 状态和可写状态。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-107">Special states: a read-only (frozen) state and a writable state.</span></span>  
  
-   <span data-ttu-id="a0f4d-108">线程安全： 的冻结<xref:System.Windows.Freezable>对象可以在线程之间共享。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-108">Thread safety: a frozen <xref:System.Windows.Freezable> object can be shared across threads.</span></span>  
  
-   <span data-ttu-id="a0f4d-109">详细的更改通知： 与其他不同<xref:System.Windows.DependencyObject>对象，<xref:System.Windows.Freezable>子属性值更改时，对象提供更改通知。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-109">Detailed change notification: Unlike other <xref:System.Windows.DependencyObject> objects, a <xref:System.Windows.Freezable> object provides change notifications when sub-property values change.</span></span>  
  
-   <span data-ttu-id="a0f4d-110">简单克隆： Freezable 类已经实现生成深层克隆的几种方法。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-110">Easy cloning: the Freezable class has already implemented several methods that produce deep clones.</span></span>  
  
 <span data-ttu-id="a0f4d-111">有关使用和创建你自己<xref:System.Windows.Freezable>对象，请参阅[Freezable 对象概述](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-111">For information on using and creating your own <xref:System.Windows.Freezable> objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="a0f4d-112">任何公共<see langword="static" />此类型的成员是线程安全。</span>
      <span class="sxs-lookup">
        <span data-stu-id="a0f4d-112">Any public <see langword="static" /> members of this type are thread safe.</span>
      </span>
      <span data-ttu-id="a0f4d-113">但不保证所有实例成员都是线程安全的。</span>
      <span class="sxs-lookup">
        <span data-stu-id="a0f4d-113">Any instance members are not guaranteed to be thread safe.</span>
      </span>
      <span data-ttu-id="a0f4d-114">当<see cref="P:System.Windows.Freezable.IsFrozen" />属性是<see langword="false" />、<see cref="T:System.Windows.Freezable" />可以仅从其创建的线程访问对象。</span>
      <span class="sxs-lookup">
        <span data-stu-id="a0f4d-114">When the <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" />, a <see cref="T:System.Windows.Freezable" /> object can be accessed only from the thread on which it was created.</span>
      </span>
      <span data-ttu-id="a0f4d-115">尝试从另一个线程，则会引发访问<see cref="T:System.InvalidOperationException" />。</span>
      <span class="sxs-lookup">
        <span data-stu-id="a0f4d-115">Attempting to access it from another thread throws an <see cref="T:System.InvalidOperationException" />.</span>
      </span>
      <span data-ttu-id="a0f4d-116">
        <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" />和<see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" />方法为封送到正确的线程提供支持。</span>
      <span class="sxs-lookup">
        <span data-stu-id="a0f4d-116">The <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> and <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> methods provide support for marshalling to the correct thread.</span>
      </span>
      <span data-ttu-id="a0f4d-117">当他们<see cref="P:System.Windows.Freezable.IsFrozen" />属性是<see langword="true" />，<see cref="T:System.Windows.Freezable" />对象是自由线程。</span>
      <span class="sxs-lookup">
        <span data-stu-id="a0f4d-117">When their <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true" />, <see cref="T:System.Windows.Freezable" /> objects are free-threaded.</span>
      </span>
      <span data-ttu-id="a0f4d-118">有关详细信息，请参阅 [Freezable 对象概述](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</span>
      <span class="sxs-lookup">
        <span data-stu-id="a0f4d-118">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a0f4d-119">初始化 <see cref="T:System.Windows.Freezable" /> 派生类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-119">Initializes a new instance of a <see cref="T:System.Windows.Freezable" /> derived class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-120">这是一个抽象类的受保护的可访问性构造函数。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-120">This is the protected-accessibility constructor of an abstract class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a0f4d-121">获取一个值，该值指示是否可将对象变为不可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-121">Gets a value that indicates whether the object can be made unmodifiable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a0f4d-122">如果当前对象可以变为不可修改，或者已经不可修改，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-122">
              <see langword="true" /> if the current object can be made unmodifiable or is already unmodifiable; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0f4d-123">此方法的实现使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法替换<paramref name="isChecking" />设置为<see langword="true" />来确定是否<see cref="T:System.Windows.Freezable" />可变为不可修改。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-123">This method implementation uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method with <paramref name="isChecking" /> set to <see langword="true" /> to determine whether a <see cref="T:System.Windows.Freezable" /> can be made unmodifiable.</span>
            </span>
            <span data-ttu-id="a0f4d-124">若要修改此属性在派生类中的行为的方式，请重写<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-124">To modify the way this property behaves in a derived class, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a0f4d-125">在修改 <see cref="T:System.Windows.Freezable" /> 或其包含的对象时发生。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-125">Occurs when the <see cref="T:System.Windows.Freezable" /> or an object it contains is modified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-126">如果你尝试添加或删除事件处理程序时它不能修改当前对象 (当<xref:System.Windows.Freezable.IsFrozen%2A>属性是`true`)，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-126">If you attempt to add or remove event handlers when the current object is not modifiable (when the <xref:System.Windows.Freezable.IsFrozen%2A> property is `true`), an exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a0f4d-127">创建 <see cref="T:System.Windows.Freezable" /> 的可修改克隆，以制作该对象值的深层副本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-127">Creates a modifiable clone of the <see cref="T:System.Windows.Freezable" />, making deep copies of the object's values.</span>
          </span>
          <span data-ttu-id="a0f4d-128">在复制此对象的依赖属性时，此方法会复制表达式（可能不再解析），但不复制动画或其当前值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-128">When copying the object's dependency properties, this method copies expressions (which might no longer resolve) but not animations or their current values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0f4d-129">当前对象的可修改复本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-129">A modifiable clone of the current object.</span>
          </span>
          <span data-ttu-id="a0f4d-130">即使源的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性为 <see langword="true." />，所克隆对象的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性也为 <see langword="false" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-130">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-131"><xref:System.Windows.Freezable.Clone%2A>并<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法将产生的可修改克隆冻结<xref:System.Windows.Freezable>对象 (方法还克隆<xref:System.Windows.Freezable>未被冻结的对象)。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-131">The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects (the methods also clone <xref:System.Windows.Freezable> objects that are not frozen).</span></span> <span data-ttu-id="a0f4d-132">复本实际上是当前对象的深层副本。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-132">The clone is effectively a deep copy of the current object.</span></span>  
  
 <span data-ttu-id="a0f4d-133">下表总结了之间的差异<xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-133">The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.</span></span>  
  
|<span data-ttu-id="a0f4d-134">操作</span><span class="sxs-lookup"><span data-stu-id="a0f4d-134">Action</span></span>|<span data-ttu-id="a0f4d-135">克隆方法行为</span><span class="sxs-lookup"><span data-stu-id="a0f4d-135">Clone method behavior</span></span>|<span data-ttu-id="a0f4d-136">CloneCurrentValue 方法行为</span><span class="sxs-lookup"><span data-stu-id="a0f4d-136">CloneCurrentValue method behavior</span></span>|  
|------------|---------------------------|---------------------------------------|  
|<span data-ttu-id="a0f4d-137">复制包含的表达式的依赖项属性</span><span class="sxs-lookup"><span data-stu-id="a0f4d-137">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="a0f4d-138">表达式复制，但可能不再解析。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-138">The expression is copied, but might no longer resolve.</span></span> <span data-ttu-id="a0f4d-139">有关详细信息，请参阅 [Freezable 对象概述](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-139">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>|<span data-ttu-id="a0f4d-140">复制当前表达式的值，但不是表达式本身。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-140">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="a0f4d-141">复制一个动画的依赖项属性</span><span class="sxs-lookup"><span data-stu-id="a0f4d-141">Copying an animated dependency property</span></span>|<span data-ttu-id="a0f4d-142">复制属性的基 （非动画的） 值。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-142">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="a0f4d-143">不复制动画。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-143">Animations are not copied.</span></span>|<span data-ttu-id="a0f4d-144">复制属性的当前动画的值。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-144">The property's current animated value is copied.</span></span> <span data-ttu-id="a0f4d-145">不复制动画。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-145">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="a0f4d-146">请注意，取消设置的属性将不会复制。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-146">Note that unset properties are not copied.</span></span> <span data-ttu-id="a0f4d-147">如果未设置的属性的默认值，则冻结<xref:System.Windows.Freezable>，属性值保持在其他可修改复本冻结状态。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-147">If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
## <a name="move-a-freezable-between-threads"></a><span data-ttu-id="a0f4d-148">Freezable 在线程间移动</span><span class="sxs-lookup"><span data-stu-id="a0f4d-148">Move a Freezable Between Threads</span></span>  
 <span data-ttu-id="a0f4d-149">此方法也可用于移动<xref:System.Windows.Freezable>线程之间。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-149">This method can be useful for moving a <xref:System.Windows.Freezable> between threads.</span></span> <span data-ttu-id="a0f4d-150">首先，请<xref:System.Windows.Freezable>变为不可修改通过调用其<xref:System.Windows.Freezable.Freeze%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-150">First, make the <xref:System.Windows.Freezable> unmodifiable by calling its <xref:System.Windows.Freezable.Freeze%2A> method.</span></span> <span data-ttu-id="a0f4d-151">现在，另一个线程可以访问<xref:System.Windows.Freezable>并进行本地<xref:System.Windows.Freezable.Clone%2A>，它可以访问。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-151">Now another thread can access the <xref:System.Windows.Freezable> and make a local <xref:System.Windows.Freezable.Clone%2A> that it can access.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0f4d-152">此方法使用<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />生成复本。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-152">This method uses <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> to produce the clone.</span>
            </span>
            <span data-ttu-id="a0f4d-153">若要修改此方法在派生类中的行为，请重写<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-153">To modify the behavior of this method in a derived class, override the <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> method.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="a0f4d-154">要克隆的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-154">The object to clone.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0f4d-155">使用基（未经过动画处理的）属性值使该实例成为指定 <see cref="T:System.Windows.Freezable" /> 的克隆（深层复制）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-155">Makes the instance a clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-156">调用此方法<xref:System.Windows.Freezable.Clone%2A>方法应不直接从代码中，除非调用在调用时重写此方法的基实现。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-156">This method is called by the <xref:System.Windows.Freezable.Clone%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="a0f4d-157">若要创建当前对象的可修改副本，请调用<xref:System.Windows.Freezable.Clone%2A>而不是直接调用此方法。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-157">To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.Clone%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0f4d-158">如果从其中派生<see cref="T:System.Windows.Freezable" />，可能需要重写此方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-158">If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method.</span>
            </span>
            <span data-ttu-id="a0f4d-159">重写的原因包括：</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-159">Reasons to override include the following:</span>
            </span>
            <span data-ttu-id="a0f4d-160">-在派生的类具有未通过依赖关系属性公开的数据。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-160">-   Your derived class has data that is not exposed via dependency properties.</span>
            </span>
            <span data-ttu-id="a0f4d-161">-在派生的类必须执行额外的初始化工作，不能通过仅重写<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-161">-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span>
            </span>
            <span data-ttu-id="a0f4d-162">例如，这适用于你的派生的类实现<see cref="T:System.ComponentModel.ISupportInitialize" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-162">For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.</span>
            </span>
            <span data-ttu-id="a0f4d-163">依赖项属性中存储其所有数据且，不需要执行额外的初始化工作的类无需重写<see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-163">Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.</span>
            </span>
            <span data-ttu-id="a0f4d-164">所有实现，都调用此方法的基实现至关重要。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-164">It is essential that all implementations call the base implementation of this method.</span>
            </span>
            <span data-ttu-id="a0f4d-165">实现才应执行的默认实现不执行工作。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-165">Implementations should only perform work that is not performed by the default implementation.</span>
            </span>
            <span data-ttu-id="a0f4d-166">默认实现使所有可写入的本地设置的属性，包括内部的表达式的深层副本。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-166">The default implementation makes deep copies of all writable, locally set properties, including internal expressions.</span>
            </span>
            <span data-ttu-id="a0f4d-167">如果对象具有数据绑定依赖关系属性，表达式被复制，但可能不再解析。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-167">If the object has data-bound dependency properties, the expressions are copied but might no longer resolve.</span>
            </span>
            <span data-ttu-id="a0f4d-168">有关克隆数据绑定对象的详细信息，请参阅[Freezable 对象概述](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-168">For more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span>
            </span>
            <span data-ttu-id="a0f4d-169">如果对象具有动画的依赖属性，复制这些属性的基 （非动画的） 值。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-169">If the object has animated dependency properties, the base (non-animated) value of those properties is copied.</span>
            </span>
            <span data-ttu-id="a0f4d-170">不复制动画。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-170">Animations are not copied.</span>
            </span>
            <span data-ttu-id="a0f4d-171">请注意，取消设置的属性不会复制，也不是只读的属性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-171">Note that unset properties are not copied, nor are read-only properties.</span>
            </span>
            <span data-ttu-id="a0f4d-172">如果此类属性的默认值，则冻结<see cref="T:System.Windows.Freezable" />，属性值保持在其他可修改复本冻结状态。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-172">If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.</span>
            </span>
            <span data-ttu-id="a0f4d-173">以下列表总结了此方法的预期的行为：</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-173">The following list summarizes the expected behavior for this method:</span>
            </span>
            <span data-ttu-id="a0f4d-174">的生成副本包含的所有副本<see cref="T:System.Windows.Freezable" />子对象。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-174">-   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.</span>
            </span>
            <span data-ttu-id="a0f4d-175">-不复制取消设置和只读属性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-175">-   Unset and read-only properties are not copied.</span>
            </span>
            <span data-ttu-id="a0f4d-176">的复制表达式。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-176">-   Expressions are copied.</span>
            </span>
            <span data-ttu-id="a0f4d-177">-None 这些子对象的已冻结上创建。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-177">-   None of these sub-objects are frozen on creation.</span>
            </span>
            <span data-ttu-id="a0f4d-178">的本身副本未被冻结。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-178">-   The copy itself is not frozen.</span>
            </span>
            <span data-ttu-id="a0f4d-179">的不会复制动画。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-179">-   Animations are not copied.</span>
            </span>
            <span data-ttu-id="a0f4d-180">-仅属性基值是复制而非当前的动画的值。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-180">-   Only property base values are copied, not current animated values.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a0f4d-181">使用 <see cref="T:System.Windows.Freezable" /> 的当前值创建其可修改复本（深层副本）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-181">Creates a modifiable clone (deep copy) of the <see cref="T:System.Windows.Freezable" /> using its current values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0f4d-182">当前对象的可修改复本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-182">A modifiable clone of the current object.</span>
          </span>
          <span data-ttu-id="a0f4d-183">即使源的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性为 <see langword="true." />，所克隆对象的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性也为 <see langword="false" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-183">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-184"><xref:System.Windows.Freezable.Clone%2A>并<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法将产生的可修改克隆冻结<xref:System.Windows.Freezable>对象 (方法还克隆<xref:System.Windows.Freezable>未被冻结的对象)。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-184">The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects (the methods also clone <xref:System.Windows.Freezable> objects that are not frozen).</span></span> <span data-ttu-id="a0f4d-185">复本实际上是当前对象的深层副本。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-185">The clone is effectively a deep copy of the current object.</span></span>  
  
 <span data-ttu-id="a0f4d-186">下表总结了之间的差异<xref:System.Windows.Freezable.Clone%2A>和<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-186">The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.</span></span>  
  
|<span data-ttu-id="a0f4d-187">操作</span><span class="sxs-lookup"><span data-stu-id="a0f4d-187">Action</span></span>|<span data-ttu-id="a0f4d-188">克隆方法行为</span><span class="sxs-lookup"><span data-stu-id="a0f4d-188">Clone method behavior</span></span>|<span data-ttu-id="a0f4d-189">CloneCurrentValue 方法行为</span><span class="sxs-lookup"><span data-stu-id="a0f4d-189">CloneCurrentValue method behavior</span></span>|  
|------------|---------------------------|---------------------------------------|  
|<span data-ttu-id="a0f4d-190">复制包含的表达式的依赖项属性</span><span class="sxs-lookup"><span data-stu-id="a0f4d-190">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="a0f4d-191">表达式复制，但可能不再解析。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-191">The expression is copied, but might no longer resolve.</span></span> <span data-ttu-id="a0f4d-192">有关详细信息，请参阅 [Freezable 对象概述](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-192">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>|<span data-ttu-id="a0f4d-193">复制当前表达式的值，但不是表达式本身。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-193">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="a0f4d-194">复制一个动画的依赖项属性</span><span class="sxs-lookup"><span data-stu-id="a0f4d-194">Copying an animated dependency property</span></span>|<span data-ttu-id="a0f4d-195">复制属性的基 （非动画的） 值。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-195">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="a0f4d-196">不复制动画。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-196">Animations are not copied.</span></span>|<span data-ttu-id="a0f4d-197">复制属性的当前动画的值。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-197">The property's current animated value is copied.</span></span> <span data-ttu-id="a0f4d-198">不复制动画。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-198">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="a0f4d-199">请注意，取消设置的属性将不会复制。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-199">Note that unset properties are not copied.</span></span> <span data-ttu-id="a0f4d-200">如果未设置的属性的默认值，则冻结<xref:System.Windows.Freezable>，属性值保持在其他可修改复本冻结状态。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-200">If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
## <a name="move-a-freezable-between-threads"></a><span data-ttu-id="a0f4d-201">Freezable 在线程间移动</span><span class="sxs-lookup"><span data-stu-id="a0f4d-201">Move a Freezable Between Threads</span></span>  
 <span data-ttu-id="a0f4d-202">此方法也可用于移动<xref:System.Windows.Freezable>线程之间。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-202">This method can be useful for moving a <xref:System.Windows.Freezable> between threads.</span></span> <span data-ttu-id="a0f4d-203">首先，请<xref:System.Windows.Freezable>变为不可修改通过使用其<xref:System.Windows.Freezable.Freeze%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-203">First, make the <xref:System.Windows.Freezable> unmodifiable by using its <xref:System.Windows.Freezable.Freeze%2A> method.</span></span> <span data-ttu-id="a0f4d-204">现在，另一个线程可以访问<xref:System.Windows.Freezable>并使它可以访问的本地克隆。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-204">Now another thread can access the <xref:System.Windows.Freezable> and make a local clone that it can access.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0f4d-205">此方法使用<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />方法以生成克隆;<see cref="T:System.Windows.Freezable" />实施者，他们重写<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />必须确保副本上创建未被冻结。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-205">This method uses the <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> method to produce the clone; <see cref="T:System.Windows.Freezable" /> implementers who override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> must ensure that the copy is not frozen on creation.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="a0f4d-206">要克隆的 <see cref="T:System.Windows.Freezable" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-206">The <see cref="T:System.Windows.Freezable" /> to be cloned.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0f4d-207">使用当前属性值使该实例成为指定 <see cref="T:System.Windows.Freezable" /> 的可修改克隆（深层复制）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-207">Makes the instance a modifiable clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using current property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-208">调用此方法<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法应不直接从代码中，除非调用在调用时重写此方法的基实现。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-208">This method is called by the <xref:System.Windows.Freezable.CloneCurrentValue%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="a0f4d-209">若要创建当前对象的可修改副本，请调用<xref:System.Windows.Freezable.CloneCurrentValue%2A>而不是直接调用此方法。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-209">To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.CloneCurrentValue%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0f4d-210">如果从其中派生<see cref="T:System.Windows.Freezable" />，可能需要重写此方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-210">If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method.</span>
            </span>
            <span data-ttu-id="a0f4d-211">重写的原因包括：</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-211">Reasons to override include the following:</span>
            </span>
            <span data-ttu-id="a0f4d-212">-在派生的类具有未通过依赖关系属性公开的数据。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-212">-   Your derived class has data that is not exposed via dependency properties.</span>
            </span>
            <span data-ttu-id="a0f4d-213">-在派生的类必须执行额外的初始化工作，不能通过仅重写<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-213">-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span>
            </span>
            <span data-ttu-id="a0f4d-214">例如，这适用于你的派生的类实现<see cref="T:System.ComponentModel.ISupportInitialize" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-214">For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.</span>
            </span>
            <span data-ttu-id="a0f4d-215">依赖项属性中存储其所有数据且，不需要执行额外的初始化工作的类无需重写<see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-215">Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.</span>
            </span>
            <span data-ttu-id="a0f4d-216">所有实现，都调用此方法的基实现至关重要。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-216">It is essential that all implementations call the base implementation of this method.</span>
            </span>
            <span data-ttu-id="a0f4d-217">实现才应执行的默认实现不执行工作。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-217">Implementations should only perform work that is not performed by the default implementation.</span>
            </span>
            <span data-ttu-id="a0f4d-218">默认实现使所有可写入的本地设置属性的深层副本。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-218">The default implementation makes deep copies of all writable, locally set properties.</span>
            </span>
            <span data-ttu-id="a0f4d-219">如果对象包含与表达式 （如数据绑定） 的依赖项属性，该表达式的当前值被复制但不是表达式本身。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-219">If the object contains dependency properties with expressions (such as a data binding), the current value of the expression is copied but not the expression itself.</span>
            </span>
            <span data-ttu-id="a0f4d-220">如果该对象具有经过动画处理的依赖项属性，复制这些属性经过动画处理的当前值，但动画不是。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-220">If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.</span>
            </span>
            <span data-ttu-id="a0f4d-221">请注意，取消设置的属性不会复制，也不是只读的属性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-221">Note that unset properties are not copied, nor are read-only properties.</span>
            </span>
            <span data-ttu-id="a0f4d-222">如果此类属性的默认值，则冻结<see cref="T:System.Windows.Freezable" />，属性值保持在其他可修改复本冻结状态。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-222">If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.</span>
            </span>
            <span data-ttu-id="a0f4d-223">以下列表总结了此方法的预期的行为。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-223">The following list summarizes the expected behavior for this method.</span>
            </span>
            <span data-ttu-id="a0f4d-224">的生成副本包含的所有副本<see cref="T:System.Windows.Freezable" />子对象。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-224">-   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.</span>
            </span>
            <span data-ttu-id="a0f4d-225">-不复制取消设置和只读属性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-225">-   Unset and read-only properties are not copied.</span>
            </span>
            <span data-ttu-id="a0f4d-226">-如果某个属性进行动画处理，复制其当前值，但动画本身不是。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-226">-   If a property is animated, its current value is copied, but the animation itself is not.</span>
            </span>
            <span data-ttu-id="a0f4d-227">-None 这些子对象的已冻结上创建。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-227">-   None of these sub-objects are frozen on creation.</span>
            </span>
            <span data-ttu-id="a0f4d-228">的本身副本未被冻结。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-228">-   The copy itself is not frozen.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a0f4d-229">初始化 <see cref="T:System.Windows.Freezable" /> 类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-229">Initializes a new instance of the <see cref="T:System.Windows.Freezable" /> class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0f4d-230">新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-230">The new instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-231">这是一个受保护的方法，并实际对象特定于实现的行为依赖于的重写实现<xref:System.Windows.Freezable.CreateInstanceCore%2A>方法，此方法在内部调用。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-231">This is a protected method, and the actual object-specific implementations for the behavior are dependent on the override implementation of the <xref:System.Windows.Freezable.CreateInstanceCore%2A> method, which this method calls internally.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a0f4d-232">在派生类中实现时，创建 <see cref="T:System.Windows.Freezable" /> 派生类的新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-232">When implemented in a derived class, creates a new instance of the <see cref="T:System.Windows.Freezable" /> derived class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0f4d-233">新实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-233">The new instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-234">请勿调用此方法，直接 （但调用基实现中）。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-234">Do not call this method directly (except when calling base in an implementation).</span></span> <span data-ttu-id="a0f4d-235">在内部调用此方法<xref:System.Windows.Freezable.CreateInstance%2A>方法时的新实例<xref:System.Windows.Freezable>创建。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-235">This method is called internally by the <xref:System.Windows.Freezable.CreateInstance%2A> method whenever a new instance of the <xref:System.Windows.Freezable> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0f4d-236">下面的示例演示的典型实现<xref:System.Windows.Freezable.CreateInstanceCore%2A>。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-236">The following example shows a typical implementation of <xref:System.Windows.Freezable.CreateInstanceCore%2A>.</span></span>  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0f4d-237">每个<see cref="T:System.Windows.Freezable" />派生的类必须实现此方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-237">Every <see cref="T:System.Windows.Freezable" /> derived class must implement this method.</span>
            </span>
            <span data-ttu-id="a0f4d-238">一个典型的实现是只需调用默认构造函数，并返回结果。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-238">A typical implementation is to simply call the default constructor and return the result.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a0f4d-239">使 <see cref="T:System.Windows.Freezable" /> 对象变为不可修改并将其 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性设置为 <see langword="true" />，或测试是否可将 <see cref="T:System.Windows.Freezable" /> 对象变为不可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-239">Makes a <see cref="T:System.Windows.Freezable" /> object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />, or tests whether a <see cref="T:System.Windows.Freezable" /> object can be made unmodifiable.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a0f4d-240">使当前对象不可修改，并且将其 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性设置为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-240">Makes the current object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-241">若要避免错误的可能性<xref:System.InvalidOperationException>调用此方法时，检查<xref:System.Windows.Freezable.CanFreeze%2A>属性来确定是否<xref:System.Windows.Freezable>可以成为不可修改之前调用此方法。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-241">To avoid the possibility of an <xref:System.InvalidOperationException> when calling this method, check the <xref:System.Windows.Freezable.CanFreeze%2A> property to determine whether the <xref:System.Windows.Freezable> can be made unmodifiable before calling this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0f4d-242">无法将 <see cref="T:System.Windows.Freezable" /> 设置为不可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-242">The <see cref="T:System.Windows.Freezable" /> cannot be made unmodifiable.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0f4d-243">此方法使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法，使<see cref="T:System.Windows.Freezable" />变为不可修改。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-243">This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable.</span>
            </span>
            <span data-ttu-id="a0f4d-244">若要修改冻结行为，请重写<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-244">To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">
          <span data-ttu-id="a0f4d-245">要检查或要变为不可修改的对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-245">The object to check or make unmodifiable.</span>
          </span>
          <span data-ttu-id="a0f4d-246">如果 <paramref name="isChecking" /> 为 <see langword="true" />，则检查此对象，以确定是否可将其变为不可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-246">If <paramref name="isChecking" /> is <see langword="true" />, the object is checked to determine whether it can be made unmodifiable.</span>
          </span>
          <span data-ttu-id="a0f4d-247">如果 <paramref name="isChecking" /> 为 <see langword="false" />，则在可能的情况下将此对象变为不可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-247">If <paramref name="isChecking" /> is <see langword="false" />, the object is made unmodifiable, if possible.</span>
          </span>
        </param>
        <param name="isChecking">
          <span data-ttu-id="a0f4d-248">若为 <see langword="true" />，则返回是否可冻结对象的指示（不实际冻结对象）；若为 <see langword="false" />，则实际冻结对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-248">
              <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0f4d-249">如果 <paramref name="isChecking" /> 参数为 <see langword="true" />，则此方法指示是否可将指定的 <see cref="T:System.Windows.Freezable" /> 变为不可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-249">If the <paramref name="isChecking" /> parameter is <see langword="true" />, this method indicates whether the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable.</span>
          </span>
          <span data-ttu-id="a0f4d-250">如果 <paramref name="isChecking" /> 参数为 <see langword="false" />，则此方法尝试将指定的 <see cref="T:System.Windows.Freezable" /> 变为不可修改，并指示操作是否成功。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-250">If the <paramref name="isChecking" /> parameter is <see langword="false" />, this method attempts to make the specified <see cref="T:System.Windows.Freezable" /> unmodifiable and indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0f4d-251">当 <paramref name="isChecking" /> 为 <see langword="true" /> 时，如果可以将指定的 <see cref="T:System.Windows.Freezable" /> 变为不可修改，则此方法返回 <see langword="true" />；如果无法将其变为不可修改，则返回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-251">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
          <span data-ttu-id="a0f4d-252">当 <paramref name="isChecking" /> 为 <see langword="false" /> 时，如果指定的 <see cref="T:System.Windows.Freezable" /> 目前已经不可修改，则此方法返回 <see langword="true" />；如果无法将其变为不可修改，则返回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-252">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-253">不要调用此方法，除非派生自<xref:System.Windows.Freezable>并重写<xref:System.Windows.Freezable.FreezeCore%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-253">Do not call this method unless you are deriving from <xref:System.Windows.Freezable> and overriding the <xref:System.Windows.Freezable.FreezeCore%2A> method.</span></span>  <span data-ttu-id="a0f4d-254">此方法可在<xref:System.Windows.Freezable.FreezeCore%2A>方法冻结类数据成员本身是<xref:System.Windows.Freezable>对象。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-254">This method may be used in the <xref:System.Windows.Freezable.FreezeCore%2A> method to freeze class data members that are themselves <xref:System.Windows.Freezable> objects.</span></span>  
  
 <span data-ttu-id="a0f4d-255">在再次调用此方法是好<xref:System.Windows.Freezable>已被冻结 （不可修改） 的对象。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-255">It is alright to call this method again on a <xref:System.Windows.Freezable> object that is already frozen (unmodifiable).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0f4d-256">如果 <paramref name="isChecking" /> 为 <see langword="false" />，则表明将 <paramref name="freezable" /> 变为不可修改的尝试已失败；对象目前处于未知状态（可能已将其部分冻结）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-256">When <paramref name="isChecking" /> is <see langword="false" />, the attempt to make <paramref name="freezable" /> unmodifiable was unsuccessful; the object is now in an unknown state (it might be partially frozen).</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0f4d-257">此方法使用<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法，使<see cref="T:System.Windows.Freezable" />变为不可修改。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-257">This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable.</span>
            </span>
            <span data-ttu-id="a0f4d-258">若要修改冻结行为，请重写<see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-258">To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          <span data-ttu-id="a0f4d-259">若为 <see langword="true" />，则返回是否可冻结对象的指示（不实际冻结对象）；若为 <see langword="false" />，则实际冻结对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-259">
              <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0f4d-260">使 <see cref="T:System.Windows.Freezable" /> 对象变为不可修改或测试是否可将其变为不可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-260">Makes the <see cref="T:System.Windows.Freezable" /> object unmodifiable or tests whether it can be made unmodifiable.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0f4d-261">当 <paramref name="isChecking" /> 为 <see langword="true" /> 时，如果可以将 <see cref="T:System.Windows.Freezable" /> 变为不可修改，则此方法返回 <see langword="true" />；如果无法将其变为不可修改，则返回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-261">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
          <span data-ttu-id="a0f4d-262">当 <paramref name="isChecking" /> 为 <see langword="false" /> 时，如果指定的 <see cref="T:System.Windows.Freezable" /> 目前已经不可修改，则此方法返回 <see langword="true" />，如果无法将其变为不可修改，则返回 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-262">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-263">请勿调用此方法，直接 （但调用基实现中）。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-263">Do not call this method directly (except when calling base in an implementation).</span></span> <span data-ttu-id="a0f4d-264">在内部调用此方法<xref:System.Windows.Freezable.CanFreeze%2A>属性 (与`isChecking`等于`true`) 和<xref:System.Windows.Freezable.Freeze%2A>方法 (与`isChecking`等于`false`)。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-264">This method is called internally by the <xref:System.Windows.Freezable.CanFreeze%2A> property (with `isChecking` equal to `true`) and the <xref:System.Windows.Freezable.Freeze%2A> method (with `isChecking` equal to `false`).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0f4d-265">
              <see cref="T:System.Windows.Freezable" /> 此类包含不使用依赖项属性存储的数据时，实施者必须重写此方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-265">
                <see cref="T:System.Windows.Freezable" /> implementers must override this method when the class contains data that is not stored using dependency properties.</span>
            </span>
            <span data-ttu-id="a0f4d-266">一个典型的实现应调用基类，然后调用静态<see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />方法对所有<see cref="T:System.Windows.Freezable" />类型的类包含，返回的属性<see langword="true" />仅当所有属性都被冻结 （或可能已被冻结，在指定的情况下<see langword="true" />为<paramref name="isChecking" />)。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-266">A typical implementation would call base, then call the static <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> method on all <see cref="T:System.Windows.Freezable" /> typed properties that the class contains, returning <see langword="true" /> only if all properties were frozen (or could have been frozen, in the case of specifying <see langword="true" /> for <paramref name="isChecking" />).</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a0f4d-267">使用基（未经过动画处理的）属性值创建 <see cref="T:System.Windows.Freezable" /> 的冻结副本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-267">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" />, using base (non-animated) property values.</span>
          </span>
          <span data-ttu-id="a0f4d-268">由于副本已冻结，因此将通过引用复制任何冻结的子对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-268">Because the copy is frozen, any frozen sub-objects are copied by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0f4d-269">
            <see cref="T:System.Windows.Freezable" /> 的冻结副本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-269">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="a0f4d-270">副本的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性设置为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-270">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-271">应检查<xref:System.Windows.Freezable.CanFreeze%2A>之前调用此方法以验证属性<xref:System.Windows.Freezable>可以冻结。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-271">You should check the <xref:System.Windows.Freezable.CanFreeze%2A> property before calling this method to verify that the <xref:System.Windows.Freezable> can be frozen.</span></span> <span data-ttu-id="a0f4d-272">使用此方法是创建副本都使用类似<xref:System.Windows.Freezable.Clone%2A>，然后将其与冻结<xref:System.Windows.Freezable.Freeze%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-272">Using this method is similar to creating a copy using the <xref:System.Windows.Freezable.Clone%2A> and then freezing it with the <xref:System.Windows.Freezable.Freeze%2A> method.</span></span>  
  
 <span data-ttu-id="a0f4d-273"><xref:System.Windows.Freezable.GetAsFrozen%2A>并<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法可以提高复制性能，因为它们不会克隆<xref:System.Windows.Freezable>子对象的已冻结; 它们仅将它们复制按引用。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-273">The <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods can improve copying performance because they do not clone <xref:System.Windows.Freezable> sub-objects that are already frozen; they only copy them by reference.</span></span>  
  
 <span data-ttu-id="a0f4d-274">下表总结了之间的差异<xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-274">The following table summarizes the differences between the <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods.</span></span>  
  
|<span data-ttu-id="a0f4d-275">操作</span><span class="sxs-lookup"><span data-stu-id="a0f4d-275">Action</span></span>|<span data-ttu-id="a0f4d-276">GetAsFrozen 方法行为</span><span class="sxs-lookup"><span data-stu-id="a0f4d-276">GetAsFrozen method behavior</span></span>|<span data-ttu-id="a0f4d-277">GetCurrentValueAsFrozen 方法行为</span><span class="sxs-lookup"><span data-stu-id="a0f4d-277">GetCurrentValueAsFrozen method behavior</span></span>|  
|------------|---------------------------------|---------------------------------------------|  
|<span data-ttu-id="a0f4d-278">复制包含的表达式的依赖项属性</span><span class="sxs-lookup"><span data-stu-id="a0f4d-278">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="a0f4d-279">该方法将引发<xref:System.InvalidOperationException>因为它不能<xref:System.Windows.Freezable.Freeze%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-279">The method throws an <xref:System.InvalidOperationException> because it cannot <xref:System.Windows.Freezable.Freeze%2A> the property.</span></span>|<span data-ttu-id="a0f4d-280">复制当前表达式的值，但不是表达式本身。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-280">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="a0f4d-281">复制一个动画的依赖项属性</span><span class="sxs-lookup"><span data-stu-id="a0f4d-281">Copying an animated dependency property</span></span>|<span data-ttu-id="a0f4d-282">复制属性的基 （非动画的） 值。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-282">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="a0f4d-283">不复制动画。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-283">Animations are not copied.</span></span>|<span data-ttu-id="a0f4d-284">复制属性的当前动画的值。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-284">The property's current animated value is copied.</span></span> <span data-ttu-id="a0f4d-285">不复制动画。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-285">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="a0f4d-286">请注意，取消设置的属性不会复制，也不是只读的属性。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-286">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
 <span data-ttu-id="a0f4d-287">若要创建一份<xref:System.Windows.Freezable>，它是未被冻结，使用<xref:System.Windows.Freezable.Clone%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-287">To create a copy of the <xref:System.Windows.Freezable> that is not frozen, use the <xref:System.Windows.Freezable.Clone%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0f4d-288">无法冻结此 <see cref="T:System.Windows.Freezable" />，因为它包含表达式或经过动画处理的属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-288">The <see cref="T:System.Windows.Freezable" /> cannot be frozen because it contains expressions or animated properties.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0f4d-289">此方法使用的虚拟<see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />方法以生成克隆。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-289">This method uses the virtual <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="a0f4d-290">要复制的实例。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-290">The instance to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0f4d-291">让该实例成为指定的 <see cref="T:System.Windows.Freezable" /> 的冻结克隆，前者使用基（非动画的）属性值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-291">Makes the instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-292">调用此方法<xref:System.Windows.Freezable.GetAsFrozen%2A>方法应不直接从代码中，除非调用在调用时重写此方法的基实现。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-292">This method is called by the <xref:System.Windows.Freezable.GetAsFrozen%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="a0f4d-293">若要创建当前对象的冻结的副本，请调用<xref:System.Windows.Freezable.GetAsFrozen%2A>而不是直接调用此方法。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-293">To create a frozen copy of the current object, call <xref:System.Windows.Freezable.GetAsFrozen%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0f4d-294">如果从其中派生<see cref="T:System.Windows.Freezable" />可能需要重写此方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-294">If you derive from <see cref="T:System.Windows.Freezable" /> you may need to override this method.</span>
            </span>
            <span data-ttu-id="a0f4d-295">重写的原因包括：</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-295">Reasons to override include the following:</span>
            </span>
            <span data-ttu-id="a0f4d-296">-在派生的类具有未通过依赖关系属性公开的数据。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-296">-   Your derived class has data that is not exposed via dependency properties.</span>
            </span>
            <span data-ttu-id="a0f4d-297">-在派生的类必须执行额外的初始化工作，不能通过仅重写<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-297">-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span>
            </span>
            <span data-ttu-id="a0f4d-298">例如，这适用于你的派生的类实现<see cref="T:System.ComponentModel.ISupportInitialize" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-298">For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.</span>
            </span>
            <span data-ttu-id="a0f4d-299">依赖项属性中存储其所有数据且，不需要执行额外的初始化工作的类无需重写<see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-299">Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.</span>
            </span>
            <span data-ttu-id="a0f4d-300">所有实现，都调用此方法的基实现至关重要。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-300">It is essential that all implementations call the base implementation of this method.</span>
            </span>
            <span data-ttu-id="a0f4d-301">实现才应执行的默认实现不执行工作。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-301">Implementations should only perform work that is not performed by the default implementation.</span>
            </span>
            <span data-ttu-id="a0f4d-302">默认实现使任何的可冻结的对象的所有其他可写的浅表副本，本地设置属性，它包含深层的副本。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-302">The default implementation makes deep copies of any unfrozen freezables and shallow copies of all other writable, locally set properties it contains.</span>
            </span>
            <span data-ttu-id="a0f4d-303">如果对象具有数据绑定依赖关系属性，表达式被复制，但可能不再解析;有关克隆数据绑定对象的详细信息，请参阅[Freezable 对象概述](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-303">If the object has data-bound dependency properties, the expressions are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span>
            </span>
            <span data-ttu-id="a0f4d-304">如果对象具有动画的依赖属性，会复制这些属性的基 （非动画的） 值。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-304">If the object has animated dependency properties, the base (non-animated) values of those properties are copied.</span>
            </span>
            <span data-ttu-id="a0f4d-305">不复制动画。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-305">Animations are not copied.</span>
            </span>
            <span data-ttu-id="a0f4d-306">请注意，取消设置的属性不会复制，也不是只读的属性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-306">Note that unset properties are not copied, nor are read-only properties.</span>
            </span>
            <span data-ttu-id="a0f4d-307">如果你重写此方法，则必须调用基实现。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-307">If you do override this method, you must call the base implementation.</span>
            </span>
            <span data-ttu-id="a0f4d-308">不需要<see cref="M:System.Windows.Freezable.Freeze" />值的复制。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-308">You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.</span>
            </span>
            <span data-ttu-id="a0f4d-309">结果被冻结<see cref="M:System.Windows.Freezable.GetAsFrozen" />之前返回。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-309">The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a0f4d-310">使用当前属性值创建 <see cref="T:System.Windows.Freezable" /> 的冻结副本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-310">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" /> using current property values.</span>
          </span>
          <span data-ttu-id="a0f4d-311">由于副本已冻结，因此将通过引用复制任何冻结的子对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-311">Because the copy is frozen, any frozen sub-objects are copied by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="a0f4d-312">
            <see cref="T:System.Windows.Freezable" /> 的冻结副本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-312">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="a0f4d-313">副本的 <see cref="P:System.Windows.Freezable.IsFrozen" /> 属性设置为 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-313">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-314">使用此方法是创建副本都使用类似<xref:System.Windows.Freezable.CloneCurrentValue%2A>，然后将其与冻结<xref:System.Windows.Freezable.Freeze%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-314">Using this method is similar to creating a copy using the <xref:System.Windows.Freezable.CloneCurrentValue%2A> and then freezing it with the <xref:System.Windows.Freezable.Freeze%2A> method.</span></span>  
  
 <span data-ttu-id="a0f4d-315"><xref:System.Windows.Freezable.GetAsFrozen%2A>并<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法可以提高复制性能，因为它们不会克隆<xref:System.Windows.Freezable>子对象的已冻结; 它们仅将它们复制按引用。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-315">The <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods can improve copying performance because they do not clone <xref:System.Windows.Freezable> sub-objects that are already frozen; they only copy them by reference.</span></span>  
  
 <span data-ttu-id="a0f4d-316">下表总结了之间的差异<xref:System.Windows.Freezable.GetAsFrozen%2A>和<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-316">The following table summarizes the differences between the <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods.</span></span>  
  
|<span data-ttu-id="a0f4d-317">操作</span><span class="sxs-lookup"><span data-stu-id="a0f4d-317">Action</span></span>|<span data-ttu-id="a0f4d-318">GetAsFrozen 方法行为</span><span class="sxs-lookup"><span data-stu-id="a0f4d-318">GetAsFrozen method behavior</span></span>|<span data-ttu-id="a0f4d-319">GetCurrentValueAsFrozen 方法行为</span><span class="sxs-lookup"><span data-stu-id="a0f4d-319">GetCurrentValueAsFrozen method behavior</span></span>|  
|------------|---------------------------------|---------------------------------------------|  
|<span data-ttu-id="a0f4d-320">复制包含的表达式的依赖项属性</span><span class="sxs-lookup"><span data-stu-id="a0f4d-320">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="a0f4d-321">该方法将引发<xref:System.InvalidOperationException>因为它不能<xref:System.Windows.Freezable.Freeze%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-321">The method throws an <xref:System.InvalidOperationException> because it cannot <xref:System.Windows.Freezable.Freeze%2A> the property.</span></span>|<span data-ttu-id="a0f4d-322">复制当前表达式的值，但不是表达式本身。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-322">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="a0f4d-323">复制一个动画的依赖项属性</span><span class="sxs-lookup"><span data-stu-id="a0f4d-323">Copying an animated dependency property</span></span>|<span data-ttu-id="a0f4d-324">复制属性的基 （非动画的） 值。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-324">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="a0f4d-325">不复制动画。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-325">Animations are not copied.</span></span>|<span data-ttu-id="a0f4d-326">复制属性的当前动画的值。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-326">The property's current animated value is copied.</span></span> <span data-ttu-id="a0f4d-327">不复制动画。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-327">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="a0f4d-328">请注意，取消设置的属性不会复制，也不是只读的属性。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-328">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
 <span data-ttu-id="a0f4d-329">若要创建一份<xref:System.Windows.Freezable>，它是未被冻结，使用<xref:System.Windows.Freezable.CloneCurrentValue%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-329">To create a copy of the <xref:System.Windows.Freezable> that is not frozen, use the <xref:System.Windows.Freezable.CloneCurrentValue%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0f4d-330">此方法使用的虚拟<see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />方法以生成克隆。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-330">This method uses the virtual <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="a0f4d-331">要复制和冻结的 <see cref="T:System.Windows.Freezable" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-331">The <see cref="T:System.Windows.Freezable" /> to copy and freeze.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0f4d-332">使当前实例成为指定 <see cref="T:System.Windows.Freezable" /> 的冻结克隆。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-332">Makes the current instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="a0f4d-333">如果对象具有动画依赖属性，则复制其当前的动画值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-333">If the object has animated dependency properties, their current animated values are copied.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-334">调用此方法<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>方法应不直接从代码中，除非调用在调用时重写此方法的基实现。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-334">This method is called by the <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="a0f4d-335">若要创建当前对象的冻结的副本，请调用<xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A>而不是直接调用此方法。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-335">To create a frozen copy of the current object, call <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0f4d-336">如果从其中派生<see cref="T:System.Windows.Freezable" />，可能需要重写此方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-336">If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method.</span>
            </span>
            <span data-ttu-id="a0f4d-337">重写的原因包括：</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-337">Reasons to override include the following:</span>
            </span>
            <span data-ttu-id="a0f4d-338">-在派生的类具有未通过依赖关系属性公开的数据。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-338">-   Your derived class has data that is not exposed via dependency properties.</span>
            </span>
            <span data-ttu-id="a0f4d-339">-在派生的类必须执行额外的初始化工作，不能通过仅重写<see cref="M:System.Windows.Freezable.CreateInstanceCore" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-339">-   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />.</span>
            </span>
            <span data-ttu-id="a0f4d-340">例如，这适用于你的派生的类实现<see cref="T:System.ComponentModel.ISupportInitialize" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-340">For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.</span>
            </span>
            <span data-ttu-id="a0f4d-341">依赖项属性中存储其所有数据且，不需要执行额外的初始化工作的类无需重写<see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-341">Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.</span>
            </span>
            <span data-ttu-id="a0f4d-342">所有实现，都调用此方法的基实现至关重要。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-342">It is essential that all implementations call the base implementation of this method.</span>
            </span>
            <span data-ttu-id="a0f4d-343">实现才应执行的默认实现不执行工作。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-343">Implementations should only perform work that is not performed by the default implementation.</span>
            </span>
            <span data-ttu-id="a0f4d-344">默认实现将创建一个新<see cref="T:System.Windows.Freezable" />使用<see cref="M:System.Windows.Freezable.CreateInstance" />可冻结对象的方法，并使深层副本和卷影副本的所有其他可写本地设置它包含的属性。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-344">The default implementation creates a new <see cref="T:System.Windows.Freezable" /> using the <see cref="M:System.Windows.Freezable.CreateInstance" /> method and makes deep copies of unfrozen freezables and shallow copies of all other writable, locally set properties it contains.</span>
            </span>
            <span data-ttu-id="a0f4d-345">如果对象具有数据绑定依赖关系属性，复制的数据绑定，但可能不再解析;有关克隆数据绑定对象的详细信息，请参阅[Freezable 对象概述](~/docs/framework/wpf/advanced/freezable-objects-overview.md)。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-345">If the object has data-bound dependency properties, the data bindings are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span>
            </span>
            <span data-ttu-id="a0f4d-346">如果该对象具有经过动画处理的依赖项属性，复制这些属性经过动画处理的当前值，但动画不是。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-346">If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.</span>
            </span>
            <span data-ttu-id="a0f4d-347">中的只读依赖属性<see cref="T:System.Windows.Freezable" />不复制此默认实现。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-347">Read-only dependency properties within a <see cref="T:System.Windows.Freezable" /> are not copied by this default implementation.</span>
            </span>
            <span data-ttu-id="a0f4d-348">如果你重写此方法，则必须调用基实现。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-348">If you do override this method, you must call the base implementation.</span>
            </span>
            <span data-ttu-id="a0f4d-349">不需要<see cref="M:System.Windows.Freezable.Freeze" />值的复制。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-349">You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.</span>
            </span>
            <span data-ttu-id="a0f4d-350">结果被冻结<see cref="M:System.Windows.Freezable.GetAsFrozen" />之前返回。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-350">The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="a0f4d-351">获取一个值，该值指示对象当前是否可修改。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-351">Gets a value that indicates whether the object is currently modifiable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="a0f4d-352">如果该对象已被冻结且无法修改，则为 <see langword="true" />；如果可以修改该对象，则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-352">
              <see langword="true" /> if the object is frozen and cannot be modified; <see langword="false" /> if the object can be modified.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-353">尝试修改对象时其<xref:System.Windows.Freezable.IsFrozen%2A>属性是`true`引发<xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-353">Attempting to modify an object when its <xref:System.Windows.Freezable.IsFrozen%2A> property is `true` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="a0f4d-354">此属性是只读的对象模型透视。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-354">This property is read-only from the object model perspective.</span></span> <span data-ttu-id="a0f4d-355">有关文档的一些<xref:System.Windows.Freezable>行为可能涉及"设置<xref:System.Windows.Freezable.IsFrozen%2A>到`true`"或类似语言时讨论的其他方法的行为<xref:System.Windows.Freezable>，但此行为中发生的情况在内部类的实例，当实例方法操作的抽象类中存在的私有变量。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-355">Some of the documentation about <xref:System.Windows.Freezable> behaviors may mention "sets <xref:System.Windows.Freezable.IsFrozen%2A> to `true`" or similar language when discussing the behavior of other methods of <xref:System.Windows.Freezable>, but this behavior is happening internally in the class instances, when methods of the instance manipulate the private variables that exist within the abstract class.</span></span> <span data-ttu-id="a0f4d-356">若要设置此属性的值，应调用<xref:System.Windows.Freezable.Freeze%2A>。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-356">To set the value of this property, you should call <xref:System.Windows.Freezable.Freeze%2A>.</span></span> <span data-ttu-id="a0f4d-357">这实际上是一次性的操作来更改<xref:System.Windows.Freezable.IsFrozen%2A>属性从默认的初始`false`状态转换`true`状态。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-357">This effectively is a one-time operation to change the <xref:System.Windows.Freezable.IsFrozen%2A> property from the initial default `false` state to the `true` state.</span></span> <span data-ttu-id="a0f4d-358">没有可用的方法将值返回到`false`。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-358">There is no available means to set the value back to `false`.</span></span> <span data-ttu-id="a0f4d-359">相反，可以将更改从原始制作的深层副本 (请参阅<xref:System.Windows.Freezable.Clone%2A>方法)。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-359">Instead, you could change any deep copy made from the original (see the <xref:System.Windows.Freezable.Clone%2A> method).</span></span> <span data-ttu-id="a0f4d-360">这是设计使然，任何派生的类的行为方式时应用于事例其中<xref:System.Windows.Freezable>模式非常有用。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-360">This is by design and is how any derived class should behave when applied to the cases where the <xref:System.Windows.Freezable> pattern is useful.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a0f4d-361">修改当前 <see cref="T:System.Windows.Freezable" /> 对象时调用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-361">Called when the current <see cref="T:System.Windows.Freezable" /> object is modified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-362">调用此方法时<xref:System.Windows.Freezable.Changed>事件发生。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-362">This method is called whenever the <xref:System.Windows.Freezable.Changed> event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0f4d-363">当实现派生自的类<see cref="T:System.Windows.Freezable" />，你可以重写此方法以执行任务。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-363">When you implement a class that derives from <see cref="T:System.Windows.Freezable" />, you may override this method to perform tasks.</span>
            </span>
          </para>
        </block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="a0f4d-364">确保为刚刚修改的类型 <see cref="T:System.Windows.DependencyObject" /> 的数据成员建立适当的上下文指针。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-364">Ensures that appropriate context pointers are established for a data member of type <see cref="T:System.Windows.DependencyObject" /> that has just been modified.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">
          <span data-ttu-id="a0f4d-365">数据成员以前的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-365">The previous value of the data member.</span>
          </span>
        </param>
        <param name="newValue">
          <span data-ttu-id="a0f4d-366">数据成员当前的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-366">The current value of the data member.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0f4d-367">确保为刚刚设置的 <see cref="T:System.Windows.DependencyObjectType" /> 数据成员建立适当的上下文指针。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-367">Ensures that appropriate context pointers are established for a <see cref="T:System.Windows.DependencyObjectType" /> data member that has just been set.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-368">此方法应由调用<xref:System.Windows.Freezable>继承者每次<xref:System.Windows.DependencyObject>不作为存储的数据成员<xref:System.Windows.DependencyProperty>设置。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-368">This method should be called by <xref:System.Windows.Freezable> inheritors each time a <xref:System.Windows.DependencyObject> data member that is not stored as a <xref:System.Windows.DependencyProperty> is set.</span></span>  
  
 <span data-ttu-id="a0f4d-369">此方法不需要为其调用<xref:System.Windows.DependencyObject>使用存储的数据成员<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-369">This method does not need to be called for <xref:System.Windows.DependencyObject> data members that are stored using a <xref:System.Windows.DependencyProperty>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">
          <span data-ttu-id="a0f4d-370">数据成员以前的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-370">The previous value of the data member.</span>
          </span>
        </param>
        <param name="newValue">
          <span data-ttu-id="a0f4d-371">数据成员当前的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-371">The current value of the data member.</span>
          </span>
        </param>
        <param name="property">
          <span data-ttu-id="a0f4d-372">已更改的属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-372">The property that changed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0f4d-373">此成员支持 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基础结构，但不能在代码中直接使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-373">This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="a0f4d-374">包含有关已更改的属性的信息及其旧值和新值的事件数据。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-374">Event data that contains information about which property changed, and its old and new values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="a0f4d-375">重写 <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> 的 <see cref="T:System.Windows.DependencyObject" /> 实现，以同时调用任何响应类型 <see cref="T:System.Windows.Freezable" /> 不断变化的依赖属性的 <see cref="E:System.Windows.Freezable.Changed" /> 处理程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-375">Overrides the <see cref="T:System.Windows.DependencyObject" /> implementation of <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> to also invoke any <see cref="E:System.Windows.Freezable.Changed" /> handlers in response to a changing dependency property of type <see cref="T:System.Windows.Freezable" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-376">事件数据包含以下信息仅<xref:System.Windows.Freezable>本身。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-376">The event data contains information about only the <xref:System.Windows.Freezable> itself.</span></span> <span data-ttu-id="a0f4d-377">子属性的任何信息必须通过获得<xref:System.Windows.Freezable.Changed>处理程序。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-377">Any sub-property information must be obtained through the <xref:System.Windows.Freezable.Changed> handlers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a0f4d-378">确保正在从有效的线程访问 <see cref="T:System.Windows.Freezable" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-378">Ensures that the <see cref="T:System.Windows.Freezable" /> is being accessed from a valid thread.</span>
          </span>
          <span data-ttu-id="a0f4d-379">
            <see cref="T:System.Windows.Freezable" /> 的继承者必须在任何 [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] 一开始读取不属于依赖项对象的数据成员时调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-379">Inheritors of <see cref="T:System.Windows.Freezable" /> must call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that reads data members that are not dependency properties.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0f4d-380">派生的类<see cref="T:System.Windows.Freezable" />应调用<see cref="M:System.Windows.Freezable.ReadPreamble" />方法之前尝试访问不依赖项属性的任何成员。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-380">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call the <see cref="M:System.Windows.Freezable.ReadPreamble" /> method before they attempt to access any members that are not dependency properties.</span>
            </span>
            <span data-ttu-id="a0f4d-381">
              <see cref="M:System.Windows.Freezable.WritePreamble" />任何此类成员写入前，应调用方法。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-381">The <see cref="M:System.Windows.Freezable.WritePreamble" /> method should be called before any such members are written to.</span>
            </span>
            <span data-ttu-id="a0f4d-382">此方法实际上不执行任何操作多个调用<see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-382">This method effectively does nothing more than call <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a0f4d-383">引发 <see cref="T:System.Windows.Freezable" /> 的 <see cref="E:System.Windows.Freezable.Changed" /> 事件并调用其 <see cref="M:System.Windows.Freezable.OnChanged" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-383">Raises the <see cref="E:System.Windows.Freezable.Changed" /> event for the <see cref="T:System.Windows.Freezable" /> and invokes its <see cref="M:System.Windows.Freezable.OnChanged" /> method.</span>
          </span>
          <span data-ttu-id="a0f4d-384">从 <see cref="T:System.Windows.Freezable" /> 派生的类应在修改的类成员不存储为依赖属性的任何 API 的末尾调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-384">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies class members that are not stored as dependency properties.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0f4d-385">派生的类<see cref="T:System.Windows.Freezable" />应调用此方法修改不存储为一个类成员的任何 API 结束时<see cref="T:System.Windows.DependencyProperty" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-385">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies a class member that is not stored as a <see cref="T:System.Windows.DependencyProperty" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="a0f4d-386">验证 <see cref="T:System.Windows.Freezable" /> 是否未被冻结，并且是否正在从有效的线程上下文中访问它。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-386">Verifies that the <see cref="T:System.Windows.Freezable" /> is not frozen and that it is being accessed from a valid threading context.</span>
          </span>
          <span data-ttu-id="a0f4d-387">
            <see cref="T:System.Windows.Freezable" /> 的继承项应当在任何 [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] 一开始写入不属于依赖项属性的数据成员时调用此方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-387">
              <see cref="T:System.Windows.Freezable" /> inheritors should call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that writes to data members that are not dependency properties.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0f4d-388">此方法调用<xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>若要验证的线程上下文可访问，并且如果引发了异常<xref:System.Windows.Freezable>实例已冻结。</span><span class="sxs-lookup"><span data-stu-id="a0f4d-388">This method calls <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> to verify the threading context is accessible, and it throws an exception if the <xref:System.Windows.Freezable> instance is already frozen.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="a0f4d-389">
            <see cref="T:System.Windows.Freezable" /> 实例已冻结，并且无法写入其成员。</span>
          <span class="sxs-lookup">
            <span data-stu-id="a0f4d-389">The <see cref="T:System.Windows.Freezable" /> instance is frozen and cannot have its members written to.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="a0f4d-390">派生的类<see cref="T:System.Windows.Freezable" />应调用<see cref="M:System.Windows.Freezable.WritePreamble" />前尝试写入不属于依赖项属性的任何成员。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-390">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call <see cref="M:System.Windows.Freezable.WritePreamble" /> before attempting to write to any members that are not dependency properties.</span>
            </span>
            <span data-ttu-id="a0f4d-391">如果您调用<see cref="M:System.Windows.Freezable.WritePreamble" />中[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]，则可以省略调用<see cref="M:System.Windows.Freezable.ReadPreamble" />。</span>
            <span class="sxs-lookup">
              <span data-stu-id="a0f4d-391">If you call <see cref="M:System.Windows.Freezable.WritePreamble" /> in an [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], you can omit a call to <see cref="M:System.Windows.Freezable.ReadPreamble" />.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>