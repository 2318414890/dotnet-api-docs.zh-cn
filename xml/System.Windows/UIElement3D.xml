<Type Name="UIElement3D" FullName="System.Windows.UIElement3D">
  <Metadata><Meta Name="ms.openlocfilehash" Value="56e8cba6ee61feec3845809abc68440c95af6e00" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53233622" /></Metadata><TypeSignature Language="C#" Value="public abstract class UIElement3D : System.Windows.Media.Media3D.Visual3D, System.Windows.IInputElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract UIElement3D extends System.Windows.Media.Media3D.Visual3D implements class System.Windows.IInputElement" />
  <TypeSignature Language="DocId" Value="T:System.Windows.UIElement3D" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class UIElement3D&#xA;Inherits Visual3D&#xA;Implements IInputElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class UIElement3D abstract : System::Windows::Media::Media3D::Visual3D, System::Windows::IInputElement" />
  <TypeSignature Language="F#" Value="type UIElement3D = class&#xA;    inherit Visual3D&#xA;    interface IInputElement" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Media3D.Visual3D</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><see cref="T:System.Windows.UIElement3D" /> 是 WPF 核心级实现的基类，这些实现是在 Windows Presentation Foundation (WPF) 元素和基本表示特性上生成的。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D> 是一个可以从其派生类来表示特定的三维元素的抽象基类。  
  
 三维元素的输入、 焦点和事件处理行为的一般情况下中定义了许多<xref:System.Windows.UIElement3D>类。 这包括键盘、 鼠标和触笔输入和相关的状态属性的事件。 许多这些事件是路由的事件，并有许多与输入相关的事件的这两个浮升路由版本，以及事件的隧道版本。 这些配对的事件通常是控件作者最感兴趣的事件。  
  
 <xref:System.Windows.UIElement3D> 此外包括[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]使与相关[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]事件模型，包括可以引发指定的方法路由源自元素实例的事件。  
  
 一个<xref:System.Windows.UIElement3D>具有以下功能的具体定义<xref:System.Windows.UIElement3D>类：  
  
-   可以响应用户输入 (包括控制输入通过处理事件的发送位置的路由或路由的命令)。  
  
-   可以引发逻辑元素树路由的路由的事件。  
  
> [!IMPORTANT]
>  <xref:System.Windows.UIElement3D.Visibility%2A> 状态会影响该元素的所有输入处理。 不可见的元素不参与命中测试和不接收输入的事件，即使鼠标位于边界的元素将是如果可见。  
  
 与不同<xref:System.Windows.UIElement>类，<xref:System.Windows.UIElement3D>类不包括布局。 因此，<xref:System.Windows.UIElement3D>类不包括**度量值**或**排列**方法。  
  
 从派生的类<xref:System.Windows.UIElement3D>并维护其自己的集合<xref:System.Windows.Media.Media3D.Visual3D>对象通过重写<xref:System.Windows.Media.Media3D.Visual3D.GetVisual3DChild%2A>并<xref:System.Windows.Media.Media3D.Visual3D.Visual3DChildrenCount%2A>必须仍传递新<xref:System.Windows.Media.Media3D.Visual3D>对象添加到<xref:System.Windows.Media.Media3D.Visual3D.AddVisual3DChild%2A>。  
  
 <xref:System.Windows.UIElement3D> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
   
  
## Examples  
 下面的示例演示如何从派生<xref:System.Windows.UIElement3D>类，以创建`Sphere`类：  
  
 [!code-csharp[Shapes#Sphere](~/samples/snippets/csharp/VS_Snippets_Wpf/Shapes/CSharp/Sphere.cs#sphere)]
 [!code-vb[Shapes#Sphere](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Shapes/visualbasic/sphere.vb#sphere)]  
  
 有关完整示例，请参阅[UIElement3D 球体示例](https://go.microsoft.com/fwlink/?LinkID=160044)。  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UIElement3D ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; UIElement3D();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.UIElement3D" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.%23ctor%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为指定的路由事件添加路由事件处理程序，并将该处理程序添加到当前元素的处理程序集合中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="uIElement3D.AddHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">要处理的路由事件的标识符。</param>
        <param name="handler">对处理程序实现的引用。</param>
        <summary>为指定的路由事件添加路由事件处理程序，并将该处理程序添加到当前元素的处理程序集合中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以将相同事件的同一处理程序添加多个时间并且不会引发异常。 但是，实际调用处理程序处理该事件时的多个时间。 因此，请考虑此行为可能应该在处理程序实现中考虑的副作用。  
  
 通常使用此方法提供的"添加"访问器实现[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]事件的自定义的路由事件的访问模式。  
  
 <xref:System.Windows.UIElement3D.AddHandler%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberSignature Language="F#" Value="member this.AddHandler : System.Windows.RoutedEvent * Delegate * bool -&gt; unit" Usage="uIElement3D.AddHandler (routedEvent, handler, handledEventsToo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent">要处理的路由事件的标识符。</param>
        <param name="handler">对处理程序实现的引用。</param>
        <param name="handledEventsToo">如果为 <see langword="true" />，则将按以下方式注册处理程序：即使路由事件在其事件数据中标记为已处理，也会调用处理程序；如果为 <see langword="false" />，则使用默认条件注册处理程序，即当路由事件被标记为已处理时，将不调用处理程序。  
  
默认值为 <see langword="false" />。  
  
请勿定期请求重新处理路由事件。</param>
        <summary>为指定的路由事件添加路由事件处理程序，并将该处理程序添加到当前元素的处理程序集合中。 将 <paramref name="handledEventsToo" /> 指定为 <see langword="true" />，可为已标记为由事件路由中的其他元素处理的路由事件调用所提供的处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以实用方式处理低级别的输入的事件是一个复杂的任务。 许多控件实现其中某个事件被标记为已处理，并且另一个更直观的事件会被替换的行为。 通常情况下，控件将仅标记平台输入的事件，为已处理是否存在某个设计意图要求执行此操作。 在某些情况下，这些设计意图可能不是在特定输入事件的处理要求。 它对于这种情况是该注册处理程序替换`handledEventsToo`作为`true`适用。 但不是应定期执行此。 调用以响应所有事件处理程序，即使处理将增加你自己的应用程序事件处理逻辑的复杂性。 如果是巨大的处理程序逻辑，可能会降低性能。 你应保留附加的已处理事件的情况下，您已经发现在开发过程中的某些控件正在处理你仍想要使用的应用程序逻辑来处理的事件处理程序的使用。  
  
 避免处理的某些事件控件组合的行为的类的另一种方法是使用该事件的预览替代方法。 例如，如果<xref:System.Windows.UIElement3D.MouseLeftButtonDown>标记为已处理类处理，您可以为添加处理程序<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown>相反。  
  
 可以将相同事件的同一处理程序添加多个时间并且不会引发异常。 但是，实际调用处理程序处理该事件时的多个时间。 因此，请考虑此行为可能应该在处理程序实现中考虑的副作用。  
  
 通常使用此方法提供的"添加"访问器实现[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]事件的自定义的路由事件的访问模式。  
  
 <xref:System.Windows.UIElement3D.AddHandler%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToEventRoute (route As EventRoute, e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToEventRoute(System::Windows::EventRoute ^ route, System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AddToEventRoute : System.Windows.EventRoute * System.Windows.RoutedEventArgs -&gt; unit" Usage="uIElement3D.AddToEventRoute (route, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route">要向其添加处理程序的事件路由。</param>
        <param name="e">用于添加处理程序的事件数据。 此方法使用事件数据的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 属性创建处理程序。</param>
        <summary>将处理程序添加到当前 <see cref="T:System.Windows.EventRoute" /> 事件处理程序集合的指定 <see cref="T:System.Windows.UIElement3D" /> 中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可以由内容宿主元素 (实现<xref:System.Windows.IContentHost>或不匹配的) 若要添加到的子元素的处理程序<xref:System.Windows.EventRoute>。  
  
 <xref:System.Windows.UIElement3D.AddToEventRoute%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.UIElement3D.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示此元素能否用作拖放操作的目标。</summary>
        <value>如果此元素可用作拖放操作的目标，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 拖放操作默认情况下，不启用，必须通过设置有意启用<xref:System.Windows.UIElement3D.AllowDrop%2A>到`true`。 除了此基本设置，拖放行为则完全是特定于实现的并且不由<xref:System.Windows.UIElement3D>或任何其他基元素类。 例如，某些控件<xref:System.Windows.Controls.RichTextBox>，是否有默认行为。 拖放功能的详细信息，请参阅[拖放概述](~/docs/framework/wpf/advanced/drag-and-drop-overview.md)。  
  
 <xref:System.Windows.UIElement3D.AllowDrop%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.AllowDropProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.AllowDropProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowDropProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowDropProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowDropProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.AllowDropProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.AllowDrop" /> 依赖项属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.AllowDropProperty> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.AreAnyTouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCaptured : bool" Usage="System.Windows.UIElement3D.AreAnyTouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示在此元素上是否至少捕获了一次触摸。</summary>
        <value>如果在此元素上至少捕获了一次触摸，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.AreAnyTouchesCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.AreAnyTouchesCaptured" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCapturedWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCapturedWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCapturedWithin : bool" Usage="System.Windows.UIElement3D.AreAnyTouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示在此元素或其可视化树中的任何子元素上是否至少捕获了一次触摸。</summary>
        <value>如果在此元素或其可视化树中的任何子元素上至少捕获了一次触摸，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.AreAnyTouchesCapturedWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.AreAnyTouchesCapturedWithin" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesDirectlyOver : bool" Usage="System.Windows.UIElement3D.AreAnyTouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示在此元素上是否至少按下了一次触摸设备。</summary>
        <value>如果在此元素上至少按下了一次触摸设备，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.AreAnyTouchesDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.AreAnyTouchesDirectlyOver" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.AreAnyTouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesOver : bool" Usage="System.Windows.UIElement3D.AreAnyTouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示在此元素或其可视化树中的任何子元素上是否至少按下了一次触摸设备。</summary>
        <value>如果在此元素或其可视化树中的任何子元素上至少按下了一次触摸设备，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.AreAnyTouchesOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.AreAnyTouchesOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.AreAnyTouchesOver" /> 依赖项属性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.CaptureMouse" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureMouse () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureMouse();" />
      <MemberSignature Language="F#" Value="abstract member CaptureMouse : unit -&gt; bool&#xA;override this.CaptureMouse : unit -&gt; bool" Usage="uIElement3D.CaptureMouse " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureMouse</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>尝试将鼠标强制捕获到此元素。</summary>
        <returns>如果成功捕获了鼠标，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要捕获，必须启用一个元素。 检查是否<xref:System.Windows.UIElement3D.IsEnabled%2A>是`true`在调用之前<xref:System.Windows.UIElement3D.CaptureMouse%2A>。  
  
 如果调用<xref:System.Windows.UIElement3D.CaptureMouse%2A>将返回`true`，然后<xref:System.Windows.UIElement3D.IsMouseCaptured%2A>也是`true`。  
  
 如果调用<xref:System.Windows.UIElement3D.CaptureMouse%2A>返回`true`，然后<xref:System.Windows.UIElement3D.GotMouseCapture>并<xref:System.Windows.UIElement3D.IsMouseCapturedChanged>引发事件，与<xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType>在事件数据报告为元素其中<xref:System.Windows.UIElement3D.CaptureMouse%2A>调用方法。 如果强制捕获，您可能会妨碍现有捕获-尤其是在使用与拖放鼠标捕获。  
  
 若要清除的所有元素的鼠标捕获，请调用<xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType>与`element`参数作为提供`null`。  
  
 <xref:System.Windows.UIElement3D.CaptureMouse%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.CaptureStylus" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureStylus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureStylus();" />
      <MemberSignature Language="F#" Value="abstract member CaptureStylus : unit -&gt; bool&#xA;override this.CaptureStylus : unit -&gt; bool" Usage="uIElement3D.CaptureStylus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureStylus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>尝试将触笔强制捕获到此元素。</summary>
        <returns>如果成功捕获了触笔，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 始终根据基础默认触笔设备的默认实现返回`true`。 但是，如果你要扩展提供在输入系统的设备实现的输入的设备，就可以创建的系统可能会返回不同结果的替代触笔设备实现。  
  
 在元素捕获触笔，它会接收触笔输入，即使在触笔位于其边界外。 只有在拖放操作通常捕获触笔。  
  
 调用此方法调用一个基础的静态<xref:System.Windows.Input.Stylus>方法<xref:System.Windows.Input.Stylus.Capture%2A>。 由活动触笔设备实现实现的实际捕获行为。  
  
 若要捕获，必须启用一个元素。 检查是否<xref:System.Windows.UIElement3D.IsEnabled%2A>是`true`返回在调用之前<xref:System.Windows.UIElement3D.CaptureStylus%2A>。  
  
 如果调用<xref:System.Windows.UIElement3D.CaptureStylus%2A>将返回`true`，<xref:System.Windows.UIElement3D.IsStylusCaptured%2A>也是`true`。  
  
 <xref:System.Windows.UIElement3D.CaptureStylus%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CaptureTouch(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.CaptureTouch : System.Windows.Input.TouchDevice -&gt; bool" Usage="uIElement3D.CaptureTouch touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">要捕获的设备。</param>
        <summary>尝试将触摸屏输入强制捕获到此元素。</summary>
        <returns>如果将指定触摸屏输入捕获到此元素，则为 <see langword="true" /> ；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.CaptureTouch%2A> 将返回`false`如果<xref:System.Windows.Input.TouchDevice>当前捕获到另一个元素。  
  
 如果<xref:System.Windows.UIElement3D.CaptureTouch%2A>将返回`true`，则<xref:System.Windows.UIElement3D.GotTouchCapture>引发事件。  
  
 若要释放的单个触摸屏输入从此元素的捕获，请使用<xref:System.Windows.UIElement3D.ReleaseTouchCapture%2A>方法并指定要发布的触摸设备。 若要释放此元素上的所有触摸，使用<xref:System.Windows.UIElement3D.ReleaseAllTouchCaptures%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="touchDevice" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Windows.Input.TouchDevice.Capture(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.CommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CommandBindings As CommandBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::CommandBindingCollection ^ CommandBindings { System::Windows::Input::CommandBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandBindings : System.Windows.Input.CommandBindingCollection" Usage="System.Windows.UIElement3D.CommandBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与此元素关联的 <see cref="T:System.Windows.Input.CommandBinding" /> 对象的集合。</summary>
        <value>所有 <see cref="T:System.Windows.Input.CommandBinding" /> 对象的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个<xref:System.Windows.Input.CommandBinding>启用此元素的特定命令的命令处理并声明命令、 其事件和由此元素附加的处理程序之间的链接。  
  
 另一种典型的方法来填充<xref:System.Windows.UIElement3D.CommandBindings%2A>集合是使用<xref:System.Windows.Input.CommandManager>方法以编程方式。  
  
 <xref:System.Windows.UIElement3D.CommandBindings%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreCommandBindings*  
 一个或多个<xref:System.Windows.Input.CommandBinding>元素。 其中每项功能都应有<xref:System.Windows.Input.CommandBinding.Command%2A>属性设置为已知命令和属性设置为<xref:System.Windows.Input.CommandBinding.CanExecute>和<xref:System.Windows.Input.CommandBinding.Executed>的处理程序实现。 有关详细信息，请参阅 <xref:System.Windows.Input.CommandBinding>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.DragEventHandler " Usage="member this.DragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在输入系统报告出现以此元素为拖动目标的基础拖动事件时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.DragEnter?displayProperty=nameWithType>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.DragEnter>事件附加到基础<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.DragEnter> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_DragEnter"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.DragEnterEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.DragEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewDragEnter>。  
  
-   重写<xref:System.Windows.UIElement3D.OnDragEnter%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragLeave" />
        <altmember cref="E:System.Windows.UIElement3D.DragOver" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.DragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.DragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.DragEnter" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.DragEnterEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : System.Windows.DragEventHandler " Usage="member this.DragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在输入系统报告出现以此元素为拖动起点的基础拖动事件时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>附加的此类事件，以便<xref:System.Windows.UIElement3D.DragLeave?displayProperty=nameWithType>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.DragLeave>事件附加到基础<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.DragLeave> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_DragLeave"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.DragLeaveEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.DragEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewDragLeave>。  
  
-   重写<xref:System.Windows.UIElement3D.OnDragLeave%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragEnter" />
        <altmember cref="E:System.Windows.UIElement3D.DragOver" />
        <altmember cref="E:System.Windows.UIElement3D.GiveFeedback" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.DragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.DragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.DragLeave" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.DragLeaveEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.DragEventHandler " Usage="member this.DragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在输入系统报告出现以此元素为可能放置目标的基础拖动事件时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 即使拖动源自于的元素边界时发生此事件。 如果拖动边界之外启动，然后将移动内容，也会引发此事件，以及<xref:System.Windows.UIElement3D.DragEnter>和相关的预览事件。  
  
 此事件创建一个别名<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>附加的此类事件，以便<xref:System.Windows.UIElement3D.DragOver?displayProperty=nameWithType>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.DragOver>事件附加到基础<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.DragOver> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_DragOver"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.DragOverEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.DragEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewDragOver>。  
  
-   重写<xref:System.Windows.UIElement3D.OnDragOver%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragEnter" />
        <altmember cref="E:System.Windows.UIElement3D.DragLeave" />
        <altmember cref="E:System.Windows.UIElement3D.Drop" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.DragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.DragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.DragOver" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.DragOverEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.Drop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ Drop;" />
      <MemberSignature Language="F#" Value="member this.Drop : System.Windows.DragEventHandler " Usage="member this.Drop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在输入系统报告出现将此元素作为放置目标的基础放置事件时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>附加的此类事件，以便<xref:System.Windows.UIElement3D.Drop?displayProperty=nameWithType>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.Drop>事件附加到基础<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.Drop> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_Drop"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.DropEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.DragEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewDrop>。  
  
-   重写<xref:System.Windows.UIElement3D.OnDrop%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragOver" />
        <altmember cref="E:System.Windows.UIElement3D.MouseLeftButtonUp" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.DropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DropEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.DropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.Drop" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.DropEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Focus();" />
      <MemberSignature Language="F#" Value="abstract member Focus : unit -&gt; bool&#xA;override this.Focus : unit -&gt; bool" Usage="uIElement3D.Focus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.Focus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>尝试对此元素设置逻辑焦点。</summary>
        <returns>如果逻辑焦点和键盘焦点都设定到此元素上，则为 <see langword="true" />；如果仅设定逻辑焦点，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可获得焦点，<xref:System.Windows.UIElement3D.Focusable%2A>并<xref:System.Windows.UIElement3D.IsEnabled%2A>都必须`true`。  
  
 即使元素是特定树中的可获得焦点并已启用，事件处理，（例如，针对复合控件） 可能会响应预览焦点事件通过不允许焦点，因此此方法将返回`false`。  
  
 如果调用<xref:System.Windows.UIElement3D.Focus%2A>将返回`true`，<xref:System.Windows.UIElement3D.IsKeyboardFocused%2A>并<xref:System.Windows.UIElement3D.IsKeyboardFocusWithin%2A>还有`true`。  
  
 如果相关的属性不是已经`true`，则在调用<xref:System.Windows.UIElement3D.Focus%2A>，按以下顺序引发一个或多个以下事件： <xref:System.Windows.UIElement3D.PreviewLostKeyboardFocus>， <xref:System.Windows.UIElement3D.PreviewGotKeyboardFocus> （来源为新的焦点目标）， <xref:System.Windows.UIElement3D.IsKeyboardFocusedChanged>， <xref:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged>，<xref:System.Windows.UIElement3D.LostKeyboardFocus>， <xref:System.Windows.UIElement3D.GotKeyboardFocus> （来源为新的焦点目标）。  
  
 为了使此调用成功，应用程序中的某些其他元素需要以前具有焦点。  
  
 焦点通常受两个不同的概念： 键盘焦点和逻辑焦点，并不总是相同。 此方法设置逻辑焦点，并还会尝试设置键盘焦点。 没有设置键盘焦点具体而言，这是由用户输入的编程方法。 有关详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.Focus%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.Focusable" />
      <MemberSignature Language="VB.NET" Value="Public Property Focusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focusable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Focusable : bool with get, set" Usage="System.Windows.UIElement3D.Focusable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.Focusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示元素能否得到焦点。</summary>
        <value>如果元素能得到焦点，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 具有焦点的元素接收键盘输入。  
  
 <xref:System.Windows.UIElement3D.Focusable%2A> 是[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]属性访问器，它实际上是依赖项属性。 此特定的依赖项属性经常具有派生的元素的类以不同方式设置其原本"默认"值。 这通常发生在两种方式之一：  
  
-   由特定的派生类，继承依赖属性，但该派生类重写依赖属性的元数据，并更改属性的默认值。  
  
 <xref:System.Windows.UIElement3D.Focusable%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_Focusable"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.FocusableProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="E:System.Windows.UIElement3D.GotKeyboardFocus" />
        <altmember cref="E:System.Windows.UIElement3D.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.FocusableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FocusableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ FocusableChanged;" />
      <MemberSignature Language="F#" Value="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="P:System.Windows.UIElement3D.Focusable" /> 属性的值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.FocusableChanged> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.Focusable" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.FocusableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusableProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusableProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.FocusableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.Focusable" /> 依赖项属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.FocusableProperty> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="member this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="uIElement3D.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，如果不存在可视父级，则返回其他[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 父级。</summary>
        <returns>如果派生类的实现具有要报告的替代父级连接，则为一个对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认虚拟实现返回`null`。 <xref:System.Windows.FrameworkElement> 提供了实际的实现。  
  
 替代父级的用于事件路由，在其中元素创建的替代父结构以便将其事件路由有何区别路由到标准的父级，在可视树的标准模式的方式的情况下或在向下预览路由策略。  
  
 <xref:System.Windows.UIElement3D.GetUIParentCore%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在输入系统报告出现涉及此元素的基础拖放操作时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.GiveFeedback>事件允许拖动事件，可以修改鼠标指针的外观，以便为用户可视反馈提供拖放操作期间的源。 视觉反馈用于强调拖放操作正在进行。  
  
 此事件创建一个别名<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>附加的此类事件，以便<xref:System.Windows.UIElement3D.GiveFeedback>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.GiveFeedback>事件附加到基础<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.GiveFeedback> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.GiveFeedbackEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewGiveFeedback>。  
  
-   重写<xref:System.Windows.UIElement3D.OnGiveFeedback%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragLeave" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.GiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.GiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.GiveFeedback" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.GiveFeedbackEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.RoutedEventHandler " Usage="member this.GotFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素获得逻辑焦点时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果焦点有意强制使用方法调用，但前一个键盘焦点位于不同的作用域将与键盘焦点不同逻辑焦点。 在此方案中，键盘焦点将保持其所在位置和元素其中<xref:System.Windows.UIElement3D.Focus%2A>方法称为仍获得逻辑焦点。  
  
 此事件的更精确地解释是它时引发的值<xref:System.Windows.UIElement3D.IsFocused%2A>路由中元素的属性有所不同`false`到`true`。  
  
 此事件使用冒泡路由，因为接收焦点的元素可能是而不是元素的子元素实际附加事件处理程序。 检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据以确定实际获得焦点的元素中。  
  
 <xref:System.Windows.UIElement3D.GotFocus> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_GotFocus"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.GotFocusEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.RoutedEventHandler>|  
  
-   没有相应的隧道事件。  
  
-   重写<xref:System.Windows.UIElement3D.OnGotFocus%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.GotKeyboardFocus" />
        <altmember cref="M:System.Windows.UIElement3D.Focus" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.GotFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.GotFocusEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.GotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ GotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素聚焦于键盘时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsKeyboardFocusedChanged> 是一个类似的事件，跟踪中维护一个元素; 的焦点状态的属性的状态更改<xref:System.Windows.UIElement3D.GotKeyboardFocus>中许多相同的情况下引发事件。  
  
 此事件使用冒泡路由，因为具有焦点的元素可能是而不是元素的子元素实际附加事件处理程序。 检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据以确定实际具有焦点的元素中。  
  
 此事件创建一个别名<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>附加的此类事件，以便<xref:System.Windows.UIElement3D.GotKeyboardFocus>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.GotKeyboardFocus>事件附加到基础<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.GotKeyboardFocus> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.GotKeyboardFocusEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewGotKeyboardFocus>。  
  
-   重写<xref:System.Windows.UIElement3D.OnGotKeyboardFocus%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.LostKeyboardFocus" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.GotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.GotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.GotKeyboardFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.GotKeyboardFocusEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ GotMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素捕获鼠标时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在元素捕获鼠标，它会接收鼠标输入，即使在鼠标指针位于其边界外。 鼠标通常仅在拖放操作期间捕获和保持捕获，直到发生拖放操作。  
  
 此事件使用冒泡路由，因为具有捕获的元素可能是而不是元素的子元素实际附加事件处理程序。 检查<xref:System.Windows.RoutedEventArgs.Source%2A>在事件数据，以确定实际元素具有鼠标捕获。  
  
 此事件创建一个别名<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>附加的此类事件，以便<xref:System.Windows.UIElement3D.GotMouseCapture>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.GotMouseCapture>事件附加到基础<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.GotMouseCapture> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.GotMouseCaptureEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   没有定义相应的隧道事件。  
  
-   重写<xref:System.Windows.UIElement3D.OnGotMouseCapture%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.CaptureMouse" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.GotMouseCapture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.GotMouseCaptureEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.GotStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ GotStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素捕获触笔时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在元素捕获触笔，它会接收触笔输入，即使在指针位于其边界外。 在触笔通常仅在拖放操作期间捕获和捕获之前发生拖放操作的状态将保持。  
  
 此事件使用冒泡路由，因为具有捕获的元素可能是而不是元素的子元素实际附加事件处理程序。 检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据来确定具有捕获的实际元素中。  
  
 此事件创建此类的附加事件的别名，以便<xref:System.Windows.UIElement3D.GotStylusCapture>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.GotStylusCapture>事件附加到基础<xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.GotStylusCapture> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.GotStylusCaptureEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   没有定义相应的隧道事件。  
  
-   重写<xref:System.Windows.UIElement3D.OnGotStylusCapture%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.GotStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.GotStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.GotStylusCapture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.GotStylusCaptureEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.GotTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ GotTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.GotTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.GotTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素上捕获触摸屏输入时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.GotTouchCaptureEvent>|  
|路由策略|浮升|  
|委托|<xref:System.EventHandler%601> 类型的 <xref:System.Windows.Input.TouchEventArgs>|  
  
-   重写<xref:System.Windows.UIElement3D.OnGotTouchCapture%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.GotTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.GotTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.GotTouchCapture" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.InputBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputBindings As InputBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputBindingCollection ^ InputBindings { System::Windows::Input::InputBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputBindings : System.Windows.Input.InputBindingCollection" Usage="System.Windows.UIElement3D.InputBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与此元素关联的输入绑定的集合。</summary>
        <value>输入绑定的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 输入的绑定支持命令来输入设备的绑定。 例如，<xref:System.Windows.Input.MouseBinding>实现的输入包括特定于鼠标设备的属性的绑定。  
  
 适用于类型的输入的绑定以及声明的实例的输入的绑定，将包括输入绑定的集合。  
  
 相关的属性， <xref:System.Windows.UIElement3D.CommandBindings%2A>，维护命令绑定的集合。 这些不同于输入绑定，因为它们表示下一级别的命令处理过程绑定到已知命令的操作。  
  
 <xref:System.Windows.UIElement3D.InputBindings%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## <a name="xaml-property-element-usage"></a>XAML 属性元素用法  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreInputBindings*  
 一个或多个<xref:System.Windows.Input.InputBinding>元素 (通常<xref:System.Windows.Input.KeyBinding>或<xref:System.Windows.Input.MouseBinding>派生类)。 其中每项功能都必须具有<xref:System.Windows.Input.InputBinding.Command%2A>和<xref:System.Windows.Input.InputBinding.Gesture%2A>属性设置。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateModel">
      <MemberSignature Language="C#" Value="public void InvalidateModel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateModel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.InvalidateModel" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateModel ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateModel();" />
      <MemberSignature Language="F#" Value="member this.InvalidateModel : unit -&gt; unit" Usage="uIElement3D.InvalidateModel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使表示元素的模型无效。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当您从派生类<xref:System.Windows.UIElement3D>类，您可以使用此方法一起使用<xref:System.Windows.UIElement3D.OnUpdateModel%2A>方法来刷新的元素的模型。  
  
 只需在高级方案中调用此方法。 如果派生的类具有多个属性，会影响外观，并且你想要一次更新的基础模型，其中一种高级的方案。  
  
 <xref:System.Windows.UIElement3D.InvalidateModel%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
   
  
## Examples  
 下面的示例演示如何从派生<xref:System.Windows.UIElement3D>类，以创建`Sphere`类：  
  
 [!code-csharp[Shapes#Sphere](~/samples/snippets/csharp/VS_Snippets_Wpf/Shapes/CSharp/Sphere.cs#sphere)]
 [!code-vb[Shapes#Sphere](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Shapes/visualbasic/sphere.vb#sphere)]  
  
 有关完整示例，请参阅[UIElement3D 球体示例](https://go.microsoft.com/fwlink/?LinkID=160044)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : bool with get, set" Usage="System.Windows.UIElement3D.IsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示是否 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中启用此元素。</summary>
        <value>如果启用此元素，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请注意，此属性是特定于类的实现<xref:System.Windows.UIElement3D.IsEnabledCore%2A>在特定元素，通常在运行时上。 因此，此处列出的默认值有时不是有效。 尝试设置此值将还可能会重写返回的值<xref:System.Windows.UIElement3D.IsEnabledCore%2A>。  
  
 未启用的元素不参与命中测试或焦点，因此不将输入事件的源。  
  
 <xref:System.Windows.UIElement3D.IsEnabled%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.IsEnabledProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.IsEnabledChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsEnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsEnabledChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsEnabledChanged;" />
      <MemberSignature Language="F#" Value="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement3D.IsEnabled" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsEnabledChanged> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.UIElement3D.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值成为派生类中 <see cref="P:System.Windows.UIElement3D.IsEnabled" /> 的返回值。</summary>
        <value>如果启用此元素，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsEnabledCore%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>此属性的默认实现缓存的值，也会计算是否启用此元素的父元素。 (如果未启用父，子元素不能有效地启用中实际[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]。)如果您选择重写此实现，请确保调用基实现，以保留此行为。</para></block>
        <altmember cref="E:System.Windows.UIElement3D.IsEnabledChanged" />
        <altmember cref="P:System.Windows.UIElement3D.IsEnabled" />
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.IsEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.IsEnabled" /> 依赖项属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsEnabledProperty> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFocused : bool" Usage="System.Windows.UIElement3D.IsFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值确定此元素是否具有逻辑焦点。</summary>
        <value>如果此元素具有逻辑焦点，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果应用程序具有多个焦点部门，如菜单的内容和应用程序的其余部分之间，可能与键盘焦点不同逻辑焦点。 在此方案中，键盘焦点仅可对应用程序 UI 中的一个元素，但是，其他焦点分支中的某些元素仍可能会保留逻辑焦点。 有关逻辑焦点的详细信息，请参阅[焦点概述](~/docs/framework/wpf/advanced/focus-overview.md)。  
  
 通过设置此属性 （它是只读的） 未设置焦点。 此属性的典型用法是使用为的依赖关系属性<xref:System.Windows.Setter>或<xref:System.Windows.EventTrigger>。 若要以编程方式设置焦点，请调用<xref:System.Windows.UIElement3D.Focus%2A>。 由用户操作或控件实现，其中可能包括鼠标捕获行为，还可以设置焦点。  
  
 <xref:System.Windows.UIElement3D.IsFocused%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.IsFocusedProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.Focusable" />
        <altmember cref="M:System.Windows.UIElement3D.Focus" />
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.IsFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.IsFocused" /> 依赖项属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsFocusedProperty> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisible">
      <MemberSignature Language="C#" Value="public bool IsHitTestVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHitTestVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsHitTestVisible" />
      <MemberSignature Language="VB.NET" Value="Public Property IsHitTestVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHitTestVisible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsHitTestVisible : bool with get, set" Usage="System.Windows.UIElement3D.IsHitTestVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值声明是否可以返回此元素作为其呈现内容的某些部分的点击测试结果。</summary>
        <value>如果此元素可以从至少一个点作为命中测试结果返回，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 逻辑树中的命中测试的元素的相对位置会影响此属性的有效值。 例如，如果一个元素的子元素的元素进行命中测试可见，子属性的有效值将始终`false`，即使尝试在本地设置该值。 出于此原因，务必不要设置<xref:System.Windows.UIElement3D.IsHitTestVisible%2A>到`false`复合控件除非您不需要任何输入或对该控件进行命中测试。 有关命中测试的详细信息，请参阅[可视化层中的命中测试](~/docs/framework/wpf/graphics-multimedia/hit-testing-in-the-visual-layer.md)。  
  
 <xref:System.Windows.UIElement3D.IsHitTestVisible%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsHitTestVisible"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.IsHitTestVisibleProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.IsHitTestVisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisibleChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsHitTestVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsHitTestVisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsHitTestVisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsHitTestVisibleChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsHitTestVisibleChanged;" />
      <MemberSignature Language="F#" Value="member this.IsHitTestVisibleChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsHitTestVisibleChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement3D.IsHitTestVisible" /> 依赖项属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsHitTestVisibleChanged> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsHitTestVisibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsHitTestVisibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsHitTestVisibleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsHitTestVisibleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsHitTestVisibleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsHitTestVisibleProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.IsHitTestVisibleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.IsHitTestVisible" /> 依赖项属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsHitTestVisibleProperty> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsInputMethodEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInputMethodEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInputMethodEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInputMethodEnabled : bool" Usage="System.Windows.UIElement3D.IsInputMethodEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否启用输入法系统（如 [!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)]）来处理此元素的输入。</summary>
        <value>如果输入法处于活动状态，则为 <see langword="true" />；否则为 <see langword="false" />。 基础附加属性的默认值为 <see langword="true;" />；但在运行时该值会受到输入法实际状态的影响。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的附加属性返回的值<xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType>的当前已启用输入法键盘、 语音 （其他输入的设备）。  
  
 <xref:System.Windows.UIElement3D.IsInputMethodEnabled%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsKeyboardFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocused : bool" Usage="System.Windows.UIElement3D.IsKeyboardFocused" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocused</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值表示该元素是否具有键盘焦点。</summary>
        <value>如果此元素具有键盘焦点，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为此属性确定值的更改可能伴随着与焦点相关的事件。  
  
 <xref:System.Windows.UIElement3D.IsKeyboardFocused%2A> 和<xref:System.Windows.UIElement3D.IsKeyboardFocusWithin%2A>通常用于在类事件处理程序中其他与输入相关的事件，例如以确定是否元素已经具有键盘焦点时，或者若要在事件和键盘事件一起出现。  
  
 <xref:System.Windows.UIElement3D.IsKeyboardFocused%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.IsKeyboardFocusedProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.GotFocus" />
        <altmember cref="E:System.Windows.UIElement3D.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsKeyboardFocusedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement3D.IsKeyboardFocused" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsKeyboardFocusedChanged> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsKeyboardFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.IsKeyboardFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.IsKeyboardFocused" /> 依赖项属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsKeyboardFocusedProperty> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsKeyboardFocusWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocusWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocusWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithin : bool" Usage="System.Windows.UIElement3D.IsKeyboardFocusWithin" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocusWithin</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示键盘焦点是否位于元素或其可视化树子元素内的任意位置。</summary>
        <value>如果键盘焦点在元素或其子元素上，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 更改此属性的值通常会引发<xref:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged>事件，除非在派生的类已重写<xref:System.Windows.UIElement3D.OnIsKeyboardFocusWithinChanged%2A>若要禁止显示该事件。  
  
 不能直接，设置此属性，但您可以通过调用将焦点设置到元素<xref:System.Windows.UIElement3D.Focus%2A>，或通过使<xref:System.Windows.UIElement3D.MoveFocus%2A>请求。 这些方法调用之一可能会更改此属性的值。  
  
 <xref:System.Windows.UIElement3D.IsKeyboardFocused%2A> 和<xref:System.Windows.UIElement3D.IsKeyboardFocusWithin%2A>通常用于在类事件处理程序中其他与输入相关的事件，例如以确定是否元素已经具有键盘焦点时，或者若要在事件和键盘事件一起出现。  
  
 <xref:System.Windows.UIElement3D.IsKeyboardFocusWithin%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.IsKeyboardFocusWithinProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement3D.IsKeyboardFocusWithin" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.IsKeyboardFocusedChanged" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.IsKeyboardFocusWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.IsKeyboardFocusWithin" /> 依赖项属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsKeyboardFocusWithinProperty> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsMouseCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptured : bool" Usage="System.Windows.UIElement3D.IsMouseCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此元素是否捕获了鼠标。</summary>
        <value>如果元素具有鼠标捕获，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 鼠标捕获状态相关于进程内拖放操作。  
  
 <xref:System.Windows.UIElement3D.IsMouseCaptured%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.IsMouseCapturedProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.CaptureMouse" />
        <altmember cref="E:System.Windows.UIElement3D.GotMouseCapture" />
        <altmember cref="E:System.Windows.UIElement3D.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsMouseCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement3D.IsMouseCaptured" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsMouseCapturedChanged> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsMouseCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.IsMouseCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.IsMouseCaptured" /> 依赖项属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsMouseCapturedProperty> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsMouseCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithin : bool" Usage="System.Windows.UIElement3D.IsMouseCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值确定鼠标捕获是由此元素还是其可视化树中的子元素持有。</summary>
        <value>如果此元素或包含的元素具有鼠标捕获，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsMouseCaptureWithin%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.IsMouseCaptureWithinProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.IsMouseCaptured" />
        <altmember cref="M:System.Windows.UIElement3D.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsMouseCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement3D.IsMouseCaptureWithin" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsMouseCaptureWithinChanged> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsMouseCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.IsMouseCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.IsMouseCaptureWithin" /> 依赖项属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsMouseCaptureWithinProperty> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.IsMouseCaptureWithinChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsMouseDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOver : bool" Usage="System.Windows.UIElement3D.IsMouseDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示在考虑元素组合的情况下，鼠标指针的位置是否与命中测试结果相对应。</summary>
        <value>如果鼠标指针位于与命中测试相同的元素结果上，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与不同<xref:System.Windows.UIElement3D.IsMouseOver%2A>，此属性才是`true`与命中测试如果将鼠标指针位于 literal 元素-。 而如果鼠标指针位于子元素上，此属性将为`false`。 对于大多数情况下不创作控件的情况，请使用<xref:System.Windows.UIElement3D.IsMouseOver%2A>相反。  
  
 如果此元素捕获鼠标，并且此属性是`true`在捕获时，此属性将继续返回`true`直到失去鼠标捕获，并且指针不是其边界上。  
  
 <xref:System.Windows.UIElement3D.IsMouseDirectlyOver%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.IsMouseDirectlyOverProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseEnter" />
        <altmember cref="E:System.Windows.UIElement3D.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsMouseDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement3D.IsMouseDirectlyOver" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsMouseDirectlyOverChanged> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsMouseDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.IsMouseDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.IsMouseDirectlyOver" /> 依赖项属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsMouseDirectlyOverProperty> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.IsMouseDirectlyOverChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsMouseOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseOver : bool" Usage="System.Windows.UIElement3D.IsMouseOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示鼠标指针是否位于此元素（包括可视化树中的子元素）的上方。</summary>
        <value>如果鼠标指针位于该元素或其子元素上方，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常情况下，控件都是复合，以便控件 （可视树） 中的各种元素都将报告包含控件的鼠标状态。 例如，<xref:System.Windows.Controls.ListBox>样式的控件将报告<xref:System.Windows.UIElement3D.IsMouseOver%2A>作为`true`如果鼠标的任何位置通过几何形状，包括任何<xref:System.Windows.Controls.ListBoxItem>。  
  
 尽管类似"等效于"事件不存在，将通过几个类似的事件。 例如，可以处理<xref:System.Windows.UIElement3D.MouseEnter>， <xref:System.Windows.UIElement3D.MouseMove>，和<xref:System.Windows.UIElement3D.IsMouseDirectlyOverChanged>。  
  
 如果此元素捕获鼠标时，此属性将保持`true`直到失去鼠标捕获并且鼠标指针离开元素边界。  
  
 某些控件有意捕获鼠标上不会显示直接涉及鼠标某些操作。 这可能会导致<xref:System.Windows.UIElement3D.IsMouseOver%2A>正在`true`即使看似未移动鼠标。  
  
 <xref:System.Windows.UIElement3D.IsMouseOver%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.IsMouseOverProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsMouseOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.IsMouseOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.IsMouseOver" /> 依赖项属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsMouseOverProperty> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsStylusCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptured : bool" Usage="System.Windows.UIElement3D.IsStylusCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值表示此元素是否捕获了触笔。</summary>
        <value>如果元素具有触笔捕获，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.IsStylusCaptured%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.IsStylusCapturedProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.CaptureStylus" />
        <altmember cref="E:System.Windows.UIElement3D.GotStylusCapture" />
        <altmember cref="E:System.Windows.UIElement3D.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsStylusCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement3D.IsStylusCaptured" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsStylusCapturedChanged> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsStylusCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.IsStylusCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.IsStylusCaptured" /> 依赖项属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsStylusCapturedProperty> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsStylusCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithin : bool" Usage="System.Windows.UIElement3D.IsStylusCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值确定触笔捕获是由此元素还是由元素边界内的元素及其可视化树持有。</summary>
        <value>如果此元素或包含的元素具有触笔捕获，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.IsStylusCaptureWithin%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.IsStylusCaptureWithinProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.CaptureStylus" />
        <altmember cref="P:System.Windows.UIElement3D.IsStylusCaptured" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsStylusCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement3D.IsStylusCaptureWithin" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsStylusCaptureWithinChanged> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsStylusCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.IsStylusCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.IsStylusCaptureWithin" /> 依赖项属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsStylusCaptureWithinProperty> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.IsStylusCaptureWithinChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsStylusDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOver : bool" Usage="System.Windows.UIElement3D.IsStylusDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示在考虑元素组合的情况下，触笔的位置是否与命中测试结果相对应。</summary>
        <value>如果触笔指针位于与命中测试相同的元素结果上，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与不同<xref:System.Windows.UIElement3D.IsStylusOver%2A>，此属性才是`true`如果触笔位于元素上。 如果触笔改为通过子元素或元素的元素的更深入地组合 （可视树） 的一部分，此属性将为`false`。  
  
 除非你知道如何控件的组合 （例如，使用此属性在自定义控件模板中定义的控件），此属性可能返回意外的结果。 对于大多数情况下不创作控件的情况，请使用<xref:System.Windows.UIElement3D.IsStylusOver%2A>相反。  
  
 如果此元素具有触笔捕获，并且此属性是`true`捕获时，此属性将保持`true`直到触笔捕获，丢失和触笔不能通过其边界。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.IsStylusDirectlyOver%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.IsStylusDirectlyOverProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsStylusDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement3D.IsStylusDirectlyOver" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsStylusDirectlyOverChanged> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsStylusDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.IsStylusDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.IsStylusDirectlyOver" /> 依赖项属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsStylusDirectlyOverProperty> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsStylusOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusOver : bool" Usage="System.Windows.UIElement3D.IsStylusOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示触笔指针是否位于此元素（包括可视化子元素）的上方。</summary>
        <value>如果触笔光标位于元素或其子元素上方，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此元素具有触笔捕获，此属性将继续返回`true`直到丢失触笔捕获并且鼠标指针离开其边界。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.IsStylusOver%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.IsStylusOverProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsStylusOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.IsStylusOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.IsStylusOver" /> 依赖项属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsStylusOverProperty> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Windows.UIElement3D.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此元素在[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 中是否可见。</summary>
        <value>如果该元素可见，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 确定<xref:System.Windows.UIElement3D.IsVisible%2A>值会考虑许多因素。 与此相反， <xref:System.Windows.UIElement3D.Visibility%2A>，这是一个可设置属性，仅指示想要以编程方式使元素可见或不可见。  
  
 更改此属性的值通常会引发<xref:System.Windows.UIElement3D.IsVisibleChanged>事件。 不存在匹配[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]"上 *"类处理将允许的重写方法某些派生类重写该行为和处理事件，但仍无法直接与附加类处理程序<xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 元素的<xref:System.Windows.UIElement3D.IsVisible%2A>是`false`不参与输入的事件 （或命令），请执行不会影响度量值或排列过程的布局、 不是可获得焦点、 不是按选项卡顺序和命中测试中将不会报告。 与之相反，元素的<xref:System.Windows.UIElement3D.IsEnabled%2A>是`false`仍将参与事件和命令，以及命中测试，但不还可获得焦点。  
  
 <xref:System.Windows.UIElement3D.IsVisible%2A> 不是要用作样式触发器。 使用<xref:System.Windows.UIElement3D.IsVisible%2A>为样式触发器可能会产生不可预知的结果。 <xref:System.Windows.UIElement3D.IsVisible%2A> 适用于较低级别的输入实现通过检查的状态。  
  
 <xref:System.Windows.UIElement3D.IsVisible%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_IsVisible"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.IsVisibleProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsVisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.IsVisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsVisibleChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsVisibleChanged;" />
      <MemberSignature Language="F#" Value="member this.IsVisibleChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsVisibleChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素的 <see cref="P:System.Windows.UIElement3D.IsVisible" /> 属性值更改时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]事件、 不是路由的事件。  
  
 <xref:System.Windows.UIElement3D.IsVisibleChanged> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsVisibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsVisibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.IsVisibleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsVisibleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsVisibleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsVisibleProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.IsVisibleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.IsVisible" /> 依赖项属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.IsVisibleProperty> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.KeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素聚焦于键盘并且按下某个键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>附加的此类事件，以便<xref:System.Windows.UIElement3D.KeyDown>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.KeyDown>事件附加到基础<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.KeyDown> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_KeyDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.KeyDownEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewKeyDown>。  
  
-   重写<xref:System.Windows.UIElement3D.OnKeyDown%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.KeyUp" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.KeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.KeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.KeyDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.KeyDownEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.KeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素聚焦于键盘并且松开某个键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>附加的此类事件，以便<xref:System.Windows.UIElement3D.KeyUp>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.KeyUp>事件附加到基础<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.KeyUp> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_KeyUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.KeyUpEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewKeyUp>。  
  
-   重写<xref:System.Windows.UIElement3D.OnKeyUp%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.KeyDown" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.KeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.KeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.KeyUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.KeyUpEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.RoutedEventHandler " Usage="member this.LostFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素丢失逻辑焦点时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果有意通过某个方法调用强制失去了焦点，而前一个键盘焦点位于不同的范围内，则逻辑焦点将与键盘焦点不同。 在此方案，其中是键盘焦点将保留和元素其中<xref:System.Windows.UIElement3D.Focus%2A>方法称为仍获得逻辑焦点。  
  
 此事件的更精确地解释是它时引发的值<xref:System.Windows.UIElement3D.IsFocused%2A>路由中的元素的属性从更改`true`到`false`。  
  
 由于此事件使用冒泡路由，因此失去焦点的元素可能是而不是元素的子元素实际附加事件处理程序。 检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据以确定实际获得焦点的元素中。  
  
 <xref:System.Windows.UIElement3D.LostFocus> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_LostFocus"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.LostFocusEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.RoutedEventHandler>|  
  
-   没有相应的隧道事件。  
  
-   重写<xref:System.Windows.UIElement3D.OnLostFocus%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.LostKeyboardFocus" />
        <altmember cref="M:System.Windows.UIElement3D.Focus" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.LostFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.LostFocusEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.LostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ LostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素不再聚焦于键盘时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于此事件使用冒泡路由，因此失去焦点的元素可能是而不是元素的子元素实际附加事件处理程序。 检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据来确定实际失去焦点的元素中。  
  
 此事件创建一个别名<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.LostKeyboardFocus>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.LostKeyboardFocus>事件附加到基础<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.LostKeyboardFocus> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.LostKeyboardFocusEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewLostKeyboardFocus>。  
  
-   重写<xref:System.Windows.UIElement3D.OnLostKeyboardFocus%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.LostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.LostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.LostKeyboardFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.LostKeyboardFocusEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ LostMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素丢失鼠标捕获时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在元素捕获鼠标，它会接收鼠标输入，即使在指针位于其边界外。 只有在拖放操作通常捕获鼠标。  
  
 此事件使用冒泡路由，因为丢失捕获的元素可能是而不是元素的子元素实际附加事件处理程序。 检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据来确定实际失去捕获的元素中。  
  
 此事件创建一个别名<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.LostMouseCapture>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.LostMouseCapture>事件附加到基础<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.LostMouseCapture> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.LostMouseCaptureEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   没有定义相应的隧道事件。  
  
-   重写<xref:System.Windows.UIElement3D.OnLostMouseCapture%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.LostMouseCapture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.LostMouseCaptureEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.LostStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ LostStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素丢失触笔捕获时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在元素捕获触笔，它会接收触笔输入，即使在指针位于其边界外。 只有在拖放操作通常捕获触笔。  
  
 由于此事件使用冒泡路由，因此失去焦点的元素可能是而不是元素的子元素实际附加事件处理程序。 检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据来确定实际失去焦点的元素中。  
  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.LostStylusCapture>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.LostStylusCapture>事件附加到基础<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.LostStylusCapture> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.LostStylusCaptureEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   没有定义相应的隧道事件。  
  
-   重写<xref:System.Windows.UIElement3D.OnLostStylusCapture%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.LostStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.LostStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.LostStylusCapture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.LostStylusCaptureEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.LostTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ LostTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.LostTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.LostTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素失去触摸屏输入捕获时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.LostTouchCaptureEvent>|  
|路由策略|浮升|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   重写<xref:System.Windows.UIElement3D.OnLostTouchCapture%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.LostTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.LostTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.LostTouchCapture" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在指针位于此元素上并且按下任意鼠标按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.MouseDown>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.MouseDown>事件附加到基础<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.MouseDown>任意一个协同通常引发事件<xref:System.Windows.UIElement3D.MouseLeftButtonDown>或<xref:System.Windows.UIElement3D.MouseRightButtonDown>，对应于一个两个标准鼠标按钮按下。 <xref:System.Windows.UIElement3D.MouseLeftButtonDown> 并<xref:System.Windows.UIElement3D.MouseRightButtonDown>也是路由的事件，但它们是直接路由的事件，并引发相应的特定于按钮的事件时<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件到达事件路由中的此元素。 请参阅备注<xref:System.Windows.UIElement3D.MouseLeftButtonDown>或<xref:System.Windows.UIElement3D.MouseRightButtonDown>。  
  
> [!IMPORTANT]
>  某些控件可能具有固有的鼠标按钮事件处理的类。 鼠标左键按下事件是最有可能的事件，以便使类处理在控件中。 类通常处理标记基础<xref:System.Windows.Input.Mouse>为已处理的类事件。 一旦该事件标记为已处理，其他实例处理程序附加到该元素通常不会引发。 通常也不会引发的任何其他类或实例处理程序附加到针对 UI 树的根节点的浮升方向中的元素。  
  
 您可以解决的问题，在前面的重要说明中所述和仍接收<xref:System.Windows.UIElement3D.MouseDown>鼠标左键按下具有类处理通过使用这些解决方案的派生类上的事件的事件：  
  
-   附加处理程序<xref:System.Windows.UIElement3D.PreviewMouseDown>未标记为已由控件处理的事件。 请注意，由于这是预览事件，该路由从根开始，隧道下行控件。  
  
-   虽然通过调用注册该控件上的处理程序<xref:System.Windows.UIElement3D.AddHandler%2A>，然后选择使处理程序以侦听事件，即使它们已标记为已处理路由的事件数据中的签名选项。  
  
 <xref:System.Windows.UIElement3D.MouseDown> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.MouseDownEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewMouseDown>。  
  
-   重写<xref:System.Windows.UIElement3D.OnMouseDown%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.MouseDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseDownEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : System.Windows.Input.MouseEventHandler " Usage="member this.MouseEnter : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针进入此元素的边界时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.MouseEnter> 是[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)，它使用直接事件处理路由策略。 直接路由的事件不会引发在路由过程;相反，它们被处理的同一元素中引发位置。  
  
 尽管<xref:System.Windows.UIElement3D.MouseEnter>跟踪当鼠标指针进入元素，此事件的多个边界确切地报告<xref:System.Windows.UIElement3D.IsMouseOver%2A>属性值已从`false`到`true`此元素上。  
  
 此事件创建一个别名<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.MouseEnter>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.MouseEnter>事件附加到基础<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.MouseEnter> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.MouseEnterEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   重写<xref:System.Windows.UIElement3D.OnMouseEnter%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.MouseEnter" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseEnterEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Input.MouseEventHandler " Usage="member this.MouseLeave : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针离开此元素的边界时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.MouseLeave> 是[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)，它使用直接事件处理路由策略。 直接路由的事件不会引发在路由过程;相反，它们被处理的同一元素中引发位置。  
  
 尽管<xref:System.Windows.UIElement3D.MouseLeave>跟踪何时鼠标离开某个元素，此事件的详细信息按原义报告<xref:System.Windows.UIElement3D.IsMouseOver%2A>属性值已从`true`到`false`此元素上。  
  
 此事件创建一个别名<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.MouseLeave>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.MouseLeave>事件附加到基础<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.MouseLeave> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseLeave"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.MouseLeaveEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   重写<xref:System.Windows.UIElement3D.OnMouseLeave%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.MouseLeave" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseLeaveEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且按下鼠标左键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎按照浮升路由通过元素树，它实际上是引发并由每个重新沿元素树的直接路由的事件<xref:System.Windows.UIElement3D>。  
  
 此事件是一个报告基础的鼠标按钮具体情况的多个相关事件<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件，它是由在事件路由的每个元素处理附加的事件。  
  
 此事件的事件数据的基础的事件数据公开<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件。 如果该事件被标记为已处理事件路由过程，则仍会引发鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.UIElement3D.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将该事件的侦听器。 如果将标记<xref:System.Windows.UIElement3D.MouseLeftButtonDown>处理，在实质上标注<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>处理沿路由的所有其他侦听器和所有相关的事件。 这可能包括类处理程序生成事件，如<xref:System.Windows.Controls.Control.MouseDoubleClick>。  
  
 从概念上讲，将此事件 (和其他鼠标事件<xref:System.Windows.UIElement3D>) 为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。 事件添加了方便的不需要检查原始的鼠标事件在事件数据中的鼠标按钮状态 （左-右、 向上向下）。 对于更高级的方案，例如非标准按钮的状态检查，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>而不是这些类上<xref:System.Windows.UIElement3D>。  
  
> [!IMPORTANT]
>  类通常处理标记基础<xref:System.Windows.Input.Mouse>为已处理的类事件。 一旦该事件标记为已处理，其他实例处理程序附加到该元素通常不会引发。 通常也不会引发的任何其他类或实例处理程序附加到针对 UI 树的根节点的浮升方向中的元素。  
  
 您可以解决的问题，在前面的重要说明中所述和仍接收<xref:System.Windows.UIElement3D.MouseLeftButtonDown>鼠标左键按下具有类处理通过使用这些解决方案的派生类上的事件的事件：  
  
-   附加处理程序<xref:System.Windows.UIElement3D.PreviewMouseDown>未标记为已由控件处理的事件。 请注意，由于这是预览事件，该路由从根开始，隧道下行控件。  
  
-   虽然通过调用注册该控件上的处理程序<xref:System.Windows.UIElement3D.AddHandler%2A>，然后选择使处理程序以侦听事件，即使它们已标记为已处理路由的事件数据中的签名选项。  
  
 <xref:System.Windows.UIElement3D.MouseLeftButtonDown> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.MouseLeftButtonDownEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   重写<xref:System.Windows.UIElement3D.OnMouseLeftButtonDown%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseLeftButtonDown" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.MouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.MouseLeftButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseLeftButtonDownEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且松开鼠标左键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎按照浮升路由通过元素树，它实际上是引发并由每个重新沿元素树的直接路由的事件<xref:System.Windows.UIElement3D>。  
  
 此事件是一个报告基础的鼠标按钮具体情况的多个相关事件<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件，它是由在事件路由的每个元素处理附加的事件。  
  
 此事件的事件数据的基础的事件数据公开<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件。 如果该事件被标记为已处理事件路由过程，则仍会引发鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.UIElement3D.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将该事件的侦听器。 如果将标记<xref:System.Windows.UIElement3D.MouseLeftButtonUp>处理，在实质上标注<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>处理沿路由的所有其他侦听器和所有相关的事件。  
  
 从概念上讲，将此事件 (和其他鼠标事件<xref:System.Windows.UIElement3D>) 为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。 事件添加了方便的不需要检查原始的鼠标事件在事件数据中的鼠标按钮状态 （左-右、 向上向下）。 对于更高级的方案，例如非标准按钮的状态检查，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>而不是这些类上<xref:System.Windows.UIElement3D>。  
  
 <xref:System.Windows.UIElement3D.MouseLeftButtonUp> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.MouseLeftButtonUpEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   重写<xref:System.Windows.UIElement3D.OnMouseLeftButtonUp%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseLeftButtonUp" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.MouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.MouseLeftButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseLeftButtonUpEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.MouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且移动鼠标指针时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.MouseMove>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.MouseMove>事件附加到基础<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.MouseMove> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseMove"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.MouseMoveEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewMouseMove>。  
  
-   重写<xref:System.Windows.UIElement3D.OnMouseMove%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseEnter" />
        <altmember cref="E:System.Windows.UIElement3D.MouseLeave" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.MouseMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseMoveEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且按下鼠标右键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎按照浮升路由通过元素树，它实际上是引发并由每个重新沿元素树的直接路由的事件<xref:System.Windows.UIElement3D>。  
  
 此事件是一个报告基础的鼠标按钮具体情况的多个相关事件<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件，它是由在事件路由的每个元素处理附加的事件。  
  
 此事件的事件数据的基础的事件数据公开<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件。 如果该事件被标记为已处理事件路由过程，则仍会引发鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.UIElement3D.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将该事件的侦听器。 如果将标记<xref:System.Windows.UIElement3D.MouseRightButtonDown>处理，在实质上标注<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>处理沿路由的所有其他侦听器和所有相关的事件。 这可能包括类处理程序生成事件，如<xref:System.Windows.Controls.Control.MouseDoubleClick>。  
  
 从概念上讲，将此事件 (和其他鼠标事件<xref:System.Windows.UIElement3D>) 为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。 事件添加了方便的不需要检查原始的鼠标事件在事件数据中的鼠标按钮状态 （左-右、 向上向下）。 对于更高级的方案，例如非标准按钮的状态检查，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>而不是这些类上<xref:System.Windows.UIElement3D>。  
  
 右侧的按钮的鼠标事件中经常会有本机处理应用程序方案。 例如，鼠标左键按下的可能会显示上下文菜单。 请参阅[ContextMenu 概述](~/docs/framework/wpf/controls/contextmenu-overview.md)。  
  
 <xref:System.Windows.UIElement3D.MouseRightButtonDown> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.MouseRightButtonDownEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   重写<xref:System.Windows.UIElement3D.OnMouseRightButtonDown%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseRightButtonDown" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.MouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.MouseRightButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseRightButtonDownEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且松开鼠标右键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎按照浮升路由通过元素树，它实际上是引发并由每个重新沿元素树的直接路由的事件<xref:System.Windows.UIElement3D>。  
  
 此事件是一个报告基础的鼠标按钮具体情况的多个相关事件<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件，它是由在事件路由的每个元素处理附加的事件。  
  
 此事件的事件数据的基础的事件数据公开<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件。 如果该事件被标记为已处理事件路由过程，则仍会引发鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.UIElement3D.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将该事件的侦听器。 如果将标记<xref:System.Windows.UIElement3D.MouseRightButtonUp>处理，在实质上标注<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>处理沿路由的所有其他侦听器和所有相关的事件。  
  
 从概念上讲，将此事件 (和其他鼠标事件<xref:System.Windows.UIElement3D>) 为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。 事件添加了方便的不需要检查原始的鼠标事件在事件数据中的鼠标按钮状态 （左-右、 向上向下）。 对于更高级的方案，例如非标准按钮的状态检查，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>而不是这些类上<xref:System.Windows.UIElement3D>。  
  
 <xref:System.Windows.UIElement3D.MouseRightButtonUp> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.MouseRightButtonUpEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   重写<xref:System.Windows.UIElement3D.OnMouseRightButtonUp%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseRightButtonUp" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.MouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.MouseRightButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseRightButtonUpEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且松开任意鼠标按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.MouseUp>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.MouseUp>事件附加到基础<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.MouseUp>任意一个协同通常引发事件<xref:System.Windows.UIElement3D.MouseLeftButtonUp>或<xref:System.Windows.UIElement3D.MouseRightButtonUp>，对应于版本的两个标准鼠标按钮之一。 <xref:System.Windows.UIElement3D.MouseLeftButtonUp> 并<xref:System.Windows.UIElement3D.MouseRightButtonUp>也是路由的事件，但它们是直接路由的事件，并引发相应的特定于按钮的事件时<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件到达事件路由中的此元素。 请参阅备注<xref:System.Windows.UIElement3D.MouseLeftButtonUp>或<xref:System.Windows.UIElement3D.MouseRightButtonUp>。  
  
 <xref:System.Windows.UIElement3D.MouseUp> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.MouseUpEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewMouseUp>。  
  
-   重写<xref:System.Windows.UIElement3D.OnMouseUp%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.MouseUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseUpEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ MouseWheel;" />
      <MemberSignature Language="F#" Value="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且用户滚动鼠标滚轮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 焦点或鼠标捕获优先于在鼠标指针位于其中;因此，如果你收到<xref:System.Windows.UIElement3D.MouseWheel>从已设定焦点或捕获的元素的事件，鼠标指针可能实际上是另一个元素上。  
  
 此事件创建一个别名<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.MouseWheel>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.MouseWheel>事件附加到基础<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.MouseWheel> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.MouseWheelEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewMouseWheel>。  
  
-   重写<xref:System.Windows.UIElement3D.OnMouseWheel%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=159992">在三维示例中处理事件</related>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.MouseWheel" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.MouseWheelEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="abstract member MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool&#xA;override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="uIElement3D.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">一个遍历请求，其中包含一个属性，该属性指示以现有 Tab 键顺序遍历的模式或视觉移动的方向。</param>
        <summary>尝试将焦点从此元素移到其他元素。 移动焦点的方向由指导方向指定，该方向在此元素的可视父级的组织结构中解释。</summary>
        <returns>如果执行了请求的遍历，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请务必检查此方法的返回值。 返回值为`false`如果遍历遇到控件的组合所定义的制表位并且遍历请求未请求来包装可能会返回。  
  
 <xref:System.Windows.UIElement3D.MoveFocus%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnAccessKey">
      <MemberSignature Language="C#" Value="protected virtual void OnAccessKey (System.Windows.Input.AccessKeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAccessKey(class System.Windows.Input.AccessKeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAccessKey (e As AccessKeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAccessKey(System::Windows::Input::AccessKeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAccessKey : System.Windows.Input.AccessKeyEventArgs -&gt; unit&#xA;override this.OnAccessKey : System.Windows.Input.AccessKeyEventArgs -&gt; unit" Usage="uIElement3D.OnAccessKey e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.AccessKeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">访问键事件的事件数据。 事件数据报告哪个键被调用，并指示控制发送这些事件的 <see cref="T:System.Windows.Input.AccessKeyManager" /> 对象是否也将此访问键调用发送到其他元素。</param>
        <summary>在调用对于此元素有意义的访问键时提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在没有实际 AccessKey 事件<xref:System.Windows.UIElement3D>类，或其他位置，你可以引发或附加处理程序。 相反，事件是通过专用管理器类， <xref:System.Windows.Input.AccessKeyManager>，其中进行后续处理所有输入要搜索适用于整个输入模型的访问密钥。  
  
 <xref:System.Windows.UIElement3D.OnAccessKey%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在此方法的默认实现<see cref="T:System.Windows.UIElement3D" />设置键盘焦点设定到此元素 (通过调用<see cref="M:System.Windows.UIElement3D.Focus" />)。 实现应保持此行为，它们是否可获得焦点，因为它是可访问性方案的预期的行为。 请注意，不执行任何操作传递的事件数据的基实现，并且不引发其他事件;它只需设置焦点。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer&#xA;override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="uIElement3D.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 基础结构返回特定于类的 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 实现。</summary>
        <returns>特定于类型的 <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 实现。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnCreateAutomationPeer%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>此方法的实现通常是调用特定构造函数<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />实现中，并将其返回作为返回值。  
  
所有<see cref="T:System.Windows.UIElement3D" />派生的类应实现此方法以提供其各自的特定<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />实现到[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]基础结构。 有关实现此模式的详细信息，请参阅<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement3D.OnDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.DragEnter" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnDragEnter%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement3D.OnDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.DragLeave" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnDragLeave%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement3D.OnDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.DragOver" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnDragOver%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDrop : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement3D.OnDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.Drop" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnDrop%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.Drop" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="uIElement3D.OnGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.GiveFeedback" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnGiveFeedback%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="uIElement3D.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.RoutedEventArgs" />。 此事件数据必须包含 <see cref="E:System.Windows.UIElement3D.GotFocus" /> 事件的标识符。</param>
        <summary>使用所提供的事件数据引发 <see cref="E:System.Windows.UIElement3D.GotFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法，尽管虚拟的但有一个默认实现，引发事件。  
  
 这在 * 方法实现用于引发事件，并在内部调用此方法的实现来引发事件时<xref:System.Windows.UIElement3D.IsFocused%2A>属性值发生更改。 <xref:System.Windows.UIElement3D.OnGotFocus%2A>实现不同于其他某些[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]上 * 实现，后者仅提供了方便地为该事件添加类处理。  
  
 <xref:System.Windows.UIElement3D.OnGotFocus%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>除非你有有意或不寻常的需求不引发焦点事件，请确保您的实现将调用基实现。 否则为<see cref="E:System.Windows.UIElement3D.GotFocus" />通常将焦点设置到此元素的典型用户操作中不引发事件。 如果不想您可获得焦点的元素，您可以通过将阻止元素<see cref="P:System.Windows.UIElement3D.Focusable" />到<see langword="false" />。</para></block>
        <altmember cref="P:System.Windows.UIElement3D.Focusable" />
        <altmember cref="E:System.Windows.UIElement3D.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="uIElement3D.OnGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnGotKeyboardFocus%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.GotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement3D.OnGotMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnGotMouseCapture%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.GotMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement3D.OnGotStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnGotStylusCapture%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.GotStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement3D.OnGotTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在此元素上捕获触摸屏输入时发生的 <see cref="E:System.Windows.UIElement3D.GotTouchCapture" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnGotTouchCapture%2A>方法具有默认实现。 重写<xref:System.Windows.UIElement3D.OnGotTouchCapture%2A>中派生的类来处理<xref:System.Windows.UIElement3D.GotTouchCapture>事件。 请务必调用基类的<xref:System.Windows.UIElement3D.OnGotTouchCapture%2A>方法，从而基本类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement3D.OnIsKeyboardFocusedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>当针对此元素引发未处理的 <see cref="E:System.Windows.UIElement3D.IsKeyboardFocusedChanged" /> 事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此虚方法时调用的值<xref:System.Windows.UIElement3D.IsKeyboardFocused%2A>依赖关系属性更改。 虚拟方法首先调用，并且可以处理在必要时的事件数据。 然后<xref:System.Windows.UIElement3D.IsKeyboardFocusedChanged>与该相同的事件数据实例引发事件。 请注意，<xref:System.Windows.UIElement3D.IsKeyboardFocusedChanged>事件不是路由的事件。 因此，您不能将其标记为已处理的类处理程序中。  
  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。 您可以调用基之前或之后应用特殊处理，具体取决于您的要求。  
  
 <xref:System.Windows.UIElement3D.OnIsKeyboardFocusedChanged%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement3D.OnIsKeyboardFocusWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>在此元素即将引发 <see cref="E:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged" /> 事件前调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此虚方法时调用的值<xref:System.Windows.UIElement3D.IsKeyboardFocusWithin%2A>依赖项属性更改其值。 虚拟方法首先调用，并且可以处理在必要时的事件数据。 然后<xref:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged>与该相同的事件数据实例引发事件。 请注意，<xref:System.Windows.UIElement3D.IsKeyboardFocusWithinChanged>事件不是路由的事件。 因此，您不能将其标记为已处理的类处理程序中。  
  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。 您可以调用基之前或之后应用特殊处理，具体取决于您的要求。  
  
 <xref:System.Windows.UIElement3D.OnIsKeyboardFocusWithinChanged%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement3D.OnIsMouseCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>当针对此元素引发未处理的 <see cref="E:System.Windows.UIElement3D.IsMouseCapturedChanged" /> 事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此虚方法时调用的值<xref:System.Windows.UIElement3D.IsMouseCaptured%2A>依赖项属性更改其值。 虚拟方法首先调用，并且可以处理在必要时的事件数据。 然后<xref:System.Windows.UIElement3D.IsMouseCapturedChanged>与该相同的事件数据实例引发事件。 请注意，<xref:System.Windows.UIElement3D.IsMouseCapturedChanged>事件不是路由的事件。 因此，您不能将其标记为已处理的类处理程序中。  
  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。 您可以调用基之前或之后应用特殊处理，具体取决于您的要求。  
  
 <xref:System.Windows.UIElement3D.OnIsMouseCapturedChanged%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement3D.OnIsMouseCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>当针对此元素引发未处理的 <see cref="E:System.Windows.UIElement3D.IsMouseCaptureWithinChanged" /> 事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnIsMouseCaptureWithinChanged%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>此虚方法时调用的值<see cref="P:System.Windows.UIElement3D.IsMouseCaptureWithin" />依赖项属性更改其值。 虚拟方法首先调用，并且可以处理在必要时的事件数据。 然后<see cref="E:System.Windows.UIElement3D.IsMouseCaptureWithinChanged" />与该相同的事件数据实例引发事件。 请注意，事件不是路由的事件。因此，您不能将其标记为已处理的类处理程序中。  
  
此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。 您可以调用基之前或之后应用特殊处理，具体取决于您的要求。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement3D.OnIsMouseDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>当针对此元素引发未处理的 <see cref="E:System.Windows.UIElement3D.IsMouseDirectlyOverChanged" /> 事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此虚方法时调用的值<xref:System.Windows.UIElement3D.IsMouseDirectlyOver%2A>依赖项属性更改其值。 虚拟方法首先调用，并且可以处理在必要时的事件数据。 然后<xref:System.Windows.UIElement3D.IsMouseDirectlyOverChanged>与该相同的事件数据实例引发事件。 请注意，<xref:System.Windows.UIElement3D.IsMouseDirectlyOverChanged>事件不是路由的事件。 因此，您不能将其标记为已处理的类处理程序中。  
  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。 您可以调用基之前或之后应用特殊处理，具体取决于您的要求。  
  
 <xref:System.Windows.UIElement3D.OnIsMouseDirectlyOverChanged%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement3D.OnIsStylusCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>当针对此元素引发未处理的 <see cref="E:System.Windows.UIElement3D.IsStylusCapturedChanged" /> 事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此虚方法时调用的值<xref:System.Windows.UIElement3D.IsStylusCaptured%2A>依赖项属性更改其值。 虚拟方法首先调用，并且可以处理在必要时的事件数据。 然后<xref:System.Windows.UIElement3D.IsStylusCapturedChanged>与该相同的事件数据实例引发事件。 请注意，该事件不是路由的事件。 因此，您不能将其标记为已处理的类处理程序中。  
  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。 您可以调用基之前或之后应用特殊处理，具体取决于您的要求。  
  
 <xref:System.Windows.UIElement3D.OnIsStylusCapturedChanged%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement3D.OnIsStylusCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>当针对此元素引发未处理的 <see cref="E:System.Windows.UIElement3D.IsStylusCaptureWithinChanged" /> 事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此虚方法时调用的值<xref:System.Windows.UIElement3D.IsStylusCaptureWithin%2A>依赖项属性更改其值。 虚拟方法首先调用，并且可以处理在必要时的事件数据。 然后<xref:System.Windows.UIElement3D.IsStylusCaptureWithinChanged>与该相同的事件数据实例引发事件。 请注意，该事件不是路由的事件。 因此，您不能将其标记为已处理的类处理程序中。  
  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。 您可以调用基之前或之后应用特殊处理，具体取决于您的要求。  
  
 <xref:System.Windows.UIElement3D.OnIsStylusCaptureWithinChanged%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement3D.OnIsStylusDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>当针对此元素引发未处理的 <see cref="E:System.Windows.UIElement3D.IsStylusDirectlyOverChanged" /> 事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此虚方法时调用的值<xref:System.Windows.UIElement3D.IsStylusDirectlyOver%2A>依赖项属性更改其值。 虚拟方法首先调用，并且可以处理在必要时的事件数据。 然后<xref:System.Windows.UIElement3D.IsStylusDirectlyOverChanged>与该相同的事件数据实例引发事件。 请注意，该事件不是路由的事件。 因此您不能将其标记为已处理的类处理程序中。  
  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。 您可以调用基之前或之后应用特殊处理，具体取决于您的要求。  
  
 <xref:System.Windows.UIElement3D.OnIsStylusDirectlyOverChanged%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="uIElement3D.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 击键通过专用的输入管理器进行处理。 其他编程功能，依赖于击键，例如，输入和命令绑定，可能会在键击公开为常规击键之前处理。 如果这些输入系统功能将事件标记为已处理，然后<xref:System.Windows.UIElement3D.OnKeyDown%2A>不调用。  
  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnKeyDown%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="uIElement3D.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 击键通过专用的输入管理器进行处理。 其他编程功能，依赖于击键，例如，输入和命令绑定，可能会在键击公开为常规击键之前处理。 如果这些输入系统功能将事件标记为已处理，然后<xref:System.Windows.UIElement3D.OnKeyUp%2A>不调用。  
  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnKeyUp%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="uIElement3D.OnLostFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.RoutedEventArgs" />。 此事件数据必须包含 <see cref="E:System.Windows.UIElement3D.LostFocus" /> 事件的标识符。</param>
        <summary>使用提供的事件数据引发 <see cref="E:System.Windows.UIElement3D.LostFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法，尽管虚拟的但有一个默认实现，引发事件。  
  
 这在 * 方法实现用于引发事件，并在内部调用此方法的实现来引发事件时<xref:System.Windows.UIElement3D.IsFocused%2A>属性值发生更改。 此实现不同于其他某些[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]上 * 实现，后者仅提供了方便地为该事件添加类处理。  
  
 <xref:System.Windows.UIElement3D.OnLostFocus%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>除非你有有意或不寻常的需求不引发焦点事件，请确保您的实现将调用基实现。 否则为<see cref="E:System.Windows.UIElement3D.LostFocus" />通常将焦点设置到此元素的典型用户操作中不引发事件。 如果不想您可获得焦点的元素，您可以通过将阻止元素<see cref="P:System.Windows.UIElement3D.Focusable" />到<see langword="false" />。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="uIElement3D.OnLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnLostKeyboardFocus%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement3D.OnLostMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnLostMouseCapture%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement3D.OnLostStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnLostStylusCapture%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement3D.OnLostTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在此元素失去触摸屏输入捕获时发生的 <see cref="E:System.Windows.UIElement3D.LostTouchCapture" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnLostTouchCapture%2A>方法具有默认实现。 重写<xref:System.Windows.UIElement3D.OnLostTouchCapture%2A>中派生的类来处理<xref:System.Windows.UIElement3D.LostTouchCapture>事件。 请务必调用基类的<xref:System.Windows.UIElement3D.OnLostTouchCapture%2A>方法，从而基本类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement3D.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 此事件数据报告有关按下鼠标按钮和已处理状态的详细信息。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理鼠标按钮操作也是通过专用的输入管理器。 公开为常规鼠标按钮操作之前，其他编程功能，依赖于鼠标按钮操作，例如输入和命令绑定，可能会调用处理程序的操作。 如果这些输入系统功能标记<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>事件处理，如<xref:System.Windows.UIElement3D.OnMouseDown%2A>不调用。  
  
 如果使用此类处理程序将事件标记为已处理，则可能会影响以下事件：<xref:System.Windows.UIElement3D.MouseLeftButtonDown>和<xref:System.Windows.UIElement3D.MouseRightButtonDown>。 上述任一事件可能会在接收元素上引发时<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>收到。  
  
 如果标记为已处理的类中处理此事件，则仍会引发子事件;但是，它们通过中的事件数据的处理的状态。 除非您显式使用类处理在处理该事件时，如果不调用为子事件的实例处理<xref:System.Windows.UIElement3D.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>与`handledEventsToo``true`才能附加处理程序。 类处理程序也不会调用与注册了这些类处理程序，除非<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>带签名`handledEventsToo` `true`。 通过处理<xref:System.Windows.UIElement3D.OnMouseDown%2A>，则意味着你类处理负责所有可能的鼠标按钮按下操作。 此行为可能不需要。 因此，此虚拟方法用于将事件标记为已处理时要格外小心。  
  
 每个特定于按钮的直接事件也有一个虚拟 On * 方法;请考虑是否重写这些特定于按钮的类处理程序可能会更合适。  
  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnMouseDown%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement3D.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>当此元素引发未处理的 <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 附加事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。 您可以调用基之前或之后应用特殊处理，具体取决于您的要求。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件，具有直接的路由策略。 将事件标记为已处理是仍有助于防止典型实例处理程序 (未指定的那些`handledEventsToo`) 调用。  
  
 <xref:System.Windows.UIElement3D.OnMouseEnter%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement3D.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>当此元素引发未处理的 <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 附加事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。 您可以调用基之前或之后应用特殊处理，具体取决于您的要求。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件，具有直接的路由策略。 将事件标记为已处理是仍有助于防止典型实例处理程序 (未指定的那些`handledEventsToo`) 调用。  
  
 <xref:System.Windows.UIElement3D.OnMouseLeave%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement3D.OnMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据报告称已按下鼠标左键。</param>
        <summary>当此元素引发未处理的 <see cref="E:System.Windows.UIElement3D.MouseLeftButtonDown" /> 路由事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.MouseLeftButtonDown>看起来进行浮升路由事件，但实际上是以间接方式。 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 是基础事件是冒泡路由，并且每个<xref:System.Windows.UIElement3D>沿着事件路由使用相同的处理引发的直接路由的事件<xref:System.Windows.UIElement3D.MouseLeftButtonDown>。 尽管可以将标记<xref:System.Windows.UIElement3D.MouseLeftButtonDown>为此元素的已处理的事件，处理的状态不会不保留到其他元素为由事件路由。 但是，你可能想要将事件标记为已处理以防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。  
  
 常规鼠标事件处理中的默认实现<xref:System.Windows.UIElement3D>侦听<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>并将其转换为相应的本地事件。 如果你想要覆盖此逻辑，必须创建派生的类。 在派生类的静态构造函数，将注册的替代类处理程序<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>。 不能更改处理行为的鼠标<xref:System.Windows.UIElement3D>通过重写<xref:System.Windows.UIElement3D.OnMouseLeftButtonDown%2A>。  
  
 或者，可以以更改的事件处理特定的鼠标状态来重写此方法。 您是否选择调用基实现取决于你的方案。 未能调用基禁用默认为基实现，也应调用该鼠标事件的输入的处理<xref:System.Windows.UIElement3D.OnMouseLeftButtonDown%2A>。 例如，您可以从其中<xref:System.Windows.Controls.Button>并重写<xref:System.Windows.UIElement3D.OnMouseLeftButtonDown%2A>在派生类而不会调用基实现; 但是，此重写禁用<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件。  
  
 <xref:System.Windows.UIElement3D.OnMouseLeftButtonDown%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement3D.OnMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据报告称已松开鼠标左键。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.UIElement3D.MouseLeftButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.MouseLeftButtonUp>看起来进行浮升路由事件，但实际上是以间接方式。 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 是基础事件是冒泡路由，并且每个<xref:System.Windows.UIElement3D>沿着事件路由使用相同的处理引发的直接路由的事件<xref:System.Windows.UIElement3D.MouseLeftButtonUp>。 尽管可以将标记<xref:System.Windows.UIElement3D.MouseLeftButtonUp>为此元素的已处理的事件，处理的状态不会不保留到其他元素为由事件路由。 但是，你可能想要将事件标记为已处理以防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。  
  
 常规鼠标事件处理中的默认实现<xref:System.Windows.UIElement3D>侦听<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>并将其转换为相应的本地事件。 如果你想要覆盖此逻辑，必须创建派生的类。 在派生类的静态构造函数，将注册的替代类处理程序<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>。 不能更改处理行为的鼠标<xref:System.Windows.UIElement3D>通过重写<xref:System.Windows.UIElement3D.OnMouseLeftButtonUp%2A>。  
  
 <xref:System.Windows.UIElement3D.OnMouseLeftButtonUp%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement3D.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnMouseMove%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement3D.OnMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据报告称已按下鼠标右键。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.UIElement3D.MouseRightButtonDown" /> 路由事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.MouseRightButtonDown>看起来进行浮升路由事件，但实际上是以间接方式。 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 是基础事件是冒泡路由，并且每个<xref:System.Windows.UIElement3D>沿着事件路由使用相同的处理引发的直接路由的事件<xref:System.Windows.UIElement3D.MouseRightButtonDown>。 尽管可以将标记<xref:System.Windows.UIElement3D.MouseRightButtonDown>为此元素的已处理的事件，处理的状态不会不保留到其他元素为由事件路由。 但是，你可能想要将事件标记为已处理以防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。  
  
 常规鼠标事件处理中的默认实现<xref:System.Windows.UIElement3D>侦听<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>并将其转换为相应的本地事件。 如果你想要覆盖此逻辑，必须创建派生的类。 在派生类的静态构造函数，将注册的替代类处理程序<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>。 不能更改处理行为的鼠标<xref:System.Windows.UIElement3D>通过重写<xref:System.Windows.UIElement3D.OnMouseRightButtonDown%2A>。  
  
 或者，可以以更改的事件处理特定的鼠标状态来重写此方法。 您是否选择调用基实现取决于你的方案。 未能调用基禁用默认为基实现，也应调用该鼠标事件的输入的处理<xref:System.Windows.UIElement3D.OnMouseRightButtonDown%2A>。 例如，您可以从其中<xref:System.Windows.Controls.Control>并重写<xref:System.Windows.UIElement3D.OnMouseRightButtonDown%2A>但是，而无需调用基实现; 在派生类中此替代禁用上下文菜单上的服务控件，都是一部分的<xref:System.Windows.Controls.Control>默认行为。  
  
 <xref:System.Windows.UIElement3D.OnMouseRightButtonDown%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement3D.OnMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据报告称已释放鼠标右键。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.UIElement3D.MouseRightButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.MouseRightButtonUp>看起来进行浮升路由事件，但实际上是以间接方式。 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 是基础事件是冒泡路由，并且每个<xref:System.Windows.UIElement3D>沿着事件路由使用相同的处理引发的直接路由的事件<xref:System.Windows.UIElement3D.MouseRightButtonUp>。 尽管可以将标记<xref:System.Windows.UIElement3D.MouseRightButtonUp>为此元素的已处理的事件，处理的状态不会不保留到其他元素为由事件路由。 但是，你可能想要将事件标记为已处理以防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。  
  
 常规鼠标事件处理中的默认实现<xref:System.Windows.UIElement3D>侦听<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>并将其转换为相应的本地事件。 如果你想要覆盖此逻辑，必须创建派生的类。 在派生类的静态构造函数，将注册的替代类处理程序<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>。 不能更改处理行为的鼠标<xref:System.Windows.UIElement3D>通过重写<xref:System.Windows.UIElement3D.OnMouseRightButtonUp%2A>。  
  
 <xref:System.Windows.UIElement3D.OnMouseRightButtonUp%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement3D.OnMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据将报告已松开了鼠标按钮。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理鼠标按钮操作也是通过专用的输入管理器。 公开为常规鼠标按钮操作之前，其他编程功能，依赖于鼠标按钮操作，例如输入和命令绑定，可能会调用处理程序的操作。 如果这些输入系统功能标记<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>事件处理，如<xref:System.Windows.UIElement3D.OnMouseUp%2A>不调用。  
  
 如果使用此类处理程序将事件标记为已处理，则可能会影响以下事件：<xref:System.Windows.UIElement3D.MouseLeftButtonUp>和<xref:System.Windows.UIElement3D.MouseRightButtonUp>。 上述任一事件可能会在接收元素上引发时<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>收到。  
  
 如果标记为已处理的类中处理此事件，则仍会引发子事件;但是，它们通过中的事件数据的处理的状态。 除非您显式使用类处理在处理该事件时，如果不调用为子事件的实例处理<xref:System.Windows.UIElement3D.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>与`handledEventsToo``true`才能附加处理程序。 类处理程序也不会调用与注册了这些类处理程序，除非<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>带签名`handledEventsToo` `true`。 通过处理<xref:System.Windows.UIElement3D.OnMouseUp%2A>，则意味着类处理负责操作的所有可能的鼠标按钮。 此行为可能不需要。 因此，此虚拟方法用于将事件标记为已处理时要格外小心。  
  
 每个特定于按钮的直接事件也有一个虚拟 On * 方法;请考虑是否重写这些特定于按钮的类处理程序可能会更合适。  
  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnMouseUp%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="uIElement3D.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnMouseWheel%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewDragEnter%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewDragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewDragLeave%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewDragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewDragOver%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewDragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewDrop" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewDrop%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewGiveFeedback%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewGiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewGotKeyboardFocus%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewKeyDown%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewKeyUp%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewLostKeyboardFocus%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据报告称已按下一个或多个鼠标按钮。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 附加路由事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理鼠标按钮操作也是通过专用的输入管理器。 公开为常规鼠标按钮操作之前，其他编程功能，依赖于鼠标按钮操作，例如输入和命令绑定，可能会调用处理程序的操作。 如果这些输入系统功能标记<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件处理，如<xref:System.Windows.UIElement3D.OnPreviewMouseDown%2A>不调用。  
  
 如果使用此类处理程序将事件标记为已处理，则可能会影响以下事件：<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown>和<xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown>。 上述任一事件可能会在接收元素上引发时<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>收到。  
  
 如果标记为已处理的类中处理此事件，则仍会引发子事件;但是，它们通过中的事件数据的处理的状态。 除非您显式使用类处理在处理该事件时，如果不调用为子事件的实例处理<xref:System.Windows.UIElement3D.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>与`handledEventsToo``true`才能附加处理程序。 类处理程序也不会调用与注册了这些类处理程序，除非<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>带签名`handledEventsToo` `true`。 通过处理<xref:System.Windows.UIElement3D.OnPreviewMouseDown%2A>，则意味着你类处理负责所有可能的鼠标按钮按下操作。 此行为可能不需要。 因此，此虚拟方法用于将事件标记为已处理时要格外小心。  
  
 每个特定于按钮的直接事件也有一个虚拟 On * 方法;请考虑是否重写这些特定于按钮的类处理程序可能会更合适。  
  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseDown%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据报告称已按下鼠标左键。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.UIElement3D.PreviewMouseLeftButtonDown" /> 路由事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown>事件看起来进行隧道路由，但实际上是以间接方式。 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 是的基础事件是隧道路由，并且每个<xref:System.Windows.UIElement3D>沿着事件路由使用相同的处理引发的直接路由的事件<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown>。 尽管可以将标记<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown>为此元素的已处理的事件，处理的状态不会不保留到其他元素为由事件路由。 但是，你可能想要将事件标记为已处理以防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。  
  
 常规鼠标事件处理中的默认实现<xref:System.Windows.UIElement3D>侦听<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>并将其转换为相应的本地事件。 如果你想要覆盖此逻辑，必须创建派生的类。 在派生类的静态构造函数，将注册的替代类处理程序<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>。 不能更改处理行为的鼠标<xref:System.Windows.UIElement3D>通过重写<xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonDown%2A>。  
  
 或者，可以以更改的事件处理特定的鼠标状态来重写此方法。 您是否选择调用基实现取决于你的方案。 未能调用基禁用默认为基实现，也应调用该鼠标事件的输入的处理<xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonDown%2A>。 例如，您可以从其中<xref:System.Windows.Controls.Button>并重写<xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonDown%2A>在派生类而不会调用基实现; 但是，此重写禁用<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonDown%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据报告称已松开鼠标左键。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.UIElement3D.PreviewMouseLeftButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp>事件看起来进行隧道路由，但实际上是以间接方式。 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 是的基础事件是隧道路由，并且每个<xref:System.Windows.UIElement3D>沿着事件路由使用相同的处理引发的直接路由的事件<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp>。 尽管可以将标记<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp>为此元素的已处理的事件，处理的状态不会不保留到其他元素为由事件路由。 但是，你可能想要将事件标记为已处理以防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。  
  
 常规鼠标事件处理中的默认实现<xref:System.Windows.UIElement3D>侦听<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>并将其转换为相应的本地事件。 如果你想要覆盖此逻辑，必须创建派生的类。 在派生类的静态构造函数，将注册的替代类处理程序<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>。 不能更改处理行为的鼠标<xref:System.Windows.UIElement3D>通过重写<xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonUp%2A>。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonUp%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseMove%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据报告称已按下鼠标右键。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.UIElement3D.PreviewMouseRightButtonDown" /> 路由事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown>事件看起来进行隧道路由，但实际上是以间接方式。 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 是的基础事件是隧道路由，并且每个<xref:System.Windows.UIElement3D>沿着事件路由使用相同的处理引发的直接路由的事件<xref:System.Windows.UIElement3D.MouseRightButtonDown>。 尽管可以将标记<xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown>为此元素的已处理的事件，处理的状态不会不保留到其他元素为由事件路由。 但是，你可能想要将事件标记为已处理以防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。  
  
 常规鼠标事件处理中的默认实现<xref:System.Windows.UIElement3D>侦听<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>并将其转换为相应的本地事件。 如果你想要覆盖此逻辑，必须创建派生的类。 在派生类的静态构造函数，将注册的替代类处理程序<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>。 不能更改处理行为的鼠标<xref:System.Windows.UIElement3D>通过重写<xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonDown%2A>。  
  
 或者，可以以更改的事件处理特定的鼠标状态来重写此方法。 您是否选择调用基实现取决于你的方案。 未能调用基禁用默认为基实现，也应调用该鼠标事件的输入的处理<xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonDown%2A>。 例如，您可以从其中<xref:System.Windows.Controls.Control>并重写<xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonDown%2A>但是，而无需调用基实现; 在派生类中此替代禁用上下文菜单上的服务控件，都是一部分的<xref:System.Windows.Controls.Control>默认行为。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonDown%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据报告称已释放鼠标右键。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.UIElement3D.PreviewMouseRightButtonUp" /> 路由事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>事件看起来进行隧道路由，但实际上是以间接方式。 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 是的基础事件是隧道路由，并且每个<xref:System.Windows.UIElement3D>沿着事件路由使用相同的处理引发的直接路由的事件<xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>。 尽管可以将标记<xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>为此元素的已处理的事件，处理的状态不会不保留到其他元素为由事件路由。 但是，你可能想要将事件标记为已处理以防止常规实例处理程序 (未指定的那些`handledEventsToo`) 调用。  
  
 常规鼠标事件处理中的默认实现<xref:System.Windows.UIElement3D>侦听<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>并将其转换为相应的本地事件。 如果你想要覆盖此逻辑，必须创建派生的类。 在派生类的静态构造函数，将注册的替代类处理程序<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>。 不能更改处理行为的鼠标<xref:System.Windows.UIElement3D>通过重写<xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonUp%2A>。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonUp%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 事件数据将报告已释放了一个或多个鼠标按钮。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 处理鼠标按钮操作也是通过专用的输入管理器。 公开为常规鼠标按钮操作之前，其他编程功能，依赖于鼠标按钮操作，例如输入和命令绑定，可能会调用处理程序的操作。 如果这些输入系统功能标记<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件处理，如<xref:System.Windows.UIElement3D.OnPreviewMouseUp%2A>不调用。  
  
 如果使用此类处理程序将事件标记为已处理，则可能会影响以下事件：<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp>和<xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>。 上述任一事件可能会在接收元素上引发时<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>收到。  
  
 如果标记为已处理的类中处理此事件，则仍会引发子事件;但是，它们通过中的事件数据的处理的状态。 除非您显式使用类处理在处理该事件时，如果不调用为子事件的实例处理<xref:System.Windows.UIElement3D.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>与`handledEventsToo``true`才能附加处理程序。 类处理程序也不会调用与注册了这些类处理程序，除非<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>带签名`handledEventsToo` `true`。 通过处理<xref:System.Windows.UIElement3D.OnPreviewMouseUp%2A>，则意味着类处理负责操作的所有可能的鼠标按钮。 此行为可能不需要。 因此，此虚拟方法用于将事件标记为已处理时要格外小心。  
  
 每个特定于按钮的直接事件也有一个虚拟 On * 方法;请考虑是否重写这些特定于按钮的类处理程序可能会更合适。  
  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseUp%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewMouseWheel%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewMouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewQueryContinueDrag%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewQueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusButtonDown%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusButtonUp%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusDown%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusInAirMove%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusInRange%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusMove%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusOutOfRange%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusSystemGesture%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewStylusUp%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。 专用于预览事件的另一个方案是将已处理，以便匹配冒泡类处理程序不会调用其标记。  
  
 <xref:System.Windows.UIElement3D.OnPreviewTextInput%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
        <altmember cref="E:System.Windows.UIElement3D.PreviewTextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在触摸屏输入按下此元素时发生的 <see cref="E:System.Windows.UIElement3D.PreviewTouchDown" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnPreviewTouchDown%2A>方法具有默认实现。 重写<xref:System.Windows.UIElement3D.OnPreviewTouchDown%2A>中派生的类来处理<xref:System.Windows.UIElement3D.PreviewTouchDown>事件。 请务必调用基类的<xref:System.Windows.UIElement3D.OnPreviewTouchDown%2A>方法，从而基本类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在此元素内部移动触摸屏输入时发生的 <see cref="E:System.Windows.UIElement3D.PreviewTouchMove" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnPreviewTouchMove%2A>方法具有默认实现。 重写<xref:System.Windows.UIElement3D.OnPreviewTouchMove%2A>中派生的类来处理<xref:System.Windows.UIElement3D.PreviewTouchMove>事件。 请务必调用基类的<xref:System.Windows.UIElement3D.OnPreviewTouchMove%2A>方法，从而基本类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement3D.OnPreviewTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在此元素内部释放触摸屏输入时发生的 <see cref="E:System.Windows.UIElement3D.PreviewTouchUp" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnPreviewTouchUp%2A>方法具有默认实现。 重写<xref:System.Windows.UIElement3D.OnPreviewTouchUp%2A>中派生的类来处理<xref:System.Windows.UIElement3D.PreviewTouchUp>事件。 请务必调用基类的<xref:System.Windows.UIElement3D.OnPreviewTouchUp%2A>方法，从而基本类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="uIElement3D.OnQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnQueryContinueDrag%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryCursor (e As QueryCursorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryCursor(System::Windows::Input::QueryCursorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit&#xA;override this.OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit" Usage="uIElement3D.OnQueryCursor e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.QueryCursorEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnQueryCursor%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.QueryCursor" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="uIElement3D.OnStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnStylusButtonDown%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="uIElement3D.OnStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnStylusButtonUp%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="uIElement3D.OnStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusDown" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnStylusDown%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusEnter (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusEnter(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement3D.OnStylusEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当此元素引发未处理的 <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> 附加事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。 您可以调用基之前或之后应用特殊处理，具体取决于您的要求。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 将事件标记为已处理是仍有助于防止典型实例处理程序 (未指定的那些`handledEventsToo`) 调用。  
  
 <xref:System.Windows.UIElement3D.OnStylusEnter%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement3D.OnStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnStylusInAirMove%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement3D.OnStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnStylusInRange%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusLeave (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusLeave(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement3D.OnStylusLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当此元素引发未处理的 <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> 附加事件时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。 您可以调用基之前或之后应用特殊处理，具体取决于您的要求。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 将事件标记为已处理是仍有助于防止典型实例处理程序 (未指定的那些`handledEventsToo`) 调用。  
  
 <xref:System.Windows.UIElement3D.OnStylusLeave%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement3D.OnStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusMove" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnStylusMove%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement3D.OnStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnStylusOutOfRange%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="uIElement3D.OnStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnStylusSystemGesture%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement3D.OnStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.Stylus.StylusUp" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnStylusUp%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="uIElement3D.OnTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>当某个未处理的 <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> 附加事件在其路由中到达派生自此类的某个元素时调用。 实现此方法可为此事件添加类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法具有默认实现。 因为中间类继承中的可能会实现此方法，我们建议在实现中调用基实现。  
  
 此方法的用途是类似于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件模式 On * 方法： 此方法提供了通过建立类处理程序而不是实例处理程序来处理从派生类的匹配事件的方法。 在这种情况下匹配事件是路由的事件。 On * 方法的实现模式是不同的路由事件，因为可以由子元素，它不一定是将调用处理程序的元素引发路由的事件。 因此，您的实现需要检查的事件数据源属性。 它不应尝试再次引发该事件在大多数情况下。  
  
 通过重写此方法或通过注册类处理程序替换<xref:System.Windows.EventManager.RegisterClassHandler%2A>，派生类的<xref:System.Windows.UIElement3D>为由事件路由收到事件时，可以调用私有类处理程序方法。 类处理是相应的一种方案是操作事件数据并将路由的事件标记为已处理。  
  
 <xref:System.Windows.UIElement3D.OnTextInput%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.TextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement3D.OnTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在此元素内按下触摸屏输入时发生的 <see cref="E:System.Windows.UIElement3D.TouchDown" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnTouchDown%2A>方法具有默认实现。 重写<xref:System.Windows.UIElement3D.OnTouchDown%2A>中派生的类来处理<xref:System.Windows.UIElement3D.TouchDown>事件。 请务必调用基类的<xref:System.Windows.UIElement3D.OnTouchDown%2A>方法，从而基本类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchEnter (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchEnter(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement3D.OnTouchEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在触摸屏输入从此元素边界外部移动到其内部时发生的 <see cref="E:System.Windows.UIElement3D.TouchEnter" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnTouchEnter%2A>方法具有默认实现。 重写<xref:System.Windows.UIElement3D.OnTouchEnter%2A>中派生的类来处理<xref:System.Windows.UIElement3D.TouchEnter>事件。 请务必调用基类的<xref:System.Windows.UIElement3D.OnTouchEnter%2A>方法，从而基本类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchLeave (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchLeave(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement3D.OnTouchLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在触摸屏输入从此元素边界内部移动到其外部时发生的 <see cref="E:System.Windows.UIElement3D.TouchLeave" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnTouchLeave%2A>方法具有默认实现。 重写<xref:System.Windows.UIElement3D.OnTouchLeave%2A>中派生的类来处理<xref:System.Windows.UIElement3D.TouchLeave>事件。 请务必调用基类的<xref:System.Windows.UIElement3D.OnTouchLeave%2A>方法，从而基本类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement3D.OnTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在此元素内部移动触摸屏输入时发生的 <see cref="E:System.Windows.UIElement3D.TouchMove" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnTouchMove%2A>方法具有默认实现。 重写<xref:System.Windows.UIElement3D.OnTouchMove%2A>中派生的类来处理<xref:System.Windows.UIElement3D.TouchMove>事件。 请务必调用基类的<xref:System.Windows.UIElement3D.OnTouchMove%2A>方法，从而基本类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement3D.OnTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>为在此元素内部释放触摸屏输入时发生的 <see cref="E:System.Windows.UIElement3D.TouchUp" /> 路由事件提供类处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnTouchUp%2A>方法具有默认实现。 重写<xref:System.Windows.UIElement3D.OnTouchUp%2A>中派生的类来处理<xref:System.Windows.UIElement3D.TouchUp>事件。 请务必调用基类的<xref:System.Windows.UIElement3D.OnTouchUp%2A>方法，从而基本类接收事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUpdateModel">
      <MemberSignature Language="C#" Value="protected virtual void OnUpdateModel ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnUpdateModel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnUpdateModel" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnUpdateModel ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnUpdateModel();" />
      <MemberSignature Language="F#" Value="abstract member OnUpdateModel : unit -&gt; unit&#xA;override this.OnUpdateModel : unit -&gt; unit" Usage="uIElement3D.OnUpdateModel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，会参与呈现操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当您从派生类<xref:System.Windows.UIElement3D>类，您可以使用此方法一起使用<xref:System.Windows.UIElement3D.InvalidateModel%2A>方法来刷新的元素的模型。  
  
 只需在高级方案中调用此方法。 如果派生的类具有多个属性，会影响外观，并且你想要一次更新的基础模型，其中一种高级的方案。 内<xref:System.Windows.UIElement3D.OnUpdateModel%2A>方法可以更新<xref:System.Windows.Media.Media3D.Visual3D.Visual3DModel%2A>属性的<xref:System.Windows.Media.Media3D.Visual3D>类。  
  
 此方法中具有默认实现<xref:System.Windows.UIElement3D>类。  
  
 <xref:System.Windows.UIElement3D.OnUpdateModel%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
   
  
## Examples  
 下面的示例演示如何从派生<xref:System.Windows.UIElement3D>类，以创建`Sphere`类：  
  
 [!code-csharp[Shapes#Sphere](~/samples/snippets/csharp/VS_Snippets_Wpf/Shapes/CSharp/Sphere.cs#sphere)]
 [!code-vb[Shapes#Sphere](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Shapes/visualbasic/sphere.vb#sphere)]  
  
 有关完整示例，请参阅[UIElement3D 球体示例](https://go.microsoft.com/fwlink/?LinkID=160044)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="uIElement3D.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">先前的父项。 如果 <see cref="T:System.Windows.DependencyObject" /> 先前不具有父元素，则此项可以提供为 <see langword="null" />。</param>
        <summary>在此 <see cref="T:System.Windows.UIElement3D" /> 的父元素报告其基础可视父元素发生更改时，调用此方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.OnVisualParentChanged%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果重写此方法，均应调用基实现。 默认的基实现执行某些内部维护的反向继承属性状态。 无法调用基实现将使此状态无效。  
  
此方法重写 <see cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />。 <see cref="T:System.Windows.FrameworkElement" /> 并<see cref="T:System.Windows.Window" />也都重写<see cref="T:System.Windows.UIElement3D" />的实现<see cref="M:System.Windows.UIElement3D.OnVisualParentChanged(System.Windows.DependencyObject)" />，和<see cref="T:System.Windows.Window" />对其进行密封。</para></block>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="abstract member PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject&#xA;override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="uIElement3D.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">请求的焦点遍历的方向。</param>
        <summary>当在派生类中重写时，返回将按指定焦点遍历方向接收焦点的元素，而不用实际将焦点移至该元素。</summary>
        <returns>如果实际调用了 <see cref="M:System.Windows.UIElement3D.MoveFocus(System.Windows.Input.TraversalRequest)" />，则为接收焦点的元素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在此类中的默认实现不完整，并始终返回`null`。  
  
 <xref:System.Windows.UIElement3D.PredictFocus%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewDragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragEnter;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragEnter : System.Windows.DragEventHandler " Usage="member this.PreviewDragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在输入系统报告出现以此元素为拖动目标的基础拖动事件时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewDragEnter>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewDragEnter>事件附加到基础<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.PreviewDragEnter> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewDragEnterEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.DragEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.DragEnter>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewDragEnter%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewDragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewDragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewDragEnter" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewDragEnterEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewDragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragLeave;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragLeave : System.Windows.DragEventHandler " Usage="member this.PreviewDragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在输入系统报告出现以此元素为拖动起点的基础拖动事件时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewDragLeave>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewDragLeave>事件附加到基础<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.PreviewDragLeave> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewDragLeaveEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.DragEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.DragLeave>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewDragLeave%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewDragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewDragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewDragLeave" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewDragLeaveEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewDragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragOver;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragOver : System.Windows.DragEventHandler " Usage="member this.PreviewDragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在输入系统报告出现以此元素为可能放置目标的基础拖动事件时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewDragOver>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewDragOver>事件附加到基础<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.PreviewDragOver> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewDragOverEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.DragEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.DragOver>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewDragOver%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewDragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewDragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewDragOver" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewDragOverEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDrop;" />
      <MemberSignature Language="F#" Value="member this.PreviewDrop : System.Windows.DragEventHandler " Usage="member this.PreviewDrop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在输入系统报告出现将此元素作为放置目标的基础放置事件时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewDrop>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewDrop>事件附加到基础<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.PreviewDrop> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewDropEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.DragEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.Drop>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewDrop%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewDropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDropEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewDropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewDrop" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewDropEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewGiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ PreviewGiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在开始拖放操作时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.PreviewGiveFeedback>事件允许拖动事件，可以修改鼠标指针的外观，以便为用户可视反馈提供拖放操作期间的源。  
  
 此事件创建一个别名<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewGiveFeedback>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewGiveFeedback>事件附加到基础<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.PreviewGiveFeedback> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewGiveFeedbackEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.GiveFeedback>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewGiveFeedback%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewGiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewGiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewGiveFeedback" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewGiveFeedbackEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewGotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewGotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewGotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素聚焦于键盘时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于此事件使用隧道路由，因此具有焦点的元素可能是而不是元素的子元素实际附加事件处理程序。 检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据以确定实际具有焦点的元素中。  
  
 此事件创建一个别名<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewGotKeyboardFocus>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewGotKeyboardFocus>事件附加到基础<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.PreviewGotKeyboardFocus> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewGotKeyboardFocusEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.GotKeyboardFocus>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewGotKeyboardFocus%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewGotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewGotKeyboardFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewGotKeyboardFocusEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素聚焦于键盘并且按下某个键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 密钥处理与其他平台功能，例如命令和文本组合进行交互。 此事件创建一个别名<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewKeyDown>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewKeyDown>事件附加到基础<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.PreviewKeyDown> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewKeyDownEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.KeyDown>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewKeyDown%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewKeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewKeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewKeyDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewKeyDownEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewKeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素聚焦于键盘并且松开某个键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 密钥处理与其他平台功能，例如命令和文本组合进行交互。  
  
 此事件创建一个别名<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewKeyUp>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewKeyUp>事件附加到基础<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.PreviewKeyUp> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewKeyUpEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.KeyUp>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewKeyUp%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewKeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewKeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewKeyUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewKeyUpEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewLostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewLostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewLostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewLostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素不再聚焦于键盘时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于此事件使用隧道路由，因此失去焦点的元素可能是而不是元素的子元素实际附加事件处理程序。 检查<xref:System.Windows.RoutedEventArgs.Source%2A>事件数据来确定实际失去焦点的元素中。  
  
 此事件创建一个别名<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewLostKeyboardFocus>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewLostKeyboardFocus>事件附加到基础<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.PreviewLostKeyboardFocus> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewLostKeyboardFocusEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.LostKeyboardFocus>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewLostKeyboardFocus%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewLostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewLostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewLostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewLostKeyboardFocus" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewLostKeyboardFocusEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在指针位于此元素上并且按下任意鼠标按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewMouseDown>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewMouseDown>事件附加到基础<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseDown>任意一个协同通常引发事件<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown>或<xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown>，对应于一个两个标准鼠标按钮按下。 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown> 并<xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown>也是路由的事件，但它们是直接路由的事件，并引发相应的特定于按钮的事件时<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件到达事件路由中的此元素。 请参阅备注<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown>或<xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseDown> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewMouseDownEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.MouseDown>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewMouseDown%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewMouseDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseDownEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且按下鼠标左键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循元素树中，通过隧道路由它实际上是引发并由每个重新沿元素树的直接路由的事件<xref:System.Windows.UIElement3D>。  
  
 此事件是一个报告基础的鼠标按钮具体情况的多个相关事件<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件，它是由在事件路由的每个元素处理附加的事件。  
  
 此事件的事件数据的基础的事件数据公开<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件。 如果该事件被标记为已处理事件路由过程，则仍会引发鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.UIElement3D.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将该事件的侦听器。 如果将标记<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown>处理，在实质上标注<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>处理沿路由的所有其他侦听器和所有相关的事件。 这可能包括类处理程序生成事件，如<xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>。  
  
 从概念上讲，将此事件 (和其他鼠标事件<xref:System.Windows.UIElement3D>) 为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。 事件添加了方便的不需要检查原始的鼠标事件在事件数据中的鼠标按钮状态 （左-右、 向上向下）。 对于更高级的方案，例如非标准按钮的状态检查，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>而不是这些类上<xref:System.Windows.UIElement3D>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDown> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDownEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonDown%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewMouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewMouseLeftButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonDownEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且松开鼠标左键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循元素树中，通过隧道路由它实际上是引发并由每个重新沿元素树的直接路由的事件<xref:System.Windows.UIElement3D>。  
  
 此事件是一个报告基础的鼠标按钮具体情况的多个相关事件<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件，它是由在事件路由的每个元素处理附加的事件。  
  
 此事件的事件数据的基础的事件数据公开<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件。 如果该事件被标记为已处理事件路由过程，则仍会引发鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.UIElement3D.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将该事件的侦听器。 如果将标记<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp>处理，在实质上标注<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>处理沿路由的所有其他侦听器和所有相关的事件。  
  
 从概念上讲，将此事件 (和其他鼠标事件<xref:System.Windows.UIElement3D>) 为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。 事件添加了方便的不需要检查原始的鼠标事件在事件数据中的鼠标按钮状态 （左-右、 向上向下）。 对于更高级的方案，例如非标准按钮的状态检查，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>而不是这些类上<xref:System.Windows.UIElement3D>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUpEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewMouseLeftButtonUp%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewMouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewMouseLeftButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUpEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ PreviewMouseMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且移动鼠标指针时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 都会发生此事件时鼠标指针第一次进入元素边界，并还在鼠标指针移动时仍剩余元素的边界内。  
  
 此事件创建一个别名<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewMouseMove>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewMouseMove>事件附加到基础<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseMove> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewMouseMoveEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.MouseMove>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewMouseMove%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewMouseMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseMoveEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且按下鼠标右键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循元素树中，通过隧道路由它实际上是引发并由每个重新沿元素树的直接路由的事件<xref:System.Windows.UIElement3D>。  
  
 此事件是一个报告基础的鼠标按钮具体情况的多个相关事件<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件，它是由在事件路由的每个元素处理附加的事件。  
  
 此事件的事件数据的基础的事件数据公开<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>事件。 如果该事件被标记为已处理事件路由过程，则仍会引发鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.UIElement3D.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将该事件的侦听器。 如果将标记<xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown>处理，在实质上标注<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>处理沿路由的所有其他侦听器和所有相关的事件。 这可能包括类处理程序生成事件，如<xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>。  
  
 从概念上讲，将此事件 (和其他鼠标事件<xref:System.Windows.UIElement3D>) 为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。 事件添加了方便的不需要检查原始的鼠标事件在事件数据中的鼠标按钮状态 （左-右、 向上向下）。 对于更高级的方案，例如非标准按钮的状态检查，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>而不是这些类上<xref:System.Windows.UIElement3D>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonDown> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewMouseRightButtonDownEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonDown%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewMouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewMouseRightButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonDownEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且松开鼠标右键时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管这[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)似乎遵循元素树中，通过隧道路由它实际上是引发并由每个重新沿元素树的直接路由的事件<xref:System.Windows.UIElement3D>。  
  
 此事件是一个报告基础的鼠标按钮具体情况的多个相关事件<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件，它是由在事件路由的每个元素处理附加的事件。  
  
 此事件的事件数据的基础的事件数据公开<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件。 如果该事件被标记为已处理事件路由过程，则仍会引发鼠标按钮特定事件;但是，必须通过显式调用添加的鼠标按钮特定事件的处理程序<xref:System.Windows.UIElement3D.AddHandler%2A>，使用选项来处理已标记为已处理的事件，以便将该事件的侦听器。 如果将标记<xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>处理，在实质上标注<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>处理沿路由的所有其他侦听器和所有相关的事件。  
  
 从概念上讲，将此事件 (和其他鼠标事件<xref:System.Windows.UIElement3D>) 为鼠标"服务"(使用提供的服务定义<xref:System.Windows.Input.Mouse>类)。 事件添加了方便的不需要检查原始的鼠标事件在事件数据中的鼠标按钮状态 （左-右、 向上向下）。 对于更高级的方案，例如非标准按钮的状态检查，您可能需要使用[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上<xref:System.Windows.Input.Mouse>而不是这些类上<xref:System.Windows.UIElement3D>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewMouseRightButtonUpEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewMouseRightButtonUp%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.MouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewMouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewMouseRightButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseRightButtonUpEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且松开任意鼠标按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewMouseUp>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewMouseUp>事件附加到基础<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseUp>任意一个协同通常引发事件<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp>或<xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>，对应于一个两个标准鼠标按钮按下。 <xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp> 并<xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>也是路由的事件，但它们是直接路由的事件，并引发相应的特定于按钮的事件时<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>事件到达事件路由中的此元素。 请参阅备注<xref:System.Windows.UIElement3D.PreviewMouseLeftButtonUp>或<xref:System.Windows.UIElement3D.PreviewMouseRightButtonUp>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseUp> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewMouseUpEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.MouseUp>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewMouseUp%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewMouseUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseUpEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ PreviewMouseWheel;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在鼠标指针位于此元素上并且用户滚动鼠标滚轮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 焦点或鼠标捕获优先于在鼠标指针位于其中;因此，如果您收到此事件的已设定焦点或捕获的元素，将鼠标指针实际上可能是另一个元素上。  
  
 此事件创建一个别名<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewMouseMove>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewMouseMove>事件附加到基础<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseWheel> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewMouseWheelEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.MouseWheel>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewMouseWheel%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewMouseWheel" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewMouseWheelEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewQueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewQueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ PreviewQueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在拖放操作期间键盘或鼠标按钮的状态改变时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.PreviewQueryContinueDrag>事件允许拖动源来声明是否应取消拖放操作。  
  
 此事件创建一个别名<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewQueryContinueDrag>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewQueryContinueDrag>事件附加到基础<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.PreviewQueryContinueDrag> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewQueryContinueDragEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.QueryContinueDrag>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewQueryContinueDrag%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewQueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewQueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewQueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewQueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewQueryContinueDrag" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewQueryContinueDragEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在指针位于此元素上并且按下触笔按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewStylusButtonDown>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewStylusButtonDown>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusButtonDown> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewStylusButtonDownEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.StylusButtonDown>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewStylusButtonDown%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewStylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewStylusButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusButtonDownEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在指针位于此元素上并且松开触笔按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewStylusButtonUp>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewStylusButtonUp>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusButtonUp> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewStylusButtonUpEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.StylusButtonUp>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewStylusButtonUp%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewStylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewStylusButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusButtonUpEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ PreviewStylusDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当触笔位于元素上且触及数字化器时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewStylusDown>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewStylusDown>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusDown> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewStylusDownEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.StylusDown>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewStylusDown%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewStylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewStylusDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusDownEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔掠过元素但并未实际接触数字化器时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewStylusInAirMove>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewStylusInAirMove>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusInAirMove> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewStylusInAirMoveEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.StylusInAirMove>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewStylusInAirMove%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewStylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewStylusInAirMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusInAirMoveEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔位于此元素上并且触笔与数字化器之间的距离近到足以检测到触笔时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewStylusInRange>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewStylusInRange>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusInRange> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewStylusInRangeEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.StylusInRange>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewStylusInRange%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewStylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewStylusInRange" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusInRangeEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔位于元素上并且移动触笔时发生。 数字化器在检测触笔时，触笔必须处于移动状态才会引发此事件，否则将改为引发 <see cref="E:System.Windows.UIElement3D.PreviewStylusInAirMove" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewStylusMove>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewStylusMove>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusMove> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewStylusMoveEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.StylusMove>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewStylusMove%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewStylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewStylusMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusMoveEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔与数字化仪之间的距离太远以致无法检测到触笔时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewStylusOutOfRange>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewStylusOutOfRange>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusOutOfRange> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewStylusOutOfRangeEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.StylusOutOfRange>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewStylusOutOfRange%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewStylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewStylusOutOfRange" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusOutOfRangeEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ PreviewStylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在用户采用某一种触笔笔势时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关触笔笔势的信息，请参阅<xref:System.Windows.Input.SystemGesture>。  
  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewStylusSystemGesture>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewStylusSystemGesture>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusSystemGesture> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewStylusSystemGestureEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.StylusSystemGesture>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewStylusSystemGesture%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewStylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewStylusSystemGesture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusSystemGestureEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewStylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当触笔位于此元素上并且用户将触笔抬离数字化器时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewStylusDown>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewStylusDown>事件附加到基础<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusUp> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewStylusUpEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.StylusUp>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewStylusUp%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewStylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewStylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewStylusUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewStylusUpEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewTextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ PreviewTextInput;" />
      <MemberSignature Language="F#" Value="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewTextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素以设备无关模式获取文本时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.PreviewTextInput>事件允许组件或应用程序以与设备无关的方式侦听文本输入。 键盘是主要的方式<xref:System.Windows.UIElement3D.PreviewTextInput>; 但语音、 手写和其他输入的设备也可以生成<xref:System.Windows.UIElement3D.PreviewTextInput>。  
  
 由于键组合的默认键盘或输入的法编辑器的多个关键事件可能会引发一个文本输入的事件。  
  
 此事件创建一个别名<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.PreviewTextInput>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.PreviewTextInput>事件附加到基础<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.PreviewTextInput> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewTextInputEvent>|  
|路由策略|隧道|  
|委托|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.TextInput>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewTextInput%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewTextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewTextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewTextInput" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.PreviewTextInputEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewTouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当悬停在此元素上方的手指触摸屏幕时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Windows.UIElement3D.PreviewTouchDown>和<xref:System.Windows.UIElement3D.TouchDown>手指触摸屏幕，并将移动之前不会发生的事件。 手指在屏幕上按住它而无需移动它会导致按下并保存的行为<xref:System.Windows.Input.Stylus>。 按下并保持行为等同于鼠标右键单击。  
  
 若要使<xref:System.Windows.UIElement3D.PreviewTouchDown>并<xref:System.Windows.UIElement3D.TouchDown>事件发生只要上方的手指触摸屏幕上，设置<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>附加到属性`false`此元素。  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewTouchDownEvent>|  
|路由策略|隧道|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.TouchDown>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewTouchDown%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewTouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewTouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewTouchDown" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewTouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当悬停在此元素上方的手指在屏幕上移动时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewTouchMoveEvent>|  
|路由策略|隧道|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.TouchMove>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewTouchMove%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewTouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewTouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewTouchMove" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.PreviewTouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当悬停在此元素上方的手指从屏幕上移开时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.PreviewTouchUpEvent>|  
|路由策略|隧道|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   相应的浮升事件是<xref:System.Windows.UIElement3D.TouchUp>。  
  
-   重写<xref:System.Windows.UIElement3D.OnPreviewTouchUp%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.PreviewTouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.PreviewTouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.PreviewTouchUp" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在拖放操作期间键盘或鼠标按钮的状态改变时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.QueryContinueDrag>事件允许拖动源确定是否应取消拖放操作。  
  
 此事件创建一个别名<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.QueryContinueDrag>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.QueryContinueDrag>事件附加到基础<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.QueryContinueDrag> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.QueryContinueDragEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewQueryContinueDrag>。  
  
-   重写<xref:System.Windows.UIElement3D.OnQueryContinueDrag%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.QueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.QueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.QueryContinueDrag" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.QueryContinueDragEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryCursor As QueryCursorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::QueryCursorEventHandler ^ QueryCursor;" />
      <MemberSignature Language="F#" Value="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " Usage="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当请求显示光标时发生。 每次鼠标指针移至新位置时都会在一个元素上引发此事件，这意味着光标对象可能需要根据其新位置进行更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.QueryCursor>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.QueryCursor>事件附加到基础<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 此事件的名称引用游标不一定是文本光标 （有时称为插入点）。 相反，此上下文中的光标是声明与多个可能的输入相关的设备或 Windows 编程中的概念相关的屏幕图形显示的对象。 该对象表示由<xref:System.Windows.Input.Cursor>在 WPF 中的类。 WPF 输入的系统，可更改此光标时它表示鼠标指针的屏幕上的位置。 可以使用预定义的值从<xref:System.Windows.Input.Cursors>枚举，也可以声明自定义光标为图像文件。  
  
 侦听<xref:System.Windows.UIElement3D.QueryCursor>事件不是游标管理的有效技术。 相反，每个元素应定义自己使用的游标行为<xref:System.Windows.FrameworkContentElement.Cursor%2A>和<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>。 您应仅依赖于<xref:System.Windows.UIElement3D.QueryCursor>如果不使用 WPF 框架级别的基本元素，或中的特殊情况下，在每个元素的基础上定义游标的行为不符合你的需求。 有关详细信息在响应中实现的游标行为<xref:System.Windows.UIElement3D.QueryCursor>，请参阅<xref:System.Windows.Input.QueryCursorEventHandler>。  
  
 <xref:System.Windows.UIElement3D.QueryCursor> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_QueryCursor"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.QueryCursorEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   没有定义相应的隧道事件。  
  
-   重写<xref:System.Windows.UIElement3D.OnQueryCursor%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryCursorEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.QueryCursor" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.QueryCursorEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RaiseEvent(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit" Usage="uIElement3D.RaiseEvent e" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RaiseEvent(System.Windows.RoutedEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">一个 <see cref="T:System.Windows.RoutedEventArgs" />，其中包含事件数据并标识要引发的事件。</param>
        <summary>引发特定路由事件。 在提供的 <see cref="T:System.Windows.RoutedEventArgs" /> 实例内标识将引发的 <see cref="T:System.Windows.RoutedEvent" />（作为该事件数据的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 属性）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `e`参数的类型为路由的事件的所有数据的公共基类型; 但是，应作为最具体的事件数据类型，是适用于要引发的事件，因为给定的事件数据<xref:System.Windows.RoutedEventArgs>派生的类包含适用于特定事件时将引发此事件的实际的特定数据属性。  
  
 <xref:System.Windows.RoutedEventArgs> 不只是事件; 的状态属性它还标识要引发的路由的事件。 此事件引发模式和路由的事件数据均不同于[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]事件和数据类，通常只包含与事件相关的属性。  
  
 <xref:System.Windows.UIElement3D.RaiseEvent%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.ReleaseAllTouchCaptures" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseAllTouchCaptures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseAllTouchCaptures();" />
      <MemberSignature Language="F#" Value="member this.ReleaseAllTouchCaptures : unit -&gt; unit" Usage="uIElement3D.ReleaseAllTouchCaptures " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从此元素中释放所有捕获的触摸设备。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.ReleaseMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMouseCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseMouseCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseMouseCapture : unit -&gt; unit&#xA;override this.ReleaseMouseCapture : unit -&gt; unit" Usage="uIElement3D.ReleaseMouseCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果此元素具有鼠标捕获，则释放该捕获。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此元素不保存捕获，调用此方法无效。 请考虑检查的值<xref:System.Windows.UIElement3D.IsMouseCaptured%2A>之前调用此方法。  
  
 <xref:System.Windows.UIElement3D.ReleaseMouseCapture%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.ReleaseStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseStylusCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseStylusCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseStylusCapture : unit -&gt; unit&#xA;override this.ReleaseStylusCapture : unit -&gt; unit" Usage="uIElement3D.ReleaseStylusCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果此元素具有触笔设备捕获，则释放该捕获。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此元素不保存捕获，调用此方法无效。 请考虑检查的值<xref:System.Windows.UIElement3D.IsStylusCaptured%2A>之前调用此方法。  
  
 <xref:System.Windows.UIElement3D.ReleaseStylusCapture%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReleaseTouchCapture(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.ReleaseTouchCapture : System.Windows.Input.TouchDevice -&gt; bool" Usage="uIElement3D.ReleaseTouchCapture touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">要释放的设备。</param>
        <summary>尝试从此元素释放指定触摸设备。</summary>
        <returns>如果释放了触摸设备，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="touchDevice" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="uIElement3D.RemoveHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">附加了处理程序的路由事件的标识符。</param>
        <param name="handler">要从此元素的事件处理程序集合中删除的特定处理程序实现。</param>
        <summary>从此元素中删除指定的路由事件处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此的最常见情形[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]是实现时[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]自定义的路由事件，特别是，当您实现在处理程序的"删除"逻辑与相关联的"包装器"事件[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]级别。  
  
 如果存在任何与条件相匹配的输入的参数的方法调用注册的处理程序调用此方法起不起作用。  
  
 如果多个处理程序附加事件移除处理程序存储区中匹配的条件，仅第一个处理程序。 此行为是与一致[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]的行为`-=`运算符。  
  
 既不`routedEvent`也不`handler`可能`null`。 在尝试提供上述任意值作为`null`将引发异常。  
  
 此方法将忽略`handledEventsToo`与第一个处理程序时提供的参数信息添加<xref:System.Windows.UIElement3D.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>签名，它使已处理事件的处理。 删除任一类型的处理程序。  
  
 <xref:System.Windows.UIElement3D.RemoveHandler%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement3D.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.ShouldSerializeCommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeCommandBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeCommandBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeCommandBindings : unit -&gt; bool" Usage="uIElement3D.ShouldSerializeCommandBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回序列化进程是否应在此类的实例上序列化 <see cref="P:System.Windows.UIElement3D.CommandBindings" /> 属性的内容。</summary>
        <returns>如果应当序列化 <see cref="P:System.Windows.UIElement3D.CommandBindings" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这将返回`true`如果<xref:System.Windows.UIElement3D.CommandBindings%2A>本地设置。  
  
 这`ShouldSerialize`提供方法，因为<xref:System.Windows.UIElement3D.CommandBindings%2A>属性不具有简单的默认值。 此方法指示属性是否已从其默认值。 如果你要开发一个设计器或开发您自己控件包含通常调用此方法<xref:System.Windows.UIElement3D>。  
  
 有关详细信息，请参阅[使用 ShouldSerialize 和重置方法定义默认值](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)。  
  
 <xref:System.Windows.UIElement3D.ShouldSerializeCommandBindings%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement3D.ShouldSerializeInputBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInputBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInputBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeInputBindings : unit -&gt; bool" Usage="uIElement3D.ShouldSerializeInputBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回序列化进程是否应在此类的实例上序列化 <see cref="P:System.Windows.UIElement3D.InputBindings" /> 属性的内容。</summary>
        <returns>如果应当序列化 <see cref="P:System.Windows.UIElement3D.InputBindings" /> 属性值，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这将返回`true`如果<xref:System.Windows.UIElement3D.InputBindings%2A>本地设置。  
  
 这`ShouldSerialize`提供方法，因为<xref:System.Windows.UIElement3D.InputBindings%2A>属性不具有简单的默认值。 此方法指示属性是否已从其默认值。 如果你要开发一个设计器或开发您自己控件包含通常调用此方法<xref:System.Windows.UIElement3D>。  
  
 有关详细信息，请参阅[使用 ShouldSerialize 和重置方法定义默认值](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)。  
  
 <xref:System.Windows.UIElement3D.ShouldSerializeInputBindings%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在指针位于此元素上并且按下触笔按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.StylusButtonDown>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.StylusButtonDown>事件附加到基础<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusButtonDown> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.StylusButtonDownEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewStylusButtonDown>。  
  
-   重写<xref:System.Windows.UIElement3D.OnStylusButtonDown%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.StylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.StylusButtonDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusButtonDownEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在指针位于此元素上并且松开触笔按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.StylusButtonUp>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.StylusButtonUp>事件附加到基础<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusButtonUp> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.StylusButtonUpEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewStylusButtonUp>。  
  
-   重写<xref:System.Windows.UIElement3D.OnStylusButtonUp%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement3D.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.StylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.StylusButtonUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusButtonUpEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ StylusDown;" />
      <MemberSignature Language="F#" Value="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔位于此元素上且同时触及数字化器时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.StylusDown>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.StylusDown>事件附加到基础<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusDown> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.StylusDownEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewStylusDown>。  
  
-   重写<xref:System.Windows.UIElement3D.OnStylusDown%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.StylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.StylusDown" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusDownEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusEnter As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusEnter;" />
      <MemberSignature Language="F#" Value="member this.StylusEnter : System.Windows.Input.StylusEventHandler " Usage="member this.StylusEnter : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔进入此元素的边界时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.StylusEnter> 是[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)，它使用直接事件处理路由策略。 直接路由的事件不会引发在路由过程;相反，它们被处理的同一元素中引发位置。 但是，它们启用了路由的事件的行为，如在样式中的事件触发的其他方面。  
  
 尽管<xref:System.Windows.UIElement3D.StylusEnter>跟踪当触笔进入的边界的元素，此事件能够更确切地报告<xref:System.Windows.UIElement3D.IsStylusOver%2A>属性值已从`false`到`true`此元素上。  
  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.StylusEnter>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.StylusEnter>事件附加到基础<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusEnter> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusEnter"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.StylusEnterEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   重写<xref:System.Windows.UIElement3D.OnStylusEnter%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.StylusEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.StylusEnter" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusEnterEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔掠过元素但并未实际接触数字化器时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.StylusInAirMove>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.StylusInAirMove>事件附加到基础<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusInAirMove> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.StylusInAirMoveEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewStylusInAirMove>。  
  
-   重写<xref:System.Windows.UIElement3D.OnStylusInAirMove%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.StylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.StylusInAirMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusInAirMoveEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInRange;" />
      <MemberSignature Language="F#" Value="member this.StylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔位于此元素上并且触笔与数字化器之间的距离近到足以检测到触笔时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.StylusInRange>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.StylusInRange>事件附加到基础<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusInRange> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusInRange"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.StylusInRangeEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewStylusInRange>。  
  
-   重写<xref:System.Windows.UIElement3D.OnStylusInRange%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.StylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.StylusInRange" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusInRangeEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusLeave As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusLeave;" />
      <MemberSignature Language="F#" Value="member this.StylusLeave : System.Windows.Input.StylusEventHandler " Usage="member this.StylusLeave : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔离开元素的边界时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.StylusLeave> 是[路由事件概述](~/docs/framework/wpf/advanced/routed-events-overview.md)，它使用直接事件处理路由策略。 直接路由的事件不会引发在路由过程;相反，它们被处理的同一元素中引发位置。 但是，它们启用了路由的事件的行为，如在样式中的事件触发的其他方面。  
  
 尽管<xref:System.Windows.UIElement3D.StylusLeave>跟踪当触笔离开元素，此事件的边界的详细信息按原义报告<xref:System.Windows.UIElement3D.IsStylusOver%2A>属性值已从`true`到`false`此元素上。  
  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.StylusLeave>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.StylusLeave>事件附加到基础<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusLeave> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusLeave"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.StylusLeaveEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   重写<xref:System.Windows.UIElement3D.OnStylusLeave%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.StylusLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.StylusLeave" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusLeaveEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusMove;" />
      <MemberSignature Language="F#" Value="member this.StylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔移到此元素上时发生。 触笔必须在位于数字化器上时移动，才会引发此事件。 否则将改为引发 <see cref="E:System.Windows.UIElement3D.StylusInAirMove" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.StylusMove>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.StylusMove>事件附加到基础<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusMove> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusMove"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.StylusMoveEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewStylusMove>。  
  
-   重写<xref:System.Windows.UIElement3D.OnStylusMove%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.StylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.StylusMove" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusMoveEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触笔位于此元素上并且触笔与数字化器之间的距离太远以致无法检测到触笔时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.StylusOutOfRange>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.StylusOutOfRange>事件附加到基础<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusOutOfRange> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.StylusOutOfRangeEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewStylusOutOfRange>。  
  
-   重写<xref:System.Windows.UIElement3D.OnStylusOutOfRange%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.StylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.StylusOutOfRange" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusOutOfRangeEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ StylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在用户采用某一种触笔笔势时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关触笔笔势的详细信息，请参阅<xref:System.Windows.Input.SystemGesture>。  
  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.StylusSystemGesture>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.StylusSystemGesture>事件附加到基础<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusSystemGesture> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.StylusSystemGestureEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewStylusSystemGesture>。  
  
-   重写<xref:System.Windows.UIElement3D.OnStylusSystemGesture%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.StylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.StylusSystemGesture" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusSystemGestureEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.StylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusUp;" />
      <MemberSignature Language="F#" Value="member this.StylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.StylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当触笔位于此元素上并且用户将触笔抬离数字化器时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件创建一个别名<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.StylusUp>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.StylusUp>事件附加到基础<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 触摸、 鼠标和触笔输入中的特定关系存在。 有关详细信息，请参阅[Windows Vista 中的触摸屏输入支持](https://go.microsoft.com/fwlink/?LinkId=160818)并[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.UIElement3D.StylusUp> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_StylusUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.StylusUpEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewStylusUp>。  
  
-   重写<xref:System.Windows.UIElement3D.OnStylusUp%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.StylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.StylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.StylusUp" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.StylusUpEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.TextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ TextInput;" />
      <MemberSignature Language="F#" Value="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.TextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在此元素以设备无关模式获取文本时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.TextInput>事件允许组件或应用程序以与设备无关的方式侦听文本输入。 键盘是主要的方式<xref:System.Windows.UIElement3D.TextInput>，但语音、 手写和其他输入的设备也可以引发<xref:System.Windows.UIElement3D.TextInput>。  
  
 由于键组合的默认键盘或输入的法编辑器的多个关键事件可能会引发只是一个文本输入的事件。  
  
 此事件创建一个别名<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>附加事件对于此类，以便<xref:System.Windows.UIElement3D.TextInput>属于类的成员列出时<xref:System.Windows.UIElement3D>作为基元素继承。 事件处理程序附加到<xref:System.Windows.UIElement3D.TextInput>事件附加到基础<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>附加事件，并接收相同的事件数据实例。  
  
 <xref:System.Windows.UIElement3D.TextInput> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="routedEventInfo_TextInput"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.TextInputEvent>|  
|路由策略|浮升|  
|委托|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewTextInput>。  
  
-   重写<xref:System.Windows.UIElement3D.OnTextInput%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.TextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.TextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.TextInput" /> 路由事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和、添加事件所有者的实用程序方法。 可以使用这些标识符添加类处理程序。  
  
 有关注册路由的事件的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>。 有关使用路由事件标识符添加类处理程序的详细信息，请参阅 <xref:System.Windows.EventManager.RegisterClassHandler%2A>。  
  
 <xref:System.Windows.UIElement3D.TextInputEvent> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.TouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchDown;" />
      <MemberSignature Language="F#" Value="member this.TouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当悬停在此元素上方的手指触摸屏幕时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Windows.UIElement3D.PreviewTouchDown>和<xref:System.Windows.UIElement3D.TouchDown>手指触摸屏幕，并将移动之前不会发生的事件。 手指在屏幕上按住它而无需移动它会导致按下并保存的行为<xref:System.Windows.Input.Stylus>。 按下并保持行为等同于鼠标右键单击。  
  
 若要使<xref:System.Windows.UIElement3D.PreviewTouchDown>并<xref:System.Windows.UIElement3D.TouchDown>事件发生只要上方的手指触摸屏幕上，设置<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>附加到属性`false`此元素。  
  
<a name="routedEventInfo_TouchDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.TouchDownEvent>|  
|路由策略|浮升|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewTouchDown>。  
  
-   重写<xref:System.Windows.UIElement3D.OnTouchDown%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.TouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.TouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.TouchDown" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.TouchEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchEnter As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchEnter;" />
      <MemberSignature Language="F#" Value="member this.TouchEnter : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchEnter : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触摸屏输入从此元素边界外部移动到其内部时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 始终引发此事件，指示此元素上捕获触摸设备。  
  
<a name="routedEventInfo_TouchEnter"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.TouchEnterEvent>|  
|路由策略|直接|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   重写<xref:System.Windows.UIElement3D.OnTouchEnter%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.TouchEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.TouchEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.TouchEnter" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.TouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCaptured As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCaptured { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCaptured : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.UIElement3D.TouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在此元素上捕获的所有触摸设备。</summary>
        <value>在此元素上捕获的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.TouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCapturedWithin As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCapturedWithin { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCapturedWithin : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.UIElement3D.TouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在此元素或其可视化树中的任何子元素上捕获的所有触摸设备。</summary>
        <value>在此元素或其可视化树中的任何子元素上捕获的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.TouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesDirectlyOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesDirectlyOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesDirectlyOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.UIElement3D.TouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此元素上的所有触摸设备。</summary>
        <value>位于此元素上的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.TouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.UIElement3D.TouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在此元素或其可视化树中的任何子元素上的所有触摸设备。</summary>
        <value>在此元素或其可视化树中的任何子元素上的 <see cref="T:System.Windows.Input.TouchDevice" /> 对象的枚举。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.TouchLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchLeave As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchLeave;" />
      <MemberSignature Language="F#" Value="member this.TouchLeave : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchLeave : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在触摸屏输入从此元素边界内部移动到其外部时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchLeave"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.TouchLeaveEvent>|  
|路由策略|直接|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   重写<xref:System.Windows.UIElement3D.OnTouchLeave%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.TouchLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.TouchLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.TouchLeave" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.TouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchMove;" />
      <MemberSignature Language="F#" Value="member this.TouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当悬停在此元素上方的手指在屏幕上移动时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchMove"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.TouchMoveEvent>|  
|路由策略|浮升|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewTouchMove>。  
  
-   重写<xref:System.Windows.UIElement3D.OnTouchMove%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.TouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.TouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.TouchMove" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement3D.TouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchUp;" />
      <MemberSignature Language="F#" Value="member this.TouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当悬停在此元素上方的手指从屏幕上移开时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchUp"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.TouchUpEvent>|  
|路由策略|浮升|  
|委托|<xref:System.EventHandler%601>类型<xref:System.Windows.Input.TouchEventArgs>。|  
  
-   相应的隧道事件是<xref:System.Windows.UIElement3D.PreviewTouchUp>。  
  
-   重写<xref:System.Windows.UIElement3D.OnTouchUp%2A>实现类处理此事件在派生类中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.TouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement3D.TouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.UIElement3D.TouchUp" /> 路由事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visibility">
      <MemberSignature Language="C#" Value="public System.Windows.Visibility Visibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Visibility Visibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement3D.Visibility" />
      <MemberSignature Language="VB.NET" Value="Public Property Visibility As Visibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Visibility Visibility { System::Windows::Visibility get(); void set(System::Windows::Visibility value); };" />
      <MemberSignature Language="F#" Value="member this.Visibility : System.Windows.Visibility with get, set" Usage="System.Windows.UIElement3D.Visibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Visibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置此元素的 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 可见性。</summary>
        <value>枚举的一个值。 默认值为 <see cref="F:System.Windows.Visibility.Visible" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置此属性的值将影响<xref:System.Windows.UIElement3D.IsVisible%2A>，这又可能会引发<xref:System.Windows.UIElement3D.IsVisibleChanged>事件。 但是，<xref:System.Windows.UIElement3D.IsVisible%2A>有其他影响的因素，例如包含它的父项的可见性设置。  
  
 元素的<xref:System.Windows.UIElement3D.Visibility%2A>不是<xref:System.Windows.Visibility.Visible>不参与输入的事件 （或命令） 并不会在命中测试报告。  
  
 <xref:System.Windows.UIElement3D.Visibility%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
<a name="dependencyPropertyInfo_Visibility"></a>   
## <a name="dependency-property-information"></a>依赖项属性信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.UIElement3D.VisibilityProperty>|  
|元数据属性设置为 `true`|无|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement3D.IsVisible" />
        <altmember cref="T:System.Windows.Visibility" />
      </Docs>
    </Member>
    <Member MemberName="VisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement3D.VisibilityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VisibilityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VisibilityProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VisibilityProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement3D.VisibilityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="P:System.Windows.UIElement3D.Visibility" /> 依赖项属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement3D.VisibilityProperty> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>