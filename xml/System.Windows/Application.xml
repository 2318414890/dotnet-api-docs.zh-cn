<Type Name="Application" FullName="System.Windows.Application">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b524996378b2882f342e465d834a727cafe277d6" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32695083" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject&#xA;Implements IQueryAmbient" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>封装 Windows Presentation Foundation 应用程序。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> 是一个类，封装[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]应用程序特定的功能，包括以下：  
  
-   **应用程序生存期**: <xref:System.Windows.Application.Activated>， <xref:System.Windows.Application.Current%2A>， <xref:System.Windows.Application.Deactivated>， <xref:System.Windows.Application.DispatcherUnhandledException>， <xref:System.Windows.Application.Exit>， <xref:System.Windows.Application.Run%2A>， <xref:System.Windows.Application.SessionEnding>， <xref:System.Windows.Application.Shutdown%2A>， <xref:System.Windows.Application.ShutdownMode%2A>， <xref:System.Windows.Application.Startup>。  
  
-   **应用程序作用域窗口、 属性和资源管理**: <xref:System.Windows.Application.FindResource%2A>， <xref:System.Windows.Application.GetContentStream%2A>， <xref:System.Windows.Application.GetResourceStream%2A>， <xref:System.Windows.Application.LoadComponent%2A>， <xref:System.Windows.Application.MainWindow%2A>， <xref:System.Windows.Application.Properties%2A>， <xref:System.Windows.Application.Resources%2A>， <xref:System.Windows.Application.StartupUri%2A>， <xref:System.Windows.Application.Windows%2A>。  
  
-   **命令行参数和退出代码处理**: <xref:System.Windows.Application.Startup?displayProperty=nameWithType>， <xref:System.Windows.Application.Exit?displayProperty=nameWithType>， <xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType>。  
  
-   **导航**: <xref:System.Windows.Application.FragmentNavigation>， <xref:System.Windows.Application.LoadCompleted>， <xref:System.Windows.Application.Navigated>， <xref:System.Windows.Application.Navigating>， <xref:System.Windows.Application.NavigationProgress>， <xref:System.Windows.Application.NavigationStopped>， <xref:System.Windows.Application.NavigationFailed>， <xref:System.Windows.Application.SetCookie%2A>， <xref:System.Windows.Application.GetCookie%2A>。  
  
 <xref:System.Windows.Application> 实现以提供对其窗口、 属性和资源作用域服务的共享的访问的单一实例模式。 因此，只有一个实例的<xref:System.Windows.Application>类可以创建每个<xref:System.AppDomain>。  
  
 你可以实现<xref:System.Windows.Application>使用标记、 标记和代码隐藏或代码。 如果<xref:System.Windows.Application>是否标记文件标记或标记和代码隐藏，必须配置为使用标记，实现[!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)]`ApplicationDefinition`项。  
  
> [!NOTE]
>  一个独立应用程序不需要<xref:System.Windows.Application>对象; 可以实现一个自定义`static`入口点方法 (`Main`)，这将打开一个窗口，而无需创建的实例<xref:System.Windows.Application>。 但是，[!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]需要<xref:System.Windows.Application>对象。  
  
   
  
## Examples  
 下面的示例演示如何标准的应用程序是使用仅标记来定义：  
  
 [!code-xaml[ApplicationSnippets#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 下面的示例演示如何使用定义标准的应用程序只代码：  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 下面的示例演示一个标准应用程序如何使用标记和代码隐藏的组合来定义。  
  
 [!code-xaml[ApplicationSnippets#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe>公共<see langword="static" />(<see langword="Shared" />在 Visual Basic 中) 的此类型的成员都是线程安全。 此外，<see cref="M:System.Windows.Application.FindResource(System.Object)" />和<see cref="M:System.Windows.Application.TryFindResource(System.Object)" />方法和<see cref="P:System.Windows.Application.Properties" />和<see cref="P:System.Windows.Application.Resources" />属性都是线程安全。</threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Application();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Application" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个实例<xref:System.Windows.Application>类可以创建每个<xref:System.AppDomain>，以确保对单个数据集的作用域的应用程序窗口、 属性和资源的共享的访问。 因此，默认构造函数的<xref:System.Windows.Application>类检测到正在初始化的实例是否中的第一个实例<xref:System.AppDomain>; 如果不是，<xref:System.InvalidOperationException>引发。  
  
 <xref:System.Windows.Application>当前对象<xref:System.AppDomain>公开从静态<xref:System.Windows.Application.Current%2A>属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">对于每个 <see cref="T:System.Windows.Application" />，都会创建 <see cref="T:System.AppDomain" /> 类的多个实例。</exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当应用程序成为前台应用程序时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 激活的 Windows Presentation Foundation 应用程序具有一个或多个打开的窗口 （成为前景应用程序） 时一窗口以来激活时首次启动应用程序，或是在激活一窗口时时应用程序处于非活动状态： 具体而言，执行了激活时：  
  
-   应用程序打开其第一个窗口。  
  
-   通过使用 ALT + TAB 或使用任务管理器，用户将切换到应用程序。  
  
-   用户单击其中一个应用程序中窗口的任务栏按钮。  
  
 需要检测何时及其激活的应用程序可以处理<xref:System.Windows.Application.Activated>事件。  
  
 第一次激活应用程序之后，它可能会停用并且在其生存期内多次重新激活。 如果应用程序的行为或状态取决于其激活状态，它可以将同时处理<xref:System.Windows.Application.Activated>和<xref:System.Windows.Application.Deactivated>的事件，以确定哪些处的激活状态。  
  
 一旦应用程序处于活动状态，<xref:System.Windows.Application.Activated>将不会再次引发直到停用应用程序，而不考虑应用程序处于活动状态时激活了多少应用程序中的窗口。  
  
 <xref:System.Windows.Application.Activated> 不会引发[!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]。  
  
   
  
## Examples  
 下面的示例演示如何检测到独立的应用程序激活和停用。  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Application ^ Current { System::Windows::Application ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.Windows.Application" /> 的 <see cref="T:System.AppDomain" /> 对象。</summary>
        <value>当前 <see cref="T:System.Windows.Application" /> 的 <see cref="T:System.AppDomain" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> 为每个-<xref:System.AppDomain>实现静态的单一实例类型<xref:System.Windows.Application.Current%2A>属性以提供对共享的访问<xref:System.Windows.Application>当前实例<xref:System.AppDomain>。 这种设计保证由该状态<xref:System.Windows.Application>，包括共享的资源和状态，可从一个单个的共享位置。  
  
 此属性是线程安全的可从任意线程。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当应用程序停止作为前台应用程序时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有一个或多个打开的窗口的 Windows Presentation Foundation 应用程序会停用 （停止作为前台应用程序） 时用户执行下列任务：  
  
-   切换到另一个应用程序通过使用 ALT + TAB 或使用任务管理器。  
  
-   单击其他应用程序中窗口的任务栏按钮。  
  
 应用程序需要检测停用可以处理<xref:System.Windows.Application.Deactivated>事件。  
  
 第一次激活应用程序之后，它可能会停用并且在其生存期内多次重新激活。 如果应用程序的行为或状态取决于其激活状态，它可以将同时处理<xref:System.Windows.Application.Deactivated>和<xref:System.Windows.Application.Activated>的事件，以确定其状态。  
  
 <xref:System.Windows.Application.Deactivated> 不会引发[!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]。  
  
   
  
## Examples  
 下面的示例演示如何检测到独立的应用程序将停用并激活。  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DispatcherUnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ DispatcherUnhandledException;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在异常由应用程序引发但未进行处理时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，Windows Presentation Foundation 捕获未经处理的异常、 将通知用户 （它们可以从该对话框报告异常） 对话框中，从异常和应用程序将自动关闭。  
  
 但是，如果应用程序需要从一个集中位置执行自定义未经处理的异常处理，则应处理<xref:System.Windows.Application.DispatcherUnhandledException>。  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> 由引发<xref:System.Windows.Application>对于每个主 UI 线程上运行的代码中未经处理的异常。  
  
 如果未处理异常时在后台 UI 线程 (具有其自己的线程<xref:System.Windows.Threading.Dispatcher>) 或后台辅助线程 (而无需线程<xref:System.Windows.Threading.Dispatcher>)，该异常不会转发到的主 UI 线程。 因此，<xref:System.Windows.Application.DispatcherUnhandledException>则不会引发。 在这些情况下，你将需要编写代码来执行以下操作：  
  
1.  处理异常的后台线程上。  
  
2.  这些异常调度到的主 UI 线程。  
  
3.  重新它们的主 UI 线程上引发，而不进行处理，以允许<xref:System.Windows.Application.DispatcherUnhandledException>被引发。  
  
 有关详细信息，请参阅[线程处理模型](~/docs/framework/wpf/advanced/threading-model.md)概述。  
  
 <xref:System.Windows.Application.DispatcherUnhandledException>事件处理程序传递<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs>包含与异常，相关的上下文信息的自变量包括：  
  
-   异常 (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>)。  
  
-   <xref:System.Windows.Threading.Dispatcher>从它 (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>)。  
  
 可以使用此信息来确定异常是否可恢复。 可恢复的异常可能是<xref:System.IO.FileNotFoundException>，例如，尽管可能不可恢复的异常<xref:System.StackOverflowException>，例如。  
  
 处理未经处理的异常时<xref:System.Windows.Application.DispatcherUnhandledException>，并且你不希望[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]以便继续处理它，你需要设置<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A>属性`true`。  
  
 与其他事件不同，<xref:System.Windows.Application>引发，<xref:System.Windows.Application.DispatcherUnhandledException>不具有匹配的受保护的虚拟实现 (OnDispatcherUnhandledException)。 因此，类派生自<xref:System.Windows.Application>始终必须注册事件处理程序与<xref:System.Windows.Application.DispatcherUnhandledException>处理未经处理的异常。  
  
   
  
## Examples  
 下面的示例演示如何通过处理处理未经处理的异常<xref:System.Windows.Application.DispatcherUnhandledException>事件。  
  
 [!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind1)]
 [!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind1)]  
[!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind2)]
[!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exit As ExitEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::ExitEventHandler ^ Exit;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>恰好在应用程序关闭之前发生，且无法取消。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序可以关闭这两个原因如下：  
  
-   <xref:System.Windows.Application.Shutdown%2A>方法<xref:System.Windows.Application>调用对象时，无论是显式还是作为确定通过<xref:System.Windows.Application.ShutdownMode%2A>属性。  
  
-   用户通过注销或关闭来结束会话。  
  
 你可以检测通过处理应用程序关闭时<xref:System.Windows.Application.Exit>事件，并执行所需的任何其他处理。  
  
 你还可以处理<xref:System.Windows.Application.Exit>若要检查或更改应用程序退出代码时无需调用<xref:System.Windows.Application.Shutdown%2A>显式。 退出代码公开从<xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>属性<xref:System.Windows.ExitEventArgs>自变量传递给<xref:System.Windows.Application.Exit>事件处理程序。 当应用程序停止运行时，退出代码将被传递到操作系统，以进行后续处理。  
  
 如果你的应用程序处理<xref:System.Windows.Application.SessionEnding>事件并随后取消它，<xref:System.Windows.Application.Exit>则不会引发和应用程序才能继续在符合关闭模式中运行。  
  
 退出代码可以设置从[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]，尽管忽略的值。  
  
 有关[!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)]，<xref:System.Windows.Application.Exit>在以下情况下引发：  
  
-   [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]离开。  
  
-   在[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]，当选项卡承载[!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]已关闭。  
  
-   关闭浏览器时。  
  
 在所有情况下，值<xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>忽略属性。  
  
   
  
## Examples  
 下面的示例演示如何：  
  
-   处理<xref:System.Windows.Application.Exit>事件。  
  
-   检查并更新<xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>属性<xref:System.Windows.ExitEventArgs>。  
  
-   向独立存储中的应用程序日志写入条目。  
  
-   对独立存储的应用程序状态保存。  
  
 [!code-xaml[ApplicationExitSnippets#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要查找的资源名。</param>
        <summary>使用指定键搜索 [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 资源（如 <see cref="T:System.Windows.Style" /> 或 <see cref="T:System.Windows.Media.Brush" />），并在未找到所请求的资源时引发异常（请参阅 [XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)）。</summary>
        <returns>所请求的资源对象。 如果未找到所请求的资源，则引发 <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.FindResource%2A> 将首先查找在指定的资源的应用程序范围资源。 应用程序范围的资源由<xref:System.Windows.Application>，和从公开<xref:System.Windows.Application.Resources%2A>属性。 如果应用程序作用域资源集中找不到指定的资源<xref:System.Windows.Application.FindResource%2A>下来会搜索系统资源。 系统资源是由用户定义的命令行程序资源，包括颜色、 字体和外壳程序配置。 这些来自<xref:System.Windows.SystemColors>， <xref:System.Windows.SystemFonts>，和<xref:System.Windows.SystemParameters>分别为静态属性类型。 若要使用<xref:System.Windows.Application.FindResource%2A>获取它们，这些类型还公开资源的键属性，旨在将传递给<xref:System.Windows.Application.FindResource%2A>; 例如， <xref:System.Windows.SystemParameters.IconWidthKey%2A>。  
  
 因为<xref:System.Windows.Application.FindResource%2A>返回一个对象，如果找到资源，你必须强制转换为适当的类型的返回的值。  
  
> [!IMPORTANT]
>  如果找不到键调用此方法，将引发异常。 如果您不想要处理的异常，导致调用<xref:System.Windows.Application.FindResource%2A>，调用<xref:System.Windows.Application.TryFindResource%2A>替换;<xref:System.Windows.Application.TryFindResource%2A>返回`null`引用时找不到请求的资源，并不会引发异常。  
  
 此方法是线程安全的可以从任何线程调用。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Windows.Application.FindResource%2A>查找的资源，并处理<xref:System.Windows.ResourceReferenceKeyNotFoundException>如果未找到资源。  
  
 [!code-csharp[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">无法找到资源。</exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当应用程序中的导航器开始导航至某个内容片断时发生，如果所需片段位于当前内容中，则导航会立即发生；或者，如果所需片段位于不同内容中，则导航会在加载了源 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 内容之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器为<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 请参阅 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetContentStream (uriContent As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetContentStream(Uri ^ uriContent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent">映射到松散资源的相对 <see cref="T:System.Uri" />。</param>
        <summary>返回位于指定 <see cref="T:System.Uri" /> 的内容数据文件的资源流（请参阅 [WPF 应用程序资源、内容和数据文件](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)）。</summary>
        <returns>一个 <see cref="T:System.Windows.Resources.StreamResourceInfo" />，包含位于指定 <see cref="T:System.Uri" /> 处的内容数据文件。 如果未找到松散资源，则返回 null。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不是线程安全。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">传递给 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> 为 null。</exception>
        <exception cref="T:System.ArgumentException">传递给 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> 是绝对 <see cref="T:System.Uri" />。</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCookie(Uri ^ uri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">
          <see cref="T:System.Uri" />，它指定已为其创建 Cookie 的位置。</param>
        <summary>为由 <see cref="T:System.Uri" /> 指定的位置检索 Cookie。</summary>
        <returns>如果该 Cookie 存在，则为 <see cref="T:System.String" /> 值；否则会引发 <see cref="T:System.ComponentModel.Win32Exception" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.GetCookie%2A> 检索指定 cookie <xref:System.Uri>。 如果无法检索 cookie，<xref:System.ComponentModel.Win32Exception>引发。 你需要编写代码以将 cookie 字符串分析为名称/值对的列表。  
  
 有关概述中的 cookie [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]，请参阅[导航概述](~/docs/framework/wpf/app-development/navigation-overview.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">如果在尝试检索指定 Cookie 时发生问题，则会由 <see langword="InternetGetCookie" /> 函数（由 <see cref="M:System.Windows.Application.GetCookie(System.Uri)" /> 调用）引发一个 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 错误。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于获取有关基于文件的<see cref="T:System.Uri" />。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">用于获取有关非基于文件的<see cref="T:System.Uri" />。 关联的枚举： <see cref="P:System.Net.WebPermission.ConnectList" /></permission>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRemoteStream (uriRemote As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetRemoteStream(Uri ^ uriRemote);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote">映射到源站点的松散资源的 <see cref="T:System.Uri" />。</param>
        <summary>返回位于指定 <see cref="T:System.Uri" /> 的源站点数据文件的资源流（请参阅 [WPF 应用程序资源、内容和数据文件](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)）。</summary>
        <returns>一个 <see cref="T:System.Windows.Resources.StreamResourceInfo" />，包含位于指定 <see cref="T:System.Uri" /> 处的源站点数据文件的资源流。 如果未找到松散资源，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不是线程安全。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">传递给 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> 为 null。</exception>
        <exception cref="T:System.ArgumentException">传递给 <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> 的 <see cref="T:System.Uri" /> 不是相对的，或虽然是绝对的但不是 <c>pack://siteoforigin:,,,/</c> 格式。</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetResourceStream (uriResource As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetResourceStream(Uri ^ uriResource);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource">映射到嵌入资源的 <see cref="T:System.Uri" />。</param>
        <summary>返回位于指定 <see cref="T:System.Uri" /> 的资源数据文件的资源流（请参阅 [WPF 应用程序资源、内容和数据文件](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)）。</summary>
        <returns>一个 <see cref="T:System.Windows.Resources.StreamResourceInfo" />，包含位于指定 <see cref="T:System.Uri" /> 处的资源数据文件的资源流。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不是线程安全。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">传递给 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> 为 null。</exception>
        <exception cref="T:System.ArgumentException">传递给 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> 的 <see cref="T:System.Uri" /> 不是相对的，或虽然是绝对的但不是 <c>pack://application:,,,/</c> 格式。</exception>
        <exception cref="T:System.IO.IOException">传递给 <see cref="T:System.Uri" /> 的 <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> 无法找到。</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在已经加载、分析并开始呈现应用程序中的导航器导航到的内容时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器为<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 请参阅 <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>。  
  
> [!NOTE]
>  如侦听事件导航内容<xref:System.Windows.FrameworkElement.Loaded>上的事件<xref:System.Windows.Controls.Page>访问导航的内容的属性之前。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>加载位于指定[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 处的 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] 文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]文件可以是应用程序代码文件 (配置为[!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)]页项) 或应用程序数据文件 (资源文件、 内容文件或的源站点文件; 请参阅[WPF 应用程序资源、 内容和数据文件](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  此方法不是线程安全。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadComponent (resourceLocator As Uri) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ LoadComponent(Uri ^ resourceLocator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator">一个 <see cref="T:System.Uri" />，它映射到相对 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 文件。</param>
        <summary>加载位于指定[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 处的 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] 文件，并将其转换为由该 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 文件的根元素指定的对象的实例。</summary>
        <returns>加载的 XAML 文件所指定的根元素的实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你必须显式转换到的根元素相同类型的返回值[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]文件。  
  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]文件可以是应用程序代码文件 (配置为[!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)]页项) 或应用程序数据文件 (资源文件、 内容文件或的源站点文件; 请参阅[WPF 应用程序资源、 内容和数据文件](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  此方法不是线程安全。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceLocator" /> 为 null。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceLocator" /> 是绝对 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]。</exception>
        <exception cref="T:System.Exception">该文件不是 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 文件。</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadComponent (component As Object, resourceLocator As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LoadComponent(System::Object ^ component, Uri ^ resourceLocator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component">一个对象，其类型与 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 文件的根元素相同。</param>
        <param name="resourceLocator">一个 <see cref="T:System.Uri" />，它映射到相对 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 文件。</param>
        <summary>加载位于指定 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] 的 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 文件，并将其转换为由 [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] 文件的根元素指定的对象的实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]文件可以是应用程序代码文件 (配置为[!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)]页项) 或应用程序数据文件 (资源文件、 内容文件或的源站点文件; 请参阅[WPF 应用程序资源、 内容和数据文件](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  此方法不是线程安全。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceLocator" /> 为 null。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceLocator" /> 是绝对 [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]。</exception>
        <exception cref="T:System.Exception">
          <paramref name="component" /> 的类型与 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 文件的根元素不匹配。</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property MainWindow As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ MainWindow { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置应用程序的主窗口。</summary>
        <value>一个指定为应用程序主窗口的 <see cref="T:System.Windows.Window" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.MainWindow%2A> 自动设置到第一个引用<xref:System.Windows.Window>对象中要实例化<xref:System.AppDomain>。  
  
 你可以通过设置指定不同的主窗口<xref:System.Windows.Application.MainWindow%2A>分配另一个<xref:System.Windows.Application.Windows%2A>对象传递给<xref:System.Windows.Application.MainWindow%2A>属性。  
  
 如果<xref:System.Windows.Application.ShutdownMode%2A>属性<xref:System.Windows.Application>对象设置为<xref:System.Windows.ShutdownMode.OnMainWindowClose>，关闭主窗口导致应用程序关闭。  
  
 可以设置<xref:System.Windows.Application.MainWindow%2A>属性从[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]，如果应用程序的主窗口不是通过设置生成的窗口<xref:System.Windows.Application.StartupUri%2A>中的属性[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]。 两个限制[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]方法是：  
  
-   你可以指定[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-仅<xref:System.Windows.Window>或[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-仅<xref:System.Windows.Navigation.NavigationWindow>作为主窗口。  
  
-   必须设置<xref:System.Windows.UIElement.Visibility%2A>你指定的窗口的属性，否则它将不会。  
  
 第一个引用<xref:System.Windows.Window>要实例化的对象还添加到的第一项为<xref:System.Windows.Application.Windows%2A>集合。 如果<xref:System.Windows.Application.MainWindow%2A>随后将设置为另一种引用<xref:System.Windows.Window>，与对主窗口的引用项的位置会更改，而在中的项的顺序<xref:System.Windows.Application.Windows%2A>保持不变。 因此，始终使用<xref:System.Windows.Application.MainWindow%2A>来引用而不是中的第一个项的主窗口<xref:System.Windows.Application.Windows%2A>。  
  
> [!NOTE]
>  如果主窗口<xref:System.Windows.Navigation.NavigationWindow>，并且需要特定的访问权<xref:System.Windows.Navigation.NavigationWindow>成员，你将需要的值转换<xref:System.Windows.Application.MainWindow%2A>到<xref:System.Windows.Navigation.NavigationWindow>。  
>   
>  此属性则仅可从创建的线程<xref:System.Windows.Application>对象。  
  
   
  
## Examples  
 下面的示例演示如何查找应用程序主窗口。  
  
 [!code-csharp[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 下面的示例演示如何设置<xref:System.Windows.Application.MainWindow%2A>使用[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]。  
  
 [!code-xaml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 下面的示例演示如何实例化<xref:System.Windows.Application.MainWindow%2A>在应用程序启动过程中的代码中。  
  
 [!code-csharp[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Application.MainWindow" /> 是从浏览器承载的应用程序（如 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)]）设置的。</exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在已经找到应用程序中的导航器要导航到的内容时发生，尽管此时该内容可能尚未完成加载。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器为<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 请参阅 <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在应用程序中的导航器请求新导航时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器为<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 请参阅 <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在应用程序中的导航器在导航到所请求内容时出现错误的情况下发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器为<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 请参阅 <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在由应用程序中的导航器管理的下载过程中定期发生，以提供导航进度信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器为<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 请参阅 <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在调用应用程序中的导航器的 <see langword="StopLoading" /> 方法时发生，或者当导航器在当前导航正在进行期间请求了一个新导航时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器为<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
 请参阅 <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.Activated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnActivated%2A> 引发 <xref:System.Windows.Application.Activated> 事件。  
  
 派生自类型<xref:System.Windows.Application>可能会重写<xref:System.Windows.Application.OnActivated%2A>。 重写的方法必须调用<xref:System.Windows.Application.OnActivated%2A>基类中如果<xref:System.Windows.Application.Activated>需要引发。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.Deactivated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnDeactivated%2A> 引发 <xref:System.Windows.Application.Deactivated> 事件。  
  
 派生自类型<xref:System.Windows.Application>可能会重写<xref:System.Windows.Application.OnDeactivated%2A>。 重写的方法必须调用<xref:System.Windows.Application.OnDeactivated%2A>基类中如果<xref:System.Windows.Application.Deactivated>需要引发。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExit (e As ExitEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExit(System::Windows::ExitEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.ExitEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.Exit" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnExit%2A> 引发 <xref:System.Windows.Application.Exit> 事件。  
  
 派生自类型<xref:System.Windows.Application>可能会重写<xref:System.Windows.Application.OnExit%2A>方法。 重写的方法必须调用<xref:System.Windows.Application.OnExit%2A>基类中如果<xref:System.Windows.Application.Exit>需要引发。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFragmentNavigation (e As FragmentNavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFragmentNavigation(System::Windows::Navigation::FragmentNavigationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.FragmentNavigation" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnFragmentNavigation%2A> 引发 <xref:System.Windows.Application.FragmentNavigation> 事件。  
  
 派生自类型<xref:System.Windows.Application>可能会重写<xref:System.Windows.Application.OnFragmentNavigation%2A>。 重写的方法必须调用<xref:System.Windows.Application.OnFragmentNavigation%2A>基类中如果<xref:System.Windows.Application.FragmentNavigation>需要引发。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadCompleted (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadCompleted(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Navigation.NavigationEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.LoadCompleted" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnLoadCompleted%2A> 引发 <xref:System.Windows.Application.LoadCompleted> 事件。  
  
 派生自类型<xref:System.Windows.Application>可能会重写<xref:System.Windows.Application.OnLoadCompleted%2A>。 重写的方法必须调用<xref:System.Windows.Application.OnLoadCompleted%2A>基类中如果<xref:System.Windows.Application.LoadCompleted>需要引发。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigated (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigated(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Navigation.NavigationEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.Navigated" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigated%2A> 引发 <xref:System.Windows.Application.Navigated> 事件。  
  
 派生自类型<xref:System.Windows.Application>可能会重写<xref:System.Windows.Application.OnNavigated%2A>。 重写的方法必须调用<xref:System.Windows.Application.OnNavigated%2A>基类中如果<xref:System.Windows.Application.Navigated>需要引发。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigating (e As NavigatingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigating(System::Windows::Navigation::NavigatingCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.Navigating" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigating%2A> 引发 <xref:System.Windows.Application.Navigating> 事件。  
  
 派生自类型<xref:System.Windows.Application>可能会重写<xref:System.Windows.Application.OnNavigating%2A>。 重写的方法必须调用<xref:System.Windows.Application.OnNavigating%2A>基类中如果<xref:System.Windows.Application.Navigating>需要引发。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationFailed (e As NavigationFailedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationFailed(System::Windows::Navigation::NavigationFailedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.NavigationFailed" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationFailed%2A> 引发 <xref:System.Windows.Application.NavigationFailed> 事件。  
  
 派生自类型<xref:System.Windows.Application>可能会重写<xref:System.Windows.Application.OnNavigationFailed%2A>。 重写的方法必须调用<xref:System.Windows.Application.OnNavigationFailed%2A>基类中如果<xref:System.Windows.Application.NavigationFailed>需要引发。  
  
   
  
## Examples  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationProgress (e As NavigationProgressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationProgress(System::Windows::Navigation::NavigationProgressEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.NavigationProgress" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationProgress%2A> 引发 <xref:System.Windows.Application.NavigationProgress> 事件。  
  
 派生自类型<xref:System.Windows.Application>可能会重写<xref:System.Windows.Application.OnNavigationProgress%2A>。 重写的方法必须显式调用<xref:System.Windows.Application.OnNavigationProgress%2A>基类中如果<xref:System.Windows.Application.NavigationProgress>需要引发。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationStopped (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationStopped(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.Navigation.NavigationEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.NavigationStopped" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationStopped%2A> 引发 <xref:System.Windows.Application.NavigationStopped> 事件。  
  
 派生自类型<xref:System.Windows.Application>可能会重写<xref:System.Windows.Application.OnNavigationStopped%2A>。 重写的方法必须调用<xref:System.Windows.Application.OnNavigationStopped%2A>基类中如果<xref:System.Windows.Application.NavigationStopped>需要引发。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionEnding (e As SessionEndingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionEnding(System::Windows::SessionEndingCancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.SessionEndingCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.SessionEnding" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnSessionEnding%2A> 引发 <xref:System.Windows.Application.SessionEnding> 事件。  
  
 派生自类型<xref:System.Windows.Application>可能会重写<xref:System.Windows.Application.OnSessionEnding%2A>。 重写的方法必须调用<xref:System.Windows.Application.OnSessionEnding%2A>基类中如果<xref:System.Windows.Application.SessionEnding>需要引发。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartup (e As StartupEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartup(System::Windows::StartupEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Windows.StartupEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Windows.Application.Startup" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnStartup%2A> 引发 <xref:System.Windows.Application.Startup> 事件。  
  
 派生自类型<xref:System.Windows.Application>可能会重写<xref:System.Windows.Application.OnStartup%2A>。 重写的方法必须调用<xref:System.Windows.Application.OnStartup%2A>基类中如果<xref:System.Windows.Application.Startup>需要发出的事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Properties { System::Collections::IDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取应用程序范围属性的集合。</summary>
        <value>一个包含应用程序范围的属性的 <see cref="T:System.Collections.IDictionary" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> 公开通过字典<xref:System.Windows.Application.Properties%2A>可以用于存储应用程序作用域属性。 这使您可以共享状态中的所有代码<xref:System.AppDomain>以线程安全的方式，而无需编写你自己的状态代码。  
  
 属性存储在<xref:System.Windows.Application.Properties%2A>必须转换为适当的返回类型。  
  
 <xref:System.Windows.Application.Properties%2A>属性是线程安全，可以从任意线程。  
  
   
  
## Examples  
 下面的示例演示如何创建和使用应用程序作用域属性使用<xref:System.Windows.Application.Properties%2A>。  
  
 [!code-xaml[ApplicationPropertiesSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ResourceAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Assembly ^ ResourceAssembly { System::Reflection::Assembly ^ get(); void set(System::Reflection::Assembly ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置为 [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] 应用程序中的资源提供包[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 的 <see cref="T:System.Reflection.Assembly" />。</summary>
        <value>对为 [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] 应用程序中的资源提供包[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 的 <see cref="T:System.Reflection.Assembly" /> 的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]资源项程序集，从返回的值由标识相关的运行时进行解析<xref:System.Reflection.Assembly.GetEntryAssembly%2A>方法。  
  
 入口程序集是通过返回的程序集<xref:System.Reflection.Assembly.GetEntryAssembly%2A>，并且可能以下：  
  
-   默认应用程序域中的可执行程序集。  
  
-   要通过调用执行的第一个程序集<xref:System.AppDomain.ExecuteAssembly%2A>。  
  
 在以下情况，但是，[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]程序集无法获取项程序集的引用：  
  
-   非托管 （本机） 应用程序主机[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]程序集。  
  
-   托管应用程序主机[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]程序集加载到新应用程序域之外使用某种方法进行<xref:System.AppDomain.ExecuteAssembly%2A>。  
  
 在这两种情况，<xref:System.Reflection.Assembly.GetEntryAssembly%2A>返回`null`，和[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]无法解析程序集的资源。 在这些情况下，<xref:System.Windows.Application.ResourceAssembly%2A>可设置，只，与对应该用于解析资源的程序集的引用一次。  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> 只能设置一次由于不可能的资源程序集将更改后[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]则加载程序集。  
  
> [!NOTE]
>  <xref:System.Windows.Application.ResourceAssembly%2A> 无法设置[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]程序集可以发现入口程序集-即，当<xref:System.Reflection.Assembly.GetEntryAssembly%2A>返回对程序集的引用而非`null`。  
  
 此属性是线程安全的可从任意线程。  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> 是.NET Framework 3.5 版中引入的。  有关详细信息，请参见[版本和依赖关系](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 应用程序具有入口程序集，或者已设置 <see cref="P:System.Windows.Application.ResourceAssembly" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置应用程序范围资源（如样式和画笔）的集合。</summary>
        <value>一个包含零个或多个应用程序范围资源的 <see cref="T:System.Windows.ResourceDictionary" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Resources%2A>属性可以用于在 windows 和应用程序的元素之间共享资源。 此外，<xref:System.Windows.Application.Resources%2A>属性包含在资源查找路径中，按以下顺序遍历：  
  
1.  元素  
  
2.  Windows  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=nameWithType>  
  
4.  系统  
  
 因此，[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]可以将元素绑定到应用程序范围的资源。 此外，如果更改资源，资源系统可确保该元素属性绑定到这些资源会自动更新以反映更改。  
  
 应用程序范围的资源提供了一种简单的方法，可支持你的应用程序一致的主题。 你可以轻松创建中的主题[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]使用`Application.Resources`标记。 但是，如果你的应用程序支持多个主题，其中可能包含大量的主题元素，则可能是更轻松地管理它们使用一个<xref:System.Windows.ResourceDictionary>每个主题的实例。 这种方式，可以通过将资源属性设置为相应应用新主题<xref:System.Windows.ResourceDictionary>。  
  
 使用时要注意两点<xref:System.Windows.Application.Resources%2A>。 首先，字典*密钥*是一个对象，因此你需要使用完全相同的对象实例时设置和获取属性值 （请注意，使用字符串键时区分大小写）。 其次，字典*值*是一个对象，因此你将需要获取的属性值时，将的值转换为所需的类型。  
  
 <xref:System.Windows.Application.Resources%2A> 是线程安全，可以从任意线程。  
  
   
  
## Examples  
 此示例演示了如何使用[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]以及应用程序范围的资源创建一致的视觉外观。  
  
 [!code-xaml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
 [!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml1)]  
[!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml2)]  
  
 下面的示例演示如何在代码和 XAML 中设置应用程序资源。  
  
 [!code-csharp[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xaml[HOWTOApplicationModelSnippets#SetApplicationScopeResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml#setapplicationscoperesourcexaml)]  
  
 下面的示例演示如何在代码中获取应用程序资源。  
  
 [!code-csharp[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>启动 Windows Presentation Foundation 应用程序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Function Run () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>启动 Windows Presentation Foundation 应用程序。</summary>
        <returns>在应用程序关闭时，返回给操作系统的 <see cref="T:System.Int32" /> 应用程序退出代码。 默认情况下，该退出代码值为 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Run%2A> 调用以启动[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]应用程序。 如果你定义你<xref:System.Windows.Application>使用标记，或标记和代码隐藏<xref:System.Windows.Application.Run%2A>将隐式调用。 但是，如果你定义你<xref:System.Windows.Application>使用代码，你将需要显式调用<xref:System.Windows.Application.Run%2A>。  
  
 当<xref:System.Windows.Application.Run%2A>调用时，<xref:System.Windows.Application>将附加新<xref:System.Windows.Threading.Dispatcher>对 UI 线程的实例。 接下来，<xref:System.Windows.Threading.Dispatcher>对象的<xref:System.Windows.Threading.Dispatcher.Run%2A>调用方法，以启动一个消息泵处理 windows 消息。 最后，<xref:System.Windows.Threading.Dispatcher>对象调用<xref:System.Windows.Application>对象的<xref:System.Windows.Application.OnStartup%2A>方法来引发<xref:System.Windows.Application.Startup>事件。 因此，你处理时建立的应用程序执行模型<xref:System.Windows.Application.Startup>，此时视为应用程序是否正在运行。  
  
 应用程序停止运行时<xref:System.Windows.Application.Shutdown%2A>称为; 的值<xref:System.Windows.Application.ShutdownMode%2A>属性确定何时<xref:System.Windows.Application.Shutdown%2A>被调用，并且是自动还是需要显式调用它。  
  
 <xref:System.Windows.Application.Run%2A> 可以仅从创建的线程调用<xref:System.Windows.Application>对象。 此外，<xref:System.Windows.Application.Run%2A>不能从调用[!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]。  
  
   
  
## Examples  
 下面的示例演示使用自定义的应用程序<xref:System.Windows.Application>，因此必须显式调用<xref:System.Windows.Application.Run%2A>。  
  
 [!code-csharp[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Application.Run" /> 是从浏览器承载的应用程序（如 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]）调用的。</exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run(System::Windows::Window ^ window);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window">在应用程序启动时自动打开的 <see cref="T:System.Windows.Window" />。</param>
        <summary>启动 Windows Presentation Foundation 应用程序并打开指定窗口。</summary>
        <returns>在应用程序关闭时，返回给操作系统的 <see cref="T:System.Int32" /> 应用程序退出代码。 默认情况下，该退出代码值为 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载扩展<xref:System.Windows.Application.Run%2A>方法以在应用程序开始运行后打开指定的窗口。  
  
 如果您定义代码<xref:System.Windows.Application>，这将打开一个窗口，在它开始运行时，请显式调用<xref:System.Windows.Application.Run%2A>。  
  
 如果你创建你<xref:System.Windows.Application>使用标记，或标记和代码隐藏，您可以自动打开一个窗口在过程中使用以下方法之一：  
  
-   以声明方式，通过设置<xref:System.Windows.Application.StartupUri%2A>。  
  
-   以编程方式处理<xref:System.Windows.Application.Startup>。  
  
   
  
## Examples  
 下面的示例演示应用程序具有手动创建静态入口点方法实例化<xref:System.Windows.Application>之前调用, <xref:System.Windows.Application.Run%2A>。  
  
 [!code-csharp[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Windows.Application.Run" /> 是从浏览器承载的应用程序（如 [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]）调用的。</exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionEnding As SessionEndingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SessionEndingCancelEventHandler ^ SessionEnding;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户通过注销或关闭操作系统来结束 Windows 会话时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下，应用程序关闭时 Windows 会话结束，发生在用户注销或关机。 在此情况下，Windows 将询问关闭每个打开的应用程序。 但是，它是应用程序可能不会准备好发生此情况时关闭。 例如，应用程序可能拥有是处于不一致状态，或中间长时间运行操作的数据。 在这些情况下，它可能需要阻止会话结束，并可能更需要允许用户决定让结束会话的选项。  
  
 你可以检测通过处理在会话结束时<xref:System.Windows.Application.SessionEnding>事件。 如果应用程序需要阻止会话结束，<xref:System.Windows.SessionEndingCancelEventArgs>传递给事件处理程序自变量公开<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>，设置为`true`(默认值是`false`)。  
  
 如果<xref:System.Windows.Application.SessionEnding>未经处理，或不被取消的情况下处理<xref:System.Windows.Application.Shutdown%2A>称为和<xref:System.Windows.Application.Exit>引发事件。  
  
 若要获取有关为什么结束会话的详细信息，应用程序可以检查<xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>，即之一<xref:System.Windows.ReasonSessionEnding>值 (<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType>和<xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>)。  
  
 <xref:System.Windows.Application.SessionEnding> 不会引发由控制台应用程序。  
  
 <xref:System.Windows.Application.SessionEnding> 仅在创建的线程上引发<xref:System.Windows.Application>对象。  
  
 <xref:System.Windows.Application.SessionEnding> 不会引发的 XAML 浏览器应用程序 (Xbap)。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Application.SessionEnding>事件，并允许用户取消它。  
  
 [!code-xaml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCookie(Uri ^ uri, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">
          <see cref="T:System.Uri" />，它指定应为其创建 Cookie 的位置。</param>
        <param name="value">包含 Cookie 数据的 <see cref="T:System.String" />。</param>
        <summary>为由 <see cref="T:System.Uri" /> 指定的位置创建一个 Cookie。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cookie 是任意的应用程序客户端计算机上应用程序的会话 (会话 cookie) 期间或跨应用程序会话 (永久 cookie) 可以存储的数据。 你可以通过调用创建两种类型的 cookie <xref:System.Windows.Application.SetCookie%2A>。  
  
 Cookie 数据通常采用以下格式的名称/值对的形式：  
  
 `Name=Value`  
  
 此格式的字符串传递<xref:System.Windows.Application.SetCookie%2A>，连同<xref:System.Uri>应为其设置 cookie 的位置 （通常情况下，应用程序域）。  
  
 Cookie 是会话 cookie 还是持久性 cookie 取决于是否 cookie 字符串传递给<xref:System.Windows.Application.SetCookie%2A>包括一个到期日期。 会话 cookie 的字符串不包括一个到期日期。 持久性 cookie 的字符串存在，并且必须采用以下格式：  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 永久 cookie 存储在当前[!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)]到期，在这种情况下删除它们之前安装的 Internet 临时文件文件夹。 通过将其到期日期设置为在过去的日期/时间值，可以从你的应用程序删除持久性 cookie。  
  
 有关概述中的 cookie [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]，请参阅[导航概述](~/docs/framework/wpf/app-development/navigation-overview.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">如果在尝试创建指定的 Cookie 时发生问题，则会由 <see langword="InternetSetCookie" /> 函数（由 <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" /> 调用）引发一个 [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] 错误。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于获取有关基于文件的<see cref="T:System.Uri" />。 关联的枚举： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">用于获取有关非基于文件的<see cref="T:System.Uri" />。 关联的枚举： <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>关闭一个应用程序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭一个应用程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Windows.Application.Shutdown%2A>调用时，应用程序停止运行。 你可以处理<xref:System.Windows.Application.Exit>事件来检测应用程序时将要停止运行，以执行任何适当的处理。  
  
 <xref:System.Windows.Application.Shutdown%2A> 在以下情况下隐式调用 Windows Presentation Foundation 通过：  
  
-   当<xref:System.Windows.Application.ShutdownMode%2A>设置为<xref:System.Windows.ShutdownMode.OnLastWindowClose>。  
  
-   当<xref:System.Windows.Application.ShutdownMode%2A>设置为<xref:System.Windows.ShutdownMode.OnMainWindowClose>。  
  
-   当用户结束会话和<xref:System.Windows.Application.SessionEnding>未处理时，或处理而无需取消事件。  
  
 调用<xref:System.Windows.Application.Shutdown%2A>显式将导致关闭的情况下，应用程序而不考虑<xref:System.Windows.Application.ShutdownMode%2A>设置。 但是，如果<xref:System.Windows.Application.ShutdownMode%2A>设置为<xref:System.Windows.ShutdownMode.OnExplicitShutdown>，必须调用<xref:System.Windows.Application.Shutdown%2A>关闭应用程序。  
  
> [!IMPORTANT]
>  当<xref:System.Windows.Application.Shutdown%2A>是调用，该应用程序将关闭而不考虑是否<xref:System.Windows.Window.Closing>取消事件的任何打开的窗口。  
  
 此方法可以仅从创建的线程调用<xref:System.Windows.Application>对象。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">若要使用所有窗口和不受限制的用户输入的事件的权限。 关联的枚举： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(int exitCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">应用程序的一个整数退出代码。 默认退出代码为 0。</param>
        <summary>关闭将指定退出代码返回给操作系统的应用程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以处理<xref:System.Windows.Application.Exit>事件设置退出代码。 但是，如果你明确地调用<xref:System.Windows.Application.Shutdown%2A>，并且你处理<xref:System.Windows.Application.Exit>仅设置退出代码，可以调用<xref:System.Windows.Application.Shutdown%2A>相反。  
  
 此方法可以仅从创建的线程调用<xref:System.Windows.Application>对象。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">若要使用所有窗口和不受限制的用户输入的事件的权限。 关联的枚举： <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ShutdownMode As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ShutdownMode ShutdownMode { System::Windows::ShutdownMode get(); void set(System::Windows::ShutdownMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置导致调用 <see cref="M:System.Windows.Application.Shutdown" /> 方法的条件。</summary>
        <value>一个 <see cref="T:System.Windows.ShutdownMode" /> 枚举值。 默认值为 <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序停止运行时，才<xref:System.Windows.Application.Shutdown%2A>调用应用程序的方法。 关闭可以进行隐式或显式的值指定<xref:System.Windows.Application.ShutdownMode%2A>属性。  
  
 如果你设置<xref:System.Windows.Application.ShutdownMode%2A>到<xref:System.Windows.ShutdownMode.OnLastWindowClose>，Windows Presentation Foundation (WPF) 隐式调用<xref:System.Windows.Application.Shutdown%2A>应用程序中的最后一个窗口关闭时，即使任何当前已实例化的 windows 设置作为主窗口 (请参阅<xref:System.Windows.Application.MainWindow%2A>)。  
  
 A<xref:System.Windows.Application.ShutdownMode%2A>的<xref:System.Windows.ShutdownMode.OnMainWindowClose>使 WPF 在隐式调用<xref:System.Windows.Application.Shutdown%2A>时<xref:System.Windows.Application.MainWindow%2A>关闭，即使其他窗口处于当前打开。  
  
 某些应用程序的生存期可能不是依赖于主窗口或最后一个窗口已关闭，或可能根本不依赖于 windows 的时。 你需要为这些方案设置<xref:System.Windows.Application.ShutdownMode%2A>属性<xref:System.Windows.ShutdownMode.OnExplicitShutdown>，这需要显式<xref:System.Windows.Application.Shutdown%2A>方法调用停止应用程序。 否则，应用程序将继续在后台运行。  
  
 <xref:System.Windows.Application.ShutdownMode%2A> 可以从以声明方式配置[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]或以编程方式从代码。  
  
 此属性则仅可从创建的线程<xref:System.Windows.Application>对象。  
  
   
  
## Examples  
 下面的示例演示如何配置<xref:System.Windows.Application.ShutdownMode%2A>指定必须显式关闭应用程序。  
  
 [!code-xaml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::StartupEventHandler ^ Startup;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在调用 <see cref="M:System.Windows.Application.Run" /> 对象的 <see cref="T:System.Windows.Application" /> 方法时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 典型的 Windows Presentation Foundation 应用程序可能会执行各种的初始化任务，它在启动时，包括：  
  
-   处理命令行参数。  
  
-   打开主窗口。  
  
-   正在初始化应用程序范围的资源。  
  
-   正在初始化应用程序作用域属性。  
  
 你可以以声明方式指定的主窗口和使用的应用程序作用域资源[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)](<xref:System.Windows.Application.StartupUri%2A>和<xref:System.Windows.Application.Resources%2A>分别)。 有时，但是，资源或应用程序的主窗口可以仅将以编程方式在运行时确定。 此外，应用程序作用域属性和命令行参数只能以编程方式。 可以通过处理执行编程初始化<xref:System.Windows.Application.Startup>事件，包括以下：  
  
-   获取和处理命令行参数，它们是可从<xref:System.Windows.StartupEventArgs.Args%2A>属性<xref:System.Windows.StartupEventArgs>类传递给<xref:System.Windows.Application.Startup>事件处理程序。  
  
-   通过使用初始化应用程序范围的资源<xref:System.Windows.Application.Resources%2A>属性。  
  
-   通过使用初始化应用程序作用域属性<xref:System.Windows.Application.Properties%2A>属性。  
  
-   实例化并显示一个 （或多个） 窗口。  
  
> [!NOTE]
>  此外可以通过调用静态获取命令行参数<xref:System.Environment.GetCommandLineArgs%2A>方法<xref:System.Environment>对象。 但是，<xref:System.Environment.GetCommandLineArgs%2A>需要完全信任才能执行。  
  
 如果你设置<xref:System.Windows.Application.StartupUri%2A>使用[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]，创建主窗口不可用从<xref:System.Windows.Application.MainWindow%2A>属性或<xref:System.Windows.Application.Windows%2A>属性<xref:System.Windows.Application>后的对象，直到<xref:System.Windows.Application.Startup>处理事件。 如果在启动期间需要向主窗口的访问，你需要手动创建新的窗口对象从你<xref:System.Windows.Application.Startup>事件处理程序。  
  
> [!NOTE]
>  如果你的应用程序使用<xref:System.Net.AuthenticationManager.CredentialPolicy%2A>若要指定凭据策略，你需要设置<xref:System.Net.AuthenticationManager.CredentialPolicy%2A>后<xref:System.Windows.Application.Startup>引发; 否则为[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]将其设置为默认内部策略直接后<xref:System.Windows.Application.Startup>引发事件。  
  
 传递给命令行自变量<xref:System.Windows.Application.Startup>事件处理程序并不作为相同[!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)]查询字符串参数传递给[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]。  
  
   
  
## Examples  
 下面的示例演示如何获取和处理的独立应用程序的命令行选项。 如果 **/StartMinimized**提供命令行参数，在打开应用程序主窗口的最小化状态。  
  
 [!code-xaml[ApplicationStartupSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] 无法检索和处理命令行自变量，因为它们与启动[!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]部署 (请参阅[部署 WPF 应用程序 (WPF)](~/docs/framework/wpf/app-development/deploying-a-wpf-application-wpf.md))。 但是，它们可以检索和处理来自用于启动它们的 URL 的查询字符串参数。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberSignature Language="VB.NET" Value="Public Property StartupUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ StartupUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在应用程序启动时自动显示的 UI。</summary>
        <value>A <see cref="T:System.Uri" /> ，是指应用程序启动时将自动打开的 UI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你可以使用<xref:System.Windows.Application.StartupUri%2A>应用程序启动时自动加载 UI 资源。  
  
 下表显示 UI 资源，可加载的类型、，到打开的窗口的类型和应用程序，这些资源可以设置为的类型<xref:System.Windows.Application.StartupUri%2A>。  
  
|类型|窗口|应用程序类型|  
|----------|------------|----------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|仅独立应用程序|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|仅独立应用程序|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|独立/浏览器承载|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|独立/浏览器承载|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|独立/浏览器承载|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|独立/浏览器承载|  
  
 通常情况下，设置<xref:System.Windows.Application.StartupUri%2A>属性中以声明方式[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]。 但是，您可以设置<xref:System.Windows.Application.StartupUri%2A>以编程方式，如从<xref:System.Windows.Application.Startup>事件处理程序，如果对于应用程序只能在运行时加载必需的 UI 资源非常有用。 例如，则应用程序可能会等到运行时才加载其资源，如果 UI 资源的名称存储在配置文件。  
  
 是否设置<xref:System.Windows.Application.StartupUri%2A>以声明方式或以编程方式，直到未加载相应的 UI 资源后<xref:System.Windows.Application.Startup>处理事件。 因此，你将无权访问生成的窗口从<xref:System.Windows.Application.Windows%2A>属性或<xref:System.Windows.Application.MainWindow%2A>属性时处理<xref:System.Windows.Application.Startup>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Windows.Application.StartupUri" /> 设置为 null 值。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">请求的环境属性的名称。</param>
        <summary>查询当前范围中是否有指定的环境属性。</summary>
        <returns>
          如果有所请求的环境属性，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式的接口成员实现。 它只能在 <xref:System.Windows.Application> 实例强制转换为 <xref:System.Windows.Markup.IQueryAmbient> 接口时使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">要查找的资源名。</param>
        <summary>搜索指定资源。</summary>
        <returns>所请求的资源对象。 如果未找到所请求的资源，则返回 null 引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.TryFindResource%2A> 将首先查找在指定的资源的应用程序范围资源。 应用程序范围的资源由<xref:System.Windows.Application>，和从公开<xref:System.Windows.Application.Resources%2A>属性。 如果应用程序作用域资源集中找不到指定的资源<xref:System.Windows.Application.TryFindResource%2A>下来会搜索系统资源。 系统资源是由用户定义的命令行程序资源，包括颜色、 字体和外壳程序配置。 这些来自<xref:System.Windows.SystemColors>， <xref:System.Windows.SystemFonts>，和<xref:System.Windows.SystemParameters>分别为静态属性类型。 若要使用<xref:System.Windows.Application.TryFindResource%2A>获取它们，这些类型还公开资源的键属性，旨在将传递给<xref:System.Windows.Application.TryFindResource%2A>; 例如， <xref:System.Windows.SystemParameters.IconWidthKey%2A>。  
  
 因为<xref:System.Windows.Application.TryFindResource%2A>返回一个对象，如果找到资源，你必须强制转换为适当的类型的返回的值。  
  
 此方法是线程安全的可以从任何线程调用。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Windows.Application.TryFindResource%2A>获取资源。  
  
 [!code-xaml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Windows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ Windows { System::Windows::WindowCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取应用程序中的实例化窗口。</summary>
        <value>一个 <see cref="T:System.Windows.WindowCollection" />，包含对当前 <see cref="T:System.AppDomain" /> 中的所有窗口对象的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Window>引用自动添加到<xref:System.Windows.Application.Windows%2A>上实例化一个窗口时，就会立即[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]线程; 创建辅助线程的线程不会添加的 windows。 A<xref:System.Windows.Window>后自动删除引用其<xref:System.Windows.Window.Closing>处理事件和之前其<xref:System.Windows.Window.Closed>引发事件。  
  
 默认情况下，第一项添加到<xref:System.Windows.Application.Windows%2A>属性变为<xref:System.Windows.Application.MainWindow%2A>。  
  
 此属性则仅可从创建的线程<xref:System.Windows.Application>对象。  
  
   
  
## Examples  
 下面的示例演示如何枚举<xref:System.Windows.Application.Windows%2A>属性生成一个顶级的 Windows 菜单，普遍适用于[!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)]应用程序如[!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)]，或多个实例单文档界面 (SDI) 应用程序，例如[!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)].  
  
 [!code-csharp[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xaml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
  </Members>
</Type>