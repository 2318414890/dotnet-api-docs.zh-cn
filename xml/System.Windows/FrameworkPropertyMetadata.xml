<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="50e37bc8286c8ba1961d7a1c298161a3c9e3100c" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37492926" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>为依赖属性报告或应用元数据（从而专门添加特定于框架的属性系统特征）。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此类派生自<xref:System.Windows.PropertyMetadata>(通过<xref:System.Windows.UIPropertyMetadata>)。 对于大多数 WPF 框架级别的应用程序开发目的<xref:System.Windows.FrameworkPropertyMetadata>是为依赖属性元数据，所使用的类型，而不是基元数据类型<xref:System.Windows.PropertyMetadata>或<xref:System.Windows.UIPropertyMetadata>。 这是对于现有依赖关系属性和大多数自定义依赖项属性的情况下，则返回 true。  
  
 此声明的成员类用于补充<xref:System.Windows.PropertyMetadata>基类包括各种指定或报表的属性继承、 数据绑定和布局如 WPF 框架级别的属性系统行为的布尔属性。  
  
 用于创建多个构造函数签名<xref:System.Windows.FrameworkPropertyMetadata>实例 take<xref:System.Windows.FrameworkPropertyMetadataOptions>参数。 <xref:System.Windows.FrameworkPropertyMetadataOptions>枚举仅用于在构造函数中指定初始行为，否则不公开后<xref:System.Windows.FrameworkPropertyMetadata>构造。 在构造实例中，可以获取或设置通过共享的名称的构造函数调用中使用的枚举值的各种属性的相应信息。  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>XAML 文本使用情况  
 此类通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下面的示例获取依赖属性元数据上的特定所有者为初始基本<xref:System.Windows.PropertyMetadata>类型。 元数据的强制转换为<xref:System.Windows.FrameworkPropertyMetadata>。 如果强制转换返回的有效<xref:System.Windows.FrameworkPropertyMetadata>，然后各种<xref:System.Windows.FrameworkPropertyMetadata>通过一个简单的 UI （未显示） 报告属性值。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此签名的所有值都初始化<xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A>为其属性的默认值。 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 将为`null`，并可使用多种<xref:System.Windows.FrameworkPropertyMetadata>布尔值属性将`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型的值提供。</param>
        <summary>使用指定的默认值初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于的依赖项属性的原始注册中指定的类型。 在编译期间不检测不匹配，是因为，则可能很难调试，元数据默认值类型的依赖属性应用于类型之间的不匹配。 属性系统不到运行时评估的属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>属性系统中具有特殊含义，不能用作依赖项属性默认值。  
  
   
  
## Examples  
 下面的示例调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <summary>用指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回调初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型的值提供。</param>
        <param name="flags">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。 这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</param>
        <summary>使用提供的默认值和框架级别的元数据选项初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于的依赖项属性的原始注册中指定的类型。 在编译期间不检测不匹配，是因为，则可能很难调试，元数据默认值类型的依赖属性应用于类型之间的不匹配。 属性系统不到运行时评估的属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>属性系统中具有特殊含义，不能用作依赖项属性默认值。  
  
 值标记为设置标志`flags`参数将设置的布尔值<xref:System.Windows.FrameworkPropertyMetadata>相匹配的属性<xref:System.Windows.FrameworkPropertyMetadataOptions>标志的名称为`true`。 只要元数据具有尚未应用到特定的属性系统操作，随后可以更改的元数据中的属性的值。  
  
   
  
## Examples  
 下面的示例调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型的值提供。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <summary>使用提供的默认值和指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回调初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于的依赖项属性的原始注册中指定的类型。 在编译期间不检测不匹配，是因为，则可能很难调试，元数据默认值类型的依赖属性应用于类型之间的不匹配。 属性系统不到运行时评估的属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>属性系统中具有特殊含义，不能用作依赖项属性默认值。  
  
   
  
## Examples  
 下面的示例调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <param name="coerceValueCallback">对处理程序实现的引用，每当属性系统调用此依赖项对象的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</param>
        <summary>用指定的回调初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现中调用基本初始值设定项，然后添加`coerceValueCallback`通过基实例上设置的属性。  
  
   
  
## Examples  
 下面的示例调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型的值提供。</param>
        <param name="flags">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。 这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <summary>使用提供的默认值和框架元数据选项及指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回调初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于的依赖项属性的原始注册中指定的类型。 在编译期间不检测不匹配，是因为，则可能很难调试，元数据默认值类型的依赖属性应用于类型之间的不匹配。 属性系统不到运行时评估的属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>属性系统中具有特殊含义，不能用作依赖项属性默认值。  
  
 值标记为设置标志`flags`参数将设置的布尔值<xref:System.Windows.FrameworkPropertyMetadata>相匹配的属性<xref:System.Windows.FrameworkPropertyMetadataOptions>标志的名称为`true`。 只要元数据具有尚未应用到特定的属性系统操作，你仍可以更改的元数据中的属性的值。  
  
   
  
## Examples  
 下面的示例调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型提供。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <param name="coerceValueCallback">对处理程序实现的引用，每当属性系统调用该依赖项对象的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</param>
        <summary>使用提供的默认值和指定的回调初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于的依赖项属性的原始注册中指定的类型。 在编译期间不检测不匹配，是因为，则可能很难调试，元数据默认值类型的依赖属性应用于类型之间的不匹配。 属性系统不到运行时评估的属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>属性系统中具有特殊含义，不能用作依赖项属性默认值。  
  
   
  
## Examples  
 下面的示例调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型提供。</param>
        <param name="flags">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。 这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <param name="coerceValueCallback">对处理程序实现的引用，每当属性系统调用该属性的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</param>
        <summary>使用提供的默认值和框架元数据选项及指定的回调初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于的依赖项属性的原始注册中指定的类型。 在编译期间不检测不匹配，是因为，则可能很难调试，元数据默认值类型的依赖属性应用于类型之间的不匹配。 属性系统不到运行时评估的属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>属性系统中具有特殊含义，不能用作依赖项属性默认值。  
  
 值标记为设置标志`flags`参数将设置的布尔值<xref:System.Windows.FrameworkPropertyMetadata>相匹配的属性<xref:System.Windows.FrameworkPropertyMetadataOptions>标志的名称为`true`。 只要元数据具有尚未应用到特定的属性系统操作，你仍可以更改的元数据中的属性的值。  
  
   
  
## Examples  
 下面的示例调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型提供。</param>
        <param name="flags">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。 这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <param name="coerceValueCallback">对处理程序实现的引用，每当属性系统调用该依赖项对象的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</param>
        <param name="isAnimationProhibited">若为 <see langword="true" />，则防止属性系统对要应用此元数据的属性进行动画处理。 如果尝试对此类属性进行动画处理，则它们会引发源自属性系统的运行时异常。 若为 <see langword="false" />，则允许对属性进行动画处理。 默认值为 <see langword="false" />。</param>
        <summary>使用提供的默认值和框架元数据选项、指定的回调及可以用来防止属性动画的布尔值初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于的依赖项属性的原始注册中指定的类型。 在编译期间不检测不匹配，是因为，则可能很难调试，元数据默认值类型的依赖属性应用于类型之间的不匹配。 属性系统不到运行时评估的属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>属性系统中具有特殊含义，不能用作依赖项属性默认值。  
  
 `isAnimationProhibited`参数设置的初始值<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>属性声明的直接基<xref:System.Windows.UIPropertyMetadata>类。  
  
 值标记为设置标志`flags`参数将设置的布尔值<xref:System.Windows.FrameworkPropertyMetadata>相匹配的属性<xref:System.Windows.FrameworkPropertyMetadataOptions>标志的名称为`true`。 只要元数据具有尚未应用到特定的属性系统操作，你仍可以更改的元数据中的属性的值。  
  
   
  
## Examples  
 下面的示例调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型提供。</param>
        <param name="flags">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。 这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <param name="coerceValueCallback">对处理程序实现的引用，每当属性系统调用该属性的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</param>
        <param name="isAnimationProhibited">若为 <see langword="true" />，则防止属性系统对要应用此元数据的属性进行动画处理。 如果尝试对此类属性进行动画处理，则它们会引发源自属性系统的运行时异常。 默认值为 <see langword="false" />。</param>
        <param name="defaultUpdateSourceTrigger">应用此属性的绑定时使用的 <see cref="T:System.Windows.Data.UpdateSourceTrigger" />，其 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 设置为 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</param>
        <summary>使用提供的默认值和框架元数据选项、指定的回调、可以用来防止属性动画的布尔值及数据绑定更新触发器默认值初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于的依赖项属性的原始注册中指定的类型。 在编译期间不检测不匹配，是因为，则可能很难调试，元数据默认值类型的依赖属性应用于类型之间的不匹配。 属性系统不到运行时评估的属性的有效值，因此默认值类型/属性类型不匹配的结果是运行时错误。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>属性系统中具有特殊含义，不能用作依赖项属性默认值。  
  
 `isAnimationProhibited`参数设置的初始值<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>属性声明的直接基<xref:System.Windows.UIPropertyMetadata>类。  
  
 有关绑定更新源行为的详细信息，请参阅[数据绑定概述](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
 值标记为设置标志`flags`参数将设置的布尔值<xref:System.Windows.FrameworkPropertyMetadata>相匹配的属性<xref:System.Windows.FrameworkPropertyMetadataOptions>标志的名称为`true`。 只要元数据具有尚未应用到特定的属性系统操作，你仍可以更改的元数据中的属性的值。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间的排列过程。</summary>
        <value>如果此元数据所在的依赖项对象可能会影响排列处理过程，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 并<xref:System.Windows.FrameworkContentElement>包括的实现<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>监视到元素存在的所有依赖项属性的有效值更改。 作为该逻辑的一部分，更改生效的依赖项属性值，并具有与元数据<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>设置为`true`将启动推迟的请求，以使该元素的可视内容无效 (调用<xref:System.Windows.UIElement.InvalidateArrange%2A>)。 因为此 WPF 框架级别实现已到位，您通常不需要查找依赖项属性与<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>除非要大量替换或修改的 WPF 框架级别的布局行为。  
  
 自定义<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>实现可以选择具有类似的行为依赖关系属性更改其中<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>是`true`。  
  
 在派生类的属性<xref:System.Windows.PropertyMetadata>通常定义为可读写的对象模型中。 这是实例的使它们可以调整后的初始化。 但是，作为调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的详细信息的属性现在被视为不可变。 尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发异常。  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>XAML 文本使用情况  
 此类的成员或者通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下面的示例从各种依赖项属性字段中获取的默认元数据、 查询的各种值<xref:System.Windows.FrameworkPropertyMetadata>属性，并使用这些信息来填充表，以实现"元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间的测量过程。</summary>
        <value>如果此元数据所在的依赖属性可能会影响测量过程，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 并<xref:System.Windows.FrameworkContentElement>包括的实现<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>监视到元素存在的所有依赖项属性的有效值更改。 作为该逻辑的一部分，更改生效的依赖项属性值，并具有与元数据<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>设置为`true`将启动推迟的请求，以使该元素的可视内容无效。 因为此 WPF 框架级别实现已到位，您通常不需要查找依赖项属性与<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>除非要大量替换或修改的 WPF 框架级别的布局行为。  
  
 自定义<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>实现可以选择具有类似的行为依赖关系属性更改其中<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>是`true`。  
  
 在派生类的属性<xref:System.Windows.PropertyMetadata>通常定义为可读写的对象模型中。 这是实例的使它们可以调整后的初始化。 但是，作为调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的详细信息的属性现在被视为不可变。 尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发异常。  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML 文本使用情况  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下面的示例从各种依赖项属性字段中获取的默认元数据、 查询的各种值<xref:System.Windows.FrameworkPropertyMetadata>属性，并使用这些信息来填充表，以实现"元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间父元素布局的排列处理过程。</summary>
        <value>如果此元数据所在的依赖项对象可能会影响特定于其父元素的排列处理过程，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 并<xref:System.Windows.FrameworkContentElement>包括的实现<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>监视到元素存在的所有依赖项属性的有效值更改。 作为该逻辑的一部分，更改生效的依赖项属性值，并具有与元数据<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>设置为`true`将启动一个延迟的请求，要使之无效的父元素的视觉对象。  
  
 通常情况下，您不需要的报告更改<xref:System.Windows.FrameworkElement>属性设置为父元素使用<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>因为元素本身可能已将其自己<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>作为`true`。 这是通常足够，因为子元素中的更改通常可以启动一个父级排列在适当的时候。 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 有时用于<xref:System.Windows.FrameworkContentElement>派生的类。 在此情况下，子元素设置了一个属性，但<xref:System.Windows.FrameworkContentElement>派生的类不会控制其自己的呈现。 由处理呈现<xref:System.Windows.FrameworkElement>用作内容宿主的父元素。 例如，对的值的更改<xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType>遭到一个子元素的附加的属性使排列的父级，因为必须更改子级的父代中的位置。 因此，<xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType>附加的属性包含的元数据位置<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>是`true`。 另一个示例是<xref:System.Windows.Controls.Control.Padding%2A>; 如果此属性的更改，父级可能会更改子，具体取决于可用空间的位置。  
  
 因为此 WPF 框架级别实现已到位，您通常不需要查找依赖项属性与<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>除非要大量替换或修改的 WPF 框架级别的布局行为。  
  
 自定义<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>实现可以选择具有类似的行为依赖关系属性更改其中<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>是`true`。  
  
 属性在任何派生类的<xref:System.Windows.PropertyMetadata>通常定义为可读写的对象模型中。 这是实例的使它们可以调整后的初始化。 但是，作为调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的详细信息的属性现在被视为不可变。 尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发异常。  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>XAML 文本使用情况  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间其父元素布局的测量过程。</summary>
        <value>如果此元数据所在的依赖属性可能会影响其父元素上的测量过程，则为 <see langword="true" />；否则为 <see langword="false" />。默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 并<xref:System.Windows.FrameworkContentElement>包括的实现<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>监视到元素存在的所有依赖项属性的有效值更改。 作为该逻辑的一部分，更改生效的依赖项属性值，并具有与元数据<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>设置为`true`将启动一个延迟的请求，要使之无效的父元素的视觉对象。 因为此 WPF 框架级别实现已到位，您通常不需要查找依赖项属性与<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>除非要大量替换或修改的 WPF 框架级别的布局行为。  
  
 通常情况下，您不需要的报告更改<xref:System.Windows.FrameworkElement>属性设置为父元素使用<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>因为元素本身可能已将其自己<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>作为`true`。 这是通常足够，因为子元素中的更改通常启动父度量值通过在适当的时候。 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 有时用于<xref:System.Windows.FrameworkContentElement>派生的类。 在此情况下，子元素设置了一个属性，但<xref:System.Windows.FrameworkContentElement>派生的类不会控制其自己的呈现。 由处理呈现<xref:System.Windows.FrameworkElement>用作内容宿主的父元素。 例如，对的值的更改<xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>遭到一个子元素的属性使无效的父度量值，因为段落的相对间隔可能会更改和可能会增加或减少内容宿主的大小。 因此，<xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>属性包含的元数据位置<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>是`true`。  
  
 内容宿主元素也经常查找依赖项属性中的更改其中<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>是`true`，内容主机呈现逻辑的一部分。 例如，<xref:System.Windows.Controls.TextBox>元素必须响应中发生的某些更改可能要求的文本的边界框<xref:System.Windows.Controls.TextBox>本身进行更改。  
  
 自定义<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>实现可以选择具有类似的行为依赖关系属性更改其中<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>是`true`。  
  
 属性在任何派生类的<xref:System.Windows.PropertyMetadata>通常定义为可读写的对象模型中。 这是实例的使它们可以调整后的初始化。 但是，作为调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的详细信息的属性现在被视为不可变。 尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发异常。  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML 文本使用情况  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示依赖属性是否会以某种方式（这种方式不会具体影响排列或测量，但将请求重绘）对常规布局造成潜在影响。</summary>
        <value>如果该元数据所在的依赖项对象会影响呈现，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 并<xref:System.Windows.FrameworkContentElement>包括的实现<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>监视到元素存在的所有依赖项属性的有效值更改。 作为该逻辑的一部分，更改生效的依赖项属性值，并具有与元数据<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>设置为`true`将启动推迟的请求，以使该元素的可视内容无效。 因为此 WPF 框架级别实现已到位，您通常不需要查找依赖项属性与<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>除非要大量替换或修改的 WPF 框架级别的布局行为。  
  
 自定义<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>实现可以选择具有类似的行为依赖关系属性更改其中<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>是`true`。  
  
 属性在任何派生类的<xref:System.Windows.PropertyMetadata>通常定义为可读写的对象模型中。 这是实例的使它们可以调整后的初始化。 但是，作为调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的详细信息的属性现在被视为不可变。 尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发异常。  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>XAML 文本使用情况  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下面的示例从各种依赖项属性字段中获取的默认元数据、 查询的各种值<xref:System.Windows.FrameworkPropertyMetadata>属性，并使用这些信息来填充表，以实现"元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示默认情况下属性是否双向绑定。</summary>
        <value>如果此元数据所在的依赖属性默认情况下为双向绑定，则为 <see langword="true" />，否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中不存在此属性所`true`，绑定更新都是单向的默认情况下，基于的默认行为<xref:System.Windows.Data.Binding>构造函数或等效身份[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]语法。  
  
 在现有元素，经常会发现此属性设置为`true`报告状态且是可修改的用户执行任何操作，例如依赖项属性的元数据中<xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>。  
  
 此属性只在一般情况下报告依赖项属性的默认绑定更新的特征。 本地设置的任何绑定到实例上此属性设置可以<xref:System.Windows.Data.Binding.Mode%2A>绑定的属性和更改此默认设置。  
  
 属性在任何派生类的<xref:System.Windows.PropertyMetadata>通常定义为可读写的对象模型中。 这是实例的使它们可以调整后的初始化。 但是，作为调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的详细信息的属性现在被视为不可变。 尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发异常。  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>XAML 文本使用情况  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下面的示例从各种依赖项属性字段中获取的默认元数据、 查询的各种值<xref:System.Windows.FrameworkPropertyMetadata>属性，并使用这些信息来填充表，以实现"元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在应用具有该元数据的属性的绑定时要使用的 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 的默认值，这些绑定的 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 设置为 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</summary>
        <value>除 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /> 以外的枚举值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在派生类的属性<xref:System.Windows.PropertyMetadata>通常定义为可读写的对象模型中。 这是实例的使它们可以调整后的初始化。 但是，作为调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的详细信息的属性现在被视为不可变。 尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发异常。  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>XAML 文本使用情况  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该属性设置为 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />；您设置的值应成为绑定请求时的默认值。</exception>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示依赖属性的值是否可继承。</summary>
        <value>如果属性值是可继承的，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性值继承是一项功能[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]WPF 框架级别，因此某些依赖项属性可以本地设置在达到或接近的根元素上的属性系统[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]元素树，然后让其通过继承的值此外没有该属性的子元素的逻辑树中的所有元素。 默认情况下，不启用属性值继承，并使其有一些性能影响。 有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
> [!NOTE]
>  虽然属性值继承看起来适用于非附加依赖项属性，但通过在运行时树中的某些对象部门的非附加属性的继承行为未定义。 始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>来注册您在其中指定的属性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>元数据中。  
  
 在派生类的属性<xref:System.Windows.PropertyMetadata>通常定义为可读写的对象模型中。 这是实例的使它们可以调整后的初始化。 但是，作为调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的详细信息的属性现在被视为不可变。 尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发异常。  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>XAML 文本使用情况  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下面的示例从各种依赖项属性字段中获取的默认元数据、 查询的各种值<xref:System.Windows.FrameworkPropertyMetadata>属性，并使用这些信息来填充表，以实现"元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示依赖属性是否支持数据绑定。</summary>
        <value>如果要应用该元数据的依赖项对象支持数据绑定，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性报告`false`两个可能的情况之一： 不允许任一数据绑定到依赖项属性，因为依赖项属性为只读 （作为中报告的依赖项属性标识符，不是元数据），或的值另一个元数据属性<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>，设置为`true`此元数据中。 此属性公开为方便起见，以便调用方不需要两项全选<xref:System.Windows.DependencyProperty.ReadOnly%2A>和<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>。  
  
 若要尝试创建指定其他的读/写属性应不支持数据绑定的元数据，指定标志<xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable>(请注意与细微的命名约定差别在于<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>)。  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>XAML 文本使用情况  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下面的示例从各种依赖项属性字段中获取的默认元数据、 查询的各种值<xref:System.Windows.FrameworkPropertyMetadata>属性，并使用这些信息来填充表，以实现"元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示依赖属性是否支持数据绑定。</summary>
        <value>如果属性不支持数据绑定，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请注意，此元数据属性设置为`true`专门针对不应支持数据绑定，尽管读写属性的属性。 预期结果是，在大多数情况下，依赖项属性的声明位置，需要数据绑定，因为数据绑定是依赖项属性是有用的重要方案之一。 与不同<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>，这不会只是更改默认值更高版本上的特定绑定已更改。 将此属性设置`true`依赖项属性的元数据中的元数据将禁用所有绑定将它们通过表达式的值应用到该依赖项属性。  
  
 只读依赖属性不支持数据绑定 （因为它们可以应用更改后的值没有 setter），但仍将报告`false`为<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>。 这是因为属性对应于<xref:System.Windows.FrameworkPropertyMetadataOptions>值将报告与如何元数据的实际创建，而不是始终报告的属性命名可能暗示的最终结果行为的奇偶校验。 若要确定给定的依赖属性是否允许将数据绑定，通常应检查<xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>相反。 <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> 它同时检查提供了便利<xref:System.Windows.DependencyProperty.ReadOnly%2A>和<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>作为单个操作，从而生成预期的结果。  
  
 在派生类的属性<xref:System.Windows.PropertyMetadata>通常定义为可读写的对象模型中。 这是实例的使它们可以调整后的初始化。 但是，作为调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的详细信息的属性现在被视为不可变。 尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发异常。  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>XAML 文本使用情况  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值表示该属性是否包含应用程序可以或应该作为日记功能实现的一部分而存储的日记信息。</summary>
        <value>
          <see langword="true" /> 如果应在此元数据应用于; 依赖属性上执行日记功能否则为<see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在派生类的属性<xref:System.Windows.PropertyMetadata>通常定义为可读写的对象模型中。 这是实例的使它们可以调整后的初始化。 但是，作为调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的详细信息的属性现在被视为不可变。 尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发异常。  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>XAML 文本使用情况  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">要合并的基本元数据。</param>
        <param name="dp">此元数据被应用到的依赖属性。</param>
        <summary>允许合并源元数据和基本元数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重写元数据时，将在内部使用此方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生的类<see cref="T:System.Windows.PropertyMetadata" />（或特别是此类） 应重写此方法要考虑的他们已在其实现中添加了任何元数据属性。例如，您的实现可能会添加一个新的按标志枚举值，和<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />实现应能够正确组合这些标志。始终调用您自己的实现之前, 的基实现，因为基实现负责合并已在以前在层次结构中的类型上定义的所有属性。添加的行为<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />中的实现<see cref="T:System.Windows.FrameworkPropertyMetadata" />在于特定 WPF 框架级别属性如元数据中<see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />组合中的按位或操作。<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />行为还实现行为时通过调用替代现有依赖属性上的属性元数据<see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />。，使用重写元数据的<see cref="T:System.Windows.FrameworkPropertyMetadata" />。</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">已应用了元数据的依赖项对象。</param>
        <param name="targetType">与此元数据关联的类型（如果这是特定于类型的元数据）。 如果这是默认的元数据，则此值可以为 <see langword="null" />。</param>
        <summary>当此元数据已经应用到一个属性时（这表明正在密封元数据）调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数据结构的任何可变性<xref:System.Windows.FrameworkPropertyMetadata>实例应标记为不可变调用此方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.FrameworkPropertyMetadata" />此方法的实现不执行任何操作超出调用基实现。</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示属性值继承计算是否应跨越元素逻辑树中的某些内容边界。</summary>
        <value>如果属性值继承应跨越某些内容边界，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此元数据在特殊的父元素的子元素边界报告对属性值继承行为的很少应用的修改。 此类边界的典型例子是的内容<xref:System.Windows.Controls.Frame>，其中<xref:System.Windows.Controls.Frame>内容可能会获得重新加载独立是否存在于<xref:System.Windows.Controls.Frame>。 所需的属性系统行为是属性值继承应遍历到的内容<xref:System.Windows.Controls.Frame>，因为这些内容可能会承载在框架的应用程序不拥有或控制的元素。 指定元数据时<xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A>设置为`true`，并将<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>作为`true`，将导致在其应用了元数据为可继承即使属性<xref:System.Windows.Controls.Frame>边界或类似的边界。  
  
 在派生类的属性<xref:System.Windows.PropertyMetadata>通常定义为可读写的对象模型中。 这是实例的使它们可以调整后的初始化。 但是，作为调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的详细信息的属性现在被视为不可变。 尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发异常。  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>XAML 文本使用情况  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示依赖属性的子属性是否影响包含对象的呈现。</summary>
        <value>如果更改后，对子属性值的更改不影响呈现，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此元数据选项是相关的是引用类型，其中该类型具有其自己的属性值的依赖项属性。 通常情况下，布局系统逻辑是认为与子属性的依赖关系属性可能会影响布局，因为检查所有子属性的更改非常耗时比实际运行另一个呈现处理。 此选项设置为`true`可用于优化性能的 WPF 框架级别的布局系统实现。  
  
 在派生类的属性<xref:System.Windows.PropertyMetadata>通常定义为可读写的对象模型中。 这是实例的使它们可以调整后的初始化。 但是，一旦调用的一部分使用元数据<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的详细信息的属性现在被视为不可变。 尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发异常。  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>XAML 文本使用情况  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>