<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3096061908923e7cf781983beaab620533614144" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36460249" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>为依赖属性报告或应用元数据（从而专门添加特定于框架的属性系统特征）。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此类派生自<xref:System.Windows.PropertyMetadata>(通过<xref:System.Windows.UIPropertyMetadata>)。 对于大多数 WPF 框架级别的应用程序开发目的，<xref:System.Windows.FrameworkPropertyMetadata>是用于依赖项属性的元数据的类型，而不是基本元数据类型<xref:System.Windows.PropertyMetadata>或<xref:System.Windows.UIPropertyMetadata>。 这是为现有依赖项属性和大多数自定义的依赖项属性的情况下，则返回 true。  
  
 此声明的成员类用于补充<xref:System.Windows.PropertyMetadata>基类包括各种指定或报告如属性继承、 数据绑定和布局的 WPF 框架级别属性系统行为的布尔属性。  
  
 用于创建多个构造函数签名<xref:System.Windows.FrameworkPropertyMetadata>实例 take<xref:System.Windows.FrameworkPropertyMetadataOptions>参数。 <xref:System.Windows.FrameworkPropertyMetadataOptions>枚举仅用于在构造函数中，指定初始的行为，否则不公开后<xref:System.Windows.FrameworkPropertyMetadata>构造。 在构造实例中，你可以获取或设置通过共享的名称的构造函数调用中使用的枚举值的各种属性的相应信息。  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 在不常使用此类[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下面的示例获取依赖属性元数据的特定所有者作为初始基<xref:System.Windows.PropertyMetadata>类型。 该元数据被强制转换为<xref:System.Windows.FrameworkPropertyMetadata>。 如果强制转换返回有效<xref:System.Windows.FrameworkPropertyMetadata>，然后各种<xref:System.Windows.FrameworkPropertyMetadata>通过 （未显示） 的简单 UI 报告的属性值。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此签名初始化的所有值<xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A>为属性默认值。 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> 将`null`，并可使用多种<xref:System.Windows.FrameworkPropertyMetadata>布尔属性将`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型的值提供。</param>
        <summary>使用指定的默认值初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。 在编译期间不能检测到不匹配，是因为，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。 属性系统不会运行时，直到计算的属性的有效值，因此默认值类型/属性类型不匹配的结果为运行时错误。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>在属性系统中具有特殊含义，并且不能用作依赖项属性默认值。  
  
   
  
## Examples  
 下面的示例调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <summary>用指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回调初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型的值提供。</param>
        <param name="flags">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。 这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</param>
        <summary>使用提供的默认值和框架级别的元数据选项初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。 在编译期间不能检测到不匹配，是因为，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。 属性系统不会运行时，直到计算的属性的有效值，因此默认值类型/属性类型不匹配的结果为运行时错误。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>在属性系统中具有特殊含义，并且不能用作依赖项属性默认值。  
  
 值标记为设置标志`flags`参数将设置的布尔值<xref:System.Windows.FrameworkPropertyMetadata>相匹配的属性<xref:System.Windows.FrameworkPropertyMetadataOptions>标志的名称与`true`。 只要元数据具有尚未应用到特定的属性系统操作，你随后可以更改的元数据中的属性的值。  
  
   
  
## Examples  
 下面的示例调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型的值提供。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <summary>使用提供的默认值和指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回调初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。 在编译期间不能检测到不匹配，是因为，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。 属性系统不会运行时，直到计算的属性的有效值，因此默认值类型/属性类型不匹配的结果为运行时错误。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>在属性系统中具有特殊含义，并且不能用作依赖项属性默认值。  
  
   
  
## Examples  
 下面的示例调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <param name="coerceValueCallback">对处理程序实现的引用，每当属性系统调用此依赖项对象的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</param>
        <summary>用指定的回调初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现中调用基初始值设定项，然后添加`coerceValueCallback`通过基实例上设置属性。  
  
   
  
## Examples  
 下面的示例调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型的值提供。</param>
        <param name="flags">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。 这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <summary>使用提供的默认值和框架元数据选项及指定的 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 回调初始化 <see cref="T:System.Windows.PropertyChangedCallback" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。 在编译期间不能检测到不匹配，是因为，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。 属性系统不会运行时，直到计算的属性的有效值，因此默认值类型/属性类型不匹配的结果为运行时错误。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>在属性系统中具有特殊含义，并且不能用作依赖项属性默认值。  
  
 值标记为设置标志`flags`参数将设置的布尔值<xref:System.Windows.FrameworkPropertyMetadata>相匹配的属性<xref:System.Windows.FrameworkPropertyMetadataOptions>标志的名称与`true`。 只要元数据具有尚未应用到特定的属性系统操作，你仍可更改的元数据中的属性的值。  
  
   
  
## Examples  
 下面的示例调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型提供。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <param name="coerceValueCallback">对处理程序实现的引用，每当属性系统调用该依赖项对象的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</param>
        <summary>使用提供的默认值和指定的回调初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。 在编译期间不能检测到不匹配，是因为，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。 属性系统不会运行时，直到计算的属性的有效值，因此默认值类型/属性类型不匹配的结果为运行时错误。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>在属性系统中具有特殊含义，并且不能用作依赖项属性默认值。  
  
   
  
## Examples  
 下面的示例调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型提供。</param>
        <param name="flags">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。 这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <param name="coerceValueCallback">对处理程序实现的引用，每当属性系统调用该属性的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</param>
        <summary>使用提供的默认值和框架元数据选项及指定的回调初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。 在编译期间不能检测到不匹配，是因为，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。 属性系统不会运行时，直到计算的属性的有效值，因此默认值类型/属性类型不匹配的结果为运行时错误。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>在属性系统中具有特殊含义，并且不能用作依赖项属性默认值。  
  
 值标记为设置标志`flags`参数将设置的布尔值<xref:System.Windows.FrameworkPropertyMetadata>相匹配的属性<xref:System.Windows.FrameworkPropertyMetadataOptions>标志的名称与`true`。 只要元数据具有尚未应用到特定的属性系统操作，你仍可更改的元数据中的属性的值。  
  
   
  
## Examples  
 下面的示例调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型提供。</param>
        <param name="flags">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。 这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <param name="coerceValueCallback">对处理程序实现的引用，每当属性系统调用该依赖项对象的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</param>
        <param name="isAnimationProhibited">若为 <see langword="true" />，则防止属性系统对要应用此元数据的属性进行动画处理。 如果尝试对此类属性进行动画处理，则它们会引发源自属性系统的运行时异常。 若为 <see langword="false" />，则允许对属性进行动画处理。 默认值为 <see langword="false" />。</param>
        <summary>使用提供的默认值和框架元数据选项、指定的回调及可以用来防止属性动画的布尔值初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。 在编译期间不能检测到不匹配，是因为，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。 属性系统不会运行时，直到计算的属性的有效值，因此默认值类型/属性类型不匹配的结果为运行时错误。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>在属性系统中具有特殊含义，并且不能用作依赖项属性默认值。  
  
 `isAnimationProhibited`参数设置的初始值<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>属性声明由即时基类<xref:System.Windows.UIPropertyMetadata>类。  
  
 值标记为设置标志`flags`参数将设置的布尔值<xref:System.Windows.FrameworkPropertyMetadata>相匹配的属性<xref:System.Windows.FrameworkPropertyMetadataOptions>标志的名称与`true`。 只要元数据具有尚未应用到特定的属性系统操作，你仍可更改的元数据中的属性的值。  
  
   
  
## Examples  
 下面的示例调用此构造函数签名：  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依赖项属性的默认值，通常作为特定类型提供。</param>
        <param name="flags">元数据选项标志（<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 值的组合）。 这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</param>
        <param name="propertyChangedCallback">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</param>
        <param name="coerceValueCallback">对处理程序实现的引用，每当属性系统调用该属性的 <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> 时，都会调用此处理程序实现。</param>
        <param name="isAnimationProhibited">若为 <see langword="true" />，则防止属性系统对要应用此元数据的属性进行动画处理。 如果尝试对此类属性进行动画处理，则它们会引发源自属性系统的运行时异常。 默认值为 <see langword="false" />。</param>
        <param name="defaultUpdateSourceTrigger">应用此属性的绑定时使用的 <see cref="T:System.Windows.Data.UpdateSourceTrigger" />，其 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 设置为 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</param>
        <summary>使用提供的默认值和框架元数据选项、指定的回调、可以用来防止属性动画的布尔值及数据绑定更新触发器默认值初始化 <see cref="T:System.Windows.FrameworkPropertyMetadata" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 为提供的值的类型`defaultValue`必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。 在编译期间不能检测到不匹配，是因为，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。 属性系统不会运行时，直到计算的属性的有效值，因此默认值类型/属性类型不匹配的结果为运行时错误。  
  
 值<xref:System.Windows.DependencyProperty.UnsetValue>在属性系统中具有特殊含义，并且不能用作依赖项属性默认值。  
  
 `isAnimationProhibited`参数设置的初始值<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>属性声明由即时基类<xref:System.Windows.UIPropertyMetadata>类。  
  
 有关绑定的更新源行为的详细信息，请参阅[数据绑定概述](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
 值标记为设置标志`flags`参数将设置的布尔值<xref:System.Windows.FrameworkPropertyMetadata>相匹配的属性<xref:System.Windows.FrameworkPropertyMetadataOptions>标志的名称与`true`。 只要元数据具有尚未应用到特定的属性系统操作，你仍可更改的元数据中的属性的值。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">将 <paramref name="defaultValue" /> 设置为 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间的排列过程。</summary>
        <value>如果此元数据所在的依赖项对象可能会影响排列处理过程，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 和<xref:System.Windows.FrameworkContentElement>包括的实现<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>监视对元素存在的所有依赖项属性的有效值更改。 作为该逻辑的一部分，更改有效值的依赖项属性值，并且具有与元数据<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>设置为`true`将启动推迟的请求，以使该元素的可视内容无效 (调用<xref:System.Windows.UIElement.InvalidateArrange%2A>)。 因为此 WPF 框架级别实现已就位，你通常不需要的依赖项属性与看起来<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>除非大体上为你要替换或修改的 WPF 框架级别布局行为。  
  
 自定义<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>实现可以选择具有类似的行为更改依赖项属性的其中<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>是`true`。  
  
 在派生类的属性<xref:System.Windows.PropertyMetadata>通常定义为读写模式的对象模型中。 这是以便可以在实例初始化后对它们进行调整。 但是，作为对的调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。 正在尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发的异常。  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不是使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下面的示例从各种依赖项属性字段中获取的默认元数据，查询的各种值<xref:System.Windows.FrameworkPropertyMetadata>属性，并使用这些信息来填充表，以实现"元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间的测量过程。</summary>
        <value>如果此元数据所在的依赖属性可能会影响测量过程，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 和<xref:System.Windows.FrameworkContentElement>包括的实现<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>监视对元素存在的所有依赖项属性的有效值更改。 作为该逻辑的一部分，更改有效值的依赖项属性值，并且具有与元数据<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>设置为`true`将启动推迟的请求，以使该元素的可视内容无效。 因为此 WPF 框架级别实现已就位，你通常不需要的依赖项属性与看起来<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>除非大体上为你要替换或修改的 WPF 框架级别布局行为。  
  
 自定义<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>实现可以选择具有类似的行为更改依赖项属性的其中<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>是`true`。  
  
 在派生类的属性<xref:System.Windows.PropertyMetadata>通常定义为读写模式的对象模型中。 这是以便可以在实例初始化后对它们进行调整。 但是，作为对的调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。 正在尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发的异常。  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下面的示例从各种依赖项属性字段中获取的默认元数据，查询的各种值<xref:System.Windows.FrameworkPropertyMetadata>属性，并使用这些信息来填充表，以实现"元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间父元素布局的排列处理过程。</summary>
        <value>如果此元数据所在的依赖项对象可能会影响特定于其父元素的排列处理过程，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 和<xref:System.Windows.FrameworkContentElement>包括的实现<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>监视对元素存在的所有依赖项属性的有效值更改。 作为该逻辑的一部分，更改有效值的依赖项属性值，并且具有与元数据<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>设置为`true`将启动推迟的请求，以使其无效的父元素的视觉对象。  
  
 通常情况下，你不需要的报告更改<xref:System.Windows.FrameworkElement>属性设置为父元素使用<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>因为元素本身可能已将其自己<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>作为`true`。 这是通常足够，因为子元素中的更改通常启动父排列在适当的时候。 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> 有时用于<xref:System.Windows.FrameworkContentElement>派生类。 在此情况下，子元素设置了一个属性，但一个<xref:System.Windows.FrameworkContentElement>派生的类不控制其自己的呈现。 呈现由<xref:System.Windows.FrameworkElement>用作内容主机的父元素。 例如，对的值的更改才<xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType>遭到一个子元素的附加的属性失效排列的父级，因为必须更改该子级的父代中的位置。 因此，<xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType>附加的属性具有元数据位置<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>是`true`。 另一个示例是<xref:System.Windows.Controls.Control.Padding%2A>; 如果此属性更改，父可能会更改的子级，具体取决于可用空间的位置。  
  
 因为此 WPF 框架级别实现已就位，你通常不需要的依赖项属性与看起来<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>除非大体上为你要替换或修改的 WPF 框架级别布局行为。  
  
 自定义<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>实现可以选择具有类似的行为更改依赖项属性的其中<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>是`true`。  
  
 属性对任何派生类的<xref:System.Windows.PropertyMetadata>通常定义为读写模式的对象模型中。 这是以便可以在实例初始化后对它们进行调整。 但是，作为对的调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。 正在尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发的异常。  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间其父元素布局的测量过程。</summary>
        <value>如果此元数据所在的依赖属性可能会影响其父元素上的测量过程，则为 <see langword="true" />；否则为 <see langword="false" />。默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 和<xref:System.Windows.FrameworkContentElement>包括的实现<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>监视对元素存在的所有依赖项属性的有效值更改。 作为该逻辑的一部分，更改有效值的依赖项属性值，并且具有与元数据<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>设置为`true`将启动推迟的请求，以使其无效的父元素的视觉对象。 因为此 WPF 框架级别实现已就位，你通常不需要的依赖项属性与看起来<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>除非大体上为你要替换或修改的 WPF 框架级别布局行为。  
  
 通常情况下，你不需要的报告更改<xref:System.Windows.FrameworkElement>属性设置为父元素使用<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>因为元素本身可能已将其自己<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>作为`true`。 这是通常足够，因为子元素中的更改通常启动父测量过程在适当的时候。 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 有时用于<xref:System.Windows.FrameworkContentElement>派生类。 在此情况下，子元素设置了一个属性，但一个<xref:System.Windows.FrameworkContentElement>派生的类不控制其自己的呈现。 呈现由<xref:System.Windows.FrameworkElement>用作内容主机的父元素。 例如，对的值的更改才<xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>遭到一个子元素的属性使无效的父代、 度量值，因为段落的相对间距可能更改和可能增加或减少内容宿主的大小。 因此，<xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>属性具有元数据位置<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>是`true`。  
  
 依赖项属性中的更改还会频繁查找内容主机元素其中<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>是`true`，作为内容主机呈现逻辑的一部分。 例如，<xref:System.Windows.Controls.TextBox>元素必须响应的某些更改可能要求的文本内的边界框<xref:System.Windows.Controls.TextBox>本身进行更改。  
  
 自定义<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>实现可以选择具有类似的行为更改依赖项属性的其中<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>是`true`。  
  
 属性对任何派生类的<xref:System.Windows.PropertyMetadata>通常定义为读写模式的对象模型中。 这是以便可以在实例初始化后对它们进行调整。 但是，作为对的调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。 正在尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发的异常。  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示依赖属性是否会以某种方式（这种方式不会具体影响排列或测量，但将请求重绘）对常规布局造成潜在影响。</summary>
        <value>如果该元数据所在的依赖项对象会影响呈现，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> 和<xref:System.Windows.FrameworkContentElement>包括的实现<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>监视对元素存在的所有依赖项属性的有效值更改。 作为该逻辑的一部分，更改有效值的依赖项属性值，并且具有与元数据<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>设置为`true`将启动推迟的请求，以使该元素的可视内容无效。 因为此 WPF 框架级别实现已就位，你通常不需要的依赖项属性与看起来<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>除非大体上为你要替换或修改的 WPF 框架级别布局行为。  
  
 自定义<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>实现可以选择具有类似的行为更改依赖项属性的其中<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>是`true`。  
  
 属性对任何派生类的<xref:System.Windows.PropertyMetadata>通常定义为读写模式的对象模型中。 这是以便可以在实例初始化后对它们进行调整。 但是，作为对的调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。 正在尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发的异常。  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下面的示例从各种依赖项属性字段中获取的默认元数据，查询的各种值<xref:System.Windows.FrameworkPropertyMetadata>属性，并使用这些信息来填充表，以实现"元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示默认情况下属性是否双向绑定。</summary>
        <value>如果此元数据所在的依赖属性默认情况下为双向绑定，则为 <see langword="true" />，否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在没有为此属性的情况下`true`，为默认情况下，基于的默认行为单向信任关系绑定更新<xref:System.Windows.Data.Binding>构造函数或同等[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]语法。  
  
 在现有元素中，您通常会发现此属性设置为`true`报告状态且是可修改的用户操作，例如依赖项属性的元数据中<xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>。  
  
 此属性通常只报告依赖项属性的默认绑定更新特征。 任何绑定设置为实例上此属性可以本地设置<xref:System.Windows.Data.Binding.Mode%2A>绑定属性和更改此默认设置。  
  
 属性对任何派生类的<xref:System.Windows.PropertyMetadata>通常定义为读写模式的对象模型中。 这是以便可以在实例初始化后对它们进行调整。 但是，作为对的调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。 正在尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发的异常。  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下面的示例从各种依赖项属性字段中获取的默认元数据，查询的各种值<xref:System.Windows.FrameworkPropertyMetadata>属性，并使用这些信息来填充表，以实现"元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在应用具有该元数据的属性的绑定时要使用的 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 的默认值，这些绑定的 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 设置为 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</summary>
        <value>除 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /> 以外的枚举值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在派生类的属性<xref:System.Windows.PropertyMetadata>通常定义为读写模式的对象模型中。 这是以便可以在实例初始化后对它们进行调整。 但是，作为对的调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。 正在尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发的异常。  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">该属性设置为 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />；您设置的值应成为绑定请求时的默认值。</exception>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示依赖属性的值是否可继承。</summary>
        <value>如果属性值是可继承的，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性值继承是一项功能的[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]在 WPF 框架级别，凭此某些依赖项属性可以是本地一个元素设置处或附近的根的属性系统[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]元素树，然后将它们由继承的值此外拥有该属性的子元素的逻辑树中的所有元素。 默认情况下，未启用属性值继承和启用它确实有一些性能影响。 有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
> [!NOTE]
>  虽然可能会出现属性值继承，使其适用于非附加依赖项属性，但通过在运行时树中某些对象对象部门的附加属性的继承行为不确定。 始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>注册你在其中指定的属性<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>的元数据中。  
  
 在派生类的属性<xref:System.Windows.PropertyMetadata>通常定义为读写模式的对象模型中。 这是以便可以在实例初始化后对它们进行调整。 但是，作为对的调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。 正在尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发的异常。  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下面的示例从各种依赖项属性字段中获取的默认元数据，查询的各种值<xref:System.Windows.FrameworkPropertyMetadata>属性，并使用这些信息来填充表，以实现"元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示依赖属性是否支持数据绑定。</summary>
        <value>如果要应用该元数据的依赖项对象支持数据绑定，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性报告`false`两个可能的条件之一： 不能使用任一数据绑定到依赖项属性，因为依赖项属性 （作为中报告的依赖项属性标识符，不是元数据），以只读的或的值另一个元数据属性， <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>，设置为`true`此元数据中。 此属性公开为方便起见，以便调用方不需要同时检查<xref:System.Windows.DependencyProperty.ReadOnly%2A>和<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>。  
  
 如果你尝试创建指定否则为的读/写属性不应支持数据绑定的元数据，请指定标志<xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable>(请注意与细微的命名约定差别在于<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>)。  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
   
  
## Examples  
 下面的示例从各种依赖项属性字段中获取的默认元数据，查询的各种值<xref:System.Windows.FrameworkPropertyMetadata>属性，并使用这些信息来填充表，以实现"元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示依赖属性是否支持数据绑定。</summary>
        <value>如果属性不支持数据绑定，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请注意，此元数据属性设置为`true`专用于不应支持数据绑定，尽管要读写属性的属性。 应当是，在大多数情况下，依赖项属性的声明位置，则需要数据绑定，因为数据绑定是依赖项属性是有用的重要方案之一。 与不同<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>，这不会只是更改更高版本可以更改特定绑定的默认值。 将此属性设置`true`元数据将依赖项属性的元数据中禁用应用到该依赖项属性的表达式通过其值的所有绑定。  
  
 只读依赖属性不支持数据绑定 （因为它们具有可以应用更改后的值没有 setter），但是仍然会报告`false`为<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>。 这是因为属性，对应于<xref:System.Windows.FrameworkPropertyMetadataOptions>值将报告与如何元数据的实际创建，而不是始终 reporting 命名的属性可能暗示的最终结果行为的奇偶校验。 若要确定给定的依赖属性是否允许数据绑定，应经常检查<xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>相反。 <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> 是一种便于同时检查<xref:System.Windows.DependencyProperty.ReadOnly%2A>和<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>作为单个操作，以生成预期的结果。  
  
 在派生类的属性<xref:System.Windows.PropertyMetadata>通常定义为读写模式的对象模型中。 这是以便可以在实例初始化后对它们进行调整。 但是，作为对的调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。 正在尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发的异常。  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值表示该属性是否包含应用程序可以或应该作为日记功能实现的一部分而存储的日记信息。</summary>
        <value>
          <see langword="true" /> 如果应在此元数据应用于; 的依赖项属性执行日记记录否则为<see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在派生类的属性<xref:System.Windows.PropertyMetadata>通常定义为读写模式的对象模型中。 这是以便可以在实例初始化后对它们进行调整。 但是，作为对的调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。 正在尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发的异常。  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit&#xA;override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">要合并的基本元数据。</param>
        <param name="dp">此元数据被应用到的依赖属性。</param>
        <summary>允许合并源元数据和基本元数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重写元数据时在内部使用此方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>派生自的类<see cref="T:System.Windows.PropertyMetadata" />（或特别是此类） 应重写此方法，以考虑它们在其实现中添加任何元数据属性。例如，您的实现可能会添加新的标志枚举值，与<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />实现应该能够正确组合这些标志。始终调用您自己的实现之前, 的基实现，因为基实现负责合并已在以前层次结构中的类型上定义的所有属性。通过添加行为<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />中的实现<see cref="T:System.Windows.FrameworkPropertyMetadata" />在于特定 WPF 框架级别属性中的元数据，如<see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />中按位组合或操作。<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />行为还实现行为，通过调用重写现有依赖项属性的属性元数据时<see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />。，使用重写元数据，即<see cref="T:System.Windows.FrameworkPropertyMetadata" />。</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="abstract member OnApply : System.Windows.DependencyProperty * Type -&gt; unit&#xA;override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">已应用了元数据的依赖项对象。</param>
        <param name="targetType">与此元数据关联的类型（如果这是特定于类型的元数据）。 如果这是默认的元数据，则此值可以为 <see langword="null" />。</param>
        <summary>当此元数据已经应用到一个属性时（这表明正在密封元数据）调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数据结构的任何可变性<xref:System.Windows.FrameworkPropertyMetadata>实例应标记为不可变时调用此方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.FrameworkPropertyMetadata" />此方法实现不执行任何操作超出调用基实现。</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示属性值继承计算是否应跨越元素逻辑树中的某些内容边界。</summary>
        <value>如果属性值继承应跨越某些内容边界，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此元数据跨特殊的父元素子级元素边界报告属性值继承行为的很少应用修改。 此类边界的典型示例是内容<xref:System.Windows.Controls.Frame>，其中<xref:System.Windows.Controls.Frame>可能获取内容重新加载独立是否存在于<xref:System.Windows.Controls.Frame>。 所需的属性系统行为是属性值继承应遍历到的内容<xref:System.Windows.Controls.Frame>，因为这些内容可能是托管帧的应用程序并不拥有或控制的元素。 指定元数据与<xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A>设置为`true`，并指定以及为<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>作为`true`，将导致在其应用了元数据要甚至跨可继承的属性<xref:System.Windows.Controls.Frame>边界或类似的边界。  
  
 在派生类的属性<xref:System.Windows.PropertyMetadata>通常定义为读写模式的对象模型中。 这是以便可以在实例初始化后对它们进行调整。 但是，作为对的调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。 正在尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发的异常。  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示依赖属性的子属性是否影响包含对象的呈现。</summary>
        <value>如果更改后，对子属性值的更改不影响呈现，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此元数据选项是相关的是引用类型，其中该类型具有自己的属性值的依赖项属性。 通常情况下，布局系统逻辑是假定具有子属性的任何依赖属性可能将影响布局，因为检查所有子属性的更改是花费更多时间比实际运行另一个呈现处理。 将此选项设置为`true`可用于优化的 WPF 框架级别布局系统实现的性能。  
  
 在派生类的属性<xref:System.Windows.PropertyMetadata>通常定义为读写模式的对象模型中。 这是以便可以在实例初始化后对它们进行调整。 但是，作为对的调用的一部分使用元数据后<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。 正在尝试设置此属性后的<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`对此元数据实例将引发的异常。  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>XAML 文本用法  
 此类的成员通常不使用在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>