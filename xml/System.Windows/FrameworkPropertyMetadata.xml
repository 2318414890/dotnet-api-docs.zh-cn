<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FrameworkPropertyMetadata.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c70304d7b52b8f4e76c37fd1e35de0928f9619c7.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c70304d7b52b8f4e76c37fd1e35de0928f9619c7</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>Reports or applies metadata for a dependency property, specifically adding framework-specific property system characteristics.</source>
          <target state="translated">为依赖属性报告或应用元数据（从而专门添加特定于框架的属性系统特征）。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>This class derives from <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> (through <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph>) .</source>
          <target state="translated">此类派生自<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>(通过<ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>For most WPF framework-level application development purposes, <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> is the type used for dependency property metadata, rather than the base metadata types <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph>.</source>
          <target state="translated">对于大多数 WPF 框架级别的应用程序开发目的，<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>是用于依赖项属性的元数据的类型，而不是基本元数据类型<ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>或<ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>This is true both for existing dependency properties and for most custom dependency property scenarios.</source>
          <target state="translated">这是为现有依赖项属性和大多数自定义的依赖项属性的情况下，则返回 true。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>The members declared by this class that supplement the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> base class include various Boolean properties that specify or report WPF framework-level property system behavior such as property inheritance, data binding, and layout.</source>
          <target state="translated">此声明的成员类用于补充<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>基类包括各种指定或报告如属性继承、 数据绑定和布局的 WPF 框架级别属性系统行为的布尔属性。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>Several constructor signatures for creating a <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> instance take a <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> parameter.</source>
          <target state="translated">用于创建多个构造函数签名<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>实例 take<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph>参数。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> enumeration is used only to specify initial behavior in the constructor, and is not otherwise exposed after <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> is constructed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph>枚举仅用于在构造函数中，指定初始的行为，否则不公开后<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>构造。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>From a constructed instance, you can get or set the corresponding information through various properties that share the name of the enumeration values used in the constructor call.</source>
          <target state="translated">在构造实例中，你可以获取或设置通过共享的名称的构造函数调用中使用的枚举值的各种属性的相应信息。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>XAML Text Usage</source>
          <target state="translated">XAML 文本用法</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>This class is not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">在不常使用此类<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>The following example gets metadata for a dependency property on a particular owner as the initial base <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> type.</source>
          <target state="translated">下面的示例获取依赖属性元数据的特定所有者作为初始基<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>类型。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>That metadata is cast to <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>.</source>
          <target state="translated">该元数据被强制转换为<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>If the cast returned a valid <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>, then various <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> property values are reported through a simple UI (not shown).</source>
          <target state="translated">如果强制转换返回有效<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>，然后各种<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>通过 （未显示） 的简单 UI 报告的属性值。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor">
          <source>This signature initializes all values of <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A&gt;</ph> to their property defaults.</source>
          <target state="translated">此签名初始化的所有值<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A&gt;</ph>为属性默认值。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor">
          <source><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> will be <ph id="ph2">`null`</ph>, and the various <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> Boolean properties will be <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> 将<ph id="ph2">`null`</ph>，并可使用多种<ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>布尔属性将<ph id="ph4">`false`</ph>。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The default value of the dependency property, usually provided as a value of a specific type.</source>
          <target state="translated">依赖项属性的默认值，通常作为特定类型的值提供。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the specified default value.</source>
          <target state="translated">使用指定的默认值初始化 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">为提供的值的类型<ph id="ph1">`defaultValue`</ph>必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">在编译期间不能检测到不匹配，是因为，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">属性系统不会运行时，直到计算的属性的有效值，因此默认值类型/属性类型不匹配的结果为运行时错误。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">值<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph>在属性系统中具有特殊含义，并且不能用作依赖项属性默认值。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">下面的示例调用此构造函数签名：</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">将 <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> 设置为 <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the specified <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> callback.</source>
          <target state="translated">用指定的 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> 回调初始化 <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">下面的示例调用此构造函数签名：</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The default value of the dependency property, usually provided as a value of a specific type.</source>
          <target state="translated">依赖项属性的默认值，通常作为特定类型的值提供。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">元数据选项标志（<ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> 值的组合）。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework-level metadata options.</source>
          <target state="translated">使用提供的默认值和框架级别的元数据选项初始化 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">为提供的值的类型<ph id="ph1">`defaultValue`</ph>必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">在编译期间不能检测到不匹配，是因为，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">属性系统不会运行时，直到计算的属性的有效值，因此默认值类型/属性类型不匹配的结果为运行时错误。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">值<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph>在属性系统中具有特殊含义，并且不能用作依赖项属性默认值。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">值标记为设置标志<ph id="ph1">`flags`</ph>参数将设置的布尔值<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>相匹配的属性<ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph>标志的名称与<ph id="ph4">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>You can subsequently change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">只要元数据具有尚未应用到特定的属性系统操作，你随后可以更改的元数据中的属性的值。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">下面的示例调用此构造函数签名：</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">将 <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> 设置为 <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The default value of the dependency property, usually provided as a value of a specific type.</source>
          <target state="translated">依赖项属性的默认值，通常作为特定类型的值提供。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and specified <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> callback.</source>
          <target state="translated">使用提供的默认值和指定的 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> 回调初始化 <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">为提供的值的类型<ph id="ph1">`defaultValue`</ph>必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">在编译期间不能检测到不匹配，是因为，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">属性系统不会运行时，直到计算的属性的有效值，因此默认值类型/属性类型不匹配的结果为运行时错误。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">值<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph>在属性系统中具有特殊含义，并且不能用作依赖项属性默认值。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">下面的示例调用此构造函数签名：</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">将 <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> 设置为 <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> for this dependency property.</source>
          <target state="translated">对处理程序实现的引用，每当属性系统调用此依赖项对象的 <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> 时，都会调用此处理程序实现。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the specified callbacks.</source>
          <target state="translated">用指定的回调初始化 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>This implementation calls a base initializer and then adds the <ph id="ph1">`coerceValueCallback`</ph> by setting the property on the base instance.</source>
          <target state="translated">此实现中调用基初始值设定项，然后添加<ph id="ph1">`coerceValueCallback`</ph>通过基实例上设置属性。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">下面的示例调用此构造函数签名：</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The default value of the dependency property, usually provided as a value of a specific type.</source>
          <target state="translated">依赖项属性的默认值，通常作为特定类型的值提供。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">元数据选项标志（<ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> 值的组合）。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework metadata options, and specified <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> callback.</source>
          <target state="translated">使用提供的默认值和框架元数据选项及指定的 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> 回调初始化 <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">为提供的值的类型<ph id="ph1">`defaultValue`</ph>必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">在编译期间不能检测到不匹配，是因为，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">属性系统不会运行时，直到计算的属性的有效值，因此默认值类型/属性类型不匹配的结果为运行时错误。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">值<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph>在属性系统中具有特殊含义，并且不能用作依赖项属性默认值。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">值标记为设置标志<ph id="ph1">`flags`</ph>参数将设置的布尔值<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>相匹配的属性<ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph>标志的名称与<ph id="ph4">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">只要元数据具有尚未应用到特定的属性系统操作，你仍可更改的元数据中的属性的值。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">下面的示例调用此构造函数签名：</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">将 <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> 设置为 <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The default value of the dependency property, usually provided as a specific type.</source>
          <target state="translated">依赖项属性的默认值，通常作为特定类型提供。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> for this dependency property.</source>
          <target state="translated">对处理程序实现的引用，每当属性系统调用该依赖项对象的 <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> 时，都会调用此处理程序实现。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and specified callbacks.</source>
          <target state="translated">使用提供的默认值和指定的回调初始化 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">为提供的值的类型<ph id="ph1">`defaultValue`</ph>必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">在编译期间不能检测到不匹配，是因为，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">属性系统不会运行时，直到计算的属性的有效值，因此默认值类型/属性类型不匹配的结果为运行时错误。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">值<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph>在属性系统中具有特殊含义，并且不能用作依赖项属性默认值。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">下面的示例调用此构造函数签名：</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">将 <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> 设置为 <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The default value of the dependency property, usually provided as a specific type.</source>
          <target state="translated">依赖项属性的默认值，通常作为特定类型提供。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">元数据选项标志（<ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> 值的组合）。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> against this property.</source>
          <target state="translated">对处理程序实现的引用，每当属性系统调用该属性的 <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> 时，都会调用此处理程序实现。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework metadata options, and specified callbacks.</source>
          <target state="translated">使用提供的默认值和框架元数据选项及指定的回调初始化 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">为提供的值的类型<ph id="ph1">`defaultValue`</ph>必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">在编译期间不能检测到不匹配，是因为，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">属性系统不会运行时，直到计算的属性的有效值，因此默认值类型/属性类型不匹配的结果为运行时错误。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">值<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph>在属性系统中具有特殊含义，并且不能用作依赖项属性默认值。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">值标记为设置标志<ph id="ph1">`flags`</ph>参数将设置的布尔值<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>相匹配的属性<ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph>标志的名称与<ph id="ph4">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">只要元数据具有尚未应用到特定的属性系统操作，你仍可更改的元数据中的属性的值。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">下面的示例调用此构造函数签名：</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">将 <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> 设置为 <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The default value of the dependency property, usually provided as a specific type.</source>
          <target state="translated">依赖项属性的默认值，通常作为特定类型提供。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">元数据选项标志（<ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> 值的组合）。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>A reference to a handler implementation that will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> on this dependency property.</source>
          <target state="translated">对处理程序实现的引用，每当属性系统调用该依赖项对象的 <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> 时，都会调用此处理程序实现。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to prevent the property system from animating the property that this metadata is applied to.</source>
          <target state="translated">若为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，则防止属性系统对要应用此元数据的属性进行动画处理。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>Such properties will raise a run-time exception originating from the property system if animations of them are attempted.</source>
          <target state="translated">如果尝试对此类属性进行动画处理，则它们会引发源自属性系统的运行时异常。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to permit animating the property.</source>
          <target state="translated">若为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>，则允许对属性进行动画处理。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework metadata options, specified callbacks, and a Boolean that can be used to prevent animation of the property.</source>
          <target state="translated">使用提供的默认值和框架元数据选项、指定的回调及可以用来防止属性动画的布尔值初始化 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">为提供的值的类型<ph id="ph1">`defaultValue`</ph>必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">在编译期间不能检测到不匹配，是因为，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">属性系统不会运行时，直到计算的属性的有效值，因此默认值类型/属性类型不匹配的结果为运行时错误。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">值<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph>在属性系统中具有特殊含义，并且不能用作依赖项属性默认值。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The <ph id="ph1">`isAnimationProhibited`</ph> parameter sets the initial value of the <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A&gt;</ph> property declared by the immediate base <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">`isAnimationProhibited`</ph>参数设置的初始值<ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A&gt;</ph>属性声明由即时基类<ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">值标记为设置标志<ph id="ph1">`flags`</ph>参数将设置的布尔值<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>相匹配的属性<ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph>标志的名称与<ph id="ph4">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">只要元数据具有尚未应用到特定的属性系统操作，你仍可更改的元数据中的属性的值。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">下面的示例调用此构造函数签名：</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">将 <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> 设置为 <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The default value of the dependency property, usually provided as a specific type.</source>
          <target state="translated">依赖项属性的默认值，通常作为特定类型提供。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">元数据选项标志（<ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> 值的组合）。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">这些选项指定依赖项对象的特性，如布局或数据绑定，它们与系统进行交互。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">对处理程序实现的引用，每当属性的有效值更改时，属性系统都会调用此处理程序实现。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>A reference to a handler implementation that will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> against this property.</source>
          <target state="translated">对处理程序实现的引用，每当属性系统调用该属性的 <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> 时，都会调用此处理程序实现。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to prevent the property system from animating the property that this metadata is applied to.</source>
          <target state="translated">若为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，则防止属性系统对要应用此元数据的属性进行动画处理。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>Such properties will raise a run-time exception originating from the property system if animations of them are attempted.</source>
          <target state="translated">如果尝试对此类属性进行动画处理，则它们会引发源自属性系统的运行时异常。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> to use when bindings for this property are applied that have their <ph id="ph2">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> set to <ph id="ph3">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</source>
          <target state="translated">应用此属性的绑定时使用的 <ph id="ph1">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph>，其 <ph id="ph2">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> 设置为 <ph id="ph3">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework metadata options, specified callbacks, a Boolean that can be used to prevent animation of the property, and a data-binding update trigger default.</source>
          <target state="translated">使用提供的默认值和框架元数据选项、指定的回调、可以用来防止属性动画的布尔值及数据绑定更新触发器默认值初始化 <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">为提供的值的类型<ph id="ph1">`defaultValue`</ph>必须匹配或与此元数据将应用于依赖项属性的原始注册中指定的类型。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">在编译期间不能检测到不匹配，是因为，则可能很难调试，元数据默认值类型和应用于依赖项属性的类型之间的不匹配。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">属性系统不会运行时，直到计算的属性的有效值，因此默认值类型/属性类型不匹配的结果为运行时错误。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">值<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph>在属性系统中具有特殊含义，并且不能用作依赖项属性默认值。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The <ph id="ph1">`isAnimationProhibited`</ph> parameter sets the initial value of the <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A&gt;</ph> property declared by the immediate base <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">`isAnimationProhibited`</ph>参数设置的初始值<ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A&gt;</ph>属性声明由即时基类<ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>For more information about the update source behavior for bindings, see <bpt id="p1">[</bpt>Data Binding Overview<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>.</source>
          <target state="translated">有关绑定的更新源行为的详细信息，请参阅<bpt id="p1">[</bpt>数据绑定概述<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">值标记为设置标志<ph id="ph1">`flags`</ph>参数将设置的布尔值<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>相匹配的属性<ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph>标志的名称与<ph id="ph4">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">只要元数据具有尚未应用到特定的属性系统操作，你仍可更改的元数据中的属性的值。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">将 <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> 设置为 <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the arrange pass during layout engine operations.</source>
          <target state="translated">获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间的排列过程。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists potentially affects the arrange pass; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果此元数据所在的依赖项对象可能会影响排列处理过程，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> 和<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>包括的实现<ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph>监视对元素存在的所有依赖项属性的有效值更改。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for that element (a call to <ph id="ph3">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph>).</source>
          <target state="translated">作为该逻辑的一部分，更改有效值的依赖项属性值，并且具有与元数据<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph>设置为<ph id="ph2">`true`</ph>将启动推迟的请求，以使该元素的可视内容无效 (调用<ph id="ph3">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">因为此 WPF 框架级别实现已就位，你通常不需要的依赖项属性与看起来<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph>除非大体上为你要替换或修改的 WPF 框架级别布局行为。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">自定义<ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph>实现可以选择具有类似的行为更改依赖项属性的其中<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph>是<ph id="ph3">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">在派生类的属性<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>通常定义为读写模式的对象模型中。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">这是以便可以在实例初始化后对它们进行调整。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">但是，作为对的调用的一部分使用元数据后<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>，或<ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">正在尝试设置此属性后的<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph>是<ph id="ph2">`true`</ph>对此元数据实例将引发的异常。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>XAML Text Usage</source>
          <target state="translated">XAML 文本用法</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Members of this class are either not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">此类的成员通常不是使用在<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">下面的示例从各种依赖项属性字段中获取的默认元数据，查询的各种值<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>属性，并使用这些信息来填充表，以实现"元数据浏览器"。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the measure pass during layout engine operations.</source>
          <target state="translated">获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间的测量过程。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists potentially affects the measure pass; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果此元数据所在的依赖属性可能会影响测量过程，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> 和<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>包括的实现<ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph>监视对元素存在的所有依赖项属性的有效值更改。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for that element.</source>
          <target state="translated">作为该逻辑的一部分，更改有效值的依赖项属性值，并且具有与元数据<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph>设置为<ph id="ph2">`true`</ph>将启动推迟的请求，以使该元素的可视内容无效。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">因为此 WPF 框架级别实现已就位，你通常不需要的依赖项属性与看起来<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph>除非大体上为你要替换或修改的 WPF 框架级别布局行为。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">自定义<ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph>实现可以选择具有类似的行为更改依赖项属性的其中<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph>是<ph id="ph3">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">在派生类的属性<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>通常定义为读写模式的对象模型中。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">这是以便可以在实例初始化后对它们进行调整。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">但是，作为对的调用的一部分使用元数据后<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>，或<ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">正在尝试设置此属性后的<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph>是<ph id="ph2">`true`</ph>对此元数据实例将引发的异常。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>XAML Text Usage</source>
          <target state="translated">XAML 文本用法</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">此类的成员通常不使用在<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">下面的示例从各种依赖项属性字段中获取的默认元数据，查询的各种值<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>属性，并使用这些信息来填充表，以实现"元数据浏览器"。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the arrange pass of its parent element's layout during layout engine operations.</source>
          <target state="translated">获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间父元素布局的排列处理过程。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists potentially affects the arrange pass specifically on its parent element; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果此元数据所在的依赖项对象可能会影响特定于其父元素的排列处理过程，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> 和<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>包括的实现<ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph>监视对元素存在的所有依赖项属性的有效值更改。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for the parent element.</source>
          <target state="translated">作为该逻辑的一部分，更改有效值的依赖项属性值，并且具有与元数据<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph>设置为<ph id="ph2">`true`</ph>将启动推迟的请求，以使其无效的父元素的视觉对象。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Generally, you do not need to report changes of a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> property to a parent element using <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> because the element itself would already have its own <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> as <ph id="ph4">`true`</ph>.</source>
          <target state="translated">通常情况下，你不需要的报告更改<ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>属性设置为父元素使用<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph>因为元素本身可能已将其自己<ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph>作为<ph id="ph4">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>That is usually sufficient, because changes in the child element generally initiate a parent arrange when appropriate.</source>
          <target state="translated">这是通常足够，因为子元素中的更改通常启动父排列在适当的时候。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> is sometimes used for a <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> 有时用于<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>派生类。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>In this case, the child element sets a property, but a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived class does not control its own rendering.</source>
          <target state="translated">在此情况下，子元素设置了一个属性，但一个<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>派生的类不控制其自己的呈现。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>The rendering is handled by a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> parent element that serves as the content host.</source>
          <target state="translated">呈现由<ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>用作内容主机的父元素。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>For instance, a change to the value of the <ph id="ph1">&lt;xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType&gt;</ph> attached property by a child element invalidates arrange of the parent, because the position of the child in the parent must be changed.</source>
          <target state="translated">例如，对的值的更改才<ph id="ph1">&lt;xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType&gt;</ph>遭到一个子元素的附加的属性失效排列的父级，因为必须更改该子级的父代中的位置。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Therefore, the <ph id="ph1">&lt;xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType&gt;</ph> attached property has metadata where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">因此，<ph id="ph1">&lt;xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType&gt;</ph>附加的属性具有元数据位置<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph>是<ph id="ph3">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Another example is <ph id="ph1">&lt;xref:System.Windows.Controls.Control.Padding%2A&gt;</ph>; when this property changes, the parent might change the positioning of the child, depending on available space.</source>
          <target state="translated">另一个示例是<ph id="ph1">&lt;xref:System.Windows.Controls.Control.Padding%2A&gt;</ph>; 如果此属性更改，父可能会更改的子级，具体取决于可用空间的位置。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">因为此 WPF 框架级别实现已就位，你通常不需要的依赖项属性与看起来<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph>除非大体上为你要替换或修改的 WPF 框架级别布局行为。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">自定义<ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph>实现可以选择具有类似的行为更改依赖项属性的其中<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph>是<ph id="ph3">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Properties on any derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">属性对任何派生类的<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>通常定义为读写模式的对象模型中。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">这是以便可以在实例初始化后对它们进行调整。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">但是，作为对的调用的一部分使用元数据后<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>，或<ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">正在尝试设置此属性后的<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph>是<ph id="ph2">`true`</ph>对此元数据实例将引发的异常。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>XAML Text Usage</source>
          <target state="translated">XAML 文本用法</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">此类的成员通常不使用在<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the measure pass of its parent element's layout during layout engine operations.</source>
          <target state="translated">获取或设置一个值，该值表示依赖属性是否会影响布局引擎操作期间其父元素布局的测量过程。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists potentially affects the measure pass specifically on its parent element; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.The default is <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果此元数据所在的依赖属性可能会影响其父元素上的测量过程，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。默认值为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> 和<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>包括的实现<ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph>监视对元素存在的所有依赖项属性的有效值更改。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for the parent element.</source>
          <target state="translated">作为该逻辑的一部分，更改有效值的依赖项属性值，并且具有与元数据<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph>设置为<ph id="ph2">`true`</ph>将启动推迟的请求，以使其无效的父元素的视觉对象。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">因为此 WPF 框架级别实现已就位，你通常不需要的依赖项属性与看起来<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph>除非大体上为你要替换或修改的 WPF 框架级别布局行为。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Generally, you do not need to report changes of a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> property to a parent element using <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> because the element itself would already have its own <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> as <ph id="ph4">`true`</ph>.</source>
          <target state="translated">通常情况下，你不需要的报告更改<ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>属性设置为父元素使用<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph>因为元素本身可能已将其自己<ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph>作为<ph id="ph4">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>That is usually sufficient, because changes in the child element generally initiate a parent measure pass when appropriate.</source>
          <target state="translated">这是通常足够，因为子元素中的更改通常启动父测量过程在适当的时候。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> is sometimes used for a <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> 有时用于<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>派生类。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>In this case, the child element sets a property, but a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived class does not control its own rendering.</source>
          <target state="translated">在此情况下，子元素设置了一个属性，但一个<ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>派生的类不控制其自己的呈现。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>The rendering is handled by a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> parent element that serves as the content host.</source>
          <target state="translated">呈现由<ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>用作内容主机的父元素。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>For instance, a change to the value of the <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType&gt;</ph> property by a child element invalidates measure of the parent, because the relative spacing of paragraphs might change and might increase or decrease the content host size.</source>
          <target state="translated">例如，对的值的更改才<ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType&gt;</ph>遭到一个子元素的属性使无效的父代、 度量值，因为段落的相对间距可能更改和可能增加或减少内容宿主的大小。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Therefore, the <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType&gt;</ph> property has metadata where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">因此，<ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType&gt;</ph>属性具有元数据位置<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph>是<ph id="ph3">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Content host elements also frequently look for changes in dependency properties where <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> is <ph id="ph2">`true`</ph>, as part of content host rendering logic.</source>
          <target state="translated">依赖项属性中的更改还会频繁查找内容主机元素其中<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph>是<ph id="ph2">`true`</ph>，作为内容主机呈现逻辑的一部分。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>For instance, the <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> element must respond to certain changes within text that might require that the bounding box of the <ph id="ph2">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> itself be changed.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph>元素必须响应的某些更改可能要求的文本内的边界框<ph id="ph2">&lt;xref:System.Windows.Controls.TextBox&gt;</ph>本身进行更改。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">自定义<ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph>实现可以选择具有类似的行为更改依赖项属性的其中<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph>是<ph id="ph3">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Properties on any derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">属性对任何派生类的<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>通常定义为读写模式的对象模型中。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">这是以便可以在实例初始化后对它们进行调整。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">但是，作为对的调用的一部分使用元数据后<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>，或<ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">正在尝试设置此属性后的<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph>是<ph id="ph2">`true`</ph>对此元数据实例将引发的异常。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>XAML Text Usage</source>
          <target state="translated">XAML 文本用法</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">此类的成员通常不使用在<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the general layout in some way that does not specifically influence arrangement or measurement, but would require a redraw.</source>
          <target state="translated">获取或设置一个值，该值指示依赖属性是否会以某种方式（这种方式不会具体影响排列或测量，但将请求重绘）对常规布局造成潜在影响。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists affects rendering; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果该元数据所在的依赖项对象会影响呈现，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> 和<ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>包括的实现<ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph>监视对元素存在的所有依赖项属性的有效值更改。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for that element.</source>
          <target state="translated">作为该逻辑的一部分，更改有效值的依赖项属性值，并且具有与元数据<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph>设置为<ph id="ph2">`true`</ph>将启动推迟的请求，以使该元素的可视内容无效。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">因为此 WPF 框架级别实现已就位，你通常不需要的依赖项属性与看起来<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph>除非大体上为你要替换或修改的 WPF 框架级别布局行为。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">自定义<ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph>实现可以选择具有类似的行为更改依赖项属性的其中<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph>是<ph id="ph3">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Properties on any derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">属性对任何派生类的<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>通常定义为读写模式的对象模型中。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">这是以便可以在实例初始化后对它们进行调整。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">但是，作为对的调用的一部分使用元数据后<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>，或<ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">正在尝试设置此属性后的<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph>是<ph id="ph2">`true`</ph>对此元数据实例将引发的异常。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>XAML Text Usage</source>
          <target state="translated">XAML 文本用法</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">此类的成员通常不使用在<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">下面的示例从各种依赖项属性字段中获取的默认元数据，查询的各种值<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>属性，并使用这些信息来填充表，以实现"元数据浏览器"。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Gets or sets a value that indicates whether the property binds two-way by default.</source>
          <target state="translated">获取或设置一个值，该值指示默认情况下属性是否双向绑定。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists binds two-way by default; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果此元数据所在的依赖属性默认情况下为双向绑定，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>，否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>In absence of this property being <ph id="ph1">`true`</ph>, binding updates are one-way by default, based on the default behavior of the <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> constructors or equivalent <ph id="ph3">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax.</source>
          <target state="translated">在没有为此属性的情况下<ph id="ph1">`true`</ph>，为默认情况下，基于的默认行为单向信任关系绑定更新<ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph>构造函数或同等<ph id="ph3">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>语法。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>In existing elements, you will usually find this property set to <ph id="ph1">`true`</ph> in metadata for dependency properties that both report state and are modifiable by user action, for example <ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">在现有元素中，您通常会发现此属性设置为<ph id="ph1">`true`</ph>报告状态且是可修改的用户操作，例如依赖项属性的元数据中<ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>This property only reports the default binding update characteristics of the dependency property in general.</source>
          <target state="translated">此属性通常只报告依赖项属性的默认绑定更新特征。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Any binding set to this property on an instance can locally set the <ph id="ph1">&lt;xref:System.Windows.Data.Binding.Mode%2A&gt;</ph> property of the binding and change this default.</source>
          <target state="translated">任何绑定设置为实例上此属性可以本地设置<ph id="ph1">&lt;xref:System.Windows.Data.Binding.Mode%2A&gt;</ph>绑定属性和更改此默认设置。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Properties on any derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">属性对任何派生类的<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>通常定义为读写模式的对象模型中。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">这是以便可以在实例初始化后对它们进行调整。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">但是，作为对的调用的一部分使用元数据后<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>，或<ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">正在尝试设置此属性后的<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph>是<ph id="ph2">`true`</ph>对此元数据实例将引发的异常。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>XAML Text Usage</source>
          <target state="translated">XAML 文本用法</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">此类的成员通常不使用在<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">下面的示例从各种依赖项属性字段中获取的默认元数据，查询的各种值<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>属性，并使用这些信息来填充表，以实现"元数据浏览器"。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>Gets or sets the default for <ph id="ph1">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> to use when bindings for the property with this metadata are applied, which have their <ph id="ph2">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> set to <ph id="ph3">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</source>
          <target state="translated">获取或设置在应用具有该元数据的属性的绑定时要使用的 <ph id="ph1">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> 的默认值，这些绑定的 <ph id="ph2">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> 设置为 <ph id="ph3">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>A value of the enumeration, other than <ph id="ph1">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</source>
          <target state="translated">除 <ph id="ph1">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph> 以外的枚举值。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">在派生类的属性<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>通常定义为读写模式的对象模型中。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">这是以便可以在实例初始化后对它们进行调整。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">但是，作为对的调用的一部分使用元数据后<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>，或<ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">正在尝试设置此属性后的<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph>是<ph id="ph2">`true`</ph>对此元数据实例将引发的异常。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>XAML Text Usage</source>
          <target state="translated">XAML 文本用法</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">此类的成员通常不使用在<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>This property is set to <ph id="ph1">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>; the value you set is supposed to become the default when requested by bindings.</source>
          <target state="translated">该属性设置为 <ph id="ph1">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>；您设置的值应成为绑定请求时的默认值。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Gets or sets a value that indicates whether the value of the dependency property is inheritable.</source>
          <target state="translated">获取或设置一个值，该值指示依赖属性的值是否可继承。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the property value is inheritable; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果属性值是可继承的，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Property value inheritance is a feature of the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system at the WPF framework level, whereby certain dependency properties can be locally set on an element at or near the root of a <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> element tree and then have their value inherited by all elements within the logical tree of child elements that also possess that property.</source>
          <target state="translated">属性值继承是一项功能的<ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>在 WPF 框架级别，凭此某些依赖项属性可以是本地一个元素设置处或附近的根的属性系统<ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>元素树，然后将它们由继承的值此外拥有该属性的子元素的逻辑树中的所有元素。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Property value inheritance is not enabled by default, and enabling it does have some performance implications.</source>
          <target state="translated">默认情况下，未启用属性值继承和启用它确实有一些性能影响。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>For details, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>属性值继承<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain object-object divisions in the runtime tree is undefined.</source>
          <target state="translated">虽然可能会出现属性值继承，使其适用于非附加依赖项属性，但通过在运行时树中某些对象对象部门的附加属性的继承行为不确定。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">始终使用<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph>注册你在其中指定的属性<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph>的元数据中。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">在派生类的属性<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>通常定义为读写模式的对象模型中。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">这是以便可以在实例初始化后对它们进行调整。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">但是，作为对的调用的一部分使用元数据后<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>，或<ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">正在尝试设置此属性后的<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph>是<ph id="ph2">`true`</ph>对此元数据实例将引发的异常。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>XAML Text Usage</source>
          <target state="translated">XAML 文本用法</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">此类的成员通常不使用在<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">下面的示例从各种依赖项属性字段中获取的默认元数据，查询的各种值<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>属性，并使用这些信息来填充表，以实现"元数据浏览器"。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>Gets a value that indicates whether data binding is supported for the dependency property.</source>
          <target state="translated">获取一个值，该值指示依赖属性是否支持数据绑定。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if data binding is supported on the dependency property to which this metadata applies; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果要应用该元数据的依赖项对象支持数据绑定，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>This property reports <ph id="ph1">`false`</ph> for one of two possible conditions: either data binding to a dependency property is not allowed because the dependency property is read-only (as reported in the dependency property identifier, not the metadata), or the value of another metadata property, <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>, is set to <ph id="ph3">`true`</ph> in this metadata.</source>
          <target state="translated">此属性报告<ph id="ph1">`false`</ph>两个可能的条件之一： 不能使用任一数据绑定到依赖项属性，因为依赖项属性 （作为中报告的依赖项属性标识符，不是元数据），以只读的或的值另一个元数据属性， <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>，设置为<ph id="ph3">`true`</ph>此元数据中。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>This property is exposed as a convenience so that callers do not have to check both <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>.</source>
          <target state="translated">此属性公开为方便起见，以便调用方不需要同时检查<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>If you are attempting to create metadata that specifies that an otherwise read/write property should not support data binding, specify the flag <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable&gt;</ph> (note the slight naming convention difference versus <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>).</source>
          <target state="translated">如果你尝试创建指定否则为的读/写属性不应支持数据绑定的元数据，请指定标志<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable&gt;</ph>(请注意与细微的命名约定差别在于<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>XAML Text Usage</source>
          <target state="translated">XAML 文本用法</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">此类的成员通常不使用在<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">下面的示例从各种依赖项属性字段中获取的默认元数据，查询的各种值<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>属性，并使用这些信息来填充表，以实现"元数据浏览器"。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Gets or sets a value that indicates whether the dependency property supports data binding.</source>
          <target state="translated">获取或设置一个值，该值指示依赖属性是否支持数据绑定。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the property does not support data binding; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果属性不支持数据绑定，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Note that this metadata property is set to <ph id="ph1">`true`</ph> specifically for properties that should not support data binding, despite being read-write properties.</source>
          <target state="translated">请注意，此元数据属性设置为<ph id="ph1">`true`</ph>专用于不应支持数据绑定，尽管要读写属性的属性。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>The expectation is that in most cases where a dependency property is declared, data binding is desired, because data binding is one of the key scenarios where a dependency property is useful.</source>
          <target state="translated">应当是，在大多数情况下，依赖项属性的声明位置，则需要数据绑定，因为数据绑定是依赖项属性是有用的重要方案之一。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Unlike <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A&gt;</ph>, this does not merely change a default that can later be changed on a specific binding.</source>
          <target state="translated">与不同<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A&gt;</ph>，这不会只是更改更高版本可以更改特定绑定的默认值。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Setting this property <ph id="ph1">`true`</ph> in the metadata for a dependency property metadata will disable all bindings from applying their values through expressions to that dependency property.</source>
          <target state="translated">将此属性设置<ph id="ph1">`true`</ph>元数据将依赖项属性的元数据中禁用应用到该依赖项属性的表达式通过其值的所有绑定。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Read-only dependency properties do not support data binding (because they have no setter that can apply changed values), but will still report <ph id="ph1">`false`</ph> for <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>.</source>
          <target state="translated">只读依赖属性不支持数据绑定 （因为它们具有可以应用更改后的值没有 setter），但是仍然会报告<ph id="ph1">`false`</ph>为<ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>This is because properties that correspond to a <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> values will report parity with how the metadata was actually established, rather than always reporting the end result behavior that the naming of the property might imply.</source>
          <target state="translated">这是因为属性，对应于<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph>值将报告与如何元数据的实际创建，而不是始终 reporting 命名的属性可能暗示的最终结果行为的奇偶校验。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>To determine whether a given dependency property permits data binding, you should usually check <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A&gt;</ph> instead.</source>
          <target state="translated">若要确定给定的依赖属性是否允许数据绑定，应经常检查<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A&gt;</ph>相反。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A&gt;</ph> is a convenience for checking both <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph> as a single operation, yielding the expected result.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A&gt;</ph> 是一种便于同时检查<ph id="ph2">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph>和<ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>作为单个操作，以生成预期的结果。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">在派生类的属性<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>通常定义为读写模式的对象模型中。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">这是以便可以在实例初始化后对它们进行调整。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">但是，作为对的调用的一部分使用元数据后<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>，或<ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">正在尝试设置此属性后的<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph>是<ph id="ph2">`true`</ph>对此元数据实例将引发的异常。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>XAML Text Usage</source>
          <target state="translated">XAML 文本用法</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">此类的成员通常不使用在<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>Gets or sets a value that indicates whether this property contains journaling information that applications can or should store as part of a journaling implementation.</source>
          <target state="translated">获取或设置一个值，该值表示该属性是否包含应用程序可以或应该作为日记功能实现的一部分而存储的日记信息。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if journaling should be performed on the dependency property that this metadata is applied to; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> 如果应在此元数据应用于; 的依赖项属性执行日记记录否则为<ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">在派生类的属性<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>通常定义为读写模式的对象模型中。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">这是以便可以在实例初始化后对它们进行调整。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">但是，作为对的调用的一部分使用元数据后<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>，或<ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">正在尝试设置此属性后的<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph>是<ph id="ph2">`true`</ph>对此元数据实例将引发的异常。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>XAML Text Usage</source>
          <target state="translated">XAML 文本用法</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">此类的成员通常不使用在<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The base metadata to merge.</source>
          <target state="translated">要合并的基本元数据。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The dependency property this metadata is being applied to.</source>
          <target state="translated">此元数据被应用到的依赖属性。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>Enables a merge of the source metadata with base metadata.</source>
          <target state="translated">允许合并源元数据和基本元数据。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>This method is used internally when metadata is being overridden.</source>
          <target state="translated">重写元数据时在内部使用此方法。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>Classes that derive from <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> (or this class particularly) should override this method to account for any metadata properties they have added in their implementations.</source>
          <target state="translated">派生自的类<ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph>（或特别是此类） 应重写此方法，以考虑它们在其实现中添加任何元数据属性。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>For instance, your implementation might have added a new flagwise enumeration value, and the <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> implementation should then be able to combine those flags correctly.</source>
          <target state="translated">例如，您的实现可能会添加新的标志枚举值，与<ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph>实现应该能够正确组合这些标志。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>Always call the base implementation prior to your own implementation, because the base implementation takes care of merging all the properties already defined on previous types in the hierarchy.</source>
          <target state="translated">始终调用您自己的实现之前, 的基实现，因为基实现负责合并已在以前层次结构中的类型上定义的所有属性。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The behavior added by the <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> implementation in <ph id="ph2">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> is that specific WPF framework-level properties in the metadata such as <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /&gt;</ph> are combined in a bitwise or operation.</source>
          <target state="translated">通过添加行为<ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph>中的实现<ph id="ph2">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph>在于特定 WPF 框架级别属性中的元数据，如<ph id="ph3">&lt;see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /&gt;</ph>中按位组合或操作。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> behavior also implements the behavior when you override the property metadata on an existing dependency property by calling <ph id="ph2">&lt;see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" /&gt;</ph>., using override metadata that is <ph id="ph3">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph>行为还实现行为，通过调用重写现有依赖项属性的属性元数据时<ph id="ph2">&lt;see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" /&gt;</ph>。，使用重写元数据，即<ph id="ph3">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>The dependency property to which the metadata has been applied.</source>
          <target state="translated">已应用了元数据的依赖项对象。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>The type associated with this metadata if this is type-specific metadata.</source>
          <target state="translated">与此元数据关联的类型（如果这是特定于类型的元数据）。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>If this is default metadata, this value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果这是默认的元数据，则此值可以为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</source>
          <target state="translated">当此元数据已经应用到一个属性时（这表明正在密封元数据）调用。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>Any mutability of the data structure of a <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> instance should be marked as immutable when this method is invoked.</source>
          <target state="translated">数据结构的任何可变性<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>实例应标记为不可变时调用此方法。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> implementation of this method does nothing beyond calling the base implementation.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph>此方法实现不执行任何操作超出调用基实现。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Gets or sets a value that indicates whether the property value inheritance evaluation should span across certain content boundaries in the logical tree of elements.</source>
          <target state="translated">获取或设置一个值，该值指示属性值继承计算是否应跨越元素逻辑树中的某些内容边界。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the property value inheritance should span across certain content boundaries; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果属性值继承应跨越某些内容边界，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>This metadata reports a seldom-applied modification to property value inheritance behavior across special parent element-child element boundaries.</source>
          <target state="translated">此元数据跨特殊的父元素子级元素边界报告属性值继承行为的很少应用修改。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>The canonical example of such a boundary is the contents of a <ph id="ph1">&lt;xref:System.Windows.Controls.Frame&gt;</ph>, where the <ph id="ph2">&lt;xref:System.Windows.Controls.Frame&gt;</ph> content might get reloaded independently of the existence of the <ph id="ph3">&lt;xref:System.Windows.Controls.Frame&gt;</ph>.</source>
          <target state="translated">此类边界的典型示例是内容<ph id="ph1">&lt;xref:System.Windows.Controls.Frame&gt;</ph>，其中<ph id="ph2">&lt;xref:System.Windows.Controls.Frame&gt;</ph>可能获取内容重新加载独立是否存在于<ph id="ph3">&lt;xref:System.Windows.Controls.Frame&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>The desired property system behavior is that property value inheritance should not traverse into the contents of the <ph id="ph1">&lt;xref:System.Windows.Controls.Frame&gt;</ph>, because these contents might be elements that the application hosting the frame does not own or control.</source>
          <target state="translated">所需的属性系统行为是属性值继承应遍历到的内容<ph id="ph1">&lt;xref:System.Windows.Controls.Frame&gt;</ph>，因为这些内容可能是托管帧的应用程序并不拥有或控制的元素。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Specifying metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A&gt;</ph> set to <ph id="ph2">`true`</ph>, as well as specifying <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> as <ph id="ph4">`true`</ph>, will cause the property on which the metadata is applied to be inheritable even across the <ph id="ph5">&lt;xref:System.Windows.Controls.Frame&gt;</ph> boundary or similar boundaries.</source>
          <target state="translated">指定元数据与<ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A&gt;</ph>设置为<ph id="ph2">`true`</ph>，并指定以及为<ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph>作为<ph id="ph4">`true`</ph>，将导致在其应用了元数据要甚至跨可继承的属性<ph id="ph5">&lt;xref:System.Windows.Controls.Frame&gt;</ph>边界或类似的边界。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">在派生类的属性<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>通常定义为读写模式的对象模型中。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">这是以便可以在实例初始化后对它们进行调整。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">但是，作为对的调用的一部分使用元数据后<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>，或<ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">正在尝试设置此属性后的<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph>是<ph id="ph2">`true`</ph>对此元数据实例将引发的异常。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>XAML Text Usage</source>
          <target state="translated">XAML 文本用法</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">此类的成员通常不使用在<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Gets or sets a value that indicates whether sub-properties of the dependency property do not affect the rendering of the containing object.</source>
          <target state="translated">获取或设置一个值，该值指示依赖属性的子属性是否影响包含对象的呈现。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if changes to sub-property values do not affect rendering if changed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果更改后，对子属性值的更改不影响呈现，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">默认值为 <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>This metadata option is pertinent for dependency properties that are reference types, where that type has property values of its own.</source>
          <target state="translated">此元数据选项是相关的是引用类型，其中该类型具有自己的属性值的依赖项属性。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Typically, the layout system logic is to assume that any dependency property with sub-properties potentially will affect layout, because checking all sub-properties for changes is more time consuming than actually running another render pass.</source>
          <target state="translated">通常情况下，布局系统逻辑是假定具有子属性的任何依赖属性可能将影响布局，因为检查所有子属性的更改是花费更多时间比实际运行另一个呈现处理。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Setting this option to <ph id="ph1">`true`</ph> is useful for optimizing performance of the WPF framework level layout system implementation.</source>
          <target state="translated">将此选项设置为<ph id="ph1">`true`</ph>可用于优化的 WPF 框架级别布局系统实现的性能。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">在派生类的属性<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>通常定义为读写模式的对象模型中。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">这是以便可以在实例初始化后对它们进行调整。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>However, once the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">但是，作为对的调用的一部分使用元数据后<ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>， <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>，或<ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>、 属性系统将密封该元数据实例和传达的元数据的特性的属性都被视为不可变。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">正在尝试设置此属性后的<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph>是<ph id="ph2">`true`</ph>对此元数据实例将引发的异常。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>XAML Text Usage</source>
          <target state="translated">XAML 文本用法</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">此类的成员通常不使用在<ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">已对依赖属性操作应用了元数据，因此元数据已密封，且无法设置其属性。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>