<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="62d0c6b5a93fa38d970f0445e7a629dacdae551c" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48699215" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示参与依赖属性系统的对象。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyObject>类启用[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]属性系统服务对其多个派生类。  
  
 属性系统的主要功能是计算属性的值，并提供有关已更改的值的系统通知。 参与属性系统的另一个关键类是<xref:System.Windows.DependencyProperty>。 <xref:System.Windows.DependencyProperty> 启用的依赖项属性的注册到属性系统中，并提供了标识和每个依赖项属性，信息而<xref:System.Windows.DependencyObject>如基类使对象能够使用依赖项属性。  
  
 <xref:System.Windows.DependencyObject> 服务和特征包括：  
  
-   承载支持的依赖项属性。 通过调用注册依赖属性<xref:System.Windows.DependencyProperty.Register%2A>方法，并为您的类中的公共静态字段存储方法的返回值。  
  
-   承载支持附加的属性。 通过调用注册附加的属性<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法，并将该方法的返回值存储为公共静态只读字段在类中。 (此外，还有其他成员要求; 请注意，这表示[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]附加属性的特定实现。 有关详细信息，请参阅[附加属性概述](~/docs/framework/wpf/advanced/attached-properties-overview.md)。)然后可以在任何派生的类上设置附加的属性<xref:System.Windows.DependencyObject>。  
  
-   获取、 设置和清除存在任何依赖项属性的值的实用工具方法<xref:System.Windows.DependencyObject>。  
  
-   元数据，强制转换值支持、 属性更改通知，以及重写依赖属性回调或附加属性。 此外，<xref:System.Windows.DependencyObject>类有助于依赖项属性的每个所有者属性元数据。  
  
-   类的公共基类派生自<xref:System.Windows.ContentElement>， <xref:System.Windows.Freezable>，或<xref:System.Windows.Media.Visual>。 (<xref:System.Windows.UIElement>，另一个基元素类，具有包含的类层次结构<xref:System.Windows.Media.Visual>。)  
  
   
  
## Examples  
 下面的示例从派生<xref:System.Windows.DependencyObject>创建新的抽象类。 然后，此类注册附加的属性，包括支持该附加属性的成员。  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.DependencyObject" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>清除属性的本地值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要清除的由 <see cref="T:System.Windows.DependencyProperty" /> 对象引用指定的依赖属性。</param>
        <summary>清除属性的本地值。 要清除的属性由 <see cref="T:System.Windows.DependencyProperty" /> 标识符指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过调用清除的属性值<xref:System.Windows.DependencyObject.ClearValue%2A>不一定会赋予依赖项属性的依赖属性元数据中指定的默认值。 清除该属性只特别清除任何本地值可能已应用。 有关详细信息，请参阅[依赖属性值优先级](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。  
  
   
  
## Examples  
 下面的示例循环访问对象上设置了本地值的所有属性然后调用<xref:System.Windows.DependencyObject.ClearValue%2A>，清除每个此类属性的值。  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试对密封 <see cref="T:System.Windows.DependencyObject" /> 调用 <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />。</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">要清除的依赖属性的关键字。</param>
        <summary>清除只读属性的本地值。 要清除的属性由 <see cref="T:System.Windows.DependencyPropertyKey" /> 指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个<xref:System.Windows.DependencyPropertyKey>标识只读依赖属性的属性系统操作。 定义只读依赖属性的类不应公开此密钥的公共访问权限。 公开提供的键将提供公共代码路径，它起作用的属性的只读的字符，如果方法<xref:System.Windows.DependencyObject.ClearValue%2A>或<xref:System.Windows.DependencyObject.SetValue%2A>类或引用键的程序集外部调用。  
  
 通过调用清除的属性值<xref:System.Windows.DependencyObject.ClearValue%2A>不一定会赋予依赖项属性的依赖属性元数据中指定的默认值。 清除值只特别清除任何本地值可能已应用。 有关详细信息，请参阅[依赖属性值优先级](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试对密封 <see cref="T:System.Windows.DependencyObject" /> 调用 <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />。</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要强制转换的依赖项属性的标识符。</param>
        <summary>对指定依赖属性的值进行强制。 通过对调用方 <see cref="T:System.Windows.DependencyObject" /> 上存在的依赖属性的属性元数据中所指定的任何 <see cref="T:System.Windows.CoerceValueCallback" /> 函数进行调用来完成此操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 除了显式调用通过调用<xref:System.Windows.DependencyObject.CoerceValue%2A>，则<xref:System.Windows.CoerceValueCallback>依赖项属性也会调用在内部由重新计算依赖项属性值时[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]属性系统。  
  
 当调用<xref:System.Windows.DependencyObject.CoerceValue%2A>方法，最终调用指定的属性强制值回叫。 通常将调用<xref:System.Windows.DependencyObject.CoerceValue%2A>唯一，如果您知道该强制值回叫存在，并且知道强制转换的回调的条件。  
  
 调用的最常见方案<xref:System.Windows.DependencyObject.CoerceValue%2A>内的依赖方式影响彼此的值的相关属性的类处理或属性更改回调。 有关详细信息，请参阅[依赖属性回调和验证](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Windows.DependencyObject.CoerceValue%2A>内<xref:System.Windows.PropertyChangedCallback>实现，可作为<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>相同的类上的不同依赖项属性。 这是一种常见模式，则返回 true 值之间引入依赖项依赖项属性。  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定的 <paramref name="dp" /> 或其值无效或不存在。</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对此实例的 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 类型进行包装的 <see cref="T:System.Windows.DependencyObjectType" />。</summary>
        <value>对此实例的 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 类型进行包装的 <see cref="T:System.Windows.DependencyObjectType" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性很有用，如果从方法返回的对象返回值类型为<xref:System.Windows.DependencyObject>并且你想要属性系统特定对其执行操作具体取决于它的类型。 例如是调用效率更高<xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29>使用<xref:System.Windows.DependencyObjectType>而不是[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]类型。 <xref:System.Windows.DependencyObjectType> 促进更快的查找。  
  
   
  
## Examples  
 在下面的伪代码示例中，`MySubClass`认为其他派生的类可能会更改的默认值`MyCustom`依赖项属性。 类实现可以通过利用多态性上确定实际的派生的类的默认构造函数<xref:System.Windows.DependencyObjectType>值时为派生的类 instantiator 使用该构造函数。  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要与当前实例进行比较的 <see cref="T:System.Windows.DependencyObject" />。</param>
        <summary>确定提供的 <see cref="T:System.Windows.DependencyObject" /> 是否等效于当前 <see cref="T:System.Windows.DependencyObject" />。</summary>
        <returns>如果两个实例相同，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现是引用相等性，且不会尝试评估所包含属性的值相等性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> 重写，然后将两个基本的封装<see cref="T:System.Object" />方法：<see cref="M:System.Windows.DependencyObject.Equals(System.Object)" />和<see cref="M:System.Windows.DependencyObject.GetHashCode" />。 重写调用<see cref="T:System.Object" />实现，从而导致对象是否相等的行为。 这些故意安排的重写的目的是为了防止派生的类尝试定义值相等性<see cref="T:System.Windows.DependencyObject" />。 值相等性<see cref="T:System.Windows.DependencyObject" />永远不会是准确的将由于固有的属性值更改功能的<see cref="T:System.Windows.DependencyObject" />及其依赖项属性。 这包括基本[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]功能，例如数据绑定和[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]属性系统。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取此 <see cref="T:System.Windows.DependencyObject" /> 的哈希代码。</summary>
        <returns>带符号 32 位整数哈希代码。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> 重写，然后将两个封装<see cref="T:System.Object" />方法：<see cref="M:System.Windows.DependencyObject.Equals(System.Object)" />和<see cref="M:System.Windows.DependencyObject.GetHashCode" />。 重写调用<see cref="T:System.Object" />实现，从而导致对象是否相等的行为。 这些故意安排的重写的目的是为了防止派生的类尝试定义值相等性<see cref="T:System.Windows.DependencyObject" />。 值相等性<see cref="T:System.Windows.DependencyObject" />永远不会是准确的将由于固有的属性值更改功能的<see cref="T:System.Windows.DependencyObject" />及其依赖项属性。 这包括基本[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]功能，例如数据绑定和[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]属性系统。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建一个专用的枚举数，用于确定哪些依赖项属性在此 <see cref="T:System.Windows.DependencyObject" /> 上具有以本地方式设置的值。</summary>
        <returns>一个专用的本地值枚举数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一个*本地值*是任何依赖项属性值所设置<xref:System.Windows.DependencyObject.SetValue%2A>，而不是属性系统的其他方面。  
  
 <xref:System.Windows.LocalValueEnumerator>获取通过调用<xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>可用于枚举具有本地设置的属性值上<xref:System.Windows.DependencyObject>实例。 每个此类属性表示的枚举器中<xref:System.Windows.LocalValueEntry>具有引用特定的属性的对象<xref:System.Windows.DependencyProperty>及其值。 此方法通过本地设置枚举的值可用于优化或其他处理的本地值，如确定哪些属性值的<xref:System.Windows.DependencyObject>在清除会更改。  
  
> [!IMPORTANT]
>  返回<xref:System.Windows.LocalValueEnumerator>可能包含<xref:System.Windows.LocalValueEntry>是只读的依赖项属性或值通过属性系统的依赖项属性的记录。 例如，通过布局使用确定宽度的可视框架元素将报告为本地值<xref:System.Windows.FrameworkElement.ActualWidth%2A>。 如果为了重置它们获得本地值，检查<xref:System.Windows.DependencyProperty.ReadOnly%2A>上的每个属性标识符的值<xref:System.Windows.LocalValueEntry>来确认<xref:System.Windows.DependencyProperty>是否为只读的。  
  
   
  
## Examples  
 下面的示例循环访问对象上设置了本地值的所有属性然后调用<xref:System.Windows.DependencyObject.ClearValue%2A>，清除每个此类属性的值。  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要为其检索值的属性的 <see cref="T:System.Windows.DependencyProperty" /> 标识符。</param>
        <summary>对 <see cref="T:System.Windows.DependencyObject" /> 的此实例返回依赖属性的当前有效值。</summary>
        <returns>返回当前有效值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *有效值*是由属性系统返回到正在请求值的任何调用方的属性的值。 有效的值为具有评估参与属性系统值优先级中的所有可能的输入属性系统的结果。 这包括强制转换和动画。 有关详细信息，请参阅[依赖属性值优先级](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。  
  
 此方法将永远不会返回<xref:System.Windows.DependencyProperty.UnsetValue>。 <xref:System.Windows.DependencyProperty.UnsetValue>是用在通过强制回调内部，有时也公开的各种功能的属性系统的 sentinel 值。  
  
 如果不确定属性的类型应该是什么，您可以查询请求的依赖关系属性，以确定是否存在多个特定的标识符<xref:System.Windows.DependencyProperty.PropertyType%2A>的返回值可以转换为。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定的 <paramref name="dp" /> 或其值无效，或者指定的 <paramref name="dp" /> 不存在。</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要使其失效的属性的 <see cref="T:System.Windows.DependencyProperty" /> 标识符。</param>
        <summary>重新计算指定依赖项属性的有效值</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当您调用<xref:System.Windows.DependencyObject.InvalidateProperty%2A>、 任何相关联的和适用<xref:System.Windows.CoerceValueCallback>或<xref:System.Windows.PropertyChangedCallback>函数注册可能会调用该依赖项属性。  
  
 调用<xref:System.Windows.DependencyObject.InvalidateProperty%2A>上设置其本地值的属性不会影响，因为本地值的优先级高于其他属性系统输入，动画除外。 但是，您可以调用<xref:System.Windows.DependencyObject.ClearValue%2A>，然后调用<xref:System.Windows.DependencyObject.InvalidateProperty%2A>。 有关详细信息，请参阅[依赖属性值优先级](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。  
  
 调用<xref:System.Windows.DependencyObject.InvalidateProperty%2A>不一定适用于许多依赖关系属性方案。 如果因任何组成部分的值变化而变得失效依赖项属性，属性系统使无效，并自动重新计算依赖项属性。 但是，仍有一些适当的方案其中<xref:System.Windows.DependencyObject.InvalidateProperty%2A>非常有用。 具体而言，可以使用<xref:System.Windows.DependencyObject.InvalidateProperty%2A>内的强制值或属性更改为不同的依赖项属性的回调。 此外可以使用<xref:System.Windows.DependencyObject.InvalidateProperty%2A>以强制重新计算对不是能够实现建议的数据源绑定<xref:System.ComponentModel.INotifyPropertyChanged>通知机制 (也许如果使用的不能被派生，或其中数据是静态的数据类成员）。  
  
   
  
## Examples  
 下面的示例调用<xref:System.Windows.DependencyObject.InvalidateProperty%2A>上自定义属性，只要无效的属性的计算中涉及的属性更改。 这是调用的替代技术<xref:System.Windows.DependencyObject.CoerceValue%2A>方法，因为导致失效属性将同时调用任何注册<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>。  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此实例当前是否为密封的（只读）。</summary>
        <value>如果此实例是密封的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此值是在内部设置。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">将包含相关依赖属性标识符、类型的属性元数据以及旧值和新值的事件数据。</param>
        <summary>每当更新此 <see cref="T:System.Windows.DependencyObject" /> 上任何依赖项属性的有效值时调用。 更改的特定依赖属性将在事件数据中报告。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不是通常将检测到单个属性更改或在每个用例的基础上执行的属性失效。 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 而被适用于修改常规失效模式中，如果特定的信息了解了宽分类的属性。 例如中, 更改<xref:System.Windows.Freezable>可能会发生更改的值类型<xref:System.Windows.Freezable>，或者可能是子属性，其中所做的更改是在其他<xref:System.Windows.Freezable>的引用。 <xref:System.Windows.Freezable>重写实现<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>使用内部信息来确定属性是否为子属性，并为任一种情况下提供了相应的基类逻辑。  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 一个对象的生命周期内可能调用多次。 因此，可以实现更好的总体属性系统的性能，如果重写特定属性的元数据，然后将附加<xref:System.Windows.CoerceValueCallback>或<xref:System.Windows.PropertyChangedCallback>各个属性的函数。 但是，应使用此方法，如果<xref:System.Windows.DependencyObject>包括大量的值相关的依赖项属性，或如果它包含逻辑，例如呈现行为，必须重新运行多个相关的属性失效的情况。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>始终调用基实现。 如果不这样做将大大禁用整个[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]属性系统，从而导致不正确的值报告。</para>
        </block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">要为其检索值的属性的 <see cref="T:System.Windows.DependencyProperty" /> 标识符。</param>
        <summary>如果存在，则返回依赖属性的本地值。</summary>
        <returns>返回本地值，或在未设置本地值的情况下返回 sentinel 值 <see cref="F:System.Windows.DependencyProperty.UnsetValue" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应使用<xref:System.Windows.DependencyObject.GetValue%2A>的依赖属性的最典型的"get"操作。 <xref:System.Windows.DependencyObject.ReadLocalValue%2A> 不会返回很多情况的生效值的值未在本地设置。  
  
 设置的样式、 主题和模板的值，从元数据或属性值继承的默认值是不被视为本地值。 但是，被视为绑定和其他表达式将本地值，在之后进行计算。  
  
 当没有本地值设置时，此方法返回<xref:System.Windows.DependencyProperty.UnsetValue>。  
  
 如果返回的值不是<xref:System.Windows.DependencyProperty.UnsetValue>，可以查询的请求的依赖关系属性，以确定是否存在更具体的类型的返回值可以转换为元数据。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">要设置的依赖属性的标识符。</param>
        <param name="value">新的本地值。</param>
        <summary>设置依赖属性的值而不更改其值源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以编程方式设置但不能禁用应用程序声明的属性使用一个自己的属性的值的组件使用此方法。 <xref:System.Windows.DependencyObject.SetCurrentValue%2A>方法将更改的有效值的属性，但现有的触发器、 数据绑定和样式将继续工作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试修改只读依赖项属性，或尝试修改密封 <see cref="T:System.Windows.DependencyObject" /> 上的属性。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> 的类型不是为 <paramref name="dp" /> 属性注册时使用的正确类型。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>设置依赖属性的本地值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">要设置的依赖属性的标识符。</param>
        <param name="value">新的本地值。</param>
        <summary>设置依赖属性的本地值，该值由其依赖属性标识符指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果提供的类型与声明的依赖项属性为最初注册该类型不匹配，将引发异常。 `value`参数应始终提供为相应的类型。  
  
 异常条件可能会受<xref:System.Windows.DependencyProperty.ValidateValueCallback%2A>位于要设置的依赖项属性的依赖项属性标识符的回调。 否则，提供的值可能会失败 （例如，将字符串传递时的本机类型为 Double） 的一般类型检查条件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试修改只读依赖项属性，或尝试修改密封 <see cref="T:System.Windows.DependencyObject" /> 上的属性。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> 的类型不是为 <paramref name="dp" /> 属性注册时使用的正确类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">要设置的属性的 <see cref="T:System.Windows.DependencyPropertyKey" /> 标识符。</param>
        <param name="value">新的本地值。</param>
        <summary>设置一个只读依赖属性的本地值，该值由依赖属性的 <see cref="T:System.Windows.DependencyPropertyKey" /> 标识符指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你设置由自定义类定义的只读依赖属性的值时，通常使用该签名。 通常情况下，<xref:System.Windows.DependencyObject.SetValue%2A>仅从已注册该依赖项属性，它实现为依赖属性提供确定的值的内部逻辑的类型。 有关详细信息，请参阅[只读依赖属性](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)。  
  
 如果提供的类型与声明的依赖项属性为最初注册该类型不匹配，将引发异常。 `value`参数应始终提供为相应的类型。 异常条件可能会受<xref:System.Windows.DependencyProperty.ValidateValueCallback%2A>位于要设置的依赖项属性的依赖项属性标识符的回调。  
  
   
  
## Examples  
 下面的示例定义只读依赖属性，连同`public static readonly` <xref:System.Windows.DependencyProperty> ，它提供必要只读接触属性的使用者和的 get 访问器[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]包装器。  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">应被序列化的依赖项属性的标识符。</param>
        <summary>返回一个值，该值指示序列化进程是否应序列化所提供的依赖属性的值。</summary>
        <returns>如果应对提供的依赖项属性的值进行序列化，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认实现返回`true`用于所有情况下，在其中一个依赖项属性具有上建立的本地值<xref:System.Windows.DependencyObject>。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>重写此方法可能会以不同方式处理特定的依赖项属性。</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>