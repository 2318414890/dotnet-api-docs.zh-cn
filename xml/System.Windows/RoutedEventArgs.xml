<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b67754600f5ea5cf963bca9d8314062e0287aaae" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55404019" /></Metadata><TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="a6a3f-101">包含与路由事件相关联的状态信息和事件数据。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-101">Contains state information and event data associated with a routed event.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6a3f-102">不同<xref:System.Windows.RoutedEventArgs>可以在单个<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-102">Different <xref:System.Windows.RoutedEventArgs> can be used with a single <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>.</span></span> <span data-ttu-id="a6a3f-103">此类负责打包的事件数据<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>、 提供额外的事件的状态信息，以及由事件系统用于调用处理程序与路由事件相关联。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-103">This class is responsible for packaging the event data for a <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, providing extra event state information, and is used by the event system for invoking the handler associated with the routed event.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a6a3f-104">初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-104">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a6a3f-105">初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-105">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6a3f-106">使用此无参数构造函数、 新的所有公共属性时<xref:System.Windows.RoutedEventArgs>实例假定有以下默认值：</span><span class="sxs-lookup"><span data-stu-id="a6a3f-106">When using this parameterless constructor, all public properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="a6a3f-107"><xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> 默认为`null`。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-107"><xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="a6a3f-108"><xref:System.Windows.RoutedEventArgs.Handled%2A> 默认值为 `false`</span><span class="sxs-lookup"><span data-stu-id="a6a3f-108"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="a6a3f-109"><xref:System.Windows.RoutedEventArgs.Source%2A> 默认为`null`。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-109"><xref:System.Windows.RoutedEventArgs.Source%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="a6a3f-110"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 默认为`null`。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-110"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="a6a3f-111">为空值<xref:System.Windows.RoutedEventArgs.Source%2A>并<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>只意味着<xref:System.Windows.RoutedEventArgs>数据不会尝试指定的源。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-111">Null values for <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> only mean that the <xref:System.Windows.RoutedEventArgs> data makes no attempt to specify the source.</span></span> <span data-ttu-id="a6a3f-112">对的调用中使用此实例时<xref:System.Windows.UIElement.RaiseEvent%2A>，则<xref:System.Windows.RoutedEventArgs.Source%2A>和<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>基于元素引发该事件并将传递到侦听器通过路由填充值。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-112">When this instance is used in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>, the  <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> values are populated based on the element that raised the event and are passed on to listeners through the routing.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="a6a3f-113"><see cref="T:System.Windows.RoutedEventArgs" /> 类的此实例的路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-113">The routed event identifier for this instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></param>
        <summary><span data-ttu-id="a6a3f-114">使用提供的路由事件标识符初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 类的一个新实例。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-114">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class, using the supplied routed event identifier.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6a3f-115">在使用此重载的构造函数时，未指定属性的新<xref:System.Windows.RoutedEventArgs>实例假定有以下默认值：</span><span class="sxs-lookup"><span data-stu-id="a6a3f-115">When using this overloaded constructor, unspecified properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="a6a3f-116"><xref:System.Windows.RoutedEventArgs.Handled%2A> 默认值为 `false`</span><span class="sxs-lookup"><span data-stu-id="a6a3f-116"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="a6a3f-117"><xref:System.Windows.RoutedEventArgs.Source%2A> 默认为`null`。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-117"><xref:System.Windows.RoutedEventArgs.Source%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="a6a3f-118"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 默认为`null`。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-118"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="a6a3f-119">为空值<xref:System.Windows.RoutedEventArgs.Source%2A>并<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>只意味着此<xref:System.Windows.RoutedEventArgs>不会尝试指定的源。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-119">Null values for <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> only mean that this <xref:System.Windows.RoutedEventArgs> makes no attempt to specify the source.</span></span> <span data-ttu-id="a6a3f-120">对的调用中使用此实例时<xref:System.Windows.UIElement.RaiseEvent%2A>，则<xref:System.Windows.RoutedEventArgs.Source%2A>和<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>基于元素引发该事件并将传递到侦听器通过路由填充值。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-120">When this instance is used in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>, the  <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> values are populated based on the element that raised the event and are passed on to listeners through the routing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a6a3f-121">下面的示例构造一个新<xref:System.Windows.RoutedEventArgs>以便在调用中使用<xref:System.Windows.UIElement.RaiseEvent%2A>。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-121">The following example constructs a new <xref:System.Windows.RoutedEventArgs> for use in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>.</span></span>  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="a6a3f-122"><see cref="T:System.Windows.RoutedEventArgs" /> 类的此实例的路由事件标识符。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-122">The routed event identifier for this instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span></span></param>
        <param name="source"><span data-ttu-id="a6a3f-123">将在处理事件时报告的备用源。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-123">An alternate source that will be reported when the event is handled.</span></span> <span data-ttu-id="a6a3f-124">这将预先填充 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 属性。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-124">This pre-populates the <see cref="P:System.Windows.RoutedEventArgs.Source" /> property.</span></span></param>
        <summary><span data-ttu-id="a6a3f-125">使用提供的路由事件标识符初始化 <see cref="T:System.Windows.RoutedEventArgs" /> 类的一个新实例，同时提供为事件另外声明一个源的机会。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-125">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class, using the supplied routed event identifier, and providing the opportunity to declare a different source for the event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6a3f-126">在使用此重载的构造函数时，未指定属性的新<xref:System.Windows.RoutedEventArgs>实例假定有以下默认值：</span><span class="sxs-lookup"><span data-stu-id="a6a3f-126">When using this overloaded constructor, unspecified properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="a6a3f-127"><xref:System.Windows.RoutedEventArgs.Handled%2A> 默认值为 `false`</span><span class="sxs-lookup"><span data-stu-id="a6a3f-127"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="a6a3f-128"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 默认为`null`。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-128"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="a6a3f-129">为空值<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>的元素引发该事件并将其通过路由，将基于填充，但将读取`null`之前调用。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-129">Null values for <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> are populated based on the element that raised the event and passed on through the routing, but will read `null` prior to invocation.</span></span>  
  
 <span data-ttu-id="a6a3f-130">传递时使用此签名<xref:System.Windows.RoutedEventArgs>到虚方法，如<xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>，使用参数来调用<xref:System.Windows.UIElement.RaiseEvent%2A>在内部。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-130">Use this signature when passing <xref:System.Windows.RoutedEventArgs> to virtuals such as <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, where the arguments are used to call <xref:System.Windows.UIElement.RaiseEvent%2A> internally.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a6a3f-131">获取或设置一个值，该值指示针对路由事件（在其经过路由时）的事件处理的当前状态。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-131">Gets or sets a value that indicates the present state of the event handling for a routed event as it travels the route.</span></span></summary>
        <value><span data-ttu-id="a6a3f-132">如果设置，将设置为<see langword="true" />事件将标记为已处理; 否则为如果<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-132">If setting, set to <see langword="true" /> if the event is to be marked handled; otherwise <see langword="false" />.</span></span> <span data-ttu-id="a6a3f-133">如果读取此值，<see langword="true" />指示的类处理程序或沿路由的某个实例处理程序具有已标记为处理此事件。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-133">If reading this value, <see langword="true" /> indicates that either a class handler, or some instance handler along the route, has already marked this event handled.</span></span> <span data-ttu-id="a6a3f-134"><see langword="false" />.指示没有这类处理程序将该事件标记为已处理。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-134"><see langword="false" />.indicates that no such handler has marked the event handled.</span></span>  
  
<span data-ttu-id="a6a3f-135">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-135">The default value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6a3f-136">将标记为处理的事件将限制到侦听器为由事件路由的路由事件的可见性。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-136">Marking the event handled will limit the visibility of the routed event to listeners along the event route.</span></span> <span data-ttu-id="a6a3f-137">该事件仍经过路由的其余部分，但仅处理程序明确添加的其`HandledEventsToo``true`中<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>方法调用将调用以响应。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-137">The event does still travel the remainder of the route, but only handlers specifically added with `HandledEventsToo` `true` in the <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> method call will be invoked in response.</span></span> <span data-ttu-id="a6a3f-138">默认实例侦听器上的处理程序 (如那些表示[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) 将不会调用。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-138">Default handlers on instance listeners (such as those expressed in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) will not be invoked.</span></span> <span data-ttu-id="a6a3f-139">处理标记为已处理的事件不是一种常见方案。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-139">Handling events that are marked handled is not a common scenario.</span></span>  
  
 <span data-ttu-id="a6a3f-140">如果您是控件作者定义你自己的事件，所做的决策有关事件在类级别的处理会影响控件的用户以及派生控件的所有用户和可能是其他元素所包含的控件或包含您的控件。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-140">If you are a control author defining your own events, the decisions you make regarding event handling at the class level will impact users of your control as well as any users of derived controls, and potentially other elements that are either contained by your control or that contain your control.</span></span> <span data-ttu-id="a6a3f-141">有关详细信息，请参阅[将路由事件标记为“已处理”和类处理](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-141">For more information, see [Marking Routed Events as Handled, and Class Handling](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
 <span data-ttu-id="a6a3f-142">在极少数情况下非常适合处理其中<xref:System.Windows.RoutedEventArgs.Handled%2A>标记`true`，并通过更改来修改事件参数<xref:System.Windows.RoutedEventArgs.Handled%2A>到`false`。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-142">In very rare circumstances it is appropriate to handle events where  <xref:System.Windows.RoutedEventArgs.Handled%2A> is marked `true`, and modify the event arguments by changing <xref:System.Windows.RoutedEventArgs.Handled%2A> to `false`.</span></span> <span data-ttu-id="a6a3f-143">这可能是必需的输入事件的控件，如密钥处理的某些区域中<xref:System.Windows.UIElement.KeyDown>与<xref:System.Windows.UIElement.TextInput>，低级别和高级别输入的事件会争用处理，以及每个正在尝试使用不同的路由策略。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-143">This can be necessary in certain areas of input events of controls, such as key handling of <xref:System.Windows.UIElement.KeyDown> versus <xref:System.Windows.UIElement.TextInput> where low level and high level input events compete for the handling, and each is attempting to work with a different routing strategy.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a6a3f-144">下面的示例实现事件处理程序中用于标记处理的事件。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-144">The following example implements an event handler that marks the event handled.</span></span>  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler"><span data-ttu-id="a6a3f-145">要调用的泛型处理程序/委托实现。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-145">The generic handler / delegate implementation to be invoked.</span></span></param>
        <param name="genericTarget"><span data-ttu-id="a6a3f-146">应在其上调用所提供的处理程序的目标。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-146">The target on which the provided handler should be invoked.</span></span></param>
        <summary><span data-ttu-id="a6a3f-147">当在派生类中重写时，提供特定于类型的调用事件处理程序的方式，该方式与基实现相比可提高效率。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-147">When overridden in a derived class, provides a way to invoke event handlers in a type-specific way, which can increase efficiency over the base implementation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6a3f-148">基实现合并了反射来确定正确的处理程序的任何情况下，该处理程序不是按字面意思<xref:System.Windows.RoutedEventHandler>，并且此反射步骤具有一些性能产生负面影响。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-148">The base implementation incorporates reflection to determine the right handler for any case where the handler is not literally <xref:System.Windows.RoutedEventHandler>, and this reflection step does have some performance consequences.</span></span> <span data-ttu-id="a6a3f-149">调用可以进行更高效通过不依赖于反射。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-149">Invocations can be made more efficient by not relying on reflection.</span></span> <span data-ttu-id="a6a3f-150">这是使得此方法可用于选择要将其重写任何路由的事件参数类的方案。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-150">This is the scenario that motivates this method being available for any routed event arguments class that choose to override it.</span></span> <span data-ttu-id="a6a3f-151">实现不应调用基针对此方法，因为您的实现应负责调用类型安全处理程序。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-151">Implementations should not call the base for this method, because your implementation should already be responsible for invoking the type safe handlers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a6a3f-152">下面是伪代码说明了可用于实现的基本模式。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-152">The following is pseudocode that illustrates a basic pattern that can be used for implementation.</span></span> <span data-ttu-id="a6a3f-153">在这里，`MyRoutedEventHandler`是一个的子类<xref:System.Windows.RoutedEventHandler>。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-153">Here, `MyRoutedEventHandler` is a subclass of <xref:System.Windows.RoutedEventHandler>.</span></span>  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="a6a3f-154">此方法旨在由派生的事件数据类以提供更有效地调用其委托的重写。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-154">This method is intended to be overridden by derived event data classes to provide more efficient invocation of their delegates.</span></span> <span data-ttu-id="a6a3f-155">实现应强制转换提供<paramref name="genericHandler" />到特定于类型的委托，，然后调用该处理程序。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-155">The implementation should cast the provided <paramref name="genericHandler" /> to the type-specific delegate, and then invoke that handler.</span></span>  
  
<span data-ttu-id="a6a3f-156">默认实现将尝试调用提供处理程序，尝试将其转换为<see cref="T:System.Windows.RoutedEventHandler" />。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-156">The default implementation will attempt to invoke the provided handler, attempting to cast it as <see cref="T:System.Windows.RoutedEventHandler" />.</span></span> <span data-ttu-id="a6a3f-157">如果任一<paramref name="genericHandler" />或<paramref name="genericTarget" />作为提供<see langword="null" />，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-157">If either <paramref name="genericHandler" /> or <paramref name="genericTarget" /> is provided as <see langword="null" />, exceptions will be raised.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a6a3f-158"><see cref="P:System.Windows.RoutedEventArgs.Source" /> 所设置为的新值。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-158">The new value that <see cref="P:System.Windows.RoutedEventArgs.Source" /> is being set to.</span></span></param>
        <summary><span data-ttu-id="a6a3f-159">在派生类中重写时，每当实例的 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 属性的值发生更改，则提供一个通知回调入口点。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-159">When overridden in a derived class, provides a notification callback entry point whenever the value of the <see cref="P:System.Windows.RoutedEventArgs.Source" /> property of an instance changes.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="a6a3f-160">以编程方式更改报告的事件源可能需要更新事件中的特定于类型的数据。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-160">Changing the reported source of an event programmatically can potentially require updating the type-specific data within the event.</span></span> <span data-ttu-id="a6a3f-161">出于此原因，<see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />方法受保护的虚拟，应由的子类中重写<see cref="T:System.Windows.RoutedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-161">For this reason, the <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> method is protected virtual and is intended to be overridden by subclasses of <see cref="T:System.Windows.RoutedEventArgs" />.</span></span>  
  
<span data-ttu-id="a6a3f-162">此方法具有默认实现。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-162">This method has no default implementation.</span></span></para></block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a6a3f-163">在父类进行任何可能的 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 调整之前，获取由纯命中测试确定的原始报告源。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-163">Gets the original reporting source as determined by pure hit testing, before any possible <see cref="P:System.Windows.RoutedEventArgs.Source" /> adjustment by a parent class.</span></span></summary>
        <value><span data-ttu-id="a6a3f-164">在类处理可能对展平复合元素树进行任何 <see cref="P:System.Windows.RoutedEventArgs.Source" /> 调整之前的原始报告源。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-164">The original reporting source, before any possible <see cref="P:System.Windows.RoutedEventArgs.Source" /> adjustment made by class handling, which may have been done to flatten composited element trees.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6a3f-165">之前类事件处理程序或任何实例处理程序调用，并永远不会调整忽略这一点后，将此属性获取其值。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-165">This property acquires its value once, before the class event handlers or any instance handlers are invoked, and is never adjusted past this point.</span></span> <span data-ttu-id="a6a3f-166">原始的源信息是只读的类处理程序或类实现中，就像它在事件数据中报告。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-166">The original source information is read-only to class handlers or class implementations, just as it is reported in the event data.</span></span>  
  
 <span data-ttu-id="a6a3f-167">常见的情况下可能会进行调整源，其中包含控件的内容模型内的内容元素 (的列表项，例如，内容将报告作为列表项元素<xref:System.Windows.RoutedEventArgs.Source%2A>和列表项中的实际元素将是<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.</span><span class="sxs-lookup"><span data-stu-id="a6a3f-167">Common cases where the source may be adjusted include content elements inside a content model for a control (the contents of a list item, for instance, will report the list item element as the <xref:System.Windows.RoutedEventArgs.Source%2A> and the actual element within the list item will be the <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.</span></span>  
  
 <span data-ttu-id="a6a3f-168">各种元素和内容模型的源调整各不相同类的。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-168">Source adjustment by various elements and content models varies from class to class.</span></span> <span data-ttu-id="a6a3f-169">调整事件源的每个类尝试预测哪个源是最有用报告为大多数输入的方案和类所针对的方案，然后将该源作为<xref:System.Windows.RoutedEventArgs.Source%2A>。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-169">Each class that adjusts event sources attempts to anticipate which source is the most useful to report for most input scenarios and the scenarios for which the class is intended, and then sets that source as the <xref:System.Windows.RoutedEventArgs.Source%2A>.</span></span> <span data-ttu-id="a6a3f-170">如果此源不是已处理事件的相关，请尝试检查<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>改为以确定它是否报告更适合的不同源。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-170">If this source is not the one that has relevance to your handling of the event, try checking <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> instead to see if it reports a different source that is more suitable.</span></span> <span data-ttu-id="a6a3f-171">输入事件的更多详细信息，请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-171">For more details on input events, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a6a3f-172">获取或设置与此 <see cref="T:System.Windows.RoutedEventArgs" /> 实例关联的 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-172">Gets or sets the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> associated with this <see cref="T:System.Windows.RoutedEventArgs" /> instance.</span></span></summary>
        <value><span data-ttu-id="a6a3f-173">已调用的事件的标识符。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-173">The identifier for the event that has been invoked.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6a3f-174">不能将此值设置上<xref:System.Windows.RoutedEventArgs>，已经传送 （例如，如果获得通过处理程序自变量）。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-174">You cannot set this value on a <xref:System.Windows.RoutedEventArgs> that has already been routed (for instance, if you obtained the arguments through a handler).</span></span> <span data-ttu-id="a6a3f-175">尝试执行此操作将生成一个异常。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-175">Attempting to do so will generate an exception.</span></span> <span data-ttu-id="a6a3f-176">你仅可以将其设置未尚未使用生成的事件调用的实例上。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-176">You can only set it on an instance that has not yet been used to generate an invocation of the event.</span></span>  
  
 <span data-ttu-id="a6a3f-177">值<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>不能为`null`在任何时间。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-177">The value of <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> cannot be `null` at any time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a6a3f-178">下面的示例使用一个初始的构造函数创建新的路由的事件数据，然后设置<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>属性用作后续操作。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-178">The following example creates new routed event data with an initial constructor and then sets the <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> property as a subsequent operation.</span></span> <span data-ttu-id="a6a3f-179">您必须具有<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>引发路由的事件之前设置。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-179">You must have <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> set prior to raising the routed event.</span></span>  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a6a3f-180">在路由事件时试图更改 <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 值。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-180">Attempted to change the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> value while the event is being routed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a6a3f-181">获取或设置对引发事件的对象的引用。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-181">Gets or sets a reference to the object that raised the event.</span></span></summary>
        <value><span data-ttu-id="a6a3f-182">引发事件的对象。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-182">The object that raised the event.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a6a3f-183">对于任何浮升路由事件的实际经过引发，它的元素之外的路由，并为任何隧道路由事件不具有尚未挖掘引发它的值的元素到<xref:System.Windows.RoutedEventArgs.Source%2A>的值与不同`sender`参数的事件参数类。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-183">For any bubbling routed event that has actually traveled the route beyond the element that raised it, and for any tunneling routed event that has not yet tunneled down to the element that raised it, the value of <xref:System.Windows.RoutedEventArgs.Source%2A> will be different than the value of the `sender` parameter of the event arguments class.</span></span> <span data-ttu-id="a6a3f-184">这两个元素的事件中涉及到在任何给定的处理程序中最重要的是 (<xref:System.Windows.RoutedEventArgs.Source%2A>，引发它，该元素或`sender`，当前正在处理它的元素) 取决于您的处理程序的应用程序逻辑寻址。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-184">Which of the two elements involved in the event is of the most importance in any given handler (<xref:System.Windows.RoutedEventArgs.Source%2A>, the element that raised it, or `sender`, the element that is currently handling it) is dependent on the application logic that your handler is addressing.</span></span>  
  
 <span data-ttu-id="a6a3f-185">设置此属性通常只是当重写或实现其他[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]调整事件源，例如类处理事件。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-185">Setting this property is typically only done when overriding or implementing other [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] that adjust event sources, such as when class handling an event.</span></span> <span data-ttu-id="a6a3f-186">不建议重置从实例处理程序的明显的事件源，尤其是在处理程序不会不将事件标记为已处理时。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-186">Resetting apparent event sources from instance handlers is not recommended, particularly when the handler does not mark the event as handled.</span></span>  
  
 <span data-ttu-id="a6a3f-187">如果执行重置<xref:System.Windows.RoutedEventArgs.Source%2A>报告不同的事件源<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>将继续的报告作为第一个源引发的起源<xref:System.Windows.UIElement.RaiseEvent%2A>调用。</span><span class="sxs-lookup"><span data-stu-id="a6a3f-187">If you do reset <xref:System.Windows.RoutedEventArgs.Source%2A> to report a different event source, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> will continue to report the source as first raised by the originating <xref:System.Windows.UIElement.RaiseEvent%2A> call.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>