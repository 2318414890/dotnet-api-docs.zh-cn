<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="StructLayoutAttribute.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac540521d9554f0cf59a81ca8f000f7fb5aa654a557.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">40521d9554f0cf59a81ca8f000f7fb5aa654a557</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Lets you control the physical layout of the data fields of a class or structure in memory.</source>
          <target state="translated">允许你控制内存中类或结构的数据字段的物理布局。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>You can apply this attribute to classes or structures.</source>
          <target state="translated">可以将此特性应用于类或结构。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>The common language runtime controls the physical layout of the data fields of a class or structure in managed memory.</source>
          <target state="translated">公共语言运行时控制类或结构在托管内存中的数据字段的物理布局。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>However, if you want to pass the type to unmanaged code, you can use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute to control the unmanaged layout of the type.</source>
          <target state="translated">但是，如果你想要将类型传递到非托管代码，你可以使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>属性控制的非托管的类型的布局。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Use the attribute with <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> to force the members to be laid out sequentially in the order they appear.</source>
          <target state="translated">属性适用的<ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>强制要按照它们出现的顺序依次布局的成员。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>For , <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> controls both the layout in managed memory and the layout in unmanaged memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>控制两个在托管内存中的布局和非托管内存中的布局。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>For non-blittable types, it controls the layout when the class or structure is marshaled to unmanaged code, but does not control the layout in managed memory.</source>
          <target state="translated">对于非本机结构中的类型，它控制的布局的类或结构封送到非托管代码，但不控制在托管内存中的布局。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Use the attribute with <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> to control the precise position of each data member.</source>
          <target state="translated">属性适用的<ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph>来控制每个数据成员的精确位置。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>This affects both managed and unmanaged layout, for both blittable and non-blittable types.</source>
          <target state="translated">这会影响托管和非托管的布局，本机结构中和非本机结构中的类型。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Using <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> requires that you use the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.FieldOffsetAttribute&gt;</ph> attribute to indicate the position of each field within the type.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph>要求你使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.FieldOffsetAttribute&gt;</ph>特性以指示类型中每个字段的位置。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>C#, Visual Basic, and C++ compilers apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential&gt;</ph> layout value to structures by default.</source>
          <target state="translated">C#、 Visual Basic 和 c + + 编译器应用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential&gt;</ph>到结构默认情况下的布局值。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>For classes, you must apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> value explicitly.</source>
          <target state="translated">对于类，则必须将应用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>显式值。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> also applies the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute; it always applies the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> value when it imports a type library.</source>
          <target state="translated"><bpt id="p1">[</bpt>Tlbimp.exe （类型库导入程序）<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept>也适用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>特性; 它始终应用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>值导入类型库时。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>The following example demonstrates a managed declaration of the <ph id="ph1">`GetSystemTime`</ph> function and defines <ph id="ph2">`MySystemTime`</ph> class with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> layout.</source>
          <target state="translated">下面的示例演示的托管的声明<ph id="ph1">`GetSystemTime`</ph>函数，并定义<ph id="ph2">`MySystemTime`</ph>类，该类具有<ph id="ph3">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph>布局。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source><ph id="ph1">`GetSystemTime`</ph> gets the system time and prints to the console.</source>
          <target state="translated"><ph id="ph1">`GetSystemTime`</ph> 获取系统时间，并输出到控制台。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.StructLayoutAttribute">
          <source>Initalizes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> class.</source>
          <target state="translated">初始化 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)">
          <source>A 16-bit integer that represents one of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> values that specifes how the class or structure should be arranged.</source>
          <target state="translated">表示 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> 值之一的 16 位整数，指定应该如何排列类或结构。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)">
          <source>Initalizes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> class with the specified <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> enumeration member.</source>
          <target state="translated">用指定的 <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> 枚举成员初始化 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)">
          <source>This constructor takes an underlying 16-bit integer that represents each <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind&gt;</ph> enumeration member.</source>
          <target state="translated">此构造函数采用一个基础的 16 位整数，表示每个<ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind&gt;</ph>枚举成员。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> uses this constructor.</source>
          <target state="translated"><bpt id="p1">[</bpt>Tlbimp.exe （类型库导入程序）<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept>使用此构造函数。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)">
          <source>One of the enumeration values that specifes how the class or structure should be arranged.</source>
          <target state="translated">枚举值之一，指定应该如何排列类或结构。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)">
          <source>Initalizes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> class with the specified <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> enumeration member.</source>
          <target state="translated">用指定的 <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> 枚举成员初始化 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> 类的新实例。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)">
          <source>For readable code that is less prone to error, always use this constructor.</source>
          <target state="translated">有关可读的代码是更不易出错，请始终使用此构造函数。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet">
          <source>Indicates whether string data fields within the class should be marshaled as <ph id="ph1">&lt;see langword="LPWSTR" /&gt;</ph> or <ph id="ph2">&lt;see langword="LPSTR" /&gt;</ph> by default.</source>
          <target state="translated">指示在默认情况下是否应将类中的字符串数据字段作为 <ph id="ph1">&lt;see langword="LPWSTR" /&gt;</ph> 或 <ph id="ph2">&lt;see langword="LPSTR" /&gt;</ph> 进行封送处理。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet">
          <source>If the <ph id="ph1">`CharSet`</ph> field is set to <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CharSet.Unicode?displayProperty=nameWithType&gt;</ph>, all string arguments are converted to Unicode characters (<ph id="ph3">`LPWSTR`</ph>) before they are passed to the unmanaged implementation.</source>
          <target state="translated">如果<ph id="ph1">`CharSet`</ph>字段设置为<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CharSet.Unicode?displayProperty=nameWithType&gt;</ph>，所有字符串自变量都转换为 Unicode 字符 (<ph id="ph3">`LPWSTR`</ph>) 它们传递给非托管实现之前。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet">
          <source>If the field is set to <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet.Ansi?displayProperty=nameWithType&gt;</ph>, the strings are converted to ANSI strings (<ph id="ph2">`LPSTR`</ph>).</source>
          <target state="translated">如果字段设置为<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet.Ansi?displayProperty=nameWithType&gt;</ph>，将字符串转换为 ANSI 字符串 (<ph id="ph2">`LPSTR`</ph>)。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet">
          <source>If the <ph id="ph1">`CharSet`</ph> field is set to <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CharSet.Auto?displayProperty=nameWithType&gt;</ph>, the conversion is platform-dependent (ANSI on Windows 98 and Windows Me, and Unicode on later versions).</source>
          <target state="translated">如果<ph id="ph1">`CharSet`</ph>字段设置为<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CharSet.Auto?displayProperty=nameWithType&gt;</ph>，转换是与平台相关 (在 Windows 98 和 Windows Me，和更高版本上的为 Unicode 的 ANSI)。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Controls the alignment of data fields of a class or structure in memory.</source>
          <target state="translated">控制类或结构的数据字段在内存中的对齐方式。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> field controls the alignment of a type's fields in memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph>字段控制的类型的字段在内存中的对齐方式。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>It affects both <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">它会同时影响<ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>By default, the value is 0, indicating the default packing size for the current platform.</source>
          <target state="translated">默认情况下，值为 0，表示默认包装当前平台的大小。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The value of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> must be 0, 1, 2, 4, 8, 16, 32, 64, or 128:</source>
          <target state="translated">值<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph>必须是 0、 1、 2、 4、 8、 16、 32、 64 或 128:</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The fields of a type instance are aligned by using the following rules:</source>
          <target state="translated">通过使用以下规则对齐的类型实例的字段：</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The alignment of the type is the size of its largest element (1, 2, 4, 8, etc., bytes) or the specified packing size, whichever is smaller.</source>
          <target state="translated">类型的对齐方式是其最大元素的大小 (1、 2、 4、 8 等，字节) 或指定的封装大小，以二者中较小者为准。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Each field must align with fields of its own size (1, 2, 4, 8, etc., bytes) or the alignment of the type, whichever is smaller.</source>
          <target state="translated">每个字段必须符合其自身的大小的字段 (1、 2、 4、 8，等等，字节) 的对齐方式的类型，或两者中较小。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Because the default alignment of the type is the size of its largest element, which is greater than or equal to all other field lengths, this usually means that fields are aligned by their size.</source>
          <target state="translated">因为类型的默认对齐方式是其最大元素，它是大于或等于所有其他字段长度，大小通常意味着字段通过其大小对齐。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>For example, even if the largest field in a type is a 64-bit (8-byte) integer or the Pack field is set to 8, <ph id="ph1">&lt;xref:System.Byte&gt;</ph> fields align on 1-byte boundaries, <ph id="ph2">&lt;xref:System.Int16&gt;</ph> fields align on 2-byte boundaries, and <ph id="ph3">&lt;xref:System.Int32&gt;</ph> fields align on 4-byte boundaries.</source>
          <target state="translated">例如，即使中一种类型的最大字段的 64 位 （8 字节） 整数或包字段设置为 8， <ph id="ph1">&lt;xref:System.Byte&gt;</ph> 1 字节边界上对齐字段<ph id="ph2">&lt;xref:System.Int16&gt;</ph>在 2 字节边界上对齐字段和<ph id="ph3">&lt;xref:System.Int32&gt;</ph>字段与 4 字节边界对齐。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Padding is added between fields to satisfy the alignment requirements.</source>
          <target state="translated">若要满足的对齐需求的字段之间会添加填充。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>For example, consider the following structure, which consists of two <ph id="ph1">&lt;xref:System.Byte&gt;</ph> fields and one <ph id="ph2">&lt;xref:System.Int32&gt;</ph> field, when it is used with various values for the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> field.</source>
          <target state="translated">例如，考虑以下结构，包含两个<ph id="ph1">&lt;xref:System.Byte&gt;</ph>字段和一个<ph id="ph2">&lt;xref:System.Int32&gt;</ph>字段，它使用的各个值时<ph id="ph3">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph>字段。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>To successfully compile the C# examples, you must specify the <ph id="ph1">`/unsafe`</ph> compiler switch.</source>
          <target state="translated">若要成功编译的 C# 示例，必须指定<ph id="ph1">`/unsafe`</ph>编译器开关。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If you specify the default packing size, the size of the structure is 8 bytes.</source>
          <target state="translated">如果你指定默认包装大小，结构的大小是 8 个字节。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The two bytes occupy the first two bytes of memory, because bytes must align on one-byte boundaries.</source>
          <target state="translated">因为字节必须与单字节边界对齐，则两个字节占用的内存，前两个字节。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Because the default alignment of the type is 4 bytes, which is the size of its largest fields, <ph id="ph1">`i3`</ph>, there are two bytes of padding followed by the integer field.</source>
          <target state="translated">类型的默认对齐方式为 4 个字节，即其最大字段的大小，因为<ph id="ph1">`i3`</ph>，有两个字节的跟整数字段的填充。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 2, the size of the structure is 6 bytes.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph>设置为 2，结构的大小为 6 个字节。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>As before, the two bytes occupy the first two bytes of memory.</source>
          <target state="translated">为之前，两个字节都占用内存的前两个字节。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Because fields now align on 2-byte boundaries, there is no padding between the second byte and the integer.</source>
          <target state="translated">因为字段现在将在 2 字节边界上对齐，则不填充第二个字节和整数之间。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 4, the size of the structure is the same as in the default case, where the type's alignment was defined by the size of its largest field, <ph id="ph2">`i3`</ph>, which is 4.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph>设置为 4，结构的大小是默认情况下，其最大字段大小定义该类型的对齐方式的位置，与相同<ph id="ph2">`i3`</ph>，为 4。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 8, the size of the structure is the still same as in the default case, because the <ph id="ph2">`i3`</ph> field aligns on a 4-byte boundary, which is smaller than the 8-byte boundary specified by the Pack field.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph>设置为 8，结构的大小是仍然与默认值相同，则用例因为<ph id="ph2">`i3`</ph>字段对齐的 4 字节边界，即小于按包字段指定的 8 字节边界上。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>To take another example, consider the following structure, which consists of two byte fields, one 32-bit signed integer field, one single-element byte array, and a decimal value.</source>
          <target state="translated">若要另一个示例，请考虑以下结构，其中包含两个字节字段、 一个 32 位有符号的整数字段、 一个单元素字节数组和一个十进制值。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>With the default packing size, the size of the structure is 28 bytes.</source>
          <target state="translated">与默认包装大小，结构的大小为 28 个字节。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The two bytes occupy the first two bytes of memory, followed by two bytes of padding, followed by the integer.</source>
          <target state="translated">两个字节占用的内存，跟两个字节填充，跟整数的前两个字节。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Next is the one-byte array, followed by three bytes of padding.</source>
          <target state="translated">接下来是一个字节数组，跟个填充的三个字节。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> field, d5, aligns on a 4-byte boundary because a decimal value consists of four <ph id="ph2">&lt;xref:System.Int32&gt;</ph> fields, so its alignment is based on the size of the largest of its fields rather than on the size of the <ph id="ph3">&lt;xref:System.Decimal&gt;</ph> structure as a whole.</source>
          <target state="translated">最后，<ph id="ph1">&lt;xref:System.Decimal&gt;</ph>因为十进制值包含以下四个字段，d5，对齐 4 字节边界上<ph id="ph2">&lt;xref:System.Int32&gt;</ph>字段，因此它的对齐基于的最大大小其字段的而不是上的大小<ph id="ph3">&lt;xref:System.Decimal&gt;</ph>作为一个整体的结构。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 2, the size of the structure is 24 bytes.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph>设置为 2，结构的大小为 24 字节。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>In comparison with the default alignment, the two bytes of padding between the two bytes and the integer have been removed because the type's alignment is now 4 rather than 2.</source>
          <target state="translated">默认的对齐方式，比较两个字节和整数之间的填充两个字节已被删除，因为该类型的对齐方式现在为 4，而不是 2。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>And the three bytes of padding after <ph id="ph1">`a4`</ph> have been replaced by one byte of padding, since <ph id="ph2">`d5`</ph> now aligns on a 2-byte boundary rather than a 4-byte boundary.</source>
          <target state="translated">和后填充三个字节<ph id="ph1">`a4`</ph>已替换为一个字节的填充，因为<ph id="ph2">`d5`</ph>现在将在 2 字节边界，而不是 4 字节边界上对齐。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>If <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 8, the size of the structure is the same as in the default case, because all the alignment requirements in this structure are less than 8.</source>
          <target state="translated">如果<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph>设置结构的大小为 8，是默认情况下，与相同因为此结构中的所有对齐需求小于 8。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> field is frequently used when structures are exported during disk and network write operations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph>结构导出期间磁盘和网络写入操作时，经常使用字段。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>The field is also frequently used during platform invoke and interop operations.</source>
          <target state="translated">也经常使用此字段来在平台调用和互操作的操作。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>Occasionally, the field is used to reduce memory requirements by producing a tighter packing size.</source>
          <target state="translated">有时，字段将用于通过生成更严苛的封装大小减少内存需求。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">
          <source>However, this usage requires careful consideration of actual hardware constraints, and may actually degrade performance.</source>
          <target state="translated">但是，这种用法需要仔细考虑的实际硬件约束，并且可能实际上会降低性能。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Size">
          <source>Indicates the absolute size of the class or structure.</source>
          <target state="translated">指示类或结构的绝对大小。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Size">
          <source>This field must be equal or greater than the total size, in bytes, of the members of the class or structure.</source>
          <target state="translated">此字段必须等于或大于的总大小，以字节为单位的类或结构的成员。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Size">
          <source>This field is primarily for compiler writers who want to extend the memory occupied by a structure for direct, unmanaged access.</source>
          <target state="translated">此字段为主要用于编译器编写人员想要扩展的非托管的直接访问结构占用的内存。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.StructLayoutAttribute.Size">
          <source>For example, you can use this field when working with unions that are not represented in metadata directly.</source>
          <target state="translated">例如，你可以在不直接表示元数据中的联合处理时使用此字段。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="P:System.Runtime.InteropServices.StructLayoutAttribute.Value">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> value that specifies how the class or structure is arranged.</source>
          <target state="translated">获取 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.LayoutKind" /&gt;</ph> 值，该值指定如何排列类或结构。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.StructLayoutAttribute.Value">
          <source>One of the enumeration values that specifies how the class or structure is arranged.</source>
          <target state="translated">枚举值之一，指定如何排列类或结构。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>