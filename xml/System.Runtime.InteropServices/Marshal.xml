<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Marshal.xml" source-language="en-US" target-language="zh-CN">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5b582e89d8a536a45d26354652aab5d4e97b21f0f.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b582e89d8a536a45d26354652aab5d4e97b21f0f</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Provides a collection of methods for allocating unmanaged memory, copying unmanaged memory blocks, and converting managed to unmanaged types, as well as other miscellaneous methods used when interacting with unmanaged code.</source>
          <target state="translated">提供了一个方法集合，这些方法用于分配非托管内存、复制非托管内存块、将托管类型转换为非托管类型，此外还提供了在与非托管代码交互时使用的其他杂项方法。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.Marshal">
          <source>The <ph id="ph1">`static`</ph> methods defined on the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class are essential to working with unmanaged code.</source>
          <target state="translated"><ph id="ph1">`static`</ph>上定义的方法<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph>类至关重要处理非托管代码。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Most methods defined in this class are typically used by developers who want to provide a bridge between the managed and unmanaged programming models.</source>
          <target state="translated">此类中定义的大多数方法通常在开发人员想要提供的托管和非托管编程模型之间的桥梁。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.Marshal">
          <source>For example, the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A&gt;</ph> method copies ANSI characters from a specified string (in the managed heap) to a buffer in the unmanaged heap.</source>
          <target state="translated">例如，<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A&gt;</ph>方法将 ANSI 字符 （中托管的堆） 的指定字符串复制到非托管堆中的缓冲区。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.Marshal">
          <source>It also allocates the target heap of the right size.</source>
          <target state="translated">它还分配适当大小的目标堆。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.Marshal">
          <source>The common language runtime provides specific marshaling capabilities.</source>
          <target state="translated">公共语言运行时提供了特定的封送处理功能。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.Marshal">
          <source>For details on marshaling behavior, see <bpt id="p1">[</bpt>Interop Marshaling<ept id="p1">](~/docs/framework/interop/interop-marshaling.md)</ept>.</source>
          <target state="translated">有关封送处理行为的详细信息，请参阅<bpt id="p1">[</bpt>互操作封送处理<ept id="p1">](~/docs/framework/interop/interop-marshaling.md)</ept>。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.Marshal">
          <source>The <ph id="ph1">`Read`</ph> and <ph id="ph2">`Write`</ph> methods in the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class support both aligned and unaligned access.</source>
          <target state="translated"><ph id="ph1">`Read`</ph>和<ph id="ph2">`Write`</ph>中的方法<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph>类支持对齐且未对齐的访问。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.Marshal">
          <source>The following example shows how to use various methods defined by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">下面的示例演示如何使用由定义的各种方法<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>The interface reference count to increment.</source>
          <target state="translated">要递增的接口引用计数。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>Increments the reference count on the specified interface.</source>
          <target state="translated">递增指定接口上的引用计数。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>The new value of the reference count on the <ph id="ph1">&lt;paramref name="pUnk" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pUnk" /&gt;</ph> 参数上的引用计数的新值。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>The common language runtime manages the reference count of a COM object for you, making it unnecessary to use this method directly.</source>
          <target state="translated">公共语言运行时管理 COM 对象的引用计数，这样就无需直接使用此方法。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>In rare cases, such as testing a custom marshaler, you might find it necessary to manipulate an object's lifetime manually.</source>
          <target state="translated">在极少数情况下，例如测试自定义封送处理程序，你可能会发现需要手动操作对象的生存期。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>After calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A&gt;</ph>, you must decrement the reference count by using a method such as <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">在调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A&gt;</ph>，必须使用一种方法类似于递减引用计数<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>Do not rely on the return value of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A&gt;</ph>, as it can sometimes be unstable.</source>
          <target state="translated">不要依赖于的返回值<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A&gt;</ph>，因为它有时会不稳定。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>You can call <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType&gt;</ph> to obtain an <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph> value that represents an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface pointer.</source>
          <target state="translated">你可以调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType&gt;</ph>， <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType&gt;</ph>，或<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType&gt;</ph>获取<ph id="ph4">&lt;xref:System.IntPtr&gt;</ph>值，该值表示<bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept>接口指针。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>You can also use these methods and the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A&gt;</ph> method on managed objects to obtain the COM interfaces represented by the managed object's COM callable wrapper.</source>
          <target state="translated">你还可以使用这些方法和<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A&gt;</ph>方法要获取由托管的对象的 COM 可调用包装的 COM 接口的托管对象。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>If you are not familiar with the details of this wrapper type, see <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>.</source>
          <target state="translated">如果你不熟悉此包装类型的详细信息，请参阅<bpt id="p1">[</bpt>COM 可调用包装<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source>The size of the block of memory to be allocated.</source>
          <target state="translated">要分配的内存块的大小。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source>Allocates a block of memory of specified size from the COM task memory allocator.</source>
          <target state="translated">从 COM 任务内存分配器分配指定大小的内存块。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source>An integer representing the address of the block of memory allocated.</source>
          <target state="translated">一个整数，表示分配的内存块的地址。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source>This memory must be released with <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">必须使用 <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" /&gt;</ph> 释放该内存。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph> is one of two memory allocation API methods in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph> 是一个两个内存分配中的 API 方法<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source>(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType&gt;</ph> is the other.) The initial memory content returned is undefined, and the allocated memory can be larger than the requested number of bytes.</source>
          <target state="translated">(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType&gt;</ph>是另。)返回的初始内存内容是不确定，并分配的内存可能会大于请求的字节数。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source>This method exposes the COM <bpt id="p1">[</bpt>CoTaskMemAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148626)</ept> function, which is referred to as the COM task memory allocator.</source>
          <target state="translated">此方法公开 COM <bpt id="p1">[</bpt>CoTaskMemAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148626)</ept>函数，称为 COM 任务内存分配器。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source>There is insufficient memory to satisfy the request.</source>
          <target state="translated">没有足够的内存来满足该请求。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Allocates memory from the unmanaged memory of the process.</source>
          <target state="translated">从进程的非托管内存中分配内存。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>The required number of bytes in memory.</source>
          <target state="translated">内存中的所需字节数。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>Allocates memory from the unmanaged memory of the process by using the specified number of bytes.</source>
          <target state="translated">通过使用指定的字节数，从进程的非托管内存中分配内存。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>A pointer to the newly allocated memory.</source>
          <target state="translated">指向新分配的内存的指针。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>This memory must be released using the <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /&gt;</ph> method.</source>
          <target state="translated">必须使用 <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /&gt;</ph> 方法释放该内存。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> is one of two memory allocation methods in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> 是中的两个内存分配方法之一<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType&gt;</ph> is the other.) This method exposes the Win32 <bpt id="p1">[</bpt>LocalAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148628)</ept> function from Kernel32.dll.</source>
          <target state="translated">(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType&gt;</ph>是另。)此方法公开 Win32 <bpt id="p1">[</bpt>LocalAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148628)</ept>从 Kernel32.dll 函数。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>When <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> calls <ph id="ph2">`LocalAlloc`</ph>, it passes a <ph id="ph3">`LMEM_FIXED`</ph> flag, which causes the allocated memory to be locked in place.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph>调用<ph id="ph2">`LocalAlloc`</ph>，它将传递<ph id="ph3">`LMEM_FIXED`</ph>标志，这会导致分配的内存就地锁定。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>Also, the allocated memory is not zero-filled.</source>
          <target state="translated">此外，分配的内存不是零填充。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>The following example demonstrates calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例演示如何调用 <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">此代码示例摘自更大的示例为提供<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>There is insufficient memory to satisfy the request.</source>
          <target state="translated">没有足够的内存来满足该请求。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>The required number of bytes in memory.</source>
          <target state="translated">内存中的所需字节数。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>Allocates memory from the unmanaged memory of the process by using the pointer to the specified number of bytes.</source>
          <target state="translated">通过使用指向指定字节数的指针，从进程的非托管内存中分配内存。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>A pointer to the newly allocated memory.</source>
          <target state="translated">指向新分配的内存的指针。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>This memory must be released using the <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /&gt;</ph> method.</source>
          <target state="translated">必须使用 <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /&gt;</ph> 方法释放该内存。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> is one of two memory allocation methods in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> 是中的两个内存分配方法之一<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType&gt;</ph> is the other.) This method exposes the Win32 <bpt id="p1">[</bpt>LocalAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148628)</ept> function from Kernel32.dll.</source>
          <target state="translated">(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType&gt;</ph>是另。)此方法公开 Win32 <bpt id="p1">[</bpt>LocalAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148628)</ept>从 Kernel32.dll 函数。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>When <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> calls <ph id="ph2">`LocalAlloc`</ph>, it passes a <ph id="ph3">`LMEM_FIXED`</ph> flag, which causes the allocated memory to be locked in place.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph>调用<ph id="ph2">`LocalAlloc`</ph>，它将传递<ph id="ph3">`LMEM_FIXED`</ph>标志，这会导致分配的内存就地锁定。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>Also, the allocated memory is not zero-filled.</source>
          <target state="translated">此外，分配的内存不是零填充。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>For example code, see <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph>.</source>
          <target state="translated">有关代码示例，请参阅 <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph>和 <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>There is insufficient memory to satisfy the request.</source>
          <target state="translated">没有足够的内存来满足该请求。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup">
          <source>Indicates whether runtime callable wrappers (RCWs) from any context are available for cleanup.</source>
          <target state="translated">指示是否可以清除任何上下文中的运行时可调用包装器 (RCW)。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if there are any RCWs available for cleanup; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果存在任何可清除的 RCW，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup">
          <source>If there are a lot of references between managed and native code with deep dependency graphs it can take a long time for all the objects to clean up.</source>
          <target state="translated">如果有大量使用它可能需要很长时间来以进行清除的所有对象的深层依赖项关系图的托管和本机代码之间的引用。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup">
          <source>Each time a GC runs it will free up some number of RCWs, which will in turn release the underlying COM objects.</source>
          <target state="translated">每次 GC 运行的时它将释放一定数量的 Rcw，这又会释放基础 COM 对象。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup">
          <source>Those COM objects will then release their managed references and make more objects available for cleanup the next time a GC runs, which starts the process over again.</source>
          <target state="translated">这些 COM 对象将然后解除其托管的引用，并使更多的对象可用于清理下一次 GC 运行，这将启动过程重新。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup%2A&gt;</ph> method provides a way for the application to determine how many cycles of GC.Collect and GC.WaitForPendingFinalizers need to happen in order to clean everything up.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup%2A&gt;</ph>方法为提供一种应用程序以确定多少周期 GC。收集和 GC。WaitForPendingFinalizers 需要发生以清除所有内容。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)">
          <source>The moniker corresponding to the desired interface pointer.</source>
          <target state="translated">与所需接口指针相对应的名字对象。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)">
          <source>Gets an interface pointer identified by the specified moniker.</source>
          <target state="translated">获取由指定的名字对象标识的接口指针。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)">
          <source>An object containing a reference to the interface pointer identified by the <ph id="ph1">&lt;paramref name="monikerName" /&gt;</ph> parameter.</source>
          <target state="translated">一个对象，它包含对由 <ph id="ph1">&lt;paramref name="monikerName" /&gt;</ph> 参数标识的接口指针的引用。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)">
          <source>A moniker is a name, and in this case, the moniker is defined by an interface.</source>
          <target state="translated">名字对象是一个名称，在此情况下，名字对象由接口定义。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.BindToMoniker%2A&gt;</ph> exposes the COM <ph id="ph2">`BindToMoniker`</ph> method, which produces an object that you can cast to any COM interface you require.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.BindToMoniker%2A&gt;</ph> 公开 COM<ph id="ph2">`BindToMoniker`</ph>方法，这样会生成将可以强制转换为所需的任何 COM 接口的对象。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)">
          <source>This method provides the same functionality as the <ph id="ph1">`GetObject`</ph> method in Visual Basic 6.0 and <ph id="ph2">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>.</source>
          <target state="translated">此方法提供的相同功能<ph id="ph1">`GetObject`</ph>Visual Basic 6.0 中的方法和<ph id="ph2">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)">
          <source>An unrecognized HRESULT was returned by the unmanaged <ph id="ph1">&lt;see langword="BindToMoniker" /&gt;</ph> method.</source>
          <target state="translated">非托管的 <ph id="ph1">&lt;see langword="BindToMoniker" /&gt;</ph> 方法返回无法识别的 HRESULT。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)">
          <source>The object whose CCW holds a reference counted handle.</source>
          <target state="translated">一个对象，其 CCW 包含带有引用计数的句柄。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)">
          <source>The handle is strong if the reference count on the CCW is greater than zero; otherwise, it is weak.</source>
          <target state="translated">如果 CCW 上的引用计数大于零，则该句柄是强句柄；否则为弱句柄。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to change the strength of the handle on the <bpt id="p1">&lt;c&gt;</bpt>otp<ept id="p1">&lt;/c&gt;</ept> parameter to weak, regardless of its reference count; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to reset the handle strength on <bpt id="p2">&lt;c&gt;</bpt>otp<ept id="p2">&lt;/c&gt;</ept> to be reference counted.</source>
          <target state="translated">为 <ph id="ph1">&lt;see langword="true" /&gt;</ph> 时，将 <bpt id="p1">&lt;c&gt;</bpt>otp<ept id="p1">&lt;/c&gt;</ept> 参数上的句柄强度更改为弱，而无论其引用计数；为 <ph id="ph2">&lt;see langword="false" /&gt;</ph> 时，重置要进行引用计数的 <bpt id="p2">&lt;c&gt;</bpt>otp<ept id="p2">&lt;/c&gt;</ept> 上的句柄强度。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)">
          <source>Changes the strength of an object's <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept> (CCW) handle.</source>
          <target state="translated">更改对象的 <bpt id="p1">[</bpt>COM 可调用包装器<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept> (CCW) 句柄的强度。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength%2A&gt;</ph> is used for object pooling functionality and should never be called by user code directly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength%2A&gt;</ph> 对象池功能使用，应永远不会由用户代码直接调用。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>Notifies the runtime to clean up all <bpt id="p1">[</bpt>Runtime Callable Wrappers<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCWs) allocated in the current context.</source>
          <target state="translated">通知运行时清理当前上下文中分配的所有<bpt id="p1">[</bpt>运行时可调用包装器<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW)。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>The interop system pumps messages while it attempts to clean up RCWs.</source>
          <target state="translated">互操作的系统抽取消息，同时会尝试清理 Rcw。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>This ensures that cleanup for single-threaded apartment (STA) RCWs happens in all applications, including applications that do not pump often enough.</source>
          <target state="translated">有关单线程单元 (STA) Rcw 发生在所有应用程序，包括不足够经常执行抽取的应用程序，这可确保该清理。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>However, some applications that do pump appropriately are very sensitive to where pumping occurs.</source>
          <target state="translated">但是，某些应用程序执行操作进行了适当泵是对发送出现的位置非常敏感。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>When the interop system pumps messages in these applications, in places that are unexpected, , the application can encounter reentrancy issues that are difficult to diagnose.</source>
          <target state="translated">当互操作的系统中的位置时，意外，这些应用程序中抽取消息、 应用程序可能会遇到可重入性问题很难诊断。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>Therefore, applications need to be able to control their own pumping for a particular STA and to control the clean-up of RCWs.</source>
          <target state="translated">因此，应用程序需要能够控制其自己发送特定 STA 以及控制清理的 Rcw。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>However, developers often only control a subset of the threads in their application and thus cannot ensure that all threads are pumping appropriately.</source>
          <target state="translated">但是，开发人员通常只控制他们的应用程序中的线程的子集，因此不能确保所有线程泵适当地都处理。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>To solve this problem:</source>
          <target state="translated">若要解决此问题：</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A?displayProperty=nameWithType&gt;</ph> method to turn off automatic cleanup of RCWs, and the message pumping that occurs, on a per-thread basis.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A?displayProperty=nameWithType&gt;</ph>方法来关闭对 Rcw 以及发生，基于每个线程的消息泵的自动清理。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>This allows developers to opt out of automatic clean-up, and the corresponding message pumping.</source>
          <target state="translated">这允许开发人员选择退出自动清理和相应的消息泵处理。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A&gt;</ph> method to notify the runtime to clean up all RCWs that are allocated in the current context.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A&gt;</ph>方法，以通知运行时清理当前上下文中分配的所有 Rcw。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>This companion method allows developers to precisely control when the runtime performs cleanup in the current context.</source>
          <target state="translated">此助理方法允许开发人员能够精确地控制当运行在当前上下文中时执行清理。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Copies data from a managed array to an unmanaged memory pointer, or from an unmanaged memory pointer to a managed array.</source>
          <target state="translated">将数据从托管数组复制到非托管内存指针，或从非托管内存指针复制到托管数组。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source>The one-dimensional array to copy from.</source>
          <target state="translated">从中进行复制的一维数组。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source>The zero-based index in the source array where copying should start.</source>
          <target state="translated">源数组中从零开始的索引，在此处开始复制。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source>The memory pointer to copy to.</source>
          <target state="translated">要复制到的内存指针。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">要复制的数组元素的数目。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source>Copies data from a one-dimensional, managed 8-bit unsigned integer array to an unmanaged memory pointer.</source>
          <target state="translated">将数据从一维托管 8 位无符号整数数组复制到非托管内存指针。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
          <target state="translated">你可以使用此方法将一维托管数组的子集复制到非托管的 C 样式数组。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source>The following example copies an array to unmanaged memory by using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.IntPtr%2CSystem.Int32%29&gt;</ph> overload, and then copies the unmanaged array back to managed memory by using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%28System.IntPtr%2CSystem.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload.</source>
          <target state="translated">下面的示例通过将数组复制到非托管内存<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.IntPtr%2CSystem.Int32%29&gt;</ph>超负荷运转，，然后通过将非托管的数组复制回托管内存<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%28System.IntPtr%2CSystem.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph>重载。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> are not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, <ph id="ph3">&lt;paramref name="destination" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>、<ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>、<ph id="ph3">&lt;paramref name="destination" /&gt;</ph> 或 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 为 <ph id="ph5">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source>The one-dimensional array to copy from.</source>
          <target state="translated">从中进行复制的一维数组。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source>The zero-based index in the source array where copying should start.</source>
          <target state="translated">源数组中从零开始的索引，在此处开始复制。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source>The memory pointer to copy to.</source>
          <target state="translated">要复制到的内存指针。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">要复制的数组元素的数目。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source>Copies data from a one-dimensional, managed character array to an unmanaged memory pointer.</source>
          <target state="translated">将数据从一维托管字符数组复制到非托管内存指针。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
          <target state="translated">你可以使用此方法将一维托管数组的子集复制到非托管的 C 样式数组。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">下面的示例将数组复制到非托管内存，然后将非托管的数组复制回托管内存。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> are not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph>、<ph id="ph2">&lt;paramref name="destination" /&gt;</ph> 或 <ph id="ph3">&lt;paramref name="length" /&gt;</ph> 为 <ph id="ph4">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source>The one-dimensional array to copy from.</source>
          <target state="translated">从中进行复制的一维数组。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source>The zero-based index in the source array where copying should start.</source>
          <target state="translated">源数组中从零开始的索引，在此处开始复制。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source>The memory pointer to copy to.</source>
          <target state="translated">要复制到的内存指针。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">要复制的数组元素的数目。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source>Copies data from a one-dimensional, managed double-precision floating-point number array to an unmanaged memory pointer.</source>
          <target state="translated">将数据从一维托管双精度浮点数数组复制到非托管内存指针。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
          <target state="translated">你可以使用此方法将一维托管数组的子集复制到非托管的 C 样式数组。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">下面的示例将数组复制到非托管内存，然后将非托管的数组复制回托管内存。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> are not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, <ph id="ph3">&lt;paramref name="destination" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>、<ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>、<ph id="ph3">&lt;paramref name="destination" /&gt;</ph> 或 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 为 <ph id="ph5">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source>The one-dimensional array to copy from.</source>
          <target state="translated">从中进行复制的一维数组。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source>The zero-based index in the source array where copying should start.</source>
          <target state="translated">源数组中从零开始的索引，在此处开始复制。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source>The memory pointer to copy to.</source>
          <target state="translated">要复制到的内存指针。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">要复制的数组元素的数目。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source>Copies data from a one-dimensional, managed 16-bit signed integer array to an unmanaged memory pointer.</source>
          <target state="translated">将数据从一维托管 16 位带符号整数数组复制到非托管内存指针。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
          <target state="translated">你可以使用此方法将一维托管数组的子集复制到非托管的 C 样式数组。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">下面的示例将数组复制到非托管内存，然后将非托管的数组复制回托管内存。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> are not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, <ph id="ph3">&lt;paramref name="destination" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>、<ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>、<ph id="ph3">&lt;paramref name="destination" /&gt;</ph> 或 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 为 <ph id="ph5">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source>The one-dimensional array to copy from.</source>
          <target state="translated">从中进行复制的一维数组。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source>The zero-based index in the source array where copying should start.</source>
          <target state="translated">源数组中从零开始的索引，在此处开始复制。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source>The memory pointer to copy to.</source>
          <target state="translated">要复制到的内存指针。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">要复制的数组元素的数目。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source>Copies data from a one-dimensional, managed 32-bit signed integer array to an unmanaged memory pointer.</source>
          <target state="translated">将数据从一维托管 32 位带符号整数数组复制到非托管内存指针。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
          <target state="translated">你可以使用此方法将一维托管数组的子集复制到非托管的 C 样式数组。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">下面的示例将数组复制到非托管内存，然后将非托管的数组复制回托管内存。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> are not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 或 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source>The one-dimensional array to copy from.</source>
          <target state="translated">从中进行复制的一维数组。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source>The zero-based index in the source array where copying should start.</source>
          <target state="translated">源数组中从零开始的索引，在此处开始复制。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source>The memory pointer to copy to.</source>
          <target state="translated">要复制到的内存指针。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">要复制的数组元素的数目。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source>Copies data from a one-dimensional, managed 64-bit signed integer array to an unmanaged memory pointer.</source>
          <target state="translated">将数据从一维托管 64 位带符号整数数组复制到非托管内存指针。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
          <target state="translated">你可以使用此方法将一维托管数组的子集复制到非托管的 C 样式数组。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">下面的示例将数组复制到非托管内存，然后将非托管的数组复制回托管内存。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> are not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, <ph id="ph3">&lt;paramref name="destination" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>、<ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>、<ph id="ph3">&lt;paramref name="destination" /&gt;</ph> 或 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 为 <ph id="ph5">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>The memory pointer to copy from.</source>
          <target state="translated">从中进行复制的内存指针。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>The array to copy to.</source>
          <target state="translated">要复制到的数组。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>The zero-based index in the destination array where copying should start.</source>
          <target state="translated">目标数组中从零开始的索引，在此处开始复制。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">要复制的数组元素的数目。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>Copies data from an unmanaged memory pointer to a managed 8-bit unsigned integer array.</source>
          <target state="translated">将数据从非托管内存指针复制到托管 8 位无符号整数数组。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
          <target state="translated">非托管、 C 样式数组不包含边界信息，这会阻止<ph id="ph1">`startIndex`</ph>和<ph id="ph2">`length`</ph>参数进行验证。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>Thus, the unmanaged data corresponding to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
          <target state="translated">因此，与对应的非托管的数据<ph id="ph1">`source`</ph>参数填充托管的数组而不考虑其用途。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
          <target state="translated">调用此方法之前，必须初始化托管的数组用适当的大小。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">下面的示例将数组复制到非托管内存，然后将非托管的数组复制回托管内存。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>、<ph id="ph2">&lt;paramref name="destination" /&gt;</ph>、<ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 或 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 为 <ph id="ph5">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>The memory pointer to copy from.</source>
          <target state="translated">从中进行复制的内存指针。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>The array to copy to.</source>
          <target state="translated">要复制到的数组。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>The zero-based index in the destination array where copying should start.</source>
          <target state="translated">目标数组中从零开始的索引，在此处开始复制。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">要复制的数组元素的数目。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>Copies data from an unmanaged memory pointer to a managed character array.</source>
          <target state="translated">将数据从非托管内存指针复制到托管字符数组。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
          <target state="translated">非托管、 C 样式数组不包含边界信息，这会阻止<ph id="ph1">`startIndex`</ph>和<ph id="ph2">`length`</ph>参数进行验证。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>Thus, the unmanaged data corresponding to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
          <target state="translated">因此，与对应的非托管的数据<ph id="ph1">`source`</ph>参数填充托管的数组而不考虑其用途。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
          <target state="translated">调用此方法之前，必须初始化托管的数组用适当的大小。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">下面的示例将数组复制到非托管内存，然后将非托管的数组复制回托管内存。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>、<ph id="ph2">&lt;paramref name="destination" /&gt;</ph>、<ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 或 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 为 <ph id="ph5">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>The memory pointer to copy from.</source>
          <target state="translated">从中进行复制的内存指针。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>The array to copy to.</source>
          <target state="translated">要复制到的数组。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>The zero-based index in the destination array where copying should start.</source>
          <target state="translated">目标数组中从零开始的索引，在此处开始复制。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">要复制的数组元素的数目。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>Copies data from an unmanaged memory pointer to a managed double-precision floating-point number array.</source>
          <target state="translated">将数据从非托管内存指针复制到托管双精度浮点数数组。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
          <target state="translated">非托管、 C 样式数组不包含边界信息，这会阻止<ph id="ph1">`startIndex`</ph>和<ph id="ph2">`length`</ph>参数进行验证。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>Thus, the unmanaged data corresponding to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
          <target state="translated">因此，与对应的非托管的数据<ph id="ph1">`source`</ph>参数填充托管的数组而不考虑其用途。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
          <target state="translated">调用此方法之前，必须初始化托管的数组用适当的大小。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">下面的示例将数组复制到非托管内存，然后将非托管的数组复制回托管内存。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>、<ph id="ph2">&lt;paramref name="destination" /&gt;</ph>、<ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 或 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 为 <ph id="ph5">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>The memory pointer to copy from.</source>
          <target state="translated">从中进行复制的内存指针。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>The array to copy to.</source>
          <target state="translated">要复制到的数组。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>The zero-based index in the destination array where copying should start.</source>
          <target state="translated">目标数组中从零开始的索引，在此处开始复制。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">要复制的数组元素的数目。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>Copies data from an unmanaged memory pointer to a managed 16-bit signed integer array.</source>
          <target state="translated">将数据从非托管内存指针复制到托管 16 位带符号整数数组。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
          <target state="translated">非托管、 C 样式数组不包含边界信息，这会阻止<ph id="ph1">`startIndex`</ph>和<ph id="ph2">`length`</ph>参数进行验证。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>Thus, the unmanaged data corresponding to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
          <target state="translated">因此，与对应的非托管的数据<ph id="ph1">`source`</ph>参数填充托管的数组而不考虑其用途。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
          <target state="translated">调用此方法之前，必须初始化托管的数组用适当的大小。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">下面的示例将数组复制到非托管内存，然后将非托管的数组复制回托管内存。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>、<ph id="ph2">&lt;paramref name="destination" /&gt;</ph>、<ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 或 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 为 <ph id="ph5">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>The memory pointer to copy from.</source>
          <target state="translated">从中进行复制的内存指针。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>The array to copy to.</source>
          <target state="translated">要复制到的数组。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>The zero-based index in the destination array where copying should start.</source>
          <target state="translated">目标数组中从零开始的索引，在此处开始复制。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">要复制的数组元素的数目。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>Copies data from an unmanaged memory pointer to a managed 32-bit signed integer array.</source>
          <target state="translated">将数据从非托管内存指针复制到托管 32 位带符号整数数组。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
          <target state="translated">非托管、 C 样式数组不包含边界信息，这会阻止<ph id="ph1">`startIndex`</ph>和<ph id="ph2">`length`</ph>参数进行验证。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>Thus, the unmanaged data corresponding to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
          <target state="translated">因此，与对应的非托管的数据<ph id="ph1">`source`</ph>参数填充托管的数组而不考虑其用途。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
          <target state="translated">调用此方法之前，必须初始化托管的数组用适当的大小。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">下面的示例将数组复制到非托管内存，然后将非托管的数组复制回托管内存。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>、<ph id="ph2">&lt;paramref name="destination" /&gt;</ph>、<ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 或 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 为 <ph id="ph5">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>The memory pointer to copy from.</source>
          <target state="translated">从中进行复制的内存指针。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>The array to copy to.</source>
          <target state="translated">要复制到的数组。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>The zero-based index in the destination array where copying should start.</source>
          <target state="translated">目标数组中从零开始的索引，在此处开始复制。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">要复制的数组元素的数目。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>Copies data from an unmanaged memory pointer to a managed 64-bit signed integer array.</source>
          <target state="translated">将数据从非托管内存指针复制到托管 64 位带符号整数数组。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
          <target state="translated">非托管、 C 样式数组不包含边界信息，这会阻止<ph id="ph1">`startIndex`</ph>和<ph id="ph2">`length`</ph>参数进行验证。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>Thus, the unmanaged data corresponding to the<ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
          <target state="translated">因此，与对应的非托管的数据<ph id="ph1">`source`</ph>参数填充托管的数组而不考虑其用途。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
          <target state="translated">调用此方法之前，必须初始化托管的数组用适当的大小。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</source>
          <target state="translated">下面的示例将数组复制到非托管内存，然后将非托管的数组复制回托管内存。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>、<ph id="ph2">&lt;paramref name="destination" /&gt;</ph>、<ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 或 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 为 <ph id="ph5">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>The memory pointer to copy from.</source>
          <target state="translated">从中进行复制的内存指针。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>The array to copy to.</source>
          <target state="translated">要复制到的数组。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>The zero-based index in the destination array where copying should start.</source>
          <target state="translated">目标数组中从零开始的索引，在此处开始复制。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">要复制的数组元素的数目。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>Copies data from an unmanaged memory pointer to a managed <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> array.</source>
          <target state="translated">将数据从非托管的内存指针复制到托管的 <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> 数组。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
          <target state="translated">非托管、 C 样式数组不包含边界信息，这会阻止<ph id="ph1">`startIndex`</ph>和<ph id="ph2">`length`</ph>参数进行验证。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>Therefore, the unmanaged data that corresponds to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
          <target state="translated">因此，对应的非托管的数据<ph id="ph1">`source`</ph>参数填充托管的数组而不考虑其用途。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>You must initialize the managed array with the appropriate size before calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">必须初始化托管的数组用适当的大小之前调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>、<ph id="ph2">&lt;paramref name="destination" /&gt;</ph>、<ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 或 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 为 <ph id="ph5">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>The memory pointer to copy from.</source>
          <target state="translated">从中进行复制的内存指针。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>The array to copy to.</source>
          <target state="translated">要复制到的数组。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>The zero-based index in the destination array where copying should start.</source>
          <target state="translated">目标数组中从零开始的索引，在此处开始复制。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">要复制的数组元素的数目。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>Copies data from an unmanaged memory pointer to a managed single-precision floating-point number array.</source>
          <target state="translated">将数据从非托管内存指针复制到托管单精度浮点数数组。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>Unmanaged, C-style arrays do not contain bounds information, which prevents the <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> parameters from being validated.</source>
          <target state="translated">非托管、 C 样式数组不包含边界信息，这会阻止<ph id="ph1">`startIndex`</ph>和<ph id="ph2">`length`</ph>参数进行验证。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>Thus, the unmanaged data corresponding to the <ph id="ph1">`source`</ph> parameter populates the managed array regardless of its usefulness.</source>
          <target state="translated">因此，与对应的非托管的数据<ph id="ph1">`source`</ph>参数填充托管的数组而不考虑其用途。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>You must initialize the managed array with the appropriate size before calling this method.</source>
          <target state="translated">调用此方法之前，必须初始化托管的数组用适当的大小。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>、<ph id="ph2">&lt;paramref name="destination" /&gt;</ph>、<ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 或 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 为 <ph id="ph5">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)">
          <source>The one-dimensional array to copy from.</source>
          <target state="translated">从中进行复制的一维数组。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)">
          <source>The zero-based index in the source array where copying should start.</source>
          <target state="translated">源数组中从零开始的索引，在此处开始复制。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)">
          <source>The memory pointer to copy to.</source>
          <target state="translated">要复制到的内存指针。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">要复制的数组元素的数目。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)">
          <source>Copies data from a one-dimensional, managed <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> array to an unmanaged memory pointer.</source>
          <target state="translated">将数据从一维托管的 <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> 数组复制到非托管内存指针。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)">
          <source>You can use this method to copy a subset of a one-dimensional managed <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> array to an unmanaged C-style array.</source>
          <target state="translated">你可以使用此方法要复制的一维托管子集<ph id="ph1">&lt;xref:System.IntPtr&gt;</ph>到非托管的 C 样式数组的数组。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>, <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>、<ph id="ph2">&lt;paramref name="destination" /&gt;</ph>、<ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> 或 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 为 <ph id="ph5">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source>The one-dimensional array to copy from.</source>
          <target state="translated">从中进行复制的一维数组。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source>The zero-based index in the source array where copying should start.</source>
          <target state="translated">源数组中从零开始的索引，在此处开始复制。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source>The memory pointer to copy to.</source>
          <target state="translated">要复制到的内存指针。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source>The number of array elements to copy.</source>
          <target state="translated">要复制的数组元素的数目。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source>Copies data from a one-dimensional, managed single-precision floating-point number array to an unmanaged memory pointer.</source>
          <target state="translated">将数据从一维托管单精度浮点数数组复制到非托管内存指针。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</source>
          <target state="translated">你可以使用此方法将一维托管数组的子集复制到非托管的 C 样式数组。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> are not valid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> 和 <ph id="ph2">&lt;paramref name="length" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="source" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, <ph id="ph3">&lt;paramref name="destination" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="source" /&gt;</ph>、<ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>、<ph id="ph3">&lt;paramref name="destination" /&gt;</ph> 或 <ph id="ph4">&lt;paramref name="length" /&gt;</ph> 为 <ph id="ph5">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)">
          <source>The outer <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> pointer.</source>
          <target state="translated">外部 <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> 指针。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)">
          <source>An object to aggregate.</source>
          <target state="translated">要聚合的对象。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)">
          <source>Aggregates a managed object with the specified COM object.</source>
          <target state="translated">聚合托管对象和指定的 COM 对象。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)">
          <source>The inner <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> pointer of the managed object.</source>
          <target state="translated">托管对象的内部 <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> 指针。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A&gt;</ph> method aggregates the inner managed pointer of a managed object with the specified outer pointer, and then returns an inner <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> pointer of the managed object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A&gt;</ph>方法聚合托管对象的内部托管的指针，指定的外部指针，并返回内部<bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept>托管对象的指针。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 是一个 <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> 对象。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source>The type of the managed object to aggregate.</source>
          <target state="translated">要聚合的托管对象的类型。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source>The outer <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> pointer.</source>
          <target state="translated">外部 <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> 指针。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source>The managed object to aggregate.</source>
          <target state="translated">要集合的托管对象。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[在 .NET Framework 4.5.1 和更高版本中受支持]</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source>Aggregates a managed object of the specified type with the specified COM object.</source>
          <target state="translated">聚合指定类型的托管对象和指定的 COM 对象。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source>The inner <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> pointer of the managed object.</source>
          <target state="translated">托管对象的内部 <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> 指针。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A&gt;</ph> method aggregates the inner managed pointer of a managed object of a specified type with the specified outer pointer, and returns an inner <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> pointer of the managed object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A&gt;</ph>方法聚合指定类型的托管对象的内部托管的指针，指定的外部指针，并返回内部<bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept>托管对象的指针。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 是一个 <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> 对象。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>The object to be wrapped.</source>
          <target state="translated">要包装的对象。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>The type of wrapper to create.</source>
          <target state="translated">要创建的包装器的类型。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>Wraps the specified COM object in an object of the specified type.</source>
          <target state="translated">在指定类型的对象中包装指定的 COM 对象。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>The newly wrapped object that is an instance of the desired type.</source>
          <target state="translated">新包装的对象，该对象是所需类型的实例。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%2A&gt;</ph> converts one COM class type, typically the base <ph id="ph2">`__ComObject`</ph> type, to another COM class type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%2A&gt;</ph> 将一个 COM 类类型，通常的基本转换<ph id="ph2">`__ComObject`</ph>类型，对另一个 COM 类类型。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>The input COM object, represented by parameter <ph id="ph1">`o`</ph>, is a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW).</source>
          <target state="translated">输入的 COM 对象，由参数表示<ph id="ph1">`o`</ph>，是<bpt id="p1">[</bpt>运行时可调用包装器<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>(RCW)。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>Both the <ph id="ph1">`t`</ph> and <ph id="ph2">`o`</ph> parameters must be classes whose signatures are attributed with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">同时<ph id="ph1">`t`</ph>和<ph id="ph2">`o`</ph>参数必须是其签名使用特性化的类<ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool applies this attribute for you when it imports a type library.</source>
          <target state="translated"><bpt id="p1">[</bpt>Tlbimp.exe （类型库导入程序）<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept>工具将此属性应用为你导入类型库时。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>If you create the RCW manually in source code, you should apply this attribute to the managed signature that represents the original coclass to signify its COM origins.</source>
          <target state="translated">如果你在源代码中手动创建 RCW，应将此属性应用到表示原始 coclass 以指示其 COM 来源的托管签名中。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>Tlbimp.exe imports a COM <bpt id="p1">[</bpt>coclass<ept id="p1">](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582)</ept> as a managed class and an interface.</source>
          <target state="translated">Tlbimp.exe 导入 COM<bpt id="p1">[</bpt>组件类<ept id="p1">](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582)</ept>作为托管的类和接口。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>The coclass interface has the same name as the original coclass, and the managed class has the original coclass name appended with "Class".</source>
          <target state="translated">组件类接口具有与原始组件类，相同的名称和托管的类具有在原始的组件类名称后追加"类"。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>For example, a coclass called <ph id="ph1">`MyCoclass`</ph> becomes a coclass interface called <ph id="ph2">`MyCoclass`</ph> and a managed class called <ph id="ph3">`MyCoclassClass`</ph>.</source>
          <target state="translated">例如，组件类调用<ph id="ph1">`MyCoclass`</ph>将成为调用组件类接口<ph id="ph2">`MyCoclass`</ph>和托管的类称为<ph id="ph3">`MyCoclassClass`</ph>。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>Since <ph id="ph1">`t`</ph> must be a class, not an interface, be sure to specify the managed class (<ph id="ph2">`MyCoclassClass`</ph>) and not the coclass interface.</source>
          <target state="translated">由于<ph id="ph1">`t`</ph>必须是类，而不是接口，请确保指定的托管的类 (<ph id="ph2">`MyCoclassClass`</ph>) 并不是 coclass 接口。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>You lose the identity of the input COM object because a new RCW instance wraps the <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> pointer exposed by the original RCW.</source>
          <target state="translated">此时将失去的 COM 对象，因为新的 RCW 实例包装的输入标识<bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept>由原始 RCW 公开的指针。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> must derive from <ph id="ph2">&lt;see langword="__ComObject" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> 必须派生自 <ph id="ph2">&lt;see langword="__ComObject" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> 是 <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> 类型。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="t" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> cannot be converted to the destination type because it does not support all required interfaces.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 不支持所有必需的接口，因此无法转换为目标类型。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>The type of object to wrap.</source>
          <target state="translated">要包装的对象的类型。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>The type of object to return.</source>
          <target state="translated">要返回的对象的类型。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>The object to be wrapped.</source>
          <target state="translated">要包装的对象。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[在 .NET Framework 4.5.1 和更高版本中受支持]</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>Wraps the specified COM object in an object of the specified type.</source>
          <target state="translated">在指定类型的对象中包装指定的 COM 对象。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>The newly wrapped object.</source>
          <target state="translated">新包装的对象。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%60%602%28%60%600%29&gt;</ph> converts a COM object of type <ph id="ph2">`T`</ph> to the <ph id="ph3">`TWrapper`</ph> COM class type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%60%602%28%60%600%29&gt;</ph> 将 COM 对象的类型转换<ph id="ph2">`T`</ph>到<ph id="ph3">`TWrapper`</ph>COM 类的类型。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>The input COM object, represented by parameter <ph id="ph1">`o`</ph>, is a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW).</source>
          <target state="translated">输入的 COM 对象，由参数表示<ph id="ph1">`o`</ph>，是<bpt id="p1">[</bpt>运行时可调用包装器<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>(RCW)。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>Both the <ph id="ph1">`T`</ph> generic type parameter and the <ph id="ph2">`o`</ph> parameter must be classes whose signatures are attributed with the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">这两个<ph id="ph1">`T`</ph>泛型类型参数和<ph id="ph2">`o`</ph>参数必须是其签名使用特性化的类<ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool applies this attribute for you when it imports a type library.</source>
          <target state="translated"><bpt id="p1">[</bpt>Tlbimp.exe （类型库导入程序）<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept>工具将此属性应用为你导入类型库时。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>If you create the RCW manually in source code, you should apply this attribute to the managed signature that represents the original coclass to signify its COM origins.</source>
          <target state="translated">如果你在源代码中手动创建 RCW，应将此属性应用到表示原始 coclass 以指示其 COM 来源的托管签名中。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>Tlbimp.exe imports a COM <bpt id="p1">[</bpt>coclass<ept id="p1">](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582)</ept> as a managed class and an interface.</source>
          <target state="translated">Tlbimp.exe 导入 COM<bpt id="p1">[</bpt>组件类<ept id="p1">](http://msdn.microsoft.com/library/333d0904-ffa2-4d25-878d-7422bcd40582)</ept>作为托管的类和接口。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>The coclass interface has the same name as the original coclass, and the managed class has the original coclass name appended with "Class".</source>
          <target state="translated">组件类接口具有与原始组件类，相同的名称和托管的类具有在原始的组件类名称后追加"类"。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>For example, a coclass called <ph id="ph1">`MyCoclass`</ph> becomes a coclass interface called <ph id="ph2">`MyCoclass`</ph> and a managed class called <ph id="ph3">`MyCoclassClass`</ph>.</source>
          <target state="translated">例如，组件类调用<ph id="ph1">`MyCoclass`</ph>将成为调用组件类接口<ph id="ph2">`MyCoclass`</ph>和托管的类称为<ph id="ph3">`MyCoclassClass`</ph>。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>Because<ph id="ph1">`T`</ph> must be a class, not an interface, be sure to specify the managed class (<ph id="ph2">`MyCoclassClass`</ph>) and not the <ph id="ph3">`coclass`</ph> interface.</source>
          <target state="translated">因为<ph id="ph1">`T`</ph>必须是类，而不是接口，请确保指定的托管的类 (<ph id="ph2">`MyCoclassClass`</ph>) 而不<ph id="ph3">`coclass`</ph>接口。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>You lose the identity of the input COM object, because a new RCW instance wraps the <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> pointer exposed by the original RCW.</source>
          <target state="translated">你将失去的输入的 COM 对象，标识，因为新的 RCW 实例包装<bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept>由原始 RCW 公开的指针。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> must derive from <ph id="ph2">&lt;see langword="__ComObject" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> 必须派生自 <ph id="ph2">&lt;see langword="__ComObject" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> type.</source>
          <target state="translated"><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> 是 <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> 类型。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> cannot be converted to the <ph id="ph2">&lt;paramref name="TWrapper" /&gt;</ph> because it does not support all required interfaces.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 无法转换为 <ph id="ph2">&lt;paramref name="TWrapper" /&gt;</ph>，因为它不支持所有需要的接口。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>A pointer to an unmanaged block of memory.</source>
          <target state="translated">指向非托管内存块的指针。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>Type of a formatted class.</source>
          <target state="translated">格式化类的类型。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>This provides the layout information necessary to delete the buffer in the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter.</source>
          <target state="translated">该类型提供删除 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数指向的缓冲区所需的布局信息。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>Frees all substructures that the specified unmanaged memory block points to.</source>
          <target state="translated">释放指定的非托管内存块所指向的所有子结构。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>You can use this method to free reference-type fields, such as strings, of an unmanaged structure.</source>
          <target state="translated">可以使用此方法以释放引用类型字段，如字符串的非托管结构。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>Unlike its fields, a structure can be a value type or a reference type.</source>
          <target state="translated">与其字段不同，结构可以是值类型或引用类型。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>Value-type structures that contain value-type fields (all blittable) have no references whose memory must be freed.</source>
          <target state="translated">包含值类型字段 （所有本机结构中） 的值类型结构具有没有必须释放其内存的引用。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType&gt;</ph> method uses this method to prevent memory leaks when reusing memory occupied by a structure.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType&gt;</ph>方法使用此方法来防止内存泄漏，当重新使用的结构占用的内存。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> calls the COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148633)</ept> function, which, in turn, frees an allocated string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> 调用 COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148633)</ept>函数，从而，反过来，释放分配的字符串。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>In addition to <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class provides two other memory-deallocation methods: <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</source>
          <target state="translated">除了<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph>、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph>类提供了两个其他内存释放方法：<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>和<ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source><ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> has an automatic layout.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> 具有自动布局。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>Use sequential or explicit instead.</source>
          <target state="translated">但请该用连续或显式布局。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>The type of the formatted structure.</source>
          <target state="translated">格式化结构的类型。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>This provides the layout information necessary to delete the buffer in the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter.</source>
          <target state="translated">该类型提供删除 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数指向的缓冲区所需的布局信息。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>A pointer to an unmanaged block of memory.</source>
          <target state="translated">指向非托管内存块的指针。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[在 .NET Framework 4.5.1 和更高版本中受支持]</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>Frees all substructures of a specified type that the specified unmanaged memory block points to.</source>
          <target state="translated">释放指定的非托管内存块所指向的所有指定类型的子结构。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>You can use this method to free reference type fields, such as strings, of an unmanaged structure.</source>
          <target state="translated">可以使用此方法以释放引用类型字段，如字符串的非托管结构。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>Unlike its fields, a structure can be a value type or a reference type.</source>
          <target state="translated">与其字段不同，结构可以是值类型或引用类型。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>Value type structures that contain value type fields (all blittable) have no references whose memory must be freed.</source>
          <target state="translated">包含值类型字段 （所有本机结构中） 的值类型结构具有没有必须释放其内存的引用。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType&gt;</ph> method uses this method to prevent memory leaks when reusing memory occupied by a structure.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType&gt;</ph>方法使用此方法来防止内存泄漏，当重新使用的结构占用的内存。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> calls the COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148633)</ept> function, which, in turn, frees an allocated string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> 调用 COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148633)</ept>函数，从而，反过来，释放分配的字符串。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> has an automatic layout.</source>
          <target state="translated"><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> 具有自动布局。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>Use sequential or explicit instead.</source>
          <target state="translated">但请该用连续或显式布局。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>The RCW to be released.</source>
          <target state="translated">要释放的 RCW。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>Releases all references to a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) by setting its reference count to 0.</source>
          <target state="translated">通过将<bpt id="p1">[</bpt>运行时可调用包装器<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) 的引用计数设置为 0，释放对它的所有引用。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>The new value of the reference count of the RCW associated with the <ph id="ph1">&lt;paramref name="o" /&gt;</ph> parameter, which is 0 (zero) if the release is successful.</source>
          <target state="translated">与 <ph id="ph1">&lt;paramref name="o" /&gt;</ph> 参数关联的 RCW 的新引用计数值，如果释放成功，则为 0（零）。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph> method releases the managed reference to a COM object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph>方法释放 COM 对象的托管的引用。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>Calling this method is equivalent to calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> method in a loop until it returns 0 (zero).</source>
          <target state="translated">调用此方法等效于调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph>方法中的循环，直到它返回 0 （零）。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>When the reference count on the COM object becomes 0, the COM object is usually freed, although this depends on the COM object's implementation and is beyond the control of the runtime.</source>
          <target state="translated">当上的 COM 对象的引用计数变为 0 时，是通常释放的 COM 对象，虽然这取决于 COM 对象实现，并且不受控制的运行时。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>However, the RCW can still exist, waiting to be garbage-collected.</source>
          <target state="translated">但是，RCW 可能仍然存在，等待进行垃圾回收。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>The COM object cannot be used after it has been separated from its underlying RCW.</source>
          <target state="translated">已从其基础 RCW 将其分隔后，不能使用的 COM 对象。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>If you try to call a method on the RCW after its reference count becomes 0, a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.InvalidComObjectException&gt;</ph> will be thrown.</source>
          <target state="translated">如果你尝试在 RCW 上调用方法后其引用计数变为 0，<ph id="ph1">&lt;xref:System.Runtime.InteropServices.InvalidComObjectException&gt;</ph>将引发。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is not a valid COM object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 不是有效的 COM 对象。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)">
          <source>The address of the BSTR to be freed.</source>
          <target state="translated">要释放的 BSTR 的地址。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)">
          <source>Frees a <ph id="ph1">&lt;see langword="BSTR" /&gt;</ph> using the COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148633)</ept> function.</source>
          <target state="translated">使用 COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148633)</ept> 函数释放 <ph id="ph1">&lt;see langword="BSTR" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)">
          <source>Like <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType&gt;</ph>, you can use this method to deallocate memory.</source>
          <target state="translated">如<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType&gt;</ph>，你可以使用此方法释放内存。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A&gt;</ph> calls the COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148633)</ept> function, which frees memory allocated by any of the following unmanaged methods: <ph id="ph2">`SysAllocString`</ph>, <ph id="ph3">`SysAllocStringByteLen`</ph>, <ph id="ph4">`SysAllocStringLen`</ph>, <ph id="ph5">`SysReAllocString`</ph>, <ph id="ph6">`SysReAllocStringLen`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A&gt;</ph> 调用 COM <bpt id="p1">[</bpt>SysFreeString<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148633)</ept>函数，从而释放通过任何以下非托管方法分配的内存： <ph id="ph2">`SysAllocString`</ph>， <ph id="ph3">`SysAllocStringByteLen`</ph>， <ph id="ph4">`SysAllocStringLen`</ph>， <ph id="ph5">`SysReAllocString`</ph>， <ph id="ph6">`SysReAllocStringLen`</ph>。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)">
          <source>You can call unmanaged methods such as these with platform invoke.</source>
          <target state="translated">例如，使用平台调用，你可以调用非托管的方法。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)">
          <source>For details, see <bpt id="p1">[</bpt>Consuming Unmanaged DLL Functions<ept id="p1">](~/docs/framework/interop/consuming-unmanaged-dll-functions.md)</ept>.</source>
          <target state="translated">有关详细信息，请参阅<bpt id="p1">[</bpt>使用非托管 DLL 函数<ept id="p1">](~/docs/framework/interop/consuming-unmanaged-dll-functions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)">
          <source>The address of the memory to be freed.</source>
          <target state="translated">要释放的内存的地址。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)">
          <source>Frees a block of memory allocated by the unmanaged COM task memory allocator.</source>
          <target state="translated">释放由非托管 COM 任务内存分配器分配的内存块。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph> to free any memory allocated by <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A&gt;</ph>, or any equivalent unmanaged method.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>以释放分配任何内存<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A&gt;</ph>，或任何等效非托管方法。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)">
          <source>If the <ph id="ph1">`ptr`</ph> parameter is <ph id="ph2">`null`</ph>, the method does nothing.</source>
          <target state="translated">如果<ph id="ph1">`ptr`</ph>参数是<ph id="ph2">`null`</ph>，该方法不执行任何操作。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph> exposes the COM <bpt id="p1">[</bpt>CoTaskMemFree<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148638)</ept> function, which frees all bytes so that you can no longer use the memory that the <ph id="ph2">`ptr`</ph> parameter points to.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph> 公开 COM <bpt id="p1">[</bpt>CoTaskMemFree<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148638)</ept>函数，将释放所有字节，以便不再可以使用内存，<ph id="ph2">`ptr`</ph>参数指向。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)">
          <source>In addition to <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class provides two other memory-deallocation methods: <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</source>
          <target state="translated">除了<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph>类提供了两个其他内存释放方法：<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph>和<ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>The handle returned by the original matching call to <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">由对 <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /&gt;</ph> 的原始匹配调用返回的句柄。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>Frees memory previously allocated from the unmanaged memory of the process.</source>
          <target state="translated">释放以前从进程的非托管内存中分配的内存。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph> to free any memory from the global heap allocated by <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A&gt;</ph>, or any equivalent unmanaged API method.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>以释放从全局堆分配任何内存<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph>， <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A&gt;</ph>，或任何等效非托管 API 方法。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>If the <ph id="ph1">`hglobal`</ph> parameter is <ph id="ph2">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph> the method does nothing.</source>
          <target state="translated">如果<ph id="ph1">`hglobal`</ph>参数是<ph id="ph2">&lt;xref:System.IntPtr.Zero?displayProperty=nameWithType&gt;</ph>方法不执行任何操作。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph> exposes the <bpt id="p1">[</bpt>LocalFree<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148640)</ept> function from Kernel32.DLL, which frees all bytes so that you can no longer use the memory pointed to by <ph id="ph2">`hglobal`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph> 公开<bpt id="p1">[</bpt>LocalFree<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148640)</ept>函数从 Kernel32.DLL，将释放所有字节，以便不再可以使用内存的指向<ph id="ph2">`hglobal`</ph>。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>In addition to <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class provides two other memory-deallocation API methods: <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>.</source>
          <target state="translated">除了<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph>类提供两个其他内存释放 API 方法：<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph>和<ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>The following example demonstrates calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例演示如何调用 <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">此代码示例摘自更大的示例为提供<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>The following example demonstrates how to convert the contents of a managed <ph id="ph1">&lt;xref:System.String&gt;</ph> class to unmanaged memory and then dispose of the unmanaged memory when done.</source>
          <target state="translated">下面的示例演示如何将托管的内容转换<ph id="ph1">&lt;xref:System.String&gt;</ph>类到非托管内存并因而释放完成的非托管内存。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source>The type to generate a GUID for.</source>
          <target state="translated">要为其生成 GUID 的类型。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source>Returns the globally unique identifier (GUID) for the specified type, or generates a GUID using the algorithm used by the Type Library Exporter (Tlbexp.exe).</source>
          <target state="translated">返回指定类型的全局唯一标识符 (GUID)，或使用类型库导出程序 (Tlbexp.exe) 所用的算法生成 GUID。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source>An identifier for the specified type.</source>
          <target state="translated">指定类型的标识符。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source>If the type has a GUID in the metadata, it is returned.</source>
          <target state="translated">如果该类型的元数据中具有一个 GUID，它将返回。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source>Otherwise, a GUID is automatically generated.</source>
          <target state="translated">否则，将自动生成一个 GUID。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source>You can use this method to programmatically determine the COM GUID for any managed type, including COM-invisible types.</source>
          <target state="translated">此方法可用于以编程方式确定任何托管类型，包括不可见的 COM 类型的 COM GUID。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source>Class interfaces are the only exception because they do not correspond to a managed type.</source>
          <target state="translated">类接口是唯一的例外，因为它们不对应于托管类型。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GenerateGuidForType%2A&gt;</ph> provides the same functionality as the <ph id="ph2">&lt;xref:System.Type.GUID%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GenerateGuidForType%2A&gt;</ph> 提供与相同的功能<ph id="ph2">&lt;xref:System.Type.GUID%2A?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>The type to get a ProgID for.</source>
          <target state="translated">要获取其 ProgID 的类型。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>Returns a programmatic identifier (ProgID) for the specified type.</source>
          <target state="translated">返回指定类型的编程标识符 (ProgID)。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>The ProgID of the specified type.</source>
          <target state="translated">指定类型的 ProgID。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>If the type has a ProgID in the metadata, that ProgID is returned.</source>
          <target state="translated">如果该类型的元数据中具有 ProgID，则返回该 ProgID。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>Otherwise, a ProgID is generated based on the fully qualified name of the type.</source>
          <target state="translated">否则，ProgID 将生成基于类型的完全限定名称。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="type" /&gt;</ph> parameter is not a class that can be create by COM.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 参数不是由 COM 创建的类。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>The class must be public, have a public default constructor, and be COM visible.</source>
          <target state="translated">该类必须是公共的，必须具有公共的默认构造函数，而且必须是 COM 可见的。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="type" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>The programmatic identifier (ProgID) of the object that was requested.</source>
          <target state="translated">所请求的对象的编程标识符 (ProgID)。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>Obtains a running instance of the specified object from the running object table (ROT).</source>
          <target state="translated">从运行对象表 (ROT) 获取指定对象的运行实例。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>The object that was requested; otherwise <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">所请求的对象；否则为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>You can cast this object to any COM interface that it supports.</source>
          <target state="translated">可将此对象转换为它支持的任何 COM 接口。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A&gt;</ph> exposes the COM <bpt id="p1">[</bpt>GetActiveObject<ept id="p1">](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx)</ept> function from OLEAUT32.DLL; however, the latter expects a class identifier (CLSID) instead of the programmatic identifier (<ph id="ph2">`ProgID`</ph>) expected by this method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A&gt;</ph> 公开 COM <bpt id="p1">[</bpt>GetActiveObject<ept id="p1">](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx)</ept> OLEAUT32 的函数。DLL;但是，后者要求将类标识符 (CLSID) 而不是编程标识符 (<ph id="ph2">`ProgID`</ph>) 应通过此方法。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>To obtain a running instance of a COM object without a registered <ph id="ph1">`ProgID`</ph>, use platform invoke to define the COM <bpt id="p1">[</bpt>GetActiveObject<ept id="p1">](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx)</ept> function.</source>
          <target state="translated">若要获取不带注册的 COM 对象的运行实例<ph id="ph1">`ProgID`</ph>，使用平台调用定义 COM <bpt id="p1">[</bpt>GetActiveObject<ept id="p1">](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx)</ept>函数。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>For a description of platform invoke, see <bpt id="p1">[</bpt>Consuming Unmanaged DLL Functions<ept id="p1">](~/docs/framework/interop/consuming-unmanaged-dll-functions.md)</ept>.</source>
          <target state="translated">有关平台的说明调用，请参阅<bpt id="p1">[</bpt>使用非托管 DLL 函数<ept id="p1">](~/docs/framework/interop/consuming-unmanaged-dll-functions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>ProgID and CLSID</source>
          <target state="translated">ProgID 和 CLSID</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>Keys in the HKEY_CLASSES_ROOT subtree of the registry contain a variety of subkey types.</source>
          <target state="translated">注册表的 HKEY_CLASSES_ROOT 子树中的项中包含不同的子项的类型。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>Most of the subkeys are ProgIDs, which map a user-friendly string to a CLSID.</source>
          <target state="translated">子项的大部分都是 Progid，映射到 CLSID 的用户友好的字符串。</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>Applications often use these human-readable strings instead of the numeric CLSIDs.</source>
          <target state="translated">应用程序通常使用这些用户可读的字符串，而不是数字的 Clsid。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>Often, a component has a version-independent ProgID that is mapped to the latest version of the component that is installed on the system.</source>
          <target state="translated">通常，组件有映射到最新版本的系统安装的组件独立于版本的 ProgID。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>Applications and components primarily use ProgIDs to retrieve their corresponding CLSIDs.</source>
          <target state="translated">应用程序和组件主要使用 Progid 检索其相应的 Clsid。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>The following example was run on a computer that was configured with a running instance of Microsoft Word.</source>
          <target state="translated">下面的示例使用 Microsoft Word 的运行实例配置的计算机上运行。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>There were no instances of Microsoft Excel running.</source>
          <target state="translated">不没有运行 Microsoft Excel 的任何实例。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>The example calls <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A&gt;</ph> twice.</source>
          <target state="translated">该示例通过调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A&gt;</ph>两次。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>The first call tries to retrieve a reference to an instance of Microsoft Word (an instance of the <ph id="ph1">`Word.Application`</ph> object).</source>
          <target state="translated">第一次调用尝试检索到的 Microsoft Word 实例的引用 (实例<ph id="ph1">`Word.Application`</ph>对象)。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>The second call tries to retrieve a reference to an instance of Microsoft Excel (an instance of an <ph id="ph1">`Excel.Application`</ph> object).</source>
          <target state="translated">第二个调用尝试检索到的 Microsoft Excel 实例的引用 (实例<ph id="ph1">`Excel.Application`</ph>对象)。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>The code retrieves a reference to an instance of Microsoft Word successfully.</source>
          <target state="translated">此代码已成功检索到的 Microsoft Word 实例的引用。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>However, because Microsoft Excel is not running, the attempt to retrieve the second object raises a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.COMException&gt;</ph>.</source>
          <target state="translated">但是，因为没有运行 Microsoft Excel，尝试检索第二个对象引发<ph id="ph1">&lt;xref:System.Runtime.InteropServices.COMException&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>The object was not found.</source>
          <target state="translated">找不到该对象。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Returns an interface pointer that represents an interface for an object.</source>
          <target state="translated">返回一个接口指针，该接口指针表示对象的接口。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The object that provides the interface.</source>
          <target state="translated">提供接口的对象。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The type of interface that is requested.</source>
          <target state="translated">所请求接口的类型。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>Returns a pointer to an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface that represents the specified interface on the specified object.</source>
          <target state="translated">返回一个指向 <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> 接口的指针，该指针表示指定对象上的指定接口。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>Custom query interface access is enabled by default.</source>
          <target state="translated">默认情况下，启用自定义查询接口访问。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The interface pointer that represents the specified interface for the object.</source>
          <target state="translated">表示对象的指定接口的接口指针。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>This method returns an interface pointer that represents the requested interface on the specified object.</source>
          <target state="translated">此方法返回表示指定的对象上请求的接口的接口指针。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</source>
          <target state="translated">如果你有一个需要传入的接口指针的非托管的方法，它将特别有用。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</source>
          <target state="translated">使用此方法调用对象会导致要递增的接口指针上之前，则返回指针的引用计数。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>Always use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph> to decrement the reference count once you have finished with the pointer.</source>
          <target state="translated">始终使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph>要完与指针后递减引用计数。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>You must adhere to the rules defined by COM when using raw COM interface pointers.</source>
          <target state="translated">你必须遵守的规则定义供 COM 使用原始 COM 接口指针。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph> is useful when calling a method that exposes a COM object parameter as an <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> type, or with custom marshaling.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph> 当调用的方法公开为 COM 对象参数时很有用<ph id="ph2">&lt;xref:System.IntPtr&gt;</ph>类型，或与自定义封送。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>Although less common, you can use this method on a managed object to obtain a pointer to the object's COM callable wrapper.</source>
          <target state="translated">但通常不你可以在托管对象上使用此方法用于获取指向对象的 COM 可调用包装器。</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>For example, you can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph> on a managed object that is exported to COM to obtain an interface pointer for <ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">例如，你可以使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph>托管对象导出到 COM，若要获取的接口指针上<ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>You cannot obtain a pointer to a class interface since a class interface lacks the corresponding type to pass to the second parameter (<ph id="ph1">`t`</ph>).</source>
          <target state="translated">无法获取指向类接口的指针，因为类接口中没有要传递给第二个参数的相应类型 (<ph id="ph1">`t`</ph>)。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>Instead, use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType&gt;</ph> to invoke the members on the default interface of the COM callable wrapper, which is usually an auto-dispatch class interface.</source>
          <target state="translated">请改用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType&gt;</ph>来调用 COM 可调用包装器，这通常是一个自动调度类接口的默认接口上的成员。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph> method overload allows query interface customization by default.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph>方法重载默认情况下允许查询接口自定义。</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>To specify whether to apply query interface customization, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29&gt;</ph> method overload.</source>
          <target state="translated">若要指定是否将查询接口自定义项，请使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>For additional information, see the <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>, <bpt id="p2">[</bpt>Runtime Callable Wrapper<ept id="p2">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>, and <bpt id="p3">[</bpt>Introducing the Class Interface<ept id="p3">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept> topics.</source>
          <target state="translated">有关其他信息，请参阅<bpt id="p1">[</bpt>COM 可调用包装<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>，<bpt id="p2">[</bpt>运行时可调用包装器<ept id="p2">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>，和<bpt id="p3">[</bpt>类接口简介<ept id="p3">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept>主题。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> parameter is not an interface.</source>
          <target state="translated"><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> 参数不是接口。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The type is not visible to COM.</source>
          <target state="translated">该类型对 COM 不可见。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> parameter is a generic type definition.</source>
          <target state="translated"><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> 参数是泛型类型定义。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="o" /&gt;</ph> parameter does not support the requested interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 参数不支持请求的接口。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="o" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>The <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>The object that provides the interface.</source>
          <target state="translated">提供接口的对象。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>The type of interface that is requested.</source>
          <target state="translated">所请求接口的类型。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>One of the enumeration values that indicates whether to apply an <ph id="ph1">&lt;see langword="IUnknown::QueryInterface" /&gt;</ph> customization that is supplied by an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ICustomQueryInterface" /&gt;</ph>.</source>
          <target state="translated">枚举值之一，用于指示是否要应用 <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ICustomQueryInterface" /&gt;</ph> 提供的 <ph id="ph1">&lt;see langword="IUnknown::QueryInterface" /&gt;</ph> 自定义。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>Returns a pointer to an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface that represents the specified interface on the specified object.</source>
          <target state="translated">返回一个指向 <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> 接口的指针，该指针表示指定对象上的指定接口。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>Custom query interface access is controlled by the specified customization mode.</source>
          <target state="translated">自定义查询接口访问由指定的自定义模式控制。</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>The interface pointer that represents the interface for the object.</source>
          <target state="translated">表示对象的接口的接口指针。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29&gt;</ph> lets you specify whether to apply query interface customization.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29&gt;</ph> 允许您指定是否要应用查询接口自定义。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph> overload to apply query interface customization by default.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29&gt;</ph>重载以默认将应用查询接口自定义。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>The <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> parameter is not an interface.</source>
          <target state="translated"><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> 参数不是接口。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>The type is not visible to COM.</source>
          <target state="translated">该类型对 COM 不可见。</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>The <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> parameter is a generic type definition.</source>
          <target state="translated"><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> 参数是泛型类型定义。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>The object <ph id="ph1">&lt;paramref name="o" /&gt;</ph> does not support the requested interface.</source>
          <target state="translated">对象 <ph id="ph1">&lt;paramref name="o" /&gt;</ph> 不支持请求的接口。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>The <ph id="ph1">&lt;paramref name="o" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>The <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The type of <bpt id="p1">&lt;c&gt;</bpt>o<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">一种<bpt id="p1">&lt;c&gt;</bpt>o<ept id="p1">&lt;/c&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The type of interface to return.</source>
          <target state="translated">要返回的接口的类型。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The object that provides the interface.</source>
          <target state="translated">提供接口的对象。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[在 .NET Framework 4.5.1 和更高版本中受支持]</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>Returns a pointer to an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface that represents the specified interface on an object of the specified type.</source>
          <target state="translated">返回一个指向 <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> 接口的指针，该指针表示指定类型的对象上的指定接口。</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>Custom query interface access is enabled by default.</source>
          <target state="translated">默认情况下，启用自定义查询接口访问。</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The interface pointer that represents the <ph id="ph1">&lt;paramref name="TInterface" /&gt;</ph> interface.</source>
          <target state="translated">表示 <ph id="ph1">&lt;paramref name="TInterface" /&gt;</ph> 接口的接口指针。</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>This method returns an interface pointer that represents the <ph id="ph1">`TInterface`</ph> interface on the specified object.</source>
          <target state="translated">此方法返回表示的接口指针<ph id="ph1">`TInterface`</ph>指定对象上的接口。</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</source>
          <target state="translated">如果你有一个需要传入的接口指针的非托管的方法，它将特别有用。</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</source>
          <target state="translated">使用此方法调用对象会导致要递增的接口指针上之前，则返回指针的引用计数。</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>Always use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph> method to decrement the reference count when you have finished with the pointer.</source>
          <target state="translated">始终使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph>方法以递减引用计数，当指针用完。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>You must adhere to the rules defined by COM when using raw COM interface pointers.</source>
          <target state="translated">你必须遵守的规则定义供 COM 使用原始 COM 接口指针。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29&gt;</ph> is useful when calling a method that exposes a COM object parameter as an <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> type, or with custom marshaling.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29&gt;</ph> 当调用的方法公开为 COM 对象参数时很有用<ph id="ph2">&lt;xref:System.IntPtr&gt;</ph>类型，或与自定义封送。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>You can also use this method on a managed object to obtain a pointer to the object's COM callable wrapper, although this is less common.</source>
          <target state="translated">你还可用于此方法对托管对象获取指向对象的 COM 可调用包装器，虽然这是不太常见。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>For example, you can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29&gt;</ph> on a managed object that is exported to COM to obtain an interface pointer for <ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">例如，你可以使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29&gt;</ph>托管对象导出到 COM，若要获取的接口指针上<ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29&gt;</ph> method overload allows query interface customization by default.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29&gt;</ph>方法重载默认情况下允许查询接口自定义。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>To specify whether to apply query interface customization, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29&gt;</ph> method overload.</source>
          <target state="translated">若要指定是否将查询接口自定义项，请使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29&gt;</ph>方法重载。</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>For additional information, see the <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>, <bpt id="p2">[</bpt>Runtime Callable Wrapper<ept id="p2">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>, and <bpt id="p3">[</bpt>Introducing the Class Interface<ept id="p3">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept> topics.</source>
          <target state="translated">有关其他信息，请参阅<bpt id="p1">[</bpt>COM 可调用包装<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>，<bpt id="p2">[</bpt>运行时可调用包装器<ept id="p2">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>，和<bpt id="p3">[</bpt>类接口简介<ept id="p3">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept>主题。</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The <ph id="ph1">&lt;paramref name="TInterface" /&gt;</ph> parameter is not an interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="TInterface" /&gt;</ph> 参数不是接口。</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The type is not visible to COM.</source>
          <target state="translated">该类型对 COM 不可见。</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> parameter is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> 参数是开放式泛型类型。</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The <ph id="ph1">&lt;paramref name="o" /&gt;</ph> parameter does not support the <ph id="ph2">&lt;paramref name="TInterface" /&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 参数不支持 <ph id="ph2">&lt;paramref name="TInterface" /&gt;</ph> 接口。</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>The <ph id="ph1">&lt;paramref name="o" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>The object that provides the interface.</source>
          <target state="translated">提供接口的对象。</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>The type of interface that is requested.</source>
          <target state="translated">所请求接口的类型。</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>Returns an interface pointer that represents the specified interface for an object, if the caller is in the same context as that object.</source>
          <target state="translated">返回一个接口指针，该指针表示对象的指定接口（如果调用方与对象在同一上下文中）。</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>The interface pointer specified by <ph id="ph1">&lt;paramref name="t" /&gt;</ph> that represents the interface for the specified object, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the caller is not in the same context as the object.</source>
          <target state="translated">由 <ph id="ph1">&lt;paramref name="t" /&gt;</ph> 指定的接口指针，用于表示指定对象的接口，或如果调用方与对象不在同一上下文中，则为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>This method is the same as <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A&gt;</ph> except that it returns <ph id="ph2">`null`</ph> if the caller is not in the same context as the object.</source>
          <target state="translated">此方法等同于<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A&gt;</ph>，只不过它将返回<ph id="ph2">`null`</ph>如果调用方不是作为对象相同的上下文中。</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer.</source>
          <target state="translated">如果你有一个需要传入的接口指针的非托管的方法，它将特别有用。</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> is not an interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> 不是接口。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>The type is not visible to COM.</source>
          <target state="translated">该类型对 COM 不可见。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> does not support the requested interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 不支持请求的接口。</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>The COM object that contains the data that you want.</source>
          <target state="translated">包含所需数据的 COM 对象。</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>The key in the internal hash table of <bpt id="p1">&lt;c&gt;</bpt>obj<ept id="p1">&lt;/c&gt;</ept> to retrieve the data from.</source>
          <target state="translated">要从中检索数据的 <bpt id="p1">&lt;c&gt;</bpt>obj<ept id="p1">&lt;/c&gt;</ept> 的内部哈希表中的键。</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>Retrieves data that is referenced by the specified key from the specified COM object.</source>
          <target state="translated">从指定的 COM 对象检索指定键所引用的数据。</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>The data represented by the <ph id="ph1">&lt;paramref name="key" /&gt;</ph> parameter in the internal hash table of the <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="obj" /&gt;</ph> 参数的内部哈希表中 <ph id="ph1">&lt;paramref name="key" /&gt;</ph> 参数所表示的数据。</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>All COM objects wrapped in a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> have an associated hash table, which <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A&gt;</ph> retrieves.</source>
          <target state="translated">所有 COM 对象都包装在<bpt id="p1">[</bpt>运行时可调用包装器<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>具有关联的哈希表，其中<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A&gt;</ph>检索。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A?displayProperty=nameWithType&gt;</ph> adds data to the hash table.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A?displayProperty=nameWithType&gt;</ph> 将数据添加到哈希表。</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>You should never have to call either method from your code.</source>
          <target state="translated">您应永远不会需要从代码中调用任何一种方法。</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is not a COM object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 不是 COM 对象。</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 是一个 <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> 对象。</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>An object that represents an interface method.</source>
          <target state="translated">表示接口方法的对象。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>Retrieves the virtual function table (v-table or VTBL) slot for a specified <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> type when that type is exposed to COM.</source>
          <target state="translated">检索指定的 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 类型向 COM 公开时该类型的虚拟功能表（v 表或 VTBL）槽。</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>The VTBL slot <ph id="ph1">&lt;paramref name="m" /&gt;</ph> identifier when it is exposed to COM.</source>
          <target state="translated">向 COM 公开时的 VTBL 槽 <ph id="ph1">&lt;paramref name="m" /&gt;</ph> 标识符。</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>The zero-based slot number returned by this method accounts for three <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> and possibly four <bpt id="p2">[</bpt>IDispatch<ept id="p2">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> methods, making the value of the first available slot either 3 or 7.</source>
          <target state="translated">返回此方法帐户为三个的从零开始的槽版本号<bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept>和可能的第四个<bpt id="p2">[</bpt>IDispatch<ept id="p2">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept>方法，使任一 3 的第一个可用槽的值或 7。</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A&gt;</ph> provides the opposite functionality of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A&gt;</ph> 提供的相反功能<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>You can use this method to retrieve slot numbers for members of interfaces that are not visible from COM and for members of private interfaces.</source>
          <target state="translated">此方法可用于检索插槽编号不是从 COM 可见的接口的成员和私有接口的成员。</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>The slot numbers returned correspond to the v-table numbers that would be reserved if the type was exposed to COM.</source>
          <target state="translated">返回插槽编号对应于该类型已公开给 com。 如果将保留的 v 表编号</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>COM-invisible members actually occupy a slot in an exposed v-table, even though the COM client cannot use the slot.</source>
          <target state="translated">COM 不可见成员实际占用公开 v 表中的槽，即使 COM 客户端无法使用该槽。</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A&gt;</ph> on a class interface by passing <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> from a class.</source>
          <target state="translated">不能使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A&gt;</ph>上通过传递的类接口<ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>从类。</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>For additional information, see <bpt id="p1">[</bpt>Introducing the Class Interface<ept id="p1">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept>.</source>
          <target state="translated">有关其他信息，请参阅<bpt id="p1">[</bpt>类接口简介<ept id="p1">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept>。</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>The <ph id="ph1">&lt;paramref name="m" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>The <ph id="ph1">&lt;paramref name="m" /&gt;</ph> parameter is not a <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph> 参数不是 <ph id="ph2">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>The <ph id="ph1">&lt;paramref name="m" /&gt;</ph> parameter is not an interface method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph> 参数不是接口方法。</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>The unmanaged function pointer to be converted.</source>
          <target state="translated">要转换的非托管函数指针。</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>The type of the delegate to be returned.</source>
          <target state="translated">要返回的委托的类型。</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>Converts an unmanaged function pointer to a delegate.</source>
          <target state="translated">将非托管函数指针转换为委托。</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>A delegate instance that can be cast to the appropriate delegate type.</source>
          <target state="translated">可转换为适当的委托类型的委托实例。</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>In versions 1.0 and 1.1 of the .NET Framework, it was possible to pass a delegate representing a managed method to unmanaged code as a function pointer, allowing the unmanaged code to call the managed method through the function pointer.</source>
          <target state="translated">在版本 1.0 和 1.1 版.NET Framework 中，就可以传递一个表示到非托管代码的托管的方法，作为函数指针，允许非托管的代码调用托管的方法通过函数指针的委托。</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>It was also possible for the unmanaged code to pass that function pointer back to the managed code, and the pointer was resolved properly to the underlying managed method.</source>
          <target state="translated">中，也可能会将该函数指针传递给托管代码中，返回的非托管代码和指针可以正确解析为基础的托管方法。</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>In the .NET Framework 2.0 and later versions, you can use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A&gt;</ph> methods to marshal delegates in both directions.</source>
          <target state="translated">在.NET Framework 2.0 和更高版本中，你可以使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A&gt;</ph>方法进行封送处理在两个方向的委托。</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>With <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A&gt;</ph>, <ph id="ph2">`ptr`</ph> is imported as a <ph id="ph3">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">与<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A&gt;</ph>，<ph id="ph2">`ptr`</ph>作为导入<ph id="ph3">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>A <ph id="ph1">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> can be obtained for a managed delegate by calling <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A&gt;</ph> and passed as a parameter; it can then be called from inside the unmanaged method.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph>可以通过调用获取的托管委托<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A&gt;</ph>和作为参数; 传递它然后，可以调用从非托管方法内。</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>Note that the parameter marshaler can also marshal function pointers to delegates in the .NET Framework 2.0 and later versions.</source>
          <target state="translated">请注意参数封送处理程序可以还封送到的.NET Framework 2.0 和更高版本中的委托的函数指针。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A&gt;</ph> method has the following restrictions:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A&gt;</ph>方法具有以下限制：</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>Generics are not supported in interop scenarios.</source>
          <target state="translated">互操作方案中不支持泛型。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>You cannot pass an invalid function pointer to this method.</source>
          <target state="translated">不能将无效的函数指针传递给此方法。</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>You can use this method only for pure unmanaged function pointers.</source>
          <target state="translated">此方法仅用于纯的非托管的函数指针。</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>You cannot use this method with function pointers obtained through C++ or from the <ph id="ph1">&lt;xref:System.RuntimeMethodHandle.GetFunctionPointer%2A&gt;</ph> method.</source>
          <target state="translated">你无法通过 c + + 或从获得的函数指针与使用此方法<ph id="ph1">&lt;xref:System.RuntimeMethodHandle.GetFunctionPointer%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>You cannot use this method to create a delegate from a function pointer to another managed delegate.</source>
          <target state="translated">此方法不能用于创建从函数指针到另一个托管委托的委托。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="t" /&gt;</ph> parameter is not a delegate or is generic.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> 参数不是委托或泛型。</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="t" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>The type of the delegate to return.</source>
          <target state="translated">要返回的委托的类型。</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>The unmanaged function pointer to convert.</source>
          <target state="translated">要转换的非托管函数指针。</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[在 .NET Framework 4.5.1 和更高版本中受支持]</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>Converts an unmanaged function pointer to a delegate of a specified type.</source>
          <target state="translated">将非托管函数指针转换为指定类型的委托。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>A instance of the specified delegate type.</source>
          <target state="translated">指定委托类型的实例。</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%60%601%28%60%600%29&gt;</ph> methods to marshal delegates in both directions.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%60%601%28%60%600%29&gt;</ph>方法进行封送处理在两个方向的委托。</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29&gt;</ph> method has the following restrictions:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29&gt;</ph>方法具有以下限制：</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>You cannot pass an invalid function pointer to this method.</source>
          <target state="translated">不能将无效的函数指针传递给此方法。</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>You can use this method only for pure unmanaged function pointers.</source>
          <target state="translated">此方法仅用于纯的非托管的函数指针。</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>You cannot use this method with function pointers obtained through C++ or from the <ph id="ph1">&lt;xref:System.RuntimeMethodHandle.GetFunctionPointer%2A&gt;</ph> method.</source>
          <target state="translated">你无法通过 c + + 或从获得的函数指针与使用此方法<ph id="ph1">&lt;xref:System.RuntimeMethodHandle.GetFunctionPointer%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>You cannot use this method to create a delegate from a function pointer to another managed delegate.</source>
          <target state="translated">此方法不能用于创建从函数指针到另一个托管委托的委托。</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>The <ph id="ph1">&lt;paramref name="TDelegate" /&gt;</ph> generic parameter is not a delegate, or it is an open generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="TDelegate" /&gt;</ph> 泛型参数不是代理，或者它是开放式泛型类型。</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>The <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>A type that represents an interface or class.</source>
          <target state="translated">表示接口或类的类型。</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>Retrieves the last slot in the virtual function table (v-table or VTBL) of a type when exposed to COM.</source>
          <target state="translated">检索向 COM 公开时某个类型的虚拟功能表（v 表或 VTBL）中的最后一个槽。</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>The last VTBL slot of the interface when exposed to COM.</source>
          <target state="translated">向 COM 公开时接口的最后一个 VTBL 槽。</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>If the <ph id="ph1">&lt;paramref name="t" /&gt;</ph> parameter is a class, the returned VTBL slot is the last slot in the interface that is generated from the class.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="t" /&gt;</ph> 参数是一个类，则返回的 VTBL 槽是从该类生成的接口中的最后一个槽。</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>This method returns the zero-based, v-table number for an interface or a class.</source>
          <target state="translated">此方法返回的接口或类的从零开始，v 表号。</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>When used on a class, the slot number returned refers to the class interface for the class.</source>
          <target state="translated">当在类上使用时, 返回的槽号引用类的类接口。</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>If the class interface is auto-dual, this method always returns -1 to indicate that the dispatch-only interface does not expose a v-table to managed clients.</source>
          <target state="translated">如果类接口为自动双重接口，此方法始终返回-1 以指示仅支持调度的接口未公开 v-表向托管客户端。</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType&gt;</ph> in conjunction with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType&gt;</ph> to pass slots within a specified range.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType&gt;</ph>结合<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType&gt;</ph>以传递指定的范围中的槽。</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>For additional information, see <bpt id="p1">[</bpt>Introducing the Class Interface<ept id="p1">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept>.</source>
          <target state="translated">有关其他信息，请参阅<bpt id="p1">[</bpt>类接口简介<ept id="p1">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept>。</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionCode">
          <source>Retrieves a code that identifies the type of the exception that occurred.</source>
          <target state="translated">检索标识所发生异常的类型的代码。</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionCode">
          <source>The type of the exception.</source>
          <target state="translated">异常的类型。</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionCode">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionCode%2A&gt;</ph> is exposed for compiler support of structured exception handling (SEH) only.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionCode%2A&gt;</ph> 编译器支持的结构化异常处理 (SEH) 仅为公开。</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionCode">
          <source>If this method is called before an exception is thrown, it returns 0x0.</source>
          <target state="translated">如果引发异常之前调用此方法，则返回 0x0。</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionCode">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionCode">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Converts an HRESULT error code to a corresponding <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> object.</source>
          <target state="translated">将 HRESULT 错误代码转换为相应的 <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)">
          <source>The HRESULT to be converted.</source>
          <target state="translated">要转换的 HRESULT。</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)">
          <source>Converts the specified HRESULT error code to a corresponding <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> object.</source>
          <target state="translated">将指定的 HRESULT 错误代码转换为对应的 <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)">
          <source>An object that represents the converted HRESULT.</source>
          <target state="translated">表示转换后的 HRESULT 的对象。</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A&gt;</ph> method to get an <ph id="ph2">&lt;xref:System.Exception&gt;</ph> based on an HRESULT without having to call the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> method and catch the exception.</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A&gt;</ph>方法以获取<ph id="ph2">&lt;xref:System.Exception&gt;</ph>而无需调用基于 HRESULT<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph>方法并捕获该异常。</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)">
          <source>The current <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447)</ept> interface is used to construct the exception.</source>
          <target state="translated">当前<bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447)</ept>接口用于构造异常。</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)">
          <source>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see <bpt id="p1">[</bpt>How to: Map HRESULTs and Exceptions<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</source>
          <target state="translated">从每个 HRESULT 到其.NET Framework 中的相似异常类的映射，请参阅<bpt id="p1">[</bpt>如何： 映射 Hresult 和异常<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>The HRESULT to be converted.</source>
          <target state="translated">要转换的 HRESULT。</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>A pointer to the <ph id="ph1">&lt;see langword="IErrorInfo" /&gt;</ph> interface that provides more information about the error.</source>
          <target state="translated">指向 <ph id="ph1">&lt;see langword="IErrorInfo" /&gt;</ph> 接口的指针，用于提供有关错误的详细信息。</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>You can specify <bpt id="p1">&lt;c&gt;</bpt>IntPtr(0)<ept id="p1">&lt;/c&gt;</ept> to use the current <ph id="ph1">&lt;see langword="IErrorInfo" /&gt;</ph> interface, or <bpt id="p2">&lt;c&gt;</bpt>IntPtr(-1)<ept id="p2">&lt;/c&gt;</ept> to ignore the current <ph id="ph2">&lt;see langword="IErrorInfo" /&gt;</ph> interface and construct the exception just from the error code.</source>
          <target state="translated">可以指定 <bpt id="p1">&lt;c&gt;</bpt>IntPtr(0)<ept id="p1">&lt;/c&gt;</ept> 以使用当前 <ph id="ph1">&lt;see langword="IErrorInfo" /&gt;</ph> 接口，或者指定 <bpt id="p2">&lt;c&gt;</bpt>IntPtr(-1)<ept id="p2">&lt;/c&gt;</ept> 以忽略当前 <ph id="ph2">&lt;see langword="IErrorInfo" /&gt;</ph> 接口，仅从错误代码构造异常。</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>Converts the specified HRESULT error code to a corresponding <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> object, with additional error information passed in an <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447)</ept> interface for the exception object.</source>
          <target state="translated">将指定的 HRESULT 错误代码转换为对应的 <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> 对象，其中包括通过此异常对象的 <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](http://msdn.microsoft.com/library/4dda6909-2d9a-4727-ae0c-b5f90dcfa447)</ept> 接口传递的其他错误信息。</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>An object that represents the converted HRESULT and information obtained from <ph id="ph1">&lt;paramref name="errorInfo" /&gt;</ph>.</source>
          <target state="translated">一个表示转换后的 HRESULT 以及从 <ph id="ph1">&lt;paramref name="errorInfo" /&gt;</ph> 获取的信息的对象。</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A&gt;</ph> method to get an <ph id="ph2">&lt;xref:System.Exception&gt;</ph> based on an HRESULT without having to call the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> method and catch the exception (thus avoiding the corresponding performance overhead).</source>
          <target state="translated">使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A&gt;</ph>方法以获取<ph id="ph2">&lt;xref:System.Exception&gt;</ph>而无需调用基于 HRESULT<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph>方法并捕获该异常 （从而避免相应的性能开销）。</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>The <ph id="ph1">`errorInfo`</ph> parameter supplies additional information about the error, such as its textual description and the globally unique identifier (GUID) for the interface that defined the error.</source>
          <target state="translated"><ph id="ph1">`errorInfo`</ph>参数提供有关该错误，例如文本描述以及定义错误的接口的全局唯一标识符 (GUID) 的其他信息。</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>Use this method overload if you have custom error information that you have to supply in the conversion.</source>
          <target state="translated">如果你有你需要在转换时提供的自定义错误消息，请使用此方法重载。</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see <bpt id="p1">[</bpt>How to: Map HRESULTs and Exceptions<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</source>
          <target state="translated">从每个 HRESULT 到其.NET Framework 中的相似异常类的映射，请参阅<bpt id="p1">[</bpt>如何： 映射 Hresult 和异常<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers">
          <source>Retrieves a computer-independent description of an exception, and information about the state that existed for the thread when the exception occurred.</source>
          <target state="translated">检索与计算机无关的异常描述，以及有关异常发生时线程的状态信息。</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers">
          <source>A pointer to an <bpt id="p1">[</bpt>EXCEPTION_POINTERS<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148648)</ept> structure.</source>
          <target state="translated">一个指向 <bpt id="p1">[</bpt>EXCEPTION_POINTERS<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148648)</ept> 结构的指针。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionPointers%2A&gt;</ph> is exposed for compiler support of structured exception handling (SEH) only.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetExceptionPointers%2A&gt;</ph> 编译器支持的结构化异常处理 (SEH) 仅为公开。</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>The delegate to be passed to unmanaged code.</source>
          <target state="translated">要传递给非托管代码的委托。</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>Converts a delegate into a function pointer that is callable from unmanaged code.</source>
          <target state="translated">将委托转换为可从非托管代码调用的函数指针。</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>A value that can be passed to unmanaged code, which, in turn, can use it to call the underlying managed delegate.</source>
          <target state="translated">一个可传递给非托管代码的值，非托管代码使用该值来调用基础托管委托。</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>The delegate <ph id="ph1">`d`</ph> is converted to a function pointer that can be passed to unmanaged code using the <bpt id="p1">[</bpt>__stdcall<ept id="p1">](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8)</ept> calling convention.</source>
          <target state="translated">委托<ph id="ph1">`d`</ph>转换为可以传递给非托管的代码使用的函数指针<bpt id="p1">[</bpt>__stdcall<ept id="p1">](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8)</ept>调用约定。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>You must manually keep the delegate from being collected by the garbage collector from managed code.</source>
          <target state="translated">从中收集垃圾回收器从托管代码，你必须手动保持委托。</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>The garbage collector does not track references to unmanaged code.</source>
          <target state="translated">垃圾回收器不会跟踪对非托管代码的引用。</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>The <ph id="ph1">&lt;paramref name="d" /&gt;</ph> parameter is a generic type definition.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> 参数是泛型类型定义。</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>The <ph id="ph1">&lt;paramref name="d" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>The type of delegate to convert.</source>
          <target state="translated">要转换的委托的类型。</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>The delegate to be passed to unmanaged code.</source>
          <target state="translated">要传递给非托管代码的委托。</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[在 .NET Framework 4.5.1 和更高版本中受支持]</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>Converts a delegate of a specified type to a function pointer that is callable from unmanaged code.</source>
          <target state="translated">将指定类型的委托转换为可从非托管代码调用的函数指针。</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>A value that can be passed to unmanaged code, which, in turn, can use it to call the underlying managed delegate.</source>
          <target state="translated">一个可传递给非托管代码的值，非托管代码使用该值来调用基础托管委托。</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>The delegate <ph id="ph1">`d`</ph> is converted to a function pointer that can be passed to unmanaged code by using the <bpt id="p1">[</bpt>__stdcall<ept id="p1">](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8)</ept> calling convention.</source>
          <target state="translated">委托<ph id="ph1">`d`</ph>转换为可以传递给由非托管代码使用的函数指针<bpt id="p1">[</bpt>__stdcall<ept id="p1">](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8)</ept>调用约定。</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>You must manually keep the delegate from being collected by the garbage collector from managed code.</source>
          <target state="translated">从中收集垃圾回收器从托管代码，你必须手动保持委托。</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>The garbage collector does not track references to unmanaged code.</source>
          <target state="translated">垃圾回收器不会跟踪对非托管代码的引用。</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>The <ph id="ph1">&lt;paramref name="d" /&gt;</ph> parameter is a generic type definition.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> 参数是泛型类型定义。</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>The <ph id="ph1">&lt;paramref name="d" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)">
          <source>The module whose HINSTANCE is desired.</source>
          <target state="translated">具有所需 HINSTANCE 的模块。</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)">
          <source>Returns the instance handle (HINSTANCE) for the specified module.</source>
          <target state="translated">返回指定模块的实例句柄 (HINSTANCE)。</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)">
          <source>The HINSTANCE for <ph id="ph1">&lt;paramref name="m" /&gt;</ph>; or -1 if the module does not have an HINSTANCE.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph> 的 INSTANCE；如果该模块没有 HINSTANCE，则为 -1。</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)">
          <source>When dynamic or in-memory, modules do not have an HINSTANCE.</source>
          <target state="translated">当动态或内存中时，模块没有 HINSTANCE。</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)">
          <source>The <ph id="ph1">&lt;paramref name="m" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>The exception to convert to an HRESULT.</source>
          <target state="translated">要转换为 HRESULT 的异常。</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>Converts the specified exception to an HRESULT.</source>
          <target state="translated">将指定异常转换为 HRESULT。</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>The HRESULT mapped to the supplied exception.</source>
          <target state="translated">映射到所提供的异常的 HRESULT。</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A&gt;</ph> also sets up an <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface for the exception that can be obtained by calling the COM GetErrorInfoNEEDGUID function.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A&gt;</ph> 此外设置<bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept>异常可以通过调用 COM GetErrorInfoNEEDGUID 函数获取的接口。</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>You can use this function to return an HRESULT value on a managed class implementation of a COM interface where you apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.PreserveSigAttribute&gt;</ph> attribute.</source>
          <target state="translated">你可以使用此函数返回在应用的 COM 接口的托管的类实现上的 HRESULT 值<ph id="ph1">&lt;xref:System.Runtime.InteropServices.PreserveSigAttribute&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>Have the attributed method catch all exceptions and use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A&gt;</ph> method to return the appropriate HRESULT value.</source>
          <target state="translated">特性化的方法捕捉所有异常，并使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A&gt;</ph>方法来返回适当的 HRESULT 值。</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>Allowing an exception to propagate outside the method produces incorrect behavior.</source>
          <target state="translated">允许异常传播方法之外生成不正确的行为。</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>(In fact, the common language runtime fails to pass an exception to a COM client that calls such a method through a v-table.)</source>
          <target state="translated">（事实上，公共语言运行时无法将异常传递给调用这种方法通过 v-表的 COM 客户端。）</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>Note that the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A&gt;</ph> method sets the <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface of the current thread.</source>
          <target state="translated">请注意，<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A&gt;</ph>方法设置<bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept>当前线程的接口。</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>This can cause unexpected results for methods like the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> methods that default to using the <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> of the current thread if it is set.</source>
          <target state="translated">这可能导致意外的结果，方法等<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph>默认使用的方法<bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept>如果设置的当前线程。</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error">
          <source>Returns the HRESULT corresponding to the last error incurred by Win32 code executed using <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.Marshal" /&gt;</ph>.</source>
          <target state="translated">返回 HRESULT，它对应于使用 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.Marshal" /&gt;</ph> 执行的 Win32 代码引起的最后一个错误。</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error">
          <source>The HRESULT corresponding to the last Win32 error code.</source>
          <target state="translated">对应于最后一个 Win32 错误代码的 HRESULT。</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error">
          <source>The target function must have had the <ph id="ph1">`setLastError`</ph> metadata flag set.</source>
          <target state="translated">必须有目标函数<ph id="ph1">`setLastError`</ph>元数据标志设置。</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error">
          <source>For example, the <ph id="ph1">`SetLastError`</ph> field of the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType&gt;</ph> must be <ph id="ph3">`true`</ph>.</source>
          <target state="translated">例如，<ph id="ph1">`SetLastError`</ph>字段<ph id="ph2">&lt;xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType&gt;</ph>必须<ph id="ph3">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error">
          <source>The process for setting this flag depends on the source language used: C# and C++ are <ph id="ph1">`false`</ph> by default, but the <ph id="ph2">`Declare`</ph> statement in Visual Basic is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">设置此标志的过程取决于使用的源语言： C# 和 c + + 是<ph id="ph1">`false`</ph>默认情况下，但<ph id="ph2">`Declare`</ph>在 Visual Basic 中的语句是<ph id="ph3">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error">
          <source>The following example demonstrates how to retrieve an HRESULT corresponding to a Win32 error code using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例演示如何检索与 Win32 错误代码使用相对应的 HRESULT<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>The object whose <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> interface is requested.</source>
          <target state="translated">其 <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> 接口被请求的对象。</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>Returns an <bpt id="p1">[</bpt>IDispatch<ept id="p1">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> interface from a managed object.</source>
          <target state="translated">从托管对象返回一个 <bpt id="p1">[</bpt>IDispatch<ept id="p1">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> 接口。</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>The <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> pointer for the <ph id="ph2">&lt;paramref name="o" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="o" /&gt;</ph> 参数的 <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> 指针。</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>In managed code, you seldom work directly with the <ph id="ph1">`IDispatch`</ph> interface.</source>
          <target state="translated">在托管代码中，您很少直接处理<ph id="ph1">`IDispatch`</ph>接口。</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>However, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A&gt;</ph> is useful when calling a method that exposes a COM object parameter as an <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> type, or with custom marshaling.</source>
          <target state="translated">但是，<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A&gt;</ph>时调用的方法公开为 COM 对象参数非常有用<ph id="ph2">&lt;xref:System.IntPtr&gt;</ph>类型，或与自定义封送。</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</source>
          <target state="translated">使用此方法调用对象会导致要递增的接口指针上之前，则返回指针的引用计数。</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>Always use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph> to decrement the reference count once you have finished with the pointer.</source>
          <target state="translated">始终使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph>要完与指针后递减引用计数。</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>You can also use this method on a managed object to obtain an interface pointer to the COM callable wrapper for the object.</source>
          <target state="translated">你可以对托管对象使用此方法以获取指向对象的 COM 可调用包装器的接口指针。</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>For additional information, see <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>.</source>
          <target state="translated">有关其他信息，请参阅<bpt id="p1">[</bpt>COM 可调用包装<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>。</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> does not support the requested interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 不支持请求的接口。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)">
          <source>The object whose <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> interface is requested.</source>
          <target state="translated">其 <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> 接口被请求的对象。</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)">
          <source>Returns an <bpt id="p1">[</bpt>IDispatch<ept id="p1">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> interface pointer from a managed object, if the caller is in the same context as that object.</source>
          <target state="translated">如果调用方与托管对象在同一上下文中，则从该对象返回一个 <bpt id="p1">[</bpt>IDispatch<ept id="p1">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> 接口指针。</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)">
          <source>The <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> interface pointer for the specified object, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the caller is not in the same context as the specified object.</source>
          <target state="translated">指定对象的 <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> 接口指针；如果调用方与指定对象不在同一上下文中，则为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)">
          <source>This method is the same as <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A&gt;</ph> except that it returns <ph id="ph2">`null`</ph> if the caller is not in the same context as the object.</source>
          <target state="translated">此方法等同于<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A&gt;</ph>，只不过它将返回<ph id="ph2">`null`</ph>如果调用方不是作为对象相同的上下文中。</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> does not support the requested interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 不支持请求的接口。</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>The type whose <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> interface is being requested.</source>
          <target state="translated">正在请求其 <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> 接口的类型。</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComTypes.ITypeInfo" /&gt;</ph> interface from a managed type.</source>
          <target state="translated">从托管类型返回一个 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComTypes.ITypeInfo" /&gt;</ph> 接口。</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>A pointer to the <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> interface for the <ph id="ph2">&lt;paramref name="t" /&gt;</ph> parameter.</source>
          <target state="translated">指向 <ph id="ph2">&lt;paramref name="t" /&gt;</ph> 参数的 <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> 接口的指针。</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>This method returns a pointer to an <ph id="ph1">`ITypeInfo`</ph> implementation that is based on the original type.</source>
          <target state="translated">此方法返回一个指向<ph id="ph1">`ITypeInfo`</ph>基于原始类型的实现。</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>Calling an object with <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A&gt;</ph> causes the reference count to increment on the interface pointer before the pointer is returned.</source>
          <target state="translated">调用具有的对象<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A&gt;</ph>导致要递增的接口指针上之前，则返回指针的引用计数。</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>Always use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph> to decrement the reference count once you have finished with the pointer.</source>
          <target state="translated">始终使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph>要完与指针后递减引用计数。</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>You can apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType&gt;</ph> to replace standard interop marshaling behavior with this custom marshaler.</source>
          <target state="translated">你可以将应用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType&gt;</ph>将替换为此自定义封送处理程序的标准的互操作封送处理行为。</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>The following example demonstrates how to retrieve a pointer to the <ph id="ph1">`ITypeInfo`</ph> interface for a type using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例演示如何检索一个指向<ph id="ph1">`ITypeInfo`</ph>类型使用的接口<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> is not a visible type to COM.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> 不是 COM 的可见类型。</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> 是 <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> 类型。</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>A type library is registered for the assembly that contains the type, but the type definition cannot be found.</source>
          <target state="translated">为包含一个类型的程序集注册了该类型的类型库，但找不到类型定义。</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>The object whose <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> interface is requested.</source>
          <target state="translated">其 <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> 接口被请求的对象。</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>Returns an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface from a managed object.</source>
          <target state="translated">从托管对象返回 <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> 接口。</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>The <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> pointer for the <ph id="ph2">&lt;paramref name="o" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="o" /&gt;</ph> 参数的 <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> 指针。</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>In managed code, you seldom work directly with the <ph id="ph1">`IUnknown`</ph> interface.</source>
          <target state="translated">在托管代码中，您很少直接处理<ph id="ph1">`IUnknown`</ph>接口。</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>However, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A&gt;</ph> is useful when calling a method that exposes a COM object parameter as an <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> type, or with custom marshaling.</source>
          <target state="translated">但是，<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A&gt;</ph>时调用的方法公开为 COM 对象参数非常有用<ph id="ph2">&lt;xref:System.IntPtr&gt;</ph>类型，或与自定义封送。</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</source>
          <target state="translated">使用此方法调用对象会导致要递增的接口指针上之前，则返回指针的引用计数。</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>Always use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph> to decrement the reference count once you have finished with the pointer.</source>
          <target state="translated">始终使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph>要完与指针后递减引用计数。</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>This method provides the opposite functionality of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">此方法提供的相反功能<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>You can also use this method on a managed object to obtain an interface pointer to the <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept> for the object.</source>
          <target state="translated">你还可用于此方法对托管对象获取的接口指针到<bpt id="p1">[</bpt>COM 可调用包装<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>对象。</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>The following example demonstrates how to retrieve an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface for a managed object using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例演示如何检索<bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept>托管的对象使用的接口<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)">
          <source>The object whose <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> interface is requested.</source>
          <target state="translated">其 <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> 接口被请求的对象。</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)">
          <source>Returns an <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface from a managed object, if the caller is in the same context as that object.</source>
          <target state="translated">如果调用方与托管对象在同一上下文中，则从该对象返回一个 <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> 接口。</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)">
          <source>The <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> pointer for the specified object, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the caller is not in the same context as the specified object.</source>
          <target state="translated">指定对象的 <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> 指针；如果调用方与指定对象不在同一上下文中，则为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)">
          <source>This method is the same as <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A&gt;</ph> except that it returns <ph id="ph2">`null`</ph> if the caller is not in the same context as the object.</source>
          <target state="translated">此方法等同于<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A&gt;</ph>，只不过它将返回<ph id="ph2">`null`</ph>如果调用方不是作为对象相同的上下文中。</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)">
          <source>The following example demonstrates how to retrieve an <ph id="ph1">`IUnknown`</ph> interface for a managed object using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例演示如何检索<ph id="ph1">`IUnknown`</ph>托管的对象使用的接口<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>Returns the error code returned by the last unmanaged function that was called using platform invoke that has the <ph id="ph1">&lt;see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /&gt;</ph> flag set.</source>
          <target state="translated">返回由上一个非托管函数返回的错误代码，该函数是使用设置了 <ph id="ph1">&lt;see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /&gt;</ph> 标志的平台调用来的。</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>The last error code set by a call to the Win32 <bpt id="p1">[</bpt>SetLastError<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148656)</ept> function.</source>
          <target state="translated">通过调用 Win32 <bpt id="p1">[</bpt>SetLastError<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148656)</ept> 函数设置的最后一个错误代码。</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A&gt;</ph> exposes the Win32 <bpt id="p1">[</bpt>GetLastError<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148657)</ept> function from Kernel32.DLL.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A&gt;</ph> 公开 Win32 <bpt id="p1">[</bpt>GetLastError<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148657)</ept>从 Kernel32.DLL 函数。</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>This method exists because it is not safe to make a direct platform invoke call to <ph id="ph1">`GetLastError`</ph> to obtain this information.</source>
          <target state="translated">此方法存在的原因是不安全直接进行平台 invoke 调用到<ph id="ph1">`GetLastError`</ph>获取此信息。</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>If you want to access this error code, you must call <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A&gt;</ph> instead of writing your own platform invoke definition for <ph id="ph2">`GetLastError`</ph> and calling it.</source>
          <target state="translated">如果你想要访问此错误代码，则必须调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A&gt;</ph>而不是编写您自己的平台调用定义<ph id="ph2">`GetLastError`</ph>并调用它。</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>The common language runtime can make internal calls to APIs that overwrite the <ph id="ph1">`GetLastError`</ph> maintained by the operating system.</source>
          <target state="translated">公共语言运行时可对覆盖的 Api 的内部调用<ph id="ph1">`GetLastError`</ph>由操作系统维护。</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>You can use this method to obtain error codes only if you apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType&gt;</ph> to the method signature and set the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError&gt;</ph> field to<ph id="ph3">`true`</ph>.</source>
          <target state="translated">你可以使用此方法以获取错误代码，仅当你将应用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType&gt;</ph>到方法签名和集<ph id="ph2">&lt;xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError&gt;</ph>字段<ph id="ph3">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>The process for this varies depending upon the source language used: C# and C++ are <ph id="ph1">`false`</ph> by default, but the <ph id="ph2">`Declare`</ph> statement in Visual Basic is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">此过程会有所不同具体使用的源语言取决于： C# 和 c + + 是<ph id="ph1">`false`</ph>默认情况下，但<ph id="ph2">`Declare`</ph>在 Visual Basic 中的语句是<ph id="ph3">`true`</ph>。</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>The following example demonstrates calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例演示如何调用 <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>The example first demonstrates calling the method with no error present and then demonstrates calling the method with an error present.</source>
          <target state="translated">该示例首先演示调用具有不显示错误的方法，然后演示调用的方法并显示错误。</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>A pointer to the method to marshal.</source>
          <target state="translated">指向要封送的方法的指针。</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>A pointer to the method signature.</source>
          <target state="translated">指向方法签名的指针。</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>The number of bytes in <bpt id="p1">&lt;c&gt;</bpt>pbSignature<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>pbSignature<ept id="p1">&lt;/c&gt;</ept> 中的字节数。</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>Gets a pointer to a runtime-generated function that marshals a call from managed to unmanaged code.</source>
          <target state="translated">获取指向运行时生成的函数的指针，该函数将调用从托管代码封送到非托管代码。</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>A pointer to the function that will marshal a call from the <ph id="ph1">&lt;paramref name="pfnMethodToWrap" /&gt;</ph> parameter to unmanaged code.</source>
          <target state="translated">指向一个函数的指针，该函数将调用从 <ph id="ph1">&lt;paramref name="pfnMethodToWrap" /&gt;</ph> 参数封送到非托管代码。</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr%2A&gt;</ph> is exposed for compiler support only.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr%2A&gt;</ph> 被公开 for 编译器仅支持 32 位。</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>The type for which the <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> is to be retrieved.</source>
          <target state="translated">要检索的 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 的类型。</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>The VTBL slot.</source>
          <target state="translated">VTBL 槽。</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>On successful return, one of the enumeration values that specifies the type of the member.</source>
          <target state="translated">在成功返回时，为指定成员类型的枚举值之一。</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>Retrieves a <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> object for the specified virtual function table (v-table or VTBL) slot.</source>
          <target state="translated">检索指定的虚拟功能表（v 表或 VTBL）槽的 <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>The object that represents the member at the specified VTBL slot.</source>
          <target state="translated">表示指定 VTBL 槽上成员的对象。</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>The return value may be a <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, or <ph id="ph3">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> object.</source>
          <target state="translated">返回值可能为<ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph>， <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>，或<ph id="ph3">&lt;xref:System.Reflection.PropertyInfo&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>The return value depends on the type of managed member that exists in the given COM slot (hence the generalized return type <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> from which all three derive).</source>
          <target state="translated">返回的值取决于托管在给定的 COM 插槽中存在的成员的类型 (因此通用的返回类型<ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph>所有三个派生)。</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>The zero-based slot number that is returned by this method accounts for three <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> and possibly four <bpt id="p2">[</bpt>IDispatch<ept id="p2">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept> methods, making the value of the first available slot either 3 or 7.</source>
          <target state="translated">此方法返回的从零开始的槽数量的三个帐户<bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept>和可能的第四个<bpt id="p2">[</bpt>IDispatch<ept id="p2">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept>方法，使任一 3 的第一个可用槽的值或 7。</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A&gt;</ph> provides the opposite functionality of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A&gt;</ph> 提供的相反功能<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType&gt;</ph> in conjunction with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A&gt;</ph> to pass slots within a specified range.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType&gt;</ph>结合<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A&gt;</ph>以传递指定的范围中的槽。</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>The <ph id="ph1">`memberType`</ph> parameter is important only on return.</source>
          <target state="translated"><ph id="ph1">`memberType`</ph>参数是仅在返回重要。</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>It contains the type of the COM member (a regular method or a property accessor) that corresponds to the returned <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object.</source>
          <target state="translated">它包含的类型对应于返回的 COM 成员 （常规方法或属性访问器） 的<ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph>对象。</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> is not visible from COM.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> 在 COM 中不可见。</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)">
          <source>The object for which to get a COM VARIANT.</source>
          <target state="translated">为其获取 COM VARIANT 的对象。</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)">
          <source>A pointer to receive the VARIANT that corresponds to the <bpt id="p1">&lt;c&gt;</bpt>obj<ept id="p1">&lt;/c&gt;</ept> parameter.</source>
          <target state="translated">一个用于接收对应于 <bpt id="p1">&lt;c&gt;</bpt>obj<ept id="p1">&lt;/c&gt;</ept> 参数的 VARIANT 的指针。</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)">
          <source>Converts an object to a COM VARIANT.</source>
          <target state="translated">将对象转换为 COM VARIANT。</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)">
          <source>The <ph id="ph1">`pDstNativeVariant`</ph> parameter must point to sufficient memory to store the resulting VARIANT.</source>
          <target state="translated"><ph id="ph1">`pDstNativeVariant`</ph>参数必须指向足够的内存来存储生成的变体。</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)">
          <source>Also, the implementation of this method calls the <bpt id="p1">[</bpt>VariantInit<ept id="p1">](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx)</ept> function on the raw memory that the <ph id="ph1">`pDstNativeVariant`</ph> parameter points to.</source>
          <target state="translated">此外，此方法的实现调用<bpt id="p1">[</bpt>VariantInit<ept id="p1">](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx)</ept>原始的内存的函数，<ph id="ph1">`pDstNativeVariant`</ph>参数指向。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is an instance of a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 参数是泛型类型的实例。</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)">
          <source>The type of the object to convert.</source>
          <target state="translated">要转换的对象的类型。</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)">
          <source>The object for which to get a COM VARIANT.</source>
          <target state="translated">为其获取 COM VARIANT 的对象。</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)">
          <source>A pointer to receive the VARIANT that corresponds to the <bpt id="p1">&lt;c&gt;</bpt>obj<ept id="p1">&lt;/c&gt;</ept> parameter.</source>
          <target state="translated">一个用于接收对应于 <bpt id="p1">&lt;c&gt;</bpt>obj<ept id="p1">&lt;/c&gt;</ept> 参数的 VARIANT 的指针。</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[在 .NET Framework 4.5.1 和更高版本中受支持]</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)">
          <source>Converts an object of a specified type to a COM VARIANT.</source>
          <target state="translated">将指定类型的对象转换为 COM VARIANT。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)">
          <source>The <ph id="ph1">`pDstNativeVariant`</ph> parameter must point to sufficient memory to store the resulting VARIANT.</source>
          <target state="translated"><ph id="ph1">`pDstNativeVariant`</ph>参数必须指向足够的内存来存储生成的变体。</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)">
          <source>Also, the implementation of this method calls <bpt id="p1">[</bpt>VariantInit<ept id="p1">](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx)</ept> function on the raw memory that the <ph id="ph1">`pDstNativeVariant`</ph> parameter points to.</source>
          <target state="translated">此外，此方法的实现调用<bpt id="p1">[</bpt>VariantInit<ept id="p1">](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx)</ept>原始的内存的函数，<ph id="ph1">`pDstNativeVariant`</ph>参数指向。</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>A pointer to the <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> interface.</source>
          <target state="translated">指向 <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> 接口的指针。</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>Returns an instance of a type that represents a COM object by a pointer to its <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface.</source>
          <target state="translated">返回一个类型实例，该实例通过指向 COM 对象的 <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> 接口的指针表示该对象。</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>An object that represents the specified unmanaged COM object.</source>
          <target state="translated">一个对象，表示指定的非托管 COM 对象。</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>This method wraps <ph id="ph1">`IUnknown`</ph> in a managed object.</source>
          <target state="translated">此方法会包装<ph id="ph1">`IUnknown`</ph>托管对象中。</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>This has the effect of incrementing the reference count of the COM component.</source>
          <target state="translated">这相当递增 COM 组件的引用计数。</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>The reference count will be decremented when the runtime performs garbage collection on the managed object that represents the COM object.</source>
          <target state="translated">当运行时对托管对象，表示 COM 对象执行垃圾回收，引用计数将会减少。</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>The <ph id="ph1">`pUnk`</ph> parameter represents an <ph id="ph2">`IUnknown`</ph> interface pointer; however, because all COM interfaces derive directly or indirectly from <ph id="ph3">`IUnknown`</ph>, you can pass any COM interface to this method.</source>
          <target state="translated"><ph id="ph1">`pUnk`</ph>参数表示<ph id="ph2">`IUnknown`</ph>接口指针; 但是，因为所有的 COM 接口直接或间接派生从<ph id="ph3">`IUnknown`</ph>，可以将任何 COM 接口传递给此方法。</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>The object returned by <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A&gt;</ph> is a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>, which the common language runtime manages as it does any other managed object.</source>
          <target state="translated">返回的对象<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A&gt;</ph>是<bpt id="p1">[</bpt>运行时可调用包装器<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>，公共语言运行时文件作为它来管理执行任何其他托管的对象。</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>The type of this wrapper is often a base <ph id="ph1">`System.__ComObject`</ph> type, which is a hidden type used when the wrapper type is ambiguous.</source>
          <target state="translated">此包装器的类型通常为基准<ph id="ph1">`System.__ComObject`</ph>类型，是使用包装类型不明确时的隐藏的类型。</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>You can still make late-bound calls to such a base type as long as the COM object implements the <bpt id="p1">[</bpt>IDispatch<ept id="p1">](https://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5(vs.85))</ept> interface.</source>
          <target state="translated">你仍可以对此类的基类的后期绑定调用，只要该 COM 对象实现<bpt id="p1">[</bpt>IDispatch<ept id="p1">](https://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5(vs.85))</ept>接口。</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>Likewise, you can cast the returned object to an appropriate COM interface.</source>
          <target state="translated">同样，您可以强制转换为适当的 COM 接口返回的对象。</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>For an object to be wrapped with a specific managed class type (and not a generic wrapper type), you must adhere to the following requirements:</source>
          <target state="translated">要包装的对象使用特定的托管的类类型 （和不能是泛型包装类型），你必须遵守以下要求：</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>Implement the <bpt id="p1">[</bpt>IProvideClassInfo<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148012)</ept> interface for the COM object.</source>
          <target state="translated">实现<bpt id="p1">[</bpt>IProvideClassInfo<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=148012)</ept> COM 对象的接口。</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>Register the containing assembly with the <bpt id="p1">[</bpt>Regasm.exe (Assembly Registration Tool)<ept id="p1">](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md)</ept>.</source>
          <target state="translated">注册具有包含程序集<bpt id="p1">[</bpt>Regasm.exe （程序集注册工具）<ept id="p1">](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md)</ept>。</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>Alternatively, you can avoid these requirements and still get an object that is wrapped with a specific managed class type by using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">或者，你可以避免这些要求，并仍获取具有特定的托管的类类型使用包装的对象<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source>A pointer to a COM VARIANT.</source>
          <target state="translated">指向 COM VARIANT 的指针。</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source>Converts a COM VARIANT to an object.</source>
          <target state="translated">将 COM VARIANT 转换为对象。</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source>An object that corresponds to the <ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> parameter.</source>
          <target state="translated">对应于 <ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> 参数的对象。</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A&gt;</ph> returns a managed object that corresponds to a raw pointer to an unmanaged VARIANT type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A&gt;</ph> 返回对应的托管的对象的原始指针到非托管的变体类型。</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source>The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</source>
          <target state="translated">公开给托管代码的变体类型时，interopmarshaler 执行相同的转换。</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A&gt;</ph> provides the opposite functionality of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A&gt;</ph> 提供的相反功能<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source>When the VARIANT type is VT_ERROR, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A&gt;</ph> returns an object of type <ph id="ph2">`Int32`</ph> instead of <ph id="ph3">`UInt32`</ph>.</source>
          <target state="translated">VARIANT 类型时 VT_ERROR，<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A&gt;</ph>返回类型的对象，<ph id="ph2">`Int32`</ph>而不是<ph id="ph3">`UInt32`</ph>。</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> is not a valid VARIANT type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> 不是有效的 VARIANT 类型。</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> has an unsupported type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> 包含不受支持的类型。</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source>The type to which to convert the COM VARIANT.</source>
          <target state="translated">要将 COM VARIANT 转换为的类型。</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source>A pointer to a COM VARIANT.</source>
          <target state="translated">指向 COM VARIANT 的指针。</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[在 .NET Framework 4.5.1 和更高版本中受支持]</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source>Converts a COM VARIANT to an object of a specified type.</source>
          <target state="translated">将 COM VARIANT 转换为指定类型的对象。</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source>An object of the specified type that corresponds to the <ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> parameter.</source>
          <target state="translated">一个与 <ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> 参数对应的指定类型的对象。</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29&gt;</ph> returns a managed object of type <ph id="ph2">`T`</ph> that corresponds to a raw pointer to an unmanaged VARIANT type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29&gt;</ph> 返回类型的托管的对象<ph id="ph2">`T`</ph>对应到非托管的变体类型的原始指针。</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source>The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</source>
          <target state="translated">公开给托管代码的变体类型时，interopmarshaler 执行相同的转换。</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29&gt;</ph> provides the opposite functionality of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%60%601%28%60%600%2CSystem.IntPtr%29&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29&gt;</ph> 提供的相反功能<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%60%601%28%60%600%2CSystem.IntPtr%29&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> is not a valid VARIANT type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> 不是有效的 VARIANT 类型。</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> has an unsupported type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pSrcNativeVariant" /&gt;</ph> 包含不受支持的类型。</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>A pointer to the first element of an array of COM VARIANTs.</source>
          <target state="translated">指向 COM VARIANT 数组中第一个元素的指针。</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>The count of COM VARIANTs in <bpt id="p1">&lt;c&gt;</bpt>aSrcNativeVariant<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>aSrcNativeVariant<ept id="p1">&lt;/c&gt;</ept> 中的 COM VARIANT 的计数。</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>Converts an array of COM <bpt id="p1">[</bpt>VARIANTs<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148670)</ept> to an array of objects.</source>
          <target state="translated">将 COM <bpt id="p1">[</bpt>VARIANT<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148670)</ept> 数组转换为对象数组。</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>An object array that corresponds to <ph id="ph1">&lt;paramref name="aSrcNativeVariant" /&gt;</ph>.</source>
          <target state="translated">对应于 <ph id="ph1">&lt;paramref name="aSrcNativeVariant" /&gt;</ph> 的对象数组。</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%2A&gt;</ph> returns an array of managed objects that corresponds to a raw pointer to a C-style array of unmanaged VARIANT types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%2A&gt;</ph> 原始指针到非托管的变体类型的 C 样式数组中返回对应托管对象的数组。</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</source>
          <target state="translated">公开给托管代码的变体类型时，interopmarshaler 执行相同的转换。</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>The method returns an empty array when the <ph id="ph1">`cVars`</ph> parameter is 0.</source>
          <target state="translated">该方法将返回一个空数组时<ph id="ph1">`cVars`</ph>参数为 0。</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>The object array (the return value) gets garbage collected as usual.</source>
          <target state="translated">对象数组 （返回值） 获取垃圾回收像往常一样。</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>The unmanaged input array or individual VARIANTs in the input array are not freed.</source>
          <target state="translated">不会释放非托管的输入的数组或输入数组中的各个变体。</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>Therefore it is your responsibility to free them as appropriate.</source>
          <target state="translated">因此它由你负责根据需要释放它们。</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="cVars" /&gt;</ph> is a negative number.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cVars" /&gt;</ph> 为负数。</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>The type of the array to return.</source>
          <target state="translated">要返回的数组的类型。</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>A pointer to the first element of an array of COM VARIANTs.</source>
          <target state="translated">指向 COM VARIANT 数组中第一个元素的指针。</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>The count of COM VARIANTs in <bpt id="p1">&lt;c&gt;</bpt>aSrcNativeVariant<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>aSrcNativeVariant<ept id="p1">&lt;/c&gt;</ept> 中的 COM VARIANT 的计数。</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[在 .NET Framework 4.5.1 和更高版本中受支持]</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>Converts an array of COM VARIANTs to an array of a specified type.</source>
          <target state="translated">将 COM VARIANT 数组转换为指定类型的数组。</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>An array of <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> objects that corresponds to <ph id="ph2">&lt;paramref name="aSrcNativeVariant" /&gt;</ph>.</source>
          <target state="translated">对应于 <ph id="ph2">&lt;paramref name="aSrcNativeVariant" /&gt;</ph> 的 <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> 对象的数组。</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%60%601%28System.IntPtr%2CSystem.Int32%29&gt;</ph> returns an array of <ph id="ph2">`T`</ph> that corresponds to a raw pointer to a C-style array of unmanaged VARIANT types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%60%601%28System.IntPtr%2CSystem.Int32%29&gt;</ph> 返回的数组<ph id="ph2">`T`</ph>对应到非托管的变体类型的 C 样式数组的原始指针。</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</source>
          <target state="translated">公开给托管代码的变体类型时，interopmarshaler 执行相同的转换。</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>The method returns an empty array when the <ph id="ph1">`cVars`</ph> parameter is 0.</source>
          <target state="translated">该方法将返回一个空数组时<ph id="ph1">`cVars`</ph>参数为 0。</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>The returned array is garbage-collected as usual.</source>
          <target state="translated">返回的数组进行垃圾回收像往常一样。</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>The unmanaged input array or individual VARIANTs in the input array are not freed.</source>
          <target state="translated">不会释放非托管的输入的数组或输入数组中的各个变体。</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>Therefore, it is your responsibility to free them as appropriate.</source>
          <target state="translated">因此，它由你负责根据需要释放它们。</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="cVars" /&gt;</ph> is a negative number.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cVars" /&gt;</ph> 为负数。</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>A type that represents an interface.</source>
          <target state="translated">表示接口的类型。</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>Gets the first slot in the virtual function table (v-table or VTBL) that contains user-defined methods.</source>
          <target state="translated">获取虚拟功能表（v 表或 VTBL）中包含用户定义的方法的第一个槽。</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>The first VTBL slot that contains user-defined methods.</source>
          <target state="translated">包含用户定义的方法的第一个 VTBL 槽。</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>The first slot is 3 if the interface is based on <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept>, and 7 if the interface is based on <bpt id="p2">[</bpt>IDispatch<ept id="p2">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept>.</source>
          <target state="translated">如果接口基于 <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept>，则第一个槽为 3；如果接口基于 <bpt id="p2">[</bpt>IDispatch<ept id="p2">](http://msdn.microsoft.com/library/ebbff4bc-36b2-4861-9efa-ffa45e013eb5)</ept>，则为 7。</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>This method returns the zero-based v-table number for an interface or a class.</source>
          <target state="translated">此方法返回的接口或类的从零开始的 v 表号。</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>When used on a class, the slot number that is returned refers to the class interface for the class.</source>
          <target state="translated">当在类上使用，则返回的槽编号引用类的类接口。</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>If the class interface is auto-dispatch, this method always returns -1 to indicate that the dispatch-only interface does not expose a v-table to managed clients.</source>
          <target state="translated">如果此类接口是自动调度，则此方法始终返回-1 以指示仅支持调度的接口未公开 v-表向托管客户端。</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType&gt;</ph> in conjunction with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType&gt;</ph> to pass slots within a specified range.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType&gt;</ph>结合<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType&gt;</ph>以传递指定的范围中的槽。</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>For additional information, see <bpt id="p1">[</bpt>Introducing the Class Interface<ept id="p1">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept>.</source>
          <target state="translated">有关其他信息，请参阅<bpt id="p1">[</bpt>类接口简介<ept id="p1">](http://msdn.microsoft.com/library/733c0dd2-12e5-46e6-8de1-39d5b25df024)</ept>。</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> is not visible from COM.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> 在 COM 中不可见。</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)">
          <source>An integer that represents a fiber cookie.</source>
          <target state="translated">表示纤程 Cookie 的整数。</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)">
          <source>Converts a fiber cookie into the corresponding <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> instance.</source>
          <target state="translated">将纤程 cookie 转换为相应的 <ph id="ph1">&lt;see cref="T:System.Threading.Thread" /&gt;</ph> 实例。</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)">
          <source>A thread that corresponds to the <ph id="ph1">&lt;paramref name="cookie" /&gt;</ph> parameter.</source>
          <target state="translated">对应于 <ph id="ph1">&lt;paramref name="cookie" /&gt;</ph> 参数的线程。</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)">
          <source>Fiber cookies are opaque tokens that are used by the host when alerting the common language runtime to its fiber-scheduling decisions.</source>
          <target state="translated">纤程 cookie 是不透明的警报及其纤程计划决策公共语言运行时主机使用的令牌。</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)">
          <source>They consist of a stack and register context.</source>
          <target state="translated">它们堆栈组成，并注册上下文。</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="cookie" /&gt;</ph> parameter is 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cookie" /&gt;</ph> 参数为 0。</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>A pointer to the <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> interface of the unmanaged object.</source>
          <target state="translated">指向非托管对象的 <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> 接口的指针。</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>The type of the requested managed class.</source>
          <target state="translated">请求的托管类的类型。</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>Returns a managed object of a specified type that represents a COM object.</source>
          <target state="translated">返回表示 COM 对象的指定类型的托管对象。</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>An instance of the class corresponding to the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the requested unmanaged COM object.</source>
          <target state="translated">类的实例，与表示所请求的非托管 COM 对象的 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象相对应。</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>The <ph id="ph1">`t`</ph> parameter must be either a COM-imported type or a subtype of a COM-imported type.</source>
          <target state="translated"><ph id="ph1">`t`</ph>参数必须是 COM 导入类型或子类型的 COM 导入的类型。</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>In addition, <ph id="ph1">`t`</ph> must be a type whose metadata was imported by the <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool.</source>
          <target state="translated">此外，<ph id="ph1">`t`</ph>必须是由其元数据导入的类型<bpt id="p1">[</bpt>Tlbimp.exe （类型库导入程序）<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept>工具。</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>This type must be a class and not an associated coclass interface, which carries the name of the COM class.</source>
          <target state="translated">此类型必须是一个类和不是关联的组件类接口，这会带来的 COM 类的名称。</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>For example, if Tlbimp.exe imports <ph id="ph1">`Myclass`</ph> as a class called <ph id="ph2">`MyclassClass`</ph> and as a coclass interface called <ph id="ph3">`Myclass`</ph>, you must use <ph id="ph4">`MyclassClass`</ph> (not <ph id="ph5">`Myclass`</ph>) with this method.</source>
          <target state="translated">例如，如果 Tlbimp.exe 导入<ph id="ph1">`Myclass`</ph>作为一个名为类<ph id="ph2">`MyclassClass`</ph>和为组件类接口调用<ph id="ph3">`Myclass`</ph>，必须使用<ph id="ph4">`MyclassClass`</ph>(不<ph id="ph5">`Myclass`</ph>) 使用此方法。</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>For additional information about imported classes and coclass interfaces, see <bpt id="p1">[</bpt>Imported Type Conversion<ept id="p1">](http://msdn.microsoft.com/library/cb1ee67d-8ef0-4e40-b2a5-13714b9f33c3)</ept>.</source>
          <target state="translated">有关导入的类和组件类接口的其他信息，请参阅<bpt id="p1">[</bpt>导入类型转换<ept id="p1">](http://msdn.microsoft.com/library/cb1ee67d-8ef0-4e40-b2a5-13714b9f33c3)</ept>。</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>If an object has already been obtained for the <ph id="ph1">`pUnk`</ph> parameter, <ph id="ph2">`t`</ph> is ignored and the existing object is returned.</source>
          <target state="translated">如果已为获取了对象<ph id="ph1">`pUnk`</ph>参数，<ph id="ph2">`t`</ph>将被忽略并返回现有对象。</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source><ph id="ph1">`pUnk`</ph> represents an<bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface pointer; however, because all COM interfaces derive directly or indirectly from <ph id="ph2">`IUnknown`</ph>, you can pass any COM interface to this method.</source>
          <target state="translated"><ph id="ph1">`pUnk`</ph> 表示<bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept>接口指针; 但是，因为所有的 COM 接口直接或间接派生从<ph id="ph2">`IUnknown`</ph>，可以将任何 COM 接口传递给此方法。</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>The object returned by <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A&gt;</ph> is a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW), which the common language runtime manages as it does any other managed object.</source>
          <target state="translated">返回的对象<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A&gt;</ph>是<bpt id="p1">[</bpt>运行时可调用包装器<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>(RCW)，公共语言运行时文件作为它来管理执行任何其他托管的对象。</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> is not attributed with <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> 并不具有 <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph> 特性。</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source><ph id="ph1">&lt;paramref name="t" /&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> 是 <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> 类型。</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)">
          <source>The <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> interface to marshal.</source>
          <target state="translated">要封送的 <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> 接口。</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)">
          <source>Converts an unmanaged <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)</ept> object into a managed <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object.</source>
          <target state="translated">将非托管 <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)</ept> 对象转换为托管 <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)">
          <source>A managed type that represents the unmanaged <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> object.</source>
          <target state="translated">表示非托管 <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> 对象的托管类型。</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A&gt;</ph> returns a <ph id="ph2">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> instance that is based on the original type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A&gt;</ph> 返回<ph id="ph2">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph>基于原始类型的实例。</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)">
          <source>You can apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType&gt;</ph> to replace standard interop marshaling behavior with this custom marshaler.</source>
          <target state="translated">你可以将应用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType&gt;</ph>将替换为此自定义封送处理程序的标准的互操作封送处理行为。</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool uses the custom marshaler to translate <ph id="ph1">`ITypeInfo`</ph> parameters to <ph id="ph2">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> parameters.</source>
          <target state="translated"><bpt id="p1">[</bpt>Tlbimp.exe （类型库导入程序）<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept>工具使用自定义封送处理程序将<ph id="ph1">`ITypeInfo`</ph>参数<ph id="ph2">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph>参数。</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)">
          <source>However, if you obtain an <ph id="ph1">`ITypeInfo`</ph> interface by some means other than Tlbimp.exe, you can use <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A&gt;</ph> to manually perform the same translation.</source>
          <target state="translated">但是，如果你获取<ph id="ph1">`ITypeInfo`</ph>某些接口意味着 Tlbimp.exe 以外，你可以使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A&gt;</ph>手动执行相同的转换。</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeFromCLSID(System.Guid)">
          <source>The CLSID of the type to return.</source>
          <target state="translated">要返回的类型的 CLSID。</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeFromCLSID(System.Guid)">
          <source>Returns the type associated with the specified class identifier (CLSID).</source>
          <target state="translated">返回与指定的类标识符 (CLSID) 关联的类型。</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeFromCLSID(System.Guid)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph>，无论 CLSID 是否有效。</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Retrieves the name of the type represented by an <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)</ept> object.</source>
          <target state="translated">检索由 <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)</ept> 对象表示的类型的名称。</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)">
          <source>An object that represents an <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> pointer.</source>
          <target state="translated">一个表示 <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> 指针的对象。</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)">
          <source>Retrieves the name of the type represented by an <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)</ept> object.</source>
          <target state="translated">检索由 <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)</ept> 对象表示的类型的名称。</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)">
          <source>The name of the type that the <ph id="ph1">&lt;paramref name="typeInfo" /&gt;</ph> parameter points to.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeInfo" /&gt;</ph> 参数指向的类型的名称。</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)">
          <source>You can also retrieve the name of the type represented by an <ph id="ph1">`ITypeInfo`</ph> by calling the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType&gt;</ph> method and passing -1 for its first parameter.</source>
          <target state="translated">您还可以检索表示的类型的名称<ph id="ph1">`ITypeInfo`</ph>通过调用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType&gt;</ph>方法并为其第一个参数传递-1。</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)">
          <source>The <ph id="ph1">&lt;paramref name="typeInfo" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeInfo" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)">
          <source>An object that represents an <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> pointer.</source>
          <target state="translated">一个表示 <ph id="ph1">&lt;see langword="ITypeInfo" /&gt;</ph> 指针的对象。</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)">
          <source>Retrieves the name of the type represented by an <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)</ept> object.</source>
          <target state="translated">检索由 <bpt id="p1">[</bpt>ITypeInfo<ept id="p1">](http://msdn.microsoft.com/library/f3356463-3373-4279-bae1-953378aa2680)</ept> 对象表示的类型的名称。</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)">
          <source>The name of the type that the <ph id="ph1">&lt;paramref name="pTI" /&gt;</ph> parameter points to.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pTI" /&gt;</ph> 参数指向的类型的名称。</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)">
          <source>You can also retrieve the name of the type represented by an <ph id="ph1">`ITypeInfo`</ph> object by calling the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType&gt;</ph> method and passing -1 for its first parameter.</source>
          <target state="translated">您还可以检索表示的类型的名称<ph id="ph1">`ITypeInfo`</ph>对象通过调用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType&gt;</ph>方法并为其第一个参数传递-1。</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Retrieves the library identifier (LIBID) of a type library.</source>
          <target state="translated">检索类型库的库标识符 (LIBID)。</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>The type library whose LIBID is to be retrieved.</source>
          <target state="translated">要检索其 LIBID 的类型库。</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>Retrieves the library identifier (LIBID) of a type library.</source>
          <target state="translated">检索类型库的库标识符 (LIBID)。</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>The LIBID of the specified type library.</source>
          <target state="translated">指定类型库的 LIBID。</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> extracts the LIBID directly from an existing type library.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> 直接从现有类型库中提取 LIBID。</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>This action differs from that of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType&gt;</ph> method, which calculates what the LIBID should be based on the current assembly.</source>
          <target state="translated">此操作不同于<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType&gt;</ph>方法，以计算 LIBID 应基于当前程序集。</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>For more information about library identifiers, see <bpt id="p1">[</bpt>Exported Assembly Conversion<ept id="p1">](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86)</ept>.</source>
          <target state="translated">有关库标识符的详细信息，请参阅<bpt id="p1">[</bpt>导出程序集转换<ept id="p1">](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86)</ept>。</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>The type library whose LIBID is to be retrieved.</source>
          <target state="translated">要检索其 LIBID 的类型库。</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>Retrieves the library identifier (LIBID) of a type library.</source>
          <target state="translated">检索类型库的库标识符 (LIBID)。</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>The LIBID of the type library that the <ph id="ph1">&lt;paramref name="pTLB" /&gt;</ph> parameter points to.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pTLB" /&gt;</ph> 参数指向的类型库的 LIBID。</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> extracts the LIBID directly from an existing type library.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> 直接从现有类型库中提取 LIBID。</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>This action differs from that of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType&gt;</ph> method, which calculates what the LIBID should be based on the current assembly.</source>
          <target state="translated">此操作不同于<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType&gt;</ph>方法，以计算 LIBID 应基于当前程序集。</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>For more information about library identifiers, see <bpt id="p1">[</bpt>Exported Assembly Conversion<ept id="p1">](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86)</ept>.</source>
          <target state="translated">有关库标识符的详细信息，请参阅<bpt id="p1">[</bpt>导出程序集转换<ept id="p1">](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86)</ept>。</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>The assembly from which the type library was exported.</source>
          <target state="translated">从其导出类型库的程序集。</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>Retrieves the library identifier (LIBID) that is assigned to a type library when it was exported from the specified assembly.</source>
          <target state="translated">检索从指定程序集导出类型库时分配给该类型库的库标识符 (LIBID)。</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>The LIBID that is assigned to a type library when it is exported from the specified assembly.</source>
          <target state="translated">从指定的程序集导出类型库时分配给该类型库的 LIBID。</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>When assemblies are exported to type libraries, the type library is assigned a LIBID.</source>
          <target state="translated">当程序集导出类型库时，类型库分配一个 LIBID。</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>You can set the LIBID explicitly by applying the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=nameWithType&gt;</ph> at the assembly level, or it can be generated automatically.</source>
          <target state="translated">您可以通过应用显式设置 LIBID<ph id="ph1">&lt;xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=nameWithType&gt;</ph>在程序集级别，或者它可以自动生成。</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool calculates a LIBID value based on the identity of the assembly.</source>
          <target state="translated"><bpt id="p1">[</bpt>Tlbimp.exe （类型库导入程序）<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept>工具计算基于程序集的标识的 LIBID 值。</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> returns the LIBID that is associated with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.GuidAttribute&gt;</ph>, if the attribute is applied.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> 返回与关联的 LIBID <ph id="ph2">&lt;xref:System.Runtime.InteropServices.GuidAttribute&gt;</ph>，如果应用了该属性。</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>Otherwise, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A&gt;</ph> returns the calculated value.</source>
          <target state="translated">否则为<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A&gt;</ph>返回计算的值。</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph> method to extract the actual LIBID from an existing type library.</source>
          <target state="translated">或者，可以使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A&gt;</ph>方法以从现有的类型库中提取实际的 LIBID。</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>See the <bpt id="p1">[</bpt>Exported Assembly Conversion<ept id="p1">](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86)</ept> topic for more information about library identifiers.</source>
          <target state="translated">请参阅<bpt id="p1">[</bpt>导出程序集转换<ept id="p1">](http://msdn.microsoft.com/library/3fffd8db-240f-4fde-a558-a5bcc01e1a86)</ept>有关库标识符的详细信息的主题。</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source><ph id="ph1">&lt;paramref name="asm" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asm" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Retrieves the LCID of a type library.</source>
          <target state="translated">检索类型库的 LCID。</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>The type library whose LCID is to be retrieved.</source>
          <target state="translated">要检索其 LCID 的类型库。</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>Retrieves the LCID of a type library.</source>
          <target state="translated">检索类型库的 LCID。</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>The LCID of the type library that the <ph id="ph1">&lt;paramref name="typelib" /&gt;</ph> parameter points to.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typelib" /&gt;</ph> 参数指向的类型库的 LCID。</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>The type library whose LCID is to be retrieved.</source>
          <target state="translated">要检索其 LCID 的类型库。</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>Retrieves the LCID of a type library.</source>
          <target state="translated">检索类型库的 LCID。</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>The LCID of the type library that the <ph id="ph1">&lt;paramref name="pTLB" /&gt;</ph> parameter points to.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pTLB" /&gt;</ph> 参数指向的类型库的 LCID。</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Retrieves the name of a type library.</source>
          <target state="translated">检索类型库的名称。</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>The type library whose name is to be retrieved.</source>
          <target state="translated">要检索其名称的类型库。</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>Retrieves the name of a type library.</source>
          <target state="translated">检索类型库的名称。</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>The name of the type library that the <ph id="ph1">&lt;paramref name="typelib" /&gt;</ph> parameter points to.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typelib" /&gt;</ph> 参数指向的类型库的名称。</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>The name returned by this method is the identifier used with the library statement, such as ADODB for the Microsoft ADO type library.</source>
          <target state="translated">此方法返回的名称是用于库语句，如 ADODB Microsoft ADO 类型库的标识符。</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>The name is not a file name.</source>
          <target state="translated">名称不是文件名。</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>You can also retrieve the type library name by calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType&gt;</ph> method and passing -1 for its first parameter.</source>
          <target state="translated">您还可以通过调用来检索类型库名称<ph id="ph1">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType&gt;</ph>方法并为其第一个参数传递-1。</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>The <ph id="ph1">&lt;paramref name="typelib" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typelib" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>The type library whose name is to be retrieved.</source>
          <target state="translated">要检索其名称的类型库。</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>Retrieves the name of a type library.</source>
          <target state="translated">检索类型库的名称。</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>The name of the type library that the <ph id="ph1">&lt;paramref name="pTLB" /&gt;</ph> parameter points to.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pTLB" /&gt;</ph> 参数指向的类型库的名称。</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>The name returned by this method is the identifier used with the library statement, such as ADODB for the Microsoft ADO type library.</source>
          <target state="translated">此方法返回的名称是用于库语句，如 ADODB Microsoft ADO 类型库的标识符。</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>The name is not a file name.</source>
          <target state="translated">名称不是文件名。</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>You can also retrieve the type library name by calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType&gt;</ph> method and passing -1 for its first parameter.</source>
          <target state="translated">您还可以通过调用来检索类型库名称<ph id="ph1">&lt;xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType&gt;</ph>方法并为其第一个参数传递-1。</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)">
          <source>A managed assembly.</source>
          <target state="translated">托管程序集。</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)">
          <source>The major version number.</source>
          <target state="translated">主版本号。</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)">
          <source>The minor version number.</source>
          <target state="translated">次版本号。</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)">
          <source>Retrieves the version number of a type library that will be exported from the specified assembly.</source>
          <target state="translated">检索将从指定程序集导出的类型库的版本号。</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)">
          <source>Before exporting an assembly by using <ph id="ph1">&lt;xref:System.Runtime.InteropServices.TypeLibExporterFlags&gt;</ph> with the <ph id="ph2">`CallerResolvedReferences`</ph> value, you can use this method to retrieve the type library version from the assembly.</source>
          <target state="translated">通过使用导出程序集之前<ph id="ph1">&lt;xref:System.Runtime.InteropServices.TypeLibExporterFlags&gt;</ph>与<ph id="ph2">`CallerResolvedReferences`</ph>值，你可以使用此方法可从集中检索类型库版本。</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)">
          <source>If you do not apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.TypeLibVersionAttribute&gt;</ph> attribute to an exported assembly to explicitly control the version number of the generated type library, the type library will have the same version number as the assembly.</source>
          <target state="translated">如果您不会将应用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.TypeLibVersionAttribute&gt;</ph>属性设为以显式控制导出程序集生成的类型库的版本号，类型库必须与程序集相同的版本号。</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)">
          <source><ph id="ph1">&lt;paramref name="inputAssembly" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="inputAssembly" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)">
          <source>A managed pointer to an <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> interface.</source>
          <target state="translated">指向 <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> 接口的托管指针。</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)">
          <source>Creates a unique <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) object for a given <bpt id="p2">[</bpt>IUnknown<ept id="p2">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface.</source>
          <target state="translated">为给定的 <bpt id="p2">[</bpt>IUnknown<ept id="p2">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> 接口创建唯一的<bpt id="p1">[</bpt>运行时可调用包装器<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) 对象。</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)">
          <source>A unique RCW for the specified <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> interface.</source>
          <target state="translated">指定的 <ph id="ph1">&lt;see langword="IUnknown" /&gt;</ph> 接口的唯一 RCW。</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown%2A&gt;</ph> method ensures that you receive a unique RCW, because it does not match an <ph id="ph2">`IUnknown`</ph> pointer to an existing object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown%2A&gt;</ph>方法将确保您收到唯一 RCW，因为它不匹配<ph id="ph2">`IUnknown`</ph>向现有对象的指针。</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)">
          <source>Use this method when you have to create a unique RCW that is not impacted by other code that calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> method.</source>
          <target state="translated">使用此方法，你必须创建不受其他调用的代码的唯一 RCW<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>A pointer to the method to marshal.</source>
          <target state="translated">指向要封送的方法的指针。</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>A pointer to the method signature.</source>
          <target state="translated">指向方法签名的指针。</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>The number of bytes in <bpt id="p1">&lt;c&gt;</bpt>pbSignature<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>pbSignature<ept id="p1">&lt;/c&gt;</ept> 中的字节数。</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>Gets a pointer to a runtime-generated function that marshals a call from unmanaged to managed code.</source>
          <target state="translated">获取指向运行时生成的函数的指针，该函数将调用从非托管代码封送到托管代码。</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>A pointer to a function that will marshal a call from <ph id="ph1">&lt;paramref name="pfnMethodToWrap" /&gt;</ph> to managed code.</source>
          <target state="translated">指向一个函数的指针，该函数将调用从 <ph id="ph1">&lt;paramref name="pfnMethodToWrap" /&gt;</ph> 封送到托管代码。</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr%2A&gt;</ph> is exposed for compiler support only.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr%2A&gt;</ph> 被公开 for 编译器仅支持 32 位。</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)">
          <source>The object to check.</source>
          <target state="translated">要检查的对象。</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)">
          <source>Indicates whether a specified object represents a COM object.</source>
          <target state="translated">指示指定对象是否表示 COM 对象。</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="o" /&gt;</ph> parameter is a COM type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph2">&lt;paramref name="o" /&gt;</ph> 参数是 COM 类型，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.IsComObject%2A&gt;</ph> returns <ph id="ph2">`true`</ph> if the class type of the instance is attributed with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType&gt;</ph> or if it derives directly or indirectly from a class attributed with <ph id="ph4">&lt;xref:System.Runtime.InteropServices.ComImportAttribute&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.IsComObject%2A&gt;</ph> 返回<ph id="ph2">`true`</ph>如果实例的类类型使用特性化<ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType&gt;</ph>或如果它从使用特性化的类派生直接或间接<ph id="ph4">&lt;xref:System.Runtime.InteropServices.ComImportAttribute&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)">
          <source>The <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool applies this attribute for you when it imports a type library.</source>
          <target state="translated"><bpt id="p1">[</bpt>Tlbimp.exe （类型库导入程序）<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept>工具将此属性应用为你导入类型库时。</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)">
          <source>Two other methods also determine whether a specified object represents a COM object, but the requirements for returning <ph id="ph1">`true`</ph> differ from this method's requirements.</source>
          <target state="translated">其他两种方法还确定指定的对象是否表示 COM 对象，但返回的要求<ph id="ph1">`true`</ph>与不同，此方法的要求。</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Type.IsImport%2A?displayProperty=nameWithType&gt;</ph> returns <ph id="ph2">`true`</ph> if the class (or interface) is attributed with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute&gt;</ph> directly; it does not return <ph id="ph4">`true`</ph> for derived types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsImport%2A?displayProperty=nameWithType&gt;</ph> 返回<ph id="ph2">`true`</ph>如果类 （或接口） 使用特性化<ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute&gt;</ph>直接; 它不返回<ph id="ph4">`true`</ph>供派生类型。</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType%2A?displayProperty=nameWithType&gt;</ph> returns <ph id="ph2">`true`</ph> if the type is attributed with <ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute&gt;</ph> or derives from a type with the same GUID.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType%2A?displayProperty=nameWithType&gt;</ph> 返回<ph id="ph2">`true`</ph>如果类型使用特性化<ph id="ph3">&lt;xref:System.Runtime.InteropServices.ComImportAttribute&gt;</ph>或派生自具有相同 GUID 的类型。</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)">
          <source>The type to check for COM visibility.</source>
          <target state="translated">要检查其 COM 可见性的类型。</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)">
          <source>Indicates whether a type is visible to COM clients.</source>
          <target state="translated">指示类型对 COM 客户端是否可见。</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type is visible to COM; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果该类型对 COM 可见，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom%2A&gt;</ph> enables you to check for COM visibility in one step.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom%2A&gt;</ph> 使您能够在一个步骤中的 COM 可见性检查。</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)">
          <source>Types that are not visible cannot be used from COM.</source>
          <target state="translated">不可见的类型不能从 com。</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)">
          <source>A type is visible if it is <ph id="ph1">`public`</ph> and not hidden with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">一种类型时才是可见<ph id="ph1">`public`</ph>并且不会隐藏与<ph id="ph2">&lt;xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>The method to be checked.</source>
          <target state="translated">要检查的方法。</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>Calculates the number of bytes in unmanaged memory that are required to hold the parameters for the specified method.</source>
          <target state="translated">计算在非托管内存中保存指定方法的参数所需要的字节数。</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>The number of bytes required to represent the method parameters in unmanaged memory.</source>
          <target state="translated">在非托管内存中表示方法参数所需要的字节数。</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.NumParamBytes%2A&gt;</ph> method returns the stack size (in bytes) needed to represent the parameters of a method signature in unmanaged memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.NumParamBytes%2A&gt;</ph>方法返回表示的参数的非托管内存中的方法签名所需的堆栈大小 （以字节为单位）。</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>Note that the return value of this method is platform-dependent.</source>
          <target state="translated">请注意，此方法的返回值是与平台相关。</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>For example, a signature with a single integer parameter returns a value of 4 on 32-bit platforms and a value of 8 on 64-bit platforms.</source>
          <target state="translated">例如，使用单个整数参数的签名在 32 位平台上部署的 64 位平台上的 8 的值返回的值为 4。</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;paramref name="m" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;paramref name="m" /&gt;</ph> parameter is not a <ph id="ph2">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph> 参数不是 <ph id="ph2">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>A value type or formatted reference type that specifies the managed class.</source>
          <target state="translated">指定托管类的值类型或格式化引用类型。</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>You must apply the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> to the class.</source>
          <target state="translated">必须将 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> 应用于该类。</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>The field within the <bpt id="p1">&lt;c&gt;</bpt>t<ept id="p1">&lt;/c&gt;</ept> parameter.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>t<ept id="p1">&lt;/c&gt;</ept> 参数中的字段。</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>Returns the field offset of the unmanaged form of the managed class.</source>
          <target state="translated">返回托管类的非托管形式的字段偏移量。</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>The offset, in bytes, for the <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> parameter within the specified class that is declared by platform invoke.</source>
          <target state="translated">平台调用声明的指定类中 <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> 参数的偏移量（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A&gt;</ph> provides the offset in terms of the unmanaged structure layout, which does not necessarily correspond to the offset of the managed structure layout.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A&gt;</ph> 提供在不一定对应的托管的结构布局的偏移量的非托管的结构布局方面的偏移量。</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>Marshaling the structure can transform the layout and alter the offset.</source>
          <target state="translated">封送处理结构可以转换布局和更改偏移量。</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>The <ph id="ph1">`t`</ph> parameter can be a value type or a formatted reference type (with either a sequential or explicit layout).</source>
          <target state="translated"><ph id="ph1">`t`</ph>参数可以为值类型或格式化的引用类型 （具有连续或显式布局）。</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>You can obtain the size of the entire layout by using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">你可以通过使用获取整个布局的大小<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>For additional information, see <bpt id="p1">[</bpt>Default Marshaling for Value Types<ept id="p1">](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a)</ept>.</source>
          <target state="translated">有关其他信息，请参阅<bpt id="p1">[</bpt>默认封送处理值类型的<ept id="p1">](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a)</ept>。</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>Beginning with the .NET Framework version 2.0, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A&gt;</ph> may expose private fields.</source>
          <target state="translated">从.NET Framework 2.0 版中，开始<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A&gt;</ph>可能会公开私有字段。</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>The class cannot be exported as a structure or the field is nonpublic.</source>
          <target state="translated">该类无法作为结构导出，或者字段为非公共字段。</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>Beginning with the .NET Framework version 2.0, the field may be private.</source>
          <target state="translated">从 .NET Framework 2.0 版开始，该字段可以是私有的。</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)">
          <source>The <ph id="ph1">&lt;paramref name="t" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>A managed value type or formatted reference type.</source>
          <target state="translated">托管值类型或格式化引用类型。</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>You must apply the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> attribute to the class.</source>
          <target state="translated">必须将 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> 属性应用于该类。</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>The name of the field in the <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> type.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> 类型中字段的名称。</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[在 .NET Framework 4.5.1 和更高版本中受支持]</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>Returns the field offset of the unmanaged form of a specified managed class.</source>
          <target state="translated">返回指定托管类的非托管形式的字段偏移量。</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>The offset, in bytes, for the <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> parameter within the specified class that is declared by platform invoke.</source>
          <target state="translated">平台调用声明的指定类中 <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> 参数的偏移量（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%60%601%28System.String%29&gt;</ph> provides the offset in terms of the unmanaged structure layout, which does not necessarily correspond to the offset of the managed structure layout.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%60%601%28System.String%29&gt;</ph> 提供在不一定对应的托管的结构布局的偏移量的非托管的结构布局方面的偏移量。</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>Marshaling the structure can transform the layout and alter the offset.</source>
          <target state="translated">封送处理结构可以转换布局和更改偏移量。</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>The <ph id="ph1">`T`</ph> generic type parameter can be a value type or a formatted reference type (with either a sequential or explicit layout).</source>
          <target state="translated"><ph id="ph1">`T`</ph>泛型类型参数可以是值类型或格式化的引用类型 （具有连续或显式布局）。</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>You can obtain the size of the entire layout by using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29&gt;</ph> method.</source>
          <target state="translated">你可以通过使用获取整个布局的大小<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>For additional information, see <bpt id="p1">[</bpt>Default Marshaling for Value Types<ept id="p1">](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a)</ept>.</source>
          <target state="translated">有关其他信息，请参阅<bpt id="p1">[</bpt>默认封送处理值类型的<ept id="p1">](http://msdn.microsoft.com/library/4d9a876c-e05a-40ba-bd85-bd22877f984a)</ept>。</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)">
          <source>Beginning with the .NET Framework version 2.0, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A&gt;</ph> may expose private fields.</source>
          <target state="translated">从.NET Framework 2.0 版中，开始<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A&gt;</ph>可能会公开私有字段。</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>The method to be checked.</source>
          <target state="translated">要检查的方法。</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>Executes one-time method setup tasks without calling the method.</source>
          <target state="translated">在不调用方法的情况下执行一次性方法设置任务。</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>Setup tasks provide early initialization and are performed automatically when the target method is invoked.</source>
          <target state="translated">安装程序任务提供早期初始化和调用目标方法时将自动执行。</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>First-time tasks include the following:</source>
          <target state="translated">第一次任务包括：</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>Verifying that the platform invoke metadata is correctly formatted.</source>
          <target state="translated">验证的平台调用元数据的格式正确。</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>Verifying that all the managed types are valid parameters of platform invoke functions.</source>
          <target state="translated">验证所有托管的类型都有效的参数的平台调用函数。</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>Locating and loading the unmanaged DLL into the process.</source>
          <target state="translated">查找并加载到进程中的非托管的 DLL。</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>Locating the entry point in the process.</source>
          <target state="translated">在进程中定位入口点。</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>Calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Prelink%2A&gt;</ph> on a method outside of platform invoke has no effect.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Prelink%2A&gt;</ph>平台以外的方法上调用不起作用。</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>To execute setup tasks on all platform invoke methods in a type, use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">若要执行安装程序在所有平台上的任务调用在类型中，使用的方法<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;paramref name="m" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;paramref name="m" /&gt;</ph> parameter is not a <ph id="ph2">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="m" /&gt;</ph> 参数不是 <ph id="ph2">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)">
          <source>The class whose methods are to be checked.</source>
          <target state="translated">要检查其方法的类。</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)">
          <source>Performs a pre-link check for all methods on a class.</source>
          <target state="translated">对类上的所有方法执行预链接检查。</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A&gt;</ph> method invokes <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Prelink%2A?displayProperty=nameWithType&gt;</ph> on every method for a given type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A&gt;</ph>方法调用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Prelink%2A?displayProperty=nameWithType&gt;</ph>上为给定类型的每个方法。</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Prelink%2A&gt;</ph> executes one-time method setup tasks without calling each method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Prelink%2A&gt;</ph> 而不会调用每个方法中执行一次性方法设置任务。</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A&gt;</ph> only for platform invoke calls.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A&gt;</ph>仅对平台调用的调用。</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="c" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Allocates a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and copies all or part of an unmanaged ANSI string into it.</source>
          <target state="translated">分配托管 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>，并向其复制所有或部分非托管 ANSI 字符串。</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source>The address of the first character of the unmanaged string.</source>
          <target state="translated">非托管字符串的第一个字符的地址。</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source>Copies all characters up to the first null character from an unmanaged ANSI string to a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, and widens each ANSI character to Unicode.</source>
          <target state="translated">将非托管 ANSI 字符串中第一个空字符之前的所有字符复制到托管 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>，并将每个 ANSI 字符扩展为 Unicode 字符。</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source>A managed string that holds a copy of the unmanaged ANSI string.</source>
          <target state="translated">包含非托管 ANSI 字符串的副本的托管字符串。</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source>If <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the method returns a null string.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>，则该方法返回一个 Null 字符串。</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph> 对于自定义封送处理或混合托管和非托管代码时很有用。</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
          <target state="translated">因为此方法创建非托管的字符串的内容的副本，必须释放为相应的原始字符串。</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source>This method provides the opposite functionality of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">此方法提供的相反功能<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph> method to create a managed string from an unmanaged <ph id="ph2">`char`</ph> array.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph>方法来创建从非托管的托管的字符串<ph id="ph2">`char`</ph>数组。</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source>The address of the first character of the unmanaged string.</source>
          <target state="translated">非托管字符串的第一个字符的地址。</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source>The byte count of the input string to copy.</source>
          <target state="translated">要复制的输入字符串的字节数。</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source>Allocates a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, copies a specified number of characters from an unmanaged ANSI string into it, and widens each ANSI character to Unicode.</source>
          <target state="translated">分配托管 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>，然后从非托管 ANSI 字符串向其复制指定数目的字符，并将每个 ANSI 字符扩展为 Unicode 字符。</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source>A managed string that holds a copy of the native ANSI string if the value of the <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>; otherwise, this method returns <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 参数的值不是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>，则为包含本机 ANSI 字符串副本的托管字符串；否则，此方法返回 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph> 对于自定义封送处理或混合托管和非托管代码时很有用。</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
          <target state="translated">因为此方法创建非托管的字符串的内容的副本，必须释放为相应的原始字符串。</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source>This method provides the opposite functionality of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">此方法提供的相反功能<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph> method to create a managed string from an unmanaged<ph id="ph2">`char`</ph> array.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph>方法来创建从非托管的托管的字符串<ph id="ph2">`char`</ph>数组。</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="len" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="len" /&gt;</ph> 小于零。</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Allocates a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and copies all or part of an unmanaged string into it.</source>
          <target state="translated">分配托管 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>，并向其复制所有或部分非托管字符串。</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>For Unicode platforms, the address of the first Unicode character.</source>
          <target state="translated">对于 Unicode 平台，表示第一个 Unicode 字符的地址。</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>For ANSI plaforms, the address of the first ANSI character.</source>
          <target state="translated">对于 ANSI 平台，表示第一个 ANSI 字符的地址。</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>Allocates a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and copies all characters up to the first null character from a string stored in unmanaged memory into it.</source>
          <target state="translated">分配托管 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>，并从非托管内存中存储的字符串向其复制第一个空字符之前的所有字符。</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>A managed string that holds a copy of the unmanaged string if the value of the <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>; otherwise, this method returns <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 参数的值不是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>；则为具有非托管字符串副本的托管字符串；否则此方法将返回 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>If the current platform is Unicode, each ANSI character is widened to a Unicode character and this method calls <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph>.</source>
          <target state="translated">如果当前的平台是 Unicode、 ANSI 的每个字符加宽到 Unicode 字符和此方法调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>Otherwise, this method calls <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph>.</source>
          <target state="translated">否则，此方法会调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> 对于自定义封送处理或混合托管和非托管代码时很有用。</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
          <target state="translated">因为此方法创建非托管的字符串的内容的副本，必须释放为相应的原始字符串。</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> provides the opposite functionality of the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> 提供的相反功能<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>For Unicode platforms, the address of the first Unicode character.</source>
          <target state="translated">对于 Unicode 平台，表示第一个 Unicode 字符的地址。</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>For ANSI plaforms, the address of the first ANSI character.</source>
          <target state="translated">对于 ANSI 平台，表示第一个 ANSI 字符的地址。</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>The number of characters to copy.</source>
          <target state="translated">要复制的字符数。</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>Allocates a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and copies the specified number of characters from a string stored in unmanaged memory into it.</source>
          <target state="translated">分配托管 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>，并从存储在非托管内存中的字符串向其复制指定数目的字符。</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>A managed string that holds a copy of the native string if the value of the <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>; otherwise, this method returns <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 参数的值不是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>；则为包含本机字符串副本的托管字符串；否则此，方法将返回 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>On Unicode platforms, this method calls <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph>; on ANSI platforms, it calls <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph>.</source>
          <target state="translated">在 Unicode 平台上，此方法调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph>; ANSI 在平台上，它调用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>No transformations are done before these methods are called.</source>
          <target state="translated">无需进行转换完成之前调用这些方法。</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> 对于自定义封送处理或混合托管和非托管代码时很有用。</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
          <target state="translated">因为此方法创建非托管的字符串的内容的副本，必须释放为相应的原始字符串。</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> provides the opposite functionality of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A&gt;</ph> 提供的相反功能<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="len" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="len" /&gt;</ph> 小于零。</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source>The address of the first character of the unmanaged string.</source>
          <target state="translated">非托管字符串的第一个字符的地址。</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source>Allocates a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and copies a <bpt id="p1">[</bpt>binary string (BSTR)<ept id="p1">](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx)</ept> stored in unmanaged memory into it.</source>
          <target state="translated">分配已托管的 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>，并向其中复制非托管内存中存储的 <bpt id="p1">[</bpt>二进制字符串 (BSTR)<ept id="p1">](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx)</ept>。</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source>A managed string that holds a copy of the unmanaged string.</source>
          <target state="translated">一个包含非托管字符串副本的托管字符串。</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source>Call this method only on strings that were allocated with the unmanaged <bpt id="p1">[</bpt>SysAllocString<ept id="p1">](https://msdn.microsoft.com/library/ms221458\(v=vs.85\).aspx)</ept> and <bpt id="p2">[</bpt>SysAllocStringLen<ept id="p2">](https://msdn.microsoft.com/library/ms221639\(v=vs.85\).aspx)</ept> functions.</source>
          <target state="translated">仅在已分配的字符串上调用此方法与非托管<bpt id="p1">[</bpt>SysAllocString<ept id="p1">](https://msdn.microsoft.com/library/ms221458\(v=vs.85\).aspx)</ept>和<bpt id="p2">[</bpt>只能<ept id="p2">](https://msdn.microsoft.com/library/ms221639\(v=vs.85\).aspx)</ept>函数。</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A&gt;</ph> 对于自定义封送处理或混合托管和非托管代码时很有用。</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
          <target state="translated">因为此方法创建非托管的字符串的内容的副本，必须释放为相应的原始字符串。</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source>This method provides the opposite functionality of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">此方法提供的相反功能<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> equals <ph id="ph2">&lt;see cref="F:System.IntPtr.Zero" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 等于 <ph id="ph2">&lt;see cref="F:System.IntPtr.Zero" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Allocates a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and copies all or part of an unmanaged Unicode string into it.</source>
          <target state="translated">分配托管 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 并向其复制所有或部分非托管 Unicode 字符串。</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)">
          <source>The address of the first character of the unmanaged string.</source>
          <target state="translated">非托管字符串的第一个字符的地址。</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)">
          <source>Allocates a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and copies all characters up to the first null character from an unmanaged Unicode string into it.</source>
          <target state="translated">分配托管 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>，并从非托管 Unicode 字符串向其复制第一个空字符之前的所有字符。</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)">
          <source>A managed string that holds a copy of the unmanaged string if the value of the <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>; otherwise, this method returns <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 参数的值不是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>；则为具有非托管字符串副本的托管字符串；否则此方法将返回 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph> is useful for custom marshaling or for use when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph> 可自定义封送处理或供使用混合托管和非托管代码时。</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
          <target state="translated">因为此方法创建非托管的字符串的内容的副本，必须释放为相应的原始字符串。</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)">
          <source>This method provides the opposite functionality of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">此方法提供的相反功能<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)">
          <source>The address of the first character of the unmanaged string.</source>
          <target state="translated">非托管字符串的第一个字符的地址。</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)">
          <source>The number of Unicode characters to copy.</source>
          <target state="translated">要复制的 Unicode 字符数。</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)">
          <source>Allocates a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and copies a specified number of characters from an unmanaged Unicode string into it.</source>
          <target state="translated">分配托管 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>，并从非托的 Unicode 字符串向其复制指定数目的字符。</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)">
          <source>A managed string that holds a copy of the unmanaged string if the value of the <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> parameter is not <ph id="ph2">&lt;see langword="null" /&gt;</ph>; otherwise, this method returns <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">如果 <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 参数的值不是 <ph id="ph2">&lt;see langword="null" /&gt;</ph>；则为具有非托管字符串副本的托管字符串；否则此方法将返回 <ph id="ph3">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A&gt;</ph> 对于自定义封送处理或混合托管和非托管代码时很有用。</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)">
          <source>Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate.</source>
          <target state="translated">因为此方法创建非托管的字符串的内容的副本，必须释放为相应的原始字符串。</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)">
          <source>This method provides the opposite functionality of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">此方法提供的相反功能<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Marshals data from an unmanaged block of memory to a managed object.</source>
          <target state="translated">将数据从非托管内存块封送到托管对象。</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>A pointer to an unmanaged block of memory.</source>
          <target state="translated">指向非托管内存块的指针。</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>The object to which the data is to be copied.</source>
          <target state="translated">将数据复制到其中的对象。</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>This must be an instance of a formatted class.</source>
          <target state="translated">这必须是格式化类的实例。</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>Marshals data from an unmanaged block of memory to a managed object.</source>
          <target state="translated">将数据从非托管内存块封送到托管对象。</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> is often necessary in COM interop and platform invoke when structure parameters are represented as an <ph id="ph2">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> 很有必要在 COM 互操作和平台调用时结构参数表示为<ph id="ph2">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph>值。</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>You cannot use this overload method with value types.</source>
          <target state="translated">无法对值类型使用此重载方法。</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>Structure layout is not sequential or explicit.</source>
          <target state="translated">结构布局不是连续或显式的。</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>Structure is a boxed value type.</source>
          <target state="translated">结构为装箱的值类型。</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>A pointer to an unmanaged block of memory.</source>
          <target state="translated">指向非托管内存块的指针。</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>The type of object to be created.</source>
          <target state="translated">要创建的对象的类型。</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>This object must represent a formatted class or a structure.</source>
          <target state="translated">此对象必须表示格式化类或结构。</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>Marshals data from an unmanaged block of memory to a newly allocated managed object of the specified type.</source>
          <target state="translated">将数据从非托管内存块封送到新分配的指定类型的托管对象。</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>A managed object containing the data pointed to by the <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> parameter.</source>
          <target state="translated">一个包含 <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 参数指向的数据的托管对象。</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> is often necessary in COM interop and platform invoke when structure parameters are represented as an <ph id="ph2">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> 很有必要在 COM 互操作和平台调用时结构参数表示为<ph id="ph2">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph>值。</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>You can pass a value type to this overload method.</source>
          <target state="translated">可以将值类型传递给此重载方法。</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>In this case, the returned object is a boxed instance.</source>
          <target state="translated">在这种情况下，返回的对象是一个装箱的实例。</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>The following example creates a managed structure, transfers it to unmanaged memory, and then transfers it back to managed memory using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例创建一个托管的结构、 将其传输到非托管内存中，然后再传输回托管的内存使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>The following example demonstrates how to marshal an unmanaged block of memory to a managed structure using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例演示如何将托管到托管的结构使用的内存块封送<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>This code assumes 32-bit compilation.</source>
          <target state="translated">此代码假定 32 位编译。</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>Before using a 64-bit compiler, replace <ph id="ph1">&lt;xref:System.IntPtr.ToInt32%2A?displayProperty=nameWithType&gt;</ph> with <ph id="ph2">&lt;xref:System.IntPtr.ToInt64%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">在使用 64 位编译器之前, 替换<ph id="ph1">&lt;xref:System.IntPtr.ToInt32%2A?displayProperty=nameWithType&gt;</ph>与<ph id="ph2">&lt;xref:System.IntPtr.ToInt64%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> parameter layout is not sequential or explicit.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> 参数布局不是连续或显式的。</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> parameter is a generic type definition.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> 参数是泛型类型定义。</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source><ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>The class specified by <ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> does not have an accessible default constructor.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="structureType" /&gt;</ph> 指定的类没有可访问的默认值构造函数。</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>The type of the object to which the data is to be copied.</source>
          <target state="translated">要将数据复制到其中的对象的类型。</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>This must be a formatted class or a structure.</source>
          <target state="translated">这必须是格式化类或结构。</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>A pointer to an unmanaged block of memory.</source>
          <target state="translated">指向非托管内存块的指针。</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[在 .NET Framework 4.5.1 和更高版本中受支持]</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>Marshals data from an unmanaged block of memory to a newly allocated managed object of the type specified by a generic type parameter.</source>
          <target state="translated">将数据从非托管内存块封送到泛型类型参数指定的类型的新分配托管对象。</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>A managed object that contains the data that the <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> parameter points to.</source>
          <target state="translated">一个包含 <ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 参数指向的数据的托管对象。</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%29&gt;</ph> is often necessary in COM interop and platform invoke when structure parameters are represented as <ph id="ph2">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%29&gt;</ph> 很有必要在 COM 互操作和平台调用时结构参数表示为<ph id="ph2">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph>值。</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>You can pass a value type to this method overload.</source>
          <target state="translated">可以将值类型传递给此方法重载。</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>The layout of <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> is not sequential or explicit.</source>
          <target state="translated"><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> 的布局不是连续或显式的。</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>The class specified by <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> does not have an accessible default constructor.</source>
          <target state="translated"><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> 指定的类没有可访问的默认值构造函数。</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>The type of <bpt id="p1">&lt;c&gt;</bpt>structure<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">一种<bpt id="p1">&lt;c&gt;</bpt>结构<ept id="p1">&lt;/c&gt;</ept>。</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>This must be a formatted class.</source>
          <target state="translated">这必须是格式化的类。</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>A pointer to an unmanaged block of memory.</source>
          <target state="translated">指向非托管内存块的指针。</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>The object to which the data is to be copied.</source>
          <target state="translated">将数据复制到其中的对象。</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[在 .NET Framework 4.5.1 和更高版本中受支持]</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>Marshals data from an unmanaged block of memory to a managed object of the specified type.</source>
          <target state="translated">将数据从非托管内存块封送到指定类型的托管内存对象。</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%2C%60%600%29&gt;</ph> is often necessary in COM interop and platform invoke when structure parameters are represented as <ph id="ph2">&lt;xref:System.IntPtr&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%2C%60%600%29&gt;</ph> 很有必要在 COM 互操作和平台调用时结构参数表示为<ph id="ph2">&lt;xref:System.IntPtr&gt;</ph>值。</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>You cannot use this method overload with value types.</source>
          <target state="translated">无法对值类型使用此方法重载。</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>Structure layout is not sequential or explicit.</source>
          <target state="translated">结构布局不是连续或显式的。</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>The interface to be queried.</source>
          <target state="translated">要查询的接口。</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>The interface identifier (IID) of the requested interface.</source>
          <target state="translated">所请求的接口的接口标识符 (IID)。</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>When this method returns, contains a reference to the returned interface.</source>
          <target state="translated">此方法返回时，包含对返回接口的引用。</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>Requests a pointer to a specified interface from a COM object.</source>
          <target state="translated">从 COM 对象请求指向指定接口的指针。</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>An HRESULT that indicates the success or failure of the call.</source>
          <target state="translated">一个 HRESULT，指示调用成功还是失败。</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.QueryInterface%2A&gt;</ph> method exposes the <bpt id="p1">[</bpt>IUnknown::QueryInterface<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=144867)</ept> method of a COM object, which attempts to obtain a specific interface pointer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.QueryInterface%2A&gt;</ph>方法公开<bpt id="p1">[</bpt>iunknown:: Queryinterface<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=144867)</ept> COM 对象，它会尝试获取特定的接口指针的方法。</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>Using <ph id="ph1">`QueryInterface`</ph> on a COM object is the same as performing a cast operation in managed code.</source>
          <target state="translated">使用<ph id="ph1">`QueryInterface`</ph>对 COM 对象是在托管代码中执行强制转换操作相同。</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned.</source>
          <target state="translated">使用此方法调用对象会导致要递增的接口指针上之前，则返回指针的引用计数。</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>Always use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph> to decrement the reference count once you have finished with the pointer.</source>
          <target state="translated">始终使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType&gt;</ph>要完与指针后递减引用计数。</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>To obtain an <ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> value that represents a <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface pointer, you can call <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">若要获取<ph id="ph1">&lt;xref:System.IntPtr&gt;</ph>值，该值表示<bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept>的接口指针，可以调用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType&gt;</ph>， <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType&gt;</ph>，或<ph id="ph4">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reads a single byte from unmanaged memory.</source>
          <target state="translated">从非托管内存读取单个字节。</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>The address in unmanaged memory from which to read.</source>
          <target state="translated">非托管内存中开始读取的地址。</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>Reads a single byte from unmanaged memory.</source>
          <target state="translated">从非托管内存读取单个字节。</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>The byte read from unmanaged memory.</source>
          <target state="translated">从非托管内存读取的字节。</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> has an implied offset of 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> 具有隐含的偏移为 0。</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>This method enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated">这种方法实现与非托管的 C 样式字节数组，不用复制整个的非托管的数组的直接交互 (使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到单独的托管数组，然后才能读取它的元素值。</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>The following example creates a block of unmanaged memory, writes a byte to the unmanaged memory, reads the byte back from unmanaged memory, and then disposes the unmanaged memory.</source>
          <target state="translated">下面的示例创建的非托管内存块、 将一个字节写入的非托管内存、 从非托管内存读取字节，然后释放的非托管的内存。</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> method to read the value of an unmanaged character.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph>方法来读取非托管的字符的值。</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 不是识别的格式。</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>The base address in unmanaged memory from which to read.</source>
          <target state="translated">非托管内存中开始读取的基址。</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">额外的字节偏移量，在读取前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>Reads a single byte at a given offset (or index) from unmanaged memory.</source>
          <target state="translated">从非托管内存按给定的偏移量（或索引）读取单个字节。</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>The byte read from unmanaged memory at the given offset.</source>
          <target state="translated">从非托管内存按给定的偏移量读取的字节。</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> 使你能够直接与非托管的 C 样式字节数组，不用复制整个的非托管的数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到单独的托管数组，然后才能读取它的元素值。</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> method to read the value of an unmanaged character.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph>方法来读取非托管的字符的值。</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source>The base address in unmanaged memory of the source object.</source>
          <target state="translated">非托管内存中源对象的基址。</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">额外的字节偏移量，在读取前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source>Reads a single byte at a given offset (or index) from unmanaged memory.</source>
          <target state="translated">从非托管内存按给定的偏移量（或索引）读取单个字节。</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source>The byte read from unmanaged memory at the given offset.</source>
          <target state="translated">从非托管内存按给定的偏移量读取的字节。</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> 使你能够直接与非托管的 C 样式字节数组，不用复制整个的非托管的数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到单独的托管数组，然后才能读取它的元素值。</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 是 <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">此方法不接受 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reads a 16-bit signed integer from unmanaged memory.</source>
          <target state="translated">从非托管内存中读取一个 16 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>The address in unmanaged memory from which to read.</source>
          <target state="translated">非托管内存中开始读取的地址。</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>Reads a 16-bit signed integer from unmanaged memory.</source>
          <target state="translated">从非托管内存中读取一个 16 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>The 16-bit signed integer read from unmanaged memory.</source>
          <target state="translated">从非托管内存中读取的 16 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> has an implied offset of 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> 具有隐含的偏移为 0。</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>This method enables direct interaction with an unmanaged C-style <ph id="ph1">`Int16`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated">这种方法实现与非托管的 C 样式的直接交互<ph id="ph1">`Int16`</ph>数组，消除了将整个的非托管的数组复制的开销 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到单独的托管数组，然后才能读取它的元素值。</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> method to read the value of an unmanaged <ph id="ph2">`short`</ph> variable.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph>方法来读取的值的非托管<ph id="ph2">`short`</ph>变量。</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 不是识别的格式。</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>The base address in unmanaged memory from which to read.</source>
          <target state="translated">非托管内存中开始读取的基址。</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">额外的字节偏移量，在读取前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>Reads a 16-bit signed integer at a given offset from unmanaged memory.</source>
          <target state="translated">从非托管内存按给定的偏移量读取一个 16 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>The 16-bit signed integer read from unmanaged memory at the given offset.</source>
          <target state="translated">从非托管内存按给定的偏移量读取的 16 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> 使你能够直接与不用复制整个的非托管的数组的非托管 16 位有符号数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到单独的托管数组，然后才能读取它的元素值。</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> method to read the value of an unmanaged <ph id="ph2">`short`</ph> variable.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph>方法来读取的值的非托管<ph id="ph2">`short`</ph>变量。</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source>The base address in unmanaged memory of the source object.</source>
          <target state="translated">非托管内存中源对象的基址。</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">额外的字节偏移量，在读取前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source>Reads a 16-bit signed integer at a given offset from unmanaged memory.</source>
          <target state="translated">从非托管内存按给定的偏移量读取一个 16 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source>The 16-bit signed integer read from unmanaged memory at the given offset.</source>
          <target state="translated">从非托管内存按给定的偏移量读取的 16 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> 使你能够直接与不用复制整个的非托管的数组的非托管 16 位有符号数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到单独的托管数组，然后才能读取它的元素值。</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 是 <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">此方法不接受 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reads a 32-bit signed integer from unmanaged memory.</source>
          <target state="translated">从非托管内存中读取一个 32 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>The address in unmanaged memory from which to read.</source>
          <target state="translated">非托管内存中开始读取的地址。</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>Reads a 32-bit signed integer from unmanaged memory.</source>
          <target state="translated">从非托管内存中读取一个 32 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>The 32-bit signed integer read from unmanaged memory.</source>
          <target state="translated">从非托管内存中读取的 32 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> has an implied offset of 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> 具有隐含的偏移为 0。</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>This method enables direct interaction with an unmanaged C-style <ph id="ph1">`Int32`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated">这种方法实现与非托管的 C 样式的直接交互<ph id="ph1">`Int32`</ph>数组，消除了将整个的非托管的数组复制的开销 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到单独的托管数组，然后才能读取它的元素值。</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> method to read the value of an unmanaged <ph id="ph2">`int`</ph> variable.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph>方法来读取的值的非托管<ph id="ph2">`int`</ph>变量。</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 不是识别的格式。</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>The base address in unmanaged memory from which to read.</source>
          <target state="translated">非托管内存中开始读取的基址。</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">额外的字节偏移量，在读取前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>Reads a 32-bit signed integer at a given offset from unmanaged memory.</source>
          <target state="translated">从非托管内存按给定的偏移量读取一个 32 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>The 32-bit signed integer read from unmanaged memory.</source>
          <target state="translated">从非托管内存中读取的 32 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> 使你能够直接与不用复制整个的非托管的数组的非托管 32 位有符号数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到单独的托管数组，然后才能读取它的元素值。</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> method to read the value of an unmanaged <ph id="ph2">`int`</ph> variable.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph>方法来读取的值的非托管<ph id="ph2">`int`</ph>变量。</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source>The base address in unmanaged memory of the source object.</source>
          <target state="translated">非托管内存中源对象的基址。</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">额外的字节偏移量，在读取前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source>Reads a 32-bit signed integer at a given offset from unmanaged memory.</source>
          <target state="translated">从非托管内存按给定的偏移量读取一个 32 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source>The 32-bit signed integer read from unmanaged memory at the given offset.</source>
          <target state="translated">从非托管内存按给定的偏移量读取的 32 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> 使你能够直接与不用复制整个的非托管的数组的非托管 32 位有符号数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到单独的托管数组，然后才能读取它的元素值。</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 是 <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">此方法不接受 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reads a 64-bit signed integer from unmanaged memory.</source>
          <target state="translated">从非托管内存中读取一个 64 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>The address in unmanaged memory from which to read.</source>
          <target state="translated">非托管内存中开始读取的地址。</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>Reads a 64-bit signed integer from unmanaged memory.</source>
          <target state="translated">从非托管内存中读取一个 64 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>The 64-bit signed integer read from unmanaged memory.</source>
          <target state="translated">从非托管内存中读取的 64 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> has an implied offset of 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> 具有隐含的偏移为 0。</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>This method enables direct interaction with an unmanaged C-style <ph id="ph1">`Int64`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated">这种方法实现与非托管的 C 样式的直接交互<ph id="ph1">`Int64`</ph>数组，消除了将整个的非托管的数组复制的开销 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到单独的托管数组，然后才能读取它的元素值。</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> method to read the value of an unmanaged <ph id="ph2">`__int64`</ph> variable.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph>方法来读取的值的非托管<ph id="ph2">`__int64`</ph>变量。</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 不是识别的格式。</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>The base address in unmanaged memory from which to read.</source>
          <target state="translated">非托管内存中开始读取的基址。</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">额外的字节偏移量，在读取前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>Reads a 64-bit signed integer at a given offset from unmanaged memory.</source>
          <target state="translated">从非托管内存按给定的偏移量读取一个 64 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>The 64-bit signed integer read from unmanaged memory at the given offset.</source>
          <target state="translated">从非托管内存按给定的偏移量读取的 64 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> 使你能够直接与不用复制整个的非托管的数组的非托管 64 位有符号数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到单独的托管数组，然后才能读取它的元素值。</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> method to read the value of an unmanaged <ph id="ph2">`__int64`</ph> variable.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph>方法来读取的值的非托管<ph id="ph2">`__int64`</ph>变量。</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source>The base address in unmanaged memory of the source object.</source>
          <target state="translated">非托管内存中源对象的基址。</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">额外的字节偏移量，在读取前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source>Reads a 64-bit signed integer at a given offset from unmanaged memory.</source>
          <target state="translated">从非托管内存按给定的偏移量读取一个 64 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source>The 64-bit signed integer read from unmanaged memory at the given offset.</source>
          <target state="translated">从非托管内存按给定的偏移量读取的 64 位带符号整数。</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> 使你能够直接与不用复制整个的非托管的数组的非托管 64 位有符号数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到单独的托管数组，然后才能读取它的元素值。</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 是 <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">此方法不接受 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reads a processor native sized integer from unmanaged memory.</source>
          <target state="translated">从非托管内存读取处理器本机大小的整数。</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>The address in unmanaged memory from which to read.</source>
          <target state="translated">非托管内存中开始读取的地址。</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>Reads a processor native-sized integer from unmanaged memory.</source>
          <target state="translated">从非托管内存读取处理器本机大小的整数。</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>The integer read from unmanaged memory.</source>
          <target state="translated">从非托管内存读取的整数。</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>A 32 bit integer is returned on 32 bit machines and a 64 bit integer is returned on 64 bit machines.</source>
          <target state="translated">在 32 位计算机上返回 32 位整数，在 64 位计算机上返回 64 位整数。</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> has an implied offset of 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> 具有隐含的偏移为 0。</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>This method enables direct interaction with an unmanaged C-style <ph id="ph1">`IntPtr`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated">这种方法实现与非托管的 C 样式的直接交互<ph id="ph1">`IntPtr`</ph>数组，消除了将整个的非托管的数组复制的开销 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到单独的托管数组，然后才能读取它的元素值。</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 不是识别的格式。</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source>The base address in unmanaged memory from which to read.</source>
          <target state="translated">非托管内存中开始读取的基址。</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">额外的字节偏移量，在读取前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source>Reads a processor native sized integer at a given offset from unmanaged memory.</source>
          <target state="translated">从非托管内存按给定的偏移量读取处理器本机大小的整数。</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source>The integer read from unmanaged memory at the given offset.</source>
          <target state="translated">从非托管内存按给定的偏移量读取的整数。</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> enables direct interaction with an unmanaged C-style <ph id="ph2">`IntPtr`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> 使你能够直接与非托管的 C 样式的交互<ph id="ph2">`IntPtr`</ph>数组，消除了将整个的非托管的数组复制的开销 (使用<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到单独的托管数组，然后才能读取它的元素值。</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source>The base address in unmanaged memory of the source object.</source>
          <target state="translated">非托管内存中源对象的基址。</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before reading.</source>
          <target state="translated">额外的字节偏移量，在读取前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source>Reads a processor native sized integer from unmanaged memory.</source>
          <target state="translated">从非托管内存读取处理器本机大小的整数。</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source>The integer read from unmanaged memory at the given offset.</source>
          <target state="translated">从非托管内存按给定的偏移量读取的整数。</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> enables direct interaction with an unmanaged C-style <ph id="ph2">`IntPtr`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before reading its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> 使你能够直接与非托管的 C 样式的交互<ph id="ph2">`IntPtr`</ph>数组，消除了将整个的非托管的数组复制的开销 (使用<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到单独的托管数组，然后才能读取它的元素值。</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source>Reading from unaligned memory locations is supported.</source>
          <target state="translated">支持从未对齐的内存位置进行读取。</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 是 <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">此方法不接受 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>A pointer to memory allocated with <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">指向用 <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" /&gt;</ph> 分配的内存的指针。</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>The new size of the allocated block.</source>
          <target state="translated">已分配块的新大小。</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>Resizes a block of memory previously allocated with <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">调整之前用 <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" /&gt;</ph> 分配的内存块的大小。</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>An integer representing the address of the reallocated block of memory.</source>
          <target state="translated">一个整数，表示重新分配的内存块的地址。</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>This memory must be released with <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">必须使用 <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" /&gt;</ph> 释放该内存。</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A&gt;</ph> is one of two memory reallocation methods in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A&gt;</ph> 是中的两个内存重新分配方法之一<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A&gt;</ph> is the other.) The beginning of the reallocated memory content is the same as the original content; however, the entire memory block can be in a different location.</source>
          <target state="translated">(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A&gt;</ph>是另。)重新分配的内存内容的开始位置等同于原始内容;但是，整个内存块可以在不同的位置。</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>This method exposes the COM <bpt id="p1">[</bpt>CoTaskMemRealloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148778)</ept> function, which is referred to as the COM task memory allocator.</source>
          <target state="translated">此方法公开 COM <bpt id="p1">[</bpt>CoTaskMemRealloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148778)</ept>函数，称为 COM 任务内存分配器。</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>There is insufficient memory to satisfy the request.</source>
          <target state="translated">没有足够的内存来满足该请求。</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>A pointer to memory allocated with <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">指向用 <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /&gt;</ph> 分配的内存的指针。</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>The new size of the allocated block.</source>
          <target state="translated">已分配块的新大小。</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>This is not a pointer; it is the byte count you are requesting, cast to type <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>.</source>
          <target state="translated">这不是指针；它是你请求的字节计数，转换为类型 <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>If you pass a pointer, it is treated as a size.</source>
          <target state="translated">如果你传递指针，则将其视为大小。</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>Resizes a block of memory previously allocated with <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">调整之前用 <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" /&gt;</ph> 分配的内存块的大小。</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>A pointer to the reallocated memory.</source>
          <target state="translated">指向重新分配的内存的指针。</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>This memory must be released using <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /&gt;</ph>.</source>
          <target state="translated">必须使用 <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /&gt;</ph> 释放该内存。</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A&gt;</ph> is one of two memory reallocation API methods in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A&gt;</ph> 是这两个内存重新分配之一中的 API 方法<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A?displayProperty=nameWithType&gt;</ph> is the other.)</source>
          <target state="translated">(<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A?displayProperty=nameWithType&gt;</ph>是另。)</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>This method exposes the Win32 <bpt id="p1">[</bpt>GlobalReAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148780)</ept> function from Kernel32.dll.</source>
          <target state="translated">此方法公开 Win32 <bpt id="p1">[</bpt>GlobalReAlloc<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148780)</ept>从 Kernel32.dll 函数。</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>The returned pointer can differ from the original.</source>
          <target state="translated">返回的指针可以不同于原始文档。</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>If it is different, the contents of the original memory block have been copied to the new block, and the original memory block has been freed.</source>
          <target state="translated">如果不同，已将原始内存块的内容复制到新的块中，和原始内存块已被释放。</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>There is insufficient memory to satisfy the request.</source>
          <target state="translated">没有足够的内存来满足该请求。</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>The interface to release.</source>
          <target state="translated">要释放的接口。</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>Decrements the reference count on the specified interface.</source>
          <target state="translated">递减指定接口上的引用计数。</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>The new value of the reference count on the interface specified by the <ph id="ph1">&lt;paramref name="pUnk" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pUnk" /&gt;</ph> 参数指定的接口上的新引用计数值。</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>The common language runtime manages the reference count of a COM object for you, making it unnecessary to use this method directly.</source>
          <target state="translated">公共语言运行时管理 COM 对象的引用计数，这样就无需直接使用此方法。</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>Use this value only for testing purposes.</source>
          <target state="translated">此值仅用于测试目的。</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>In rare cases, such as testing a custom marshaler, you might find it necessary to manipulate an object's lifetime manually.</source>
          <target state="translated">在极少数情况下，例如测试自定义封送处理程序，你可能会发现需要手动操作对象的生存期。</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>Only programs that call <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A?displayProperty=nameWithType&gt;</ph> should call <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph>.</source>
          <target state="translated">仅程序该调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.AddRef%2A?displayProperty=nameWithType&gt;</ph>应调用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>Calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph> after the reference count has reached zero causes undefined behavior.</source>
          <target state="translated">调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph>零的引用计数已达到后导致未定义的行为。</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>You can call <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType&gt;</ph> to obtain an <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph> value that represents a <bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept> interface pointer to release.</source>
          <target state="translated">你可以调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType&gt;</ph>， <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType&gt;</ph>，或<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType&gt;</ph>获取<ph id="ph4">&lt;xref:System.IntPtr&gt;</ph>值，该值表示<bpt id="p1">[</bpt>IUnknown<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=148003)</ept>要释放的接口指针。</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>You can also use these methods and the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph> method on managed objects to release the COM interfaces represented by the managed object's <bpt id="p1">[</bpt>COM Callable Wrapper<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>.</source>
          <target state="translated">你还可以使用这些方法和<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph>上要释放的托管对象所表示的 COM 接口的托管对象的方法<bpt id="p1">[</bpt>COM 可调用包装<ept id="p1">](~/docs/framework/interop/com-callable-wrapper.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>The following example demonstrates how to retrieve an <ph id="ph1">`IUnknown`</ph> interface for a managed object using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例演示如何检索<ph id="ph1">`IUnknown`</ph>托管的对象使用的接口<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>The example then releases the interface pointer by calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph> method.</source>
          <target state="translated">该示例然后通过调用释放的接口指针<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.Release%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>The COM object to release.</source>
          <target state="translated">要释放的 COM 对象。</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>Decrements the reference count of the <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) associated with the specified COM object.</source>
          <target state="translated">递减与指定的 COM 对象关联的<bpt id="p1">[</bpt>运行时可调用包装器<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) 的引用计数。</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>The new value of the reference count of the RCW associated with <ph id="ph1">&lt;paramref name="o" /&gt;</ph>.</source>
          <target state="translated">与 <ph id="ph1">&lt;paramref name="o" /&gt;</ph> 关联的 RCW 的新引用计数值。</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>This value is typically zero since the RCW keeps just one reference to the wrapped COM object regardless of the number of managed clients calling it.</source>
          <target state="translated">此值通常为零，因为无论调用包装 COM 对象的托管客户端有多少，RCW 仅保留对该对象的一次引用。</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>This method is used to explicitly control the lifetime of a COM object used from managed code.</source>
          <target state="translated">此方法用于显式控制使用从托管代码的 COM 对象的生存期。</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>You should use this method to free the underlying COM object that holds references to resources in a timely manner or when objects must be freed in a specific order.</source>
          <target state="translated">应使用此方法以释放及时必须按特定顺序释放对象时持有对资源的引用的基础 COM 对象。</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>Every time a COM interface pointer enters the common language runtime (CLR), it is wrapped in an RCW.</source>
          <target state="translated">每次 COM 接口指针进入公共语言运行时 (CLR)，则将其包装在 RCW。</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>The RCW has a reference count that is incremented every time a COM interface pointer is mapped to it.</source>
          <target state="translated">RCW 具有即会递增每次 COM 接口指针映射到它的引用计数。</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> method decrements the reference count of an RCW.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph>方法递减引用计数的 RCW。</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>When the reference count reaches zero, the runtime releases all its references on the unmanaged COM object, and throws a <ph id="ph1">&lt;xref:System.NullReferenceException?displayProperty=nameWithType&gt;</ph> if you attempt to use the object further.</source>
          <target state="translated">当引用计数达到零时，运行时释放的非托管的 COM 对象上的所有引用，并引发<ph id="ph1">&lt;xref:System.NullReferenceException?displayProperty=nameWithType&gt;</ph>如果你尝试进一步使用该对象。</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>If the same COM interface is passed more than one time from unmanaged to managed code, the reference count on the wrapper is incremented every time, and calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> returns the number of remaining references.</source>
          <target state="translated">如果相同的 COM 接口传递不止一次从非托管到托管代码，在包装上的引用计数是每次递增且调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph>返回剩余引用的数目。</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>This method enables you to force an RCW reference count release so that it occurs precisely when you want it to.</source>
          <target state="translated">此方法使你可以强制将 RCW 引用计数的版本，以使其出现确切地说在需要时才到。</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>However, improper use of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> may cause your application to fail, or may cause an access violation.</source>
          <target state="translated">但是，错误地使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph>可能会导致应用程序失败，也可能会导致访问冲突。</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>Consider a scenario in which managed code in an application domain is holding onto an RCW that represents a COM component.</source>
          <target state="translated">请考虑到表示 COM 组件的 RCW 保存应用程序域中的托管的代码的方案。</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> method on the RCW, the managed code will be unable to access the RCW and will raise an <ph id="ph2">&lt;xref:System.Runtime.InteropServices.InvalidComObjectException&gt;</ph> exception.</source>
          <target state="translated">如果调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph>在 RCW 上的方法，托管的代码将无法访问 RCW，并将引发<ph id="ph2">&lt;xref:System.Runtime.InteropServices.InvalidComObjectException&gt;</ph>异常。</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>A more serious error may occur if a call to the RCW is executing when the RCW is released.</source>
          <target state="translated">如果在释放 RCW 时正在执行对 RCW 的调用，则可能出现更严重的错误。</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>In this case, there is a good chance that the thread making the call will cause an access violation.</source>
          <target state="translated">在这种情况下，存在很可能进行调用的线程将导致访问冲突。</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>However, process memory may become corrupted, and the process may continue to run until it fails for reasons that are very difficult to debug.</source>
          <target state="translated">但是，可能会损坏进程内存，并且该过程可能继续运行，直到非常难以调试的原因而失败。</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>This risk is compounded when the COM component that is being used is a singleton, for the following reason: The CLR activates COM components by calling the COM <bpt id="p1">[</bpt>CoCreateInstance<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=142894)</ept> function, which returns the same interface pointer every time it is called for singleton COM components.</source>
          <target state="translated">这种风险变得非常复杂正在使用的 COM 组件是单一实例，原因如下： CLR 激活 COM 组件，通过调用 COM <bpt id="p1">[</bpt>CoCreateInstance<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=142894)</ept>函数，返回相同的接口指针每个出于 singleton COM 组件调用的时间。</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>Thus, separate and independent pieces of managed code in an application domain can be using the same RCW for a singleton COM component, and if either one calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> method on the COM component, the other will be broken.</source>
          <target state="translated">因此，应用程序域中的托管代码的独立的单独部分可以使用相同的 RCW singleton COM 组件，如果其中一个调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph>对 COM 组件的方法，另一个将成为中断。</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>Therefore, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> only if it is absolutely required.</source>
          <target state="translated">因此，使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph>仅当它是绝对必要。</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>If you want to call this method to ensure that a COM component is released at a determined time, consider using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph> method instead.</source>
          <target state="translated">如果你想要调用此方法以确保在已确定时释放 COM 组件，请考虑使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph>方法相反。</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph> will release the underlying COM component regardless of how many times it has re-entered the CLR.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph> 将释放基础的 COM 组件，而不考虑其已重新进入 CLR 的次数。</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>The internal reference count of the RCW is incremented by one every time the COM component re-enters the CLR.</source>
          <target state="translated">每次 COM 组件重新进入 CLR 时，将按一个递增 RCW 的内部引用计数。</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>Therefore, you could call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph> method in a loop until the value returned is zero.</source>
          <target state="translated">因此，您可以调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A&gt;</ph>方法在循环之前返回的值为零。</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>This achieves the same result as the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph> method.</source>
          <target state="translated">这实现相同的结果作为<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is not a valid COM object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 不是有效的 COM 对象。</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ReleaseThreadCache">
          <source>Releases the thread cache.</source>
          <target state="translated">释放线程缓存。</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseThreadCache">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ReleaseThreadCache">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>The managed object to copy.</source>
          <target state="translated">要复制的托管对象。</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>Allocates an unmanaged <bpt id="p1">[</bpt>binary string (BSTR)<ept id="p1">](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx)</ept> and copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> object into it.</source>
          <target state="translated">分配非托管<bpt id="p1">[</bpt>二进制字符串 (BSTR)<ept id="p1">](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx)</ept>并将托管 <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> 对象的内容复制到其中。</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>The address, in unmanaged memory, where the <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter was copied to, or 0 if a null object was supplied.</source>
          <target state="translated">非托管内存中将 <ph id="ph1">&lt;paramref name="s" /&gt;</ph> 参数复制到的地址；如果提供了 null 对象，则为 0。</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A&gt;</ph> method is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A&gt;</ph>方法可用于自定义封送处理或在混合托管和非托管代码。</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the <ph id="ph1">`BSTR`</ph> when finished by calling the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A&gt;</ph> method.</source>
          <target state="translated">由于此方法分配字符串所需的非托管的内存，所以始终释放<ph id="ph1">`BSTR`</ph>完成时通过调用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>The current computer is not running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">当前计算机运行的不是 Windows 2000 Service Pack 3 或更高版本。</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>There is insufficient memory available.</source>
          <target state="translated">没有足够的可用内存。</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)">
          <source>This method is supported only on computers running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">此方法是仅在运行 Windows 2000 Service Pack 3 的计算机上受支持或更高版本。</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>The managed object to copy.</source>
          <target state="translated">要复制的托管对象。</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> object to a block of memory allocated from the unmanaged COM task allocator.</source>
          <target state="translated">将托管 <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> 对象的内容复制到从非托管 COM 任务分配器分配的内存块。</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>The address, in unmanaged memory, where the <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter was copied to, or 0 if a null object was supplied.</source>
          <target state="translated">非托管内存中将 <ph id="ph1">&lt;paramref name="s" /&gt;</ph> 参数复制到的地址；如果提供了 null 对象，则为 0。</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A&gt;</ph> method is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A&gt;</ph>方法可用于自定义封送处理或在混合托管和非托管代码。</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A&gt;</ph>.</source>
          <target state="translated">通过调用此方法分配字符串所需的非托管的内存，因为始终释放的内存<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>The characters of the string are copied as ANSI characters.</source>
          <target state="translated">字符串的字符所复制为 ANSI 字符。</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A&gt;</ph> method to marshal and decrypt the contents of a <ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph> object to a block of unmanaged memory.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A&gt;</ph>方法进行封送和解密的内容<ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph>到非托管内存块的对象。</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>It then uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A&gt;</ph> method to zero out and dispose the unmanaged block.</source>
          <target state="translated">然后，它使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A&gt;</ph>清空并释放非托管的块的方法。</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>The current computer is not running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">当前计算机运行的不是 Windows 2000 Service Pack 3 或更高版本。</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>There is insufficient memory available.</source>
          <target state="translated">没有足够的可用内存。</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)">
          <source>This method is supported only on computers running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">此方法是仅在运行 Windows 2000 Service Pack 3 的计算机上受支持或更高版本。</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>The managed object to copy.</source>
          <target state="translated">要复制的托管对象。</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> object to a block of memory allocated from the unmanaged COM task allocator.</source>
          <target state="translated">将托管 <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> 对象的内容复制到从非托管 COM 任务分配器分配的内存块。</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>The address, in unmanaged memory, where the <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter was copied to, or 0 if a null object was supplied.</source>
          <target state="translated">非托管内存中将 <ph id="ph1">&lt;paramref name="s" /&gt;</ph> 参数复制到的地址；如果提供了 null 对象，则为 0。</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A&gt;</ph> method is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A&gt;</ph>方法可用于自定义封送处理或在混合托管和非托管代码。</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A&gt;</ph> method.</source>
          <target state="translated">通过调用此方法分配字符串所需的非托管的内存，因为始终释放的内存<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>The characters of the string are copied as Unicode characters.</source>
          <target state="translated">字符串的字符所复制为 Unicode 字符。</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A&gt;</ph> method to marshal and decrypt the contents of a <ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph> object to a block of unmanaged memory.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A&gt;</ph>方法进行封送和解密的内容<ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph>到非托管内存块的对象。</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>It then uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A&gt;</ph> method to zero out and dispose the unmanaged block.</source>
          <target state="translated">然后，它使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A&gt;</ph>清空并释放非托管的块的方法。</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>The current computer is not running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">当前计算机运行的不是 Windows 2000 Service Pack 3 或更高版本。</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>There is insufficient memory available.</source>
          <target state="translated">没有足够的可用内存。</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)">
          <source>This method is supported only on computers running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">此方法是仅在运行 Windows 2000 Service Pack 3 的计算机上受支持或更高版本。</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>The managed object to copy.</source>
          <target state="translated">要复制的托管对象。</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> into unmanaged memory, converting into ANSI format as it copies.</source>
          <target state="translated">将托管 <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> 的内容复制到非托管内存，并在复制时转换为 ANSI 格式。</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>The address, in unmanaged memory, to where the <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter was copied, or 0 if a null object was supplied.</source>
          <target state="translated">非托管内存中将 <ph id="ph1">&lt;paramref name="s" /&gt;</ph> 参数复制到的地址，或者，如果提供了 null 对象，则为 0。</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A&gt;</ph> method is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A&gt;</ph>方法可用于自定义封送处理或在混合托管和非托管代码。</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A&gt;</ph> method.</source>
          <target state="translated">通过调用此方法分配字符串所需的非托管的内存，因为始终释放的内存<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A&gt;</ph> method to marshal and decrypt the contents of a <ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph> object to a block of unmanaged memory.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A&gt;</ph>方法进行封送和解密的内容<ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph>到非托管内存块的对象。</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>It then uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A&gt;</ph> method to zero out and dispose the unmanaged block.</source>
          <target state="translated">然后，它使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A&gt;</ph>清空并释放非托管的块的方法。</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>The current computer is not running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">当前计算机运行的不是 Windows 2000 Service Pack 3 或更高版本。</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>There is insufficient memory available.</source>
          <target state="translated">没有足够的可用内存。</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)">
          <source>This method is supported only on computers running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">此方法是仅在运行 Windows 2000 Service Pack 3 的计算机上受支持或更高版本。</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>The managed object to copy.</source>
          <target state="translated">要复制的托管对象。</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> object into unmanaged memory.</source>
          <target state="translated">将托管 <ph id="ph1">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> 对象的内容复制到非托管内存中。</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>The address, in unmanaged memory, where <ph id="ph1">&lt;paramref name="s" /&gt;</ph> was copied, or 0 if <ph id="ph2">&lt;paramref name="s" /&gt;</ph> is a <ph id="ph3">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> object whose length is 0.</source>
          <target state="translated">非托管内存中复制 <ph id="ph1">&lt;paramref name="s" /&gt;</ph> 的地址，如果 <ph id="ph2">&lt;paramref name="s" /&gt;</ph> 是长度为 0 的 <ph id="ph3">&lt;see cref="T:System.Security.SecureString" /&gt;</ph> 对象，则为 0。</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A&gt;</ph> method is useful for custom marshaling or for use when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A&gt;</ph>时混合托管和非托管代码方法非常有用的自定义封送处理或供使用。</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A&gt;</ph> method.</source>
          <target state="translated">通过调用此方法分配字符串所需的非托管的内存，因为始终释放的内存<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A&gt;</ph> method with the unmanaged <ph id="ph2">`LogonUser`</ph> function to perform impersonation with the <ph id="ph3">&lt;xref:System.Security.SecureString&gt;</ph> class.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A&gt;</ph>与非托管方法<ph id="ph2">`LogonUser`</ph>函数来执行模拟<ph id="ph3">&lt;xref:System.Security.SecureString&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>The example then uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A&gt;</ph> method to zero out and free the unmanaged string reference.</source>
          <target state="translated">然后该示例使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A&gt;</ph>清零并释放非托管的字符串引用的方法。</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>The <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>The current computer is not running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">当前计算机运行的不是 Windows 2000 Service Pack 3 或更高版本。</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>There is insufficient memory available.</source>
          <target state="translated">没有足够的可用内存。</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)">
          <source>This method is supported only on computers running Windows 2000 Service Pack 3 or later.</source>
          <target state="translated">此方法是仅在运行 Windows 2000 Service Pack 3 的计算机上受支持或更高版本。</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>The COM object in which to store the data.</source>
          <target state="translated">用于存储数据的 COM 对象。</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>The key in the internal hash table of the COM object in which to store the data.</source>
          <target state="translated">用于存储数据的 COM 对象的内部哈希表中的键。</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>The data to set.</source>
          <target state="translated">要设置的数据。</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>Sets data referenced by the specified key in the specified COM object.</source>
          <target state="translated">设置由指定 COM 对象中的指定键引用的数据。</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the data was set successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">如果数据设置成功，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>；否则为 <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>All COM objects wrapped in a <bpt id="p1">[</bpt>Runtime Callable Wrapper<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept> (RCW) have an associated hash table, to which <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A&gt;</ph> adds data.</source>
          <target state="translated">所有 COM 对象都包装在<bpt id="p1">[</bpt>运行时可调用包装器<ept id="p1">](~/docs/framework/interop/runtime-callable-wrapper.md)</ept>(RCW) 有一个关联的哈希表，向其<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A&gt;</ph>将数据添加。</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A?displayProperty=nameWithType&gt;</ph> retrieves data from the hash table.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A?displayProperty=nameWithType&gt;</ph> 从哈希表中检索数据。</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>You should never have to call either method from your code.</source>
          <target state="translated">您应永远不会需要从代码中调用任何一种方法。</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is not a COM object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 不是 COM 对象。</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> 是一个 <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> 对象。</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Returns the unmanaged size, in bytes, of a class.</source>
          <target state="translated">返回类的非托管大小（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>The object whose size is to be returned.</source>
          <target state="translated">要返回其大小的对象。</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>Returns the unmanaged size of an object in bytes.</source>
          <target state="translated">返回对象的非托管大小（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>The size of the specified object in unmanaged code.</source>
          <target state="translated">非托管代码中指定对象的大小。</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>This method accepts an instance of a structure, which can be a reference type or a boxed value type.</source>
          <target state="translated">此方法接受一个结构，它可以是引用类型或装箱的值类型的实例。</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>The layout must be sequential or explicit.</source>
          <target state="translated">布局必须按顺序或显式。</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>The size returned is the size of the unmanaged object.</source>
          <target state="translated">返回大小为非托管对象的大小。</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>The unmanaged and managed sizes of an object can differ.</source>
          <target state="translated">一个对象的非托管及托管大小可能有所不同。</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>For character types, the size is affected by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph> value applied to that class.</source>
          <target state="translated">对于字符类型，大小受<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph>值应用于该类。</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%2A&gt;</ph> method to determine how much unmanaged memory to allocate using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph> methods.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%2A&gt;</ph>方法来确定非托管的内存量，以分配使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph>和<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>The following example creates a managed structure, transfers it to unmanaged memory, and then transfers it back to managed memory.</source>
          <target state="translated">下面的示例创建一个托管的结构、 将其传输到非托管内存中，然后再传输回托管内存。</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>This example uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%2A&gt;</ph> method to determine how much unmanaged memory to allocate.</source>
          <target state="translated">此示例使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%2A&gt;</ph>方法来确定分配多少非托管的内存。</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="structure" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="structure" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>The type whose size is to be returned.</source>
          <target state="translated">要返回其大小的类型。</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>Returns the size of an unmanaged type in bytes.</source>
          <target state="translated">返回非托管类型的大小（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>The size of the specified type in unmanaged code.</source>
          <target state="translated">非托管代码中指定类型的大小。</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>You can use this method when you do not have a structure.</source>
          <target state="translated">你还没有一种结构时，可以使用此方法。</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>The layout must be sequential or explicit.</source>
          <target state="translated">布局必须按顺序或显式。</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>The size returned is the size of the unmanaged type.</source>
          <target state="translated">返回大小为非托管类型的大小。</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>The unmanaged and managed sizes of an object can differ.</source>
          <target state="translated">一个对象的非托管及托管大小可能有所不同。</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>For character types, the size is affected by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph> value applied to that class.</source>
          <target state="translated">对于字符类型，大小受<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph>值应用于该类。</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>The following example demonstrates calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例演示如何调用 <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%2A&gt;</ph> 方法。</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">此代码示例摘自更大的示例为提供<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="t" /&gt;</ph> parameter is a generic type definition.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> 参数是泛型类型定义。</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="t" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="t" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1">
          <source>The type whose size is to be returned.</source>
          <target state="translated">要返回其大小的类型。</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[在 .NET Framework 4.5.1 和更高版本中受支持]</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1">
          <source>Returns the size of an unmanaged type in bytes.</source>
          <target state="translated">返回非托管类型的大小（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1">
          <source>The size, in bytes, of the type that is specified by the <ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> generic type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;typeparamref name="T" /&gt;</ph> 泛型类型参数指定的类型的大小（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1">
          <source>You can use this method when you do not have a structure.</source>
          <target state="translated">你还没有一种结构时，可以使用此方法。</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1">
          <source>The layout must be sequential or explicit.</source>
          <target state="translated">布局必须按顺序或显式。</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1">
          <source>The size returned is the size of the unmanaged type.</source>
          <target state="translated">返回大小为非托管类型的大小。</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1">
          <source>The unmanaged and managed sizes of an object can differ.</source>
          <target state="translated">一个对象的非托管及托管大小可能有所不同。</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1">
          <source>For character types, the size is affected by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph> value applied to that class.</source>
          <target state="translated">对于字符类型，大小受<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph>值应用于该类。</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>The type of the <bpt id="p1">&lt;c&gt;</bpt>structure<ept id="p1">&lt;/c&gt;</ept> parameter.</source>
          <target state="translated">一种<bpt id="p1">&lt;c&gt;</bpt>结构<ept id="p1">&lt;/c&gt;</ept>参数。</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>The object whose size is to be returned.</source>
          <target state="translated">要返回其大小的对象。</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[在 .NET Framework 4.5.1 和更高版本中受支持]</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>Returns the unmanaged size of an object of a specified type in bytes.</source>
          <target state="translated">返回指定类型的对象的非托管大小（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>The size, in bytes, of the specified object in unmanaged code.</source>
          <target state="translated">非托管代码中指定对象的大小（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>This method accepts an instance of a structure, which can be a reference type or a boxed value type.</source>
          <target state="translated">此方法接受一个结构，它可以是引用类型或装箱的值类型的实例。</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>The layout must be sequential or explicit.</source>
          <target state="translated">布局必须按顺序或显式。</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>The size returned is the size of the unmanaged object.</source>
          <target state="translated">返回大小为非托管对象的大小。</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>The unmanaged and managed sizes of an object can differ.</source>
          <target state="translated">一个对象的非托管及托管大小可能有所不同。</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>For character types, the size is affected by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph> value applied to that class.</source>
          <target state="translated">对于字符类型，大小受<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CharSet&gt;</ph>值应用于该类。</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29&gt;</ph> method to determine how much unmanaged memory to allocate by using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph> methods.</source>
          <target state="translated">你可以使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29&gt;</ph>方法来确定非托管的内存量，以通过使用分配<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A&gt;</ph>和<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)">
          <source>The <ph id="ph1">&lt;paramref name="structure" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="structure" /&gt;</ph> 参数为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source>The managed string to be copied.</source>
          <target state="translated">要复制的托管字符串。</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source>Allocates a <bpt id="p1">[</bpt>BSTR<ept id="p1">](https://msdn.microsoft.com/library/ms221069.aspx)</ept> and copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> into it.</source>
          <target state="translated">分配 <bpt id="p1">[</bpt>BSTR<ept id="p1">](https://msdn.microsoft.com/library/ms221069.aspx)</ept> 并向其复制托管 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的内容。</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source>An unmanaged pointer to the <ph id="ph1">&lt;see langword="BSTR" /&gt;</ph>, or 0 if <ph id="ph2">&lt;paramref name="s" /&gt;</ph> is null.</source>
          <target state="translated">指向 <ph id="ph1">&lt;see langword="BSTR" /&gt;</ph> 的非托管指针；如果 <ph id="ph2">&lt;paramref name="s" /&gt;</ph> 为 Null，则为 0。</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A&gt;</ph> 对于自定义封送处理或混合托管和非托管代码时很有用。</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the <ph id="ph1">`BSTR`</ph> when finished by calling <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">由于此方法分配字符串所需的非托管的内存，所以始终释放<ph id="ph1">`BSTR`</ph>完成时通过调用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source>This method provides the opposite functionality of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">此方法提供的相反功能<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source>There is insufficient memory available.</source>
          <target state="translated">没有足够的可用内存。</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source>The length for <ph id="ph1">&lt;paramref name="s" /&gt;</ph> is out of range.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> 的长度超出范围。</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>A managed string to be copied.</source>
          <target state="translated">要复制的托管字符串。</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> to a block of memory allocated from the unmanaged COM task allocator.</source>
          <target state="translated">将托管 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的内容复制到从非托管 COM 任务分配器分配的内存块。</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>An integer representing a pointer to the block of memory allocated for the string, or 0 if <ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个整数，表示指向字符串的内存块的指针；如果 <ph id="ph1">&lt;paramref name="s" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>，则为 0。</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A&gt;</ph> 对于自定义封送处理或混合托管和非托管代码时很有用。</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>.</source>
          <target state="translated">通过调用此方法分配字符串所需的非托管的内存，因为始终释放的内存<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>This method provides the opposite functionality of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">此方法提供的相反功能<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>The characters of the string are copied as ANSI characters.</source>
          <target state="translated">字符串的字符所复制为 ANSI 字符。</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>There is insufficient memory available.</source>
          <target state="translated">没有足够的可用内存。</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter exceeds the maximum length allowed by the operating system.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> 参数超过了操作系统所允许的最大长度。</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>A managed string to be copied.</source>
          <target state="translated">要复制的托管字符串。</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> to a block of memory allocated from the unmanaged COM task allocator.</source>
          <target state="translated">将托管 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的内容复制到从非托管 COM 任务分配器分配的内存块。</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>The allocated memory block, or 0 if <ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">已分配的内存块；如果 <ph id="ph1">&lt;paramref name="s" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>，则为 0。</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A&gt;</ph> is useful for custom marshaling or for use when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A&gt;</ph> 可自定义封送处理或供使用混合托管和非托管代码时。</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>.</source>
          <target state="translated">通过调用此方法分配字符串所需的非托管的内存，因为始终释放的内存<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>This method provides the opposite functionality of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">此方法提供的相反功能<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>The characters of the string are copied as either ANSI or Unicode characters, depending on the operating system where the code is executing.</source>
          <target state="translated">字符串的字符所复制为 ANSI 或 Unicode 字符，具体取决于执行代码的操作系统中。</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>On Windows 98, the characters are copied as ANSI characters.</source>
          <target state="translated">在 Windows 98 上为 ANSI 字符将复制的字符。</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>On Windows NT 4.0, Windows 2000, Windows XP, and the Windows Server 2003 family, the characters are copied as Unicode characters.</source>
          <target state="translated">在 Windows NT 4.0、 Windows 2000、 Windows XP 和 Windows Server 2003 系列，字符所复制为 Unicode 字符。</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>There is insufficient memory available.</source>
          <target state="translated">没有足够的可用内存。</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>The length for <ph id="ph1">&lt;paramref name="s" /&gt;</ph> is out of range.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> 的长度超出范围。</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>A managed string to be copied.</source>
          <target state="translated">要复制的托管字符串。</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> to a block of memory allocated from the unmanaged COM task allocator.</source>
          <target state="translated">将托管 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的内容复制到从非托管 COM 任务分配器分配的内存块。</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>An integer representing a pointer to the block of memory allocated for the string, or 0 if s is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">一个整数，表示指向为字符串分配的内存块的指针；如果 s 为 <ph id="ph1">&lt;see langword="null" /&gt;</ph>，则为 0。</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A&gt;</ph> is useful for custom marshaling or for use when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A&gt;</ph> 可自定义封送处理或供使用混合托管和非托管代码时。</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">通过调用此方法分配字符串所需的非托管的内存，因为始终释放的内存<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>This method provides the opposite functionality of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">此方法提供的相反功能<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>The characters of the string are copied as Unicode characters.</source>
          <target state="translated">字符串的字符所复制为 Unicode 字符。</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter exceeds the maximum length allowed by the operating system.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> 参数超过了操作系统所允许的最大长度。</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>There is insufficient memory available.</source>
          <target state="translated">没有足够的可用内存。</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>A managed string to be copied.</source>
          <target state="translated">要复制的托管字符串。</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> into unmanaged memory, converting into ANSI format as it copies.</source>
          <target state="translated">将托管 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的内容复制到非托管内存，并在复制时转换为 ANSI 格式。</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>The address, in unmanaged memory, to where <ph id="ph1">&lt;paramref name="s" /&gt;</ph> was copied, or 0 if <ph id="ph2">&lt;paramref name="s" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">非托管内存中将 <ph id="ph1">&lt;paramref name="s" /&gt;</ph> 复制到其中的地址；如果 <ph id="ph2">&lt;paramref name="s" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，则为 0。</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A&gt;</ph> is useful for custom marshaling or when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A&gt;</ph> 对于自定义封送处理或混合托管和非托管代码时很有用。</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</source>
          <target state="translated">通过调用此方法分配字符串所需的非托管的内存，因为始终释放的内存<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A&gt;</ph> provides the opposite functionality of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A&gt;</ph> 提供的相反功能<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>This method copies embedded null characters, and includes a terminating null character.</source>
          <target state="translated">此方法会复制嵌入的空字符，包括终止 null 字符。</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>The following example demonstrates how to convert the contents of a managed <ph id="ph1">&lt;xref:System.String&gt;</ph> class to unmanaged memory and then dispose of the unmanaged memory when done.</source>
          <target state="translated">下面的示例演示如何将托管的内容转换<ph id="ph1">&lt;xref:System.String&gt;</ph>类到非托管内存并因而释放完成的非托管内存。</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>There is insufficient memory available.</source>
          <target state="translated">没有足够的可用内存。</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter exceeds the maximum length allowed by the operating system.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> 参数超过了操作系统所允许的最大长度。</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>A managed string to be copied.</source>
          <target state="translated">要复制的托管字符串。</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> into unmanaged memory, converting into ANSI format if required.</source>
          <target state="translated">将托管 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的内容复制到非托管内存，并在需要时转换为 ANSI 格式。</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>The address, in unmanaged memory, to where the string was copied, or 0 if <ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">非托管内存中将字符串复制到其中的地址；如果 <ph id="ph1">&lt;paramref name="s" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>，则为 0。</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A&gt;</ph> is useful for custom marshaling or for use when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A&gt;</ph> 可自定义封送处理或供使用混合托管和非托管代码时。</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</source>
          <target state="translated">通过调用此方法分配字符串所需的非托管的内存，因为始终释放的内存<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>This method provides the opposite functionality of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">此方法提供的相反功能<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>This method copies embedded null characters, and includes a terminating null character.</source>
          <target state="translated">此方法会复制嵌入的空字符，包括终止 null 字符。</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>The following example demonstrates how to convert the contents of a managed <ph id="ph1">&lt;xref:System.String&gt;</ph> class to unmanaged memory and then dispose of the unmanaged memory when done.</source>
          <target state="translated">下面的示例演示如何将托管的内容转换<ph id="ph1">&lt;xref:System.String&gt;</ph>类到非托管内存并因而释放完成的非托管内存。</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>There is insufficient memory available.</source>
          <target state="translated">没有足够的可用内存。</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>A managed string to be copied.</source>
          <target state="translated">要复制的托管字符串。</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>Copies the contents of a managed <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> into unmanaged memory.</source>
          <target state="translated">将托管 <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 的内容复制到非托管内存。</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>The address, in unmanaged memory, to where the <ph id="ph1">&lt;paramref name="s" /&gt;</ph> was copied, or 0 if <ph id="ph2">&lt;paramref name="s" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">非托管内存中将 <ph id="ph1">&lt;paramref name="s" /&gt;</ph> 复制到其中的地址；如果 <ph id="ph2">&lt;paramref name="s" /&gt;</ph> 为 <ph id="ph3">&lt;see langword="null" /&gt;</ph>，则为 0。</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A&gt;</ph> is useful for custom marshaling or for use when mixing managed and unmanaged code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A&gt;</ph> 可自定义封送处理或供使用混合托管和非托管代码时。</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>Because this method allocates the unmanaged memory required for a string, always free the memory by calling <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>.</source>
          <target state="translated">通过调用此方法分配字符串所需的非托管的内存，因为始终释放的内存<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>This method provides the opposite functionality of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">此方法提供的相反功能<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>This method copies embedded null characters, and includes a terminating null character.</source>
          <target state="translated">此方法会复制嵌入的空字符，包括终止 null 字符。</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>The method could not allocate enough native heap memory.</source>
          <target state="translated">此方法未能分配足够的本机堆内存。</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="s" /&gt;</ph> parameter exceeds the maximum length allowed by the operating system.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> 参数超过了操作系统所允许的最大长度。</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>A managed object that holds the data to be marshaled.</source>
          <target state="translated">包含要封送的数据的托管对象。</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>This object must be a structure or an instance of a formatted class.</source>
          <target state="translated">该对象必须是格式化类的结构或实例。</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>A pointer to an unmanaged block of memory, which must be allocated before this method is called.</source>
          <target state="translated">指向非托管内存块的指针，必须在调用此方法之前分配该指针。</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to call the <ph id="ph2">&lt;see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /&gt;</ph> method on the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before this method copies the data.</source>
          <target state="translated">如果在此方法复制该数据前在 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数上调用 <ph id="ph2">&lt;see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /&gt;</ph> 方法，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>The block must contain valid data.</source>
          <target state="translated">该块必须包含有效的数据。</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>Note that passing <ph id="ph1">&lt;see langword="false" /&gt;</ph> when the memory block already contains data can lead to a memory leak.</source>
          <target state="translated">请注意，在内存块已包含数据时传递 <ph id="ph1">&lt;see langword="false" /&gt;</ph> 可能会导致内存泄漏。</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>Marshals data from a managed object to an unmanaged block of memory.</source>
          <target state="translated">将数据从托管对象封送到非托管内存块。</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>If <ph id="ph1">`structure`</ph> is a value type, it can be boxed or unboxed.</source>
          <target state="translated">如果<ph id="ph1">`structure`</ph>是值类型，它可以装箱或取消装箱。</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>If it is boxed, it is unboxed before copying.</source>
          <target state="translated">如果它进行装箱时，它是未装箱复制前。</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>A formatted class is a reference type whose layout is specified by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute, as either <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">格式化的类是引用类型由指定其布局<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>特性，为<ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph>或<ph id="ph3">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> copies the contents of <ph id="ph2">`structure`</ph> to the pre-allocated block of memory that the <ph id="ph3">`ptr`</ph> parameter points to.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> 内容复制<ph id="ph2">`structure`</ph>到预分配的内存块，<ph id="ph3">`ptr`</ph>参数指向。</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>If <ph id="ph1">`structure`</ph> contains reference types that marshal to COM interface pointers (interfaces, classes without layout, and <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>), the managed objects are kept alive with reference counts.</source>
          <target state="translated">如果<ph id="ph1">`structure`</ph>包含封送处理为 COM 接口指针的引用类型 (接口，而无需布局的类和<ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>)，托管的对象将保持活动状态与引用计数。</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>All other reference types (for example, strings and arrays) are marshaled to copies.</source>
          <target state="translated">所有其他引用类型 （例如，字符串和数组） 进行封送到副本。</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>To release these managed or unmanaged objects, you must call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A?displayProperty=nameWithType&gt;</ph> method before you free the memory block.</source>
          <target state="translated">若要释放这些托管或非托管对象，必须调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A?displayProperty=nameWithType&gt;</ph>方法之前释放内存块。</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>If you use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> method to copy a different instance to the memory block at a later time, specify <ph id="ph2">`true`</ph> for <ph id="ph3">`fDeleteOld`</ph> to remove reference counts for reference types in the previous instance.</source>
          <target state="translated">如果你使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph>方法可在更高版本时，将不同的实例复制到的内存块指定<ph id="ph2">`true`</ph>为<ph id="ph3">`fDeleteOld`</ph>要删除的引用计数在以前的实例的引用类型。</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>Otherwise, the managed reference typesand unmanaged copies are effectively leaked.</source>
          <target state="translated">否则，不会有效地泄漏的托管的引用非托管的 typesand 副本。</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>The overall pattern for using <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> is as follows:</source>
          <target state="translated">使用的总体模式<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph>如下：</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>On the first call to the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> method after a memory block has been allocated, <ph id="ph2">`fDeleteOld`</ph> must be <ph id="ph3">`false`</ph>, because there are no contents to clear.</source>
          <target state="translated">在第一个调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph>方法后尚未分配的内存块的<ph id="ph2">`fDeleteOld`</ph>必须<ph id="ph3">`false`</ph>，因为没有要清除的内容。</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>Specify <ph id="ph1">`true`</ph> for <ph id="ph2">`fDeleteOld`</ph> only if the block contains valid data.</source>
          <target state="translated">指定<ph id="ph1">`true`</ph>为<ph id="ph2">`fDeleteOld`</ph>仅块包含有效的数据的情况。</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>If you copy a different instance to the memory block, and the object contains reference types, <ph id="ph1">`fDeleteOld`</ph> must be <ph id="ph2">`true`</ph> to free reference types in the old contents.</source>
          <target state="translated">如果将不同的实例复制到的内存块，并且该对象包含引用类型，<ph id="ph1">`fDeleteOld`</ph>必须<ph id="ph2">`true`</ph>要释放的旧内容中的引用类型。</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>If the object contains reference types, you must call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> method before you free the memory block.</source>
          <target state="translated">如果对象包含引用类型，则必须调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph>方法之前释放内存块。</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>To pin an existing structure instead of copying it, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType&gt;</ph> type to create a pinned handle for the structure.</source>
          <target state="translated">若要固定现有结构而不是复制它，请使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType&gt;</ph>要创建结构的固定句柄类型。</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>For details on how to pin, see <bpt id="p1">[</bpt>Copying and Pinning<ept id="p1">](~/docs/framework/interop/copying-and-pinning.md)</ept>.</source>
          <target state="translated">有关如何将固定的详细信息，请参阅<bpt id="p1">[</bpt>复制和固定<ept id="p1">](~/docs/framework/interop/copying-and-pinning.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>The following example creates a managed structure, transfers it to unmanaged memory using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> method, and then transfers it back to managed memory using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph> method.</source>
          <target state="translated">下面的示例创建一个托管的结构，将其传送到非托管的内存使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph>方法，，然后将它传输回托管的内存使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="structure" /&gt;</ph> is a reference type that is not a formatted class.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="structure" /&gt;</ph> 为不是格式化类的引用类型。</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="structure" /&gt;</ph> is an instance of a generic type (in the .NET Framework 4.5 and earlier versions only).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="structure" /&gt;</ph> 是泛型类型的实例（仅限 .NET Framework 4.5 和更低版本）。</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>The type of the managed object.</source>
          <target state="translated">托管对象的类型。</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>A managed object that holds the data to be marshaled.</source>
          <target state="translated">包含要封送的数据的托管对象。</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>The object must be a structure or an instance of a formatted class.</source>
          <target state="translated">该对象必须是格式化类的结构或实例。</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>A pointer to an unmanaged block of memory, which must be allocated before this method is called.</source>
          <target state="translated">指向非托管内存块的指针，必须在调用此方法之前分配该指针。</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to call the <ph id="ph2">&lt;see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" /&gt;</ph> method on the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before this method copies the data.</source>
          <target state="translated">如果在此方法复制该数据前在 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数上调用 <ph id="ph2">&lt;see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" /&gt;</ph> 方法，则为 <ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>The block must contain valid data.</source>
          <target state="translated">该块必须包含有效的数据。</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>Note that passing <ph id="ph1">&lt;see langword="false" /&gt;</ph> when the memory block already contains data can lead to a memory leak.</source>
          <target state="translated">请注意，在内存块已包含数据时传递 <ph id="ph1">&lt;see langword="false" /&gt;</ph> 可能会导致内存泄漏。</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[在 .NET Framework 4.5.1 和更高版本中受支持]</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>Marshals data from a managed object of a specified type to an unmanaged block of memory.</source>
          <target state="translated">将数据从指定类型的托管对象封送到非托管内存块。</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>A formatted class is a reference type whose layout is specified by the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute, as either <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">格式化的类是引用类型由指定其布局<ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>特性，为<ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph>或<ph id="ph3">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> copies the contents of <ph id="ph2">`structure`</ph> to the pre-allocated block of memory that the <ph id="ph3">`ptr`</ph> parameter points to.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> 内容复制<ph id="ph2">`structure`</ph>到预分配的内存块，<ph id="ph3">`ptr`</ph>参数指向。</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>If <ph id="ph1">`structure`</ph> contains reference types that marshal to COM interface pointers (interfaces, classes without layout, and <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>), the managed objects are kept alive with reference counts.</source>
          <target state="translated">如果<ph id="ph1">`structure`</ph>包含封送处理为 COM 接口指针的引用类型 (接口，而无需布局的类和<ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>)，托管的对象将保持活动状态与引用计数。</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>All other reference types (for example, strings and arrays) are marshaled to copies.</source>
          <target state="translated">所有其他引用类型 （例如，字符串和数组） 进行封送到副本。</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>To release these managed or unmanaged objects, you must call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%60%601%28System.IntPtr%29&gt;</ph> method before you free the memory block.</source>
          <target state="translated">若要释放这些托管或非托管对象，必须调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%60%601%28System.IntPtr%29&gt;</ph>方法之前释放内存块。</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>If you use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> method to copy a different instance to the memory block at a later time, specify <ph id="ph2">`true`</ph> for <ph id="ph3">`fDeleteOld`</ph> to remove reference counts for reference types in the previous instance.</source>
          <target state="translated">如果你使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph>方法可在更高版本时，将不同的实例复制到的内存块指定<ph id="ph2">`true`</ph>为<ph id="ph3">`fDeleteOld`</ph>要删除的引用计数在以前的实例的引用类型。</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>Otherwise, the managed reference types and unmanaged copies are effectively leaked.</source>
          <target state="translated">否则，会有效地泄漏的托管的引用类型和非托管的副本。</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>The overall pattern for using <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph> is as follows:</source>
          <target state="translated">使用的总体模式<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29&gt;</ph>如下：</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>On the first call to the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph> method after a memory block has been allocated, <ph id="ph2">`fDeleteOld`</ph> must be <ph id="ph3">`false`</ph>, because there are no contents to clear.</source>
          <target state="translated">在第一个调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A&gt;</ph>方法后尚未分配的内存块的<ph id="ph2">`fDeleteOld`</ph>必须<ph id="ph3">`false`</ph>，因为没有要清除的内容。</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>Specify <ph id="ph1">`true`</ph> for <ph id="ph2">`fDeleteOld`</ph> only if the block contains valid data.</source>
          <target state="translated">指定<ph id="ph1">`true`</ph>为<ph id="ph2">`fDeleteOld`</ph>仅块包含有效的数据的情况。</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>If you copy a different instance to the memory block, and the object contains reference types, <ph id="ph1">`fDeleteOld`</ph> must be <ph id="ph2">`true`</ph> to free reference types in the old contents.</source>
          <target state="translated">如果将不同的实例复制到的内存块，并且该对象包含引用类型，<ph id="ph1">`fDeleteOld`</ph>必须<ph id="ph2">`true`</ph>要释放的旧内容中的引用类型。</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>If the object contains reference types, you must call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph> method before you free the memory block.</source>
          <target state="translated">如果对象包含引用类型，则必须调用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A&gt;</ph>方法之前释放内存块。</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>To pin an existing structure instead of copying it, use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType&gt;</ph> type to create a pinned handle for the structure.</source>
          <target state="translated">若要固定现有结构而不是复制它，请使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType&gt;</ph>要创建结构的固定句柄类型。</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>For details on how to pin, see <bpt id="p1">[</bpt>Copying and Pinning<ept id="p1">](~/docs/framework/interop/copying-and-pinning.md)</ept>.</source>
          <target state="translated">有关如何将固定的详细信息，请参阅<bpt id="p1">[</bpt>复制和固定<ept id="p1">](~/docs/framework/interop/copying-and-pinning.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="structure" /&gt;</ph> is a reference type that is not a formatted class.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="structure" /&gt;</ph> 为不是格式化类的引用类型。</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize">
          <source>Represents the default character size on the system; the default is 2 for Unicode systems and 1 for ANSI systems.</source>
          <target state="translated">表示系统上的默认字符大小；Unicode 系统上默认值为 2，ANSI 系统上默认值为 1。</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize">
          <source>This field is read-only.</source>
          <target state="translated">此字段为只读。</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize&gt;</ph> field.</source>
          <target state="translated">下面的示例演示<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize&gt;</ph>字段。</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">此代码示例摘自更大的示例为提供<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize">
          <source>Represents the maximum size of a double byte character set (DBCS) size, in bytes, for the current operating system.</source>
          <target state="translated">表示用于当前操作系统的双字节字符集 (DBCS) 的最大大小（以字节为单位）。</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize">
          <source>This field is read-only.</source>
          <target state="translated">此字段为只读。</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize&gt;</ph> field.</source>
          <target state="translated">下面的示例演示<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize&gt;</ph>字段。</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">此代码示例摘自更大的示例为提供<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Throws an exception with a specific failure HRESULT value.</source>
          <target state="translated">用特定的失败 HRESULT 值引发异常。</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>The HRESULT corresponding to the desired exception.</source>
          <target state="translated">与所需异常相对应的 HRESULT。</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>Throws an exception with a specific failure HRESULT value.</source>
          <target state="translated">用特定的失败 HRESULT 值引发异常。</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>This method creates an exception object for the specified failure HRESULT.</source>
          <target state="translated">此方法创建指定的失败 HRESULT 的异常对象。</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>If the HRESULT is 0 or positive (a success code), the method returns without creating or throwing an exception.</source>
          <target state="translated">如果 HRESULT 为 0 或正数 （成功代码），该方法将返回而不创建或引发异常。</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>Note that the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%28System.Int32%29&gt;</ph> method returns an exception based on the <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface of the current thread if one is set.</source>
          <target state="translated">请注意，<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%28System.Int32%29&gt;</ph>方法返回基于异常<bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept>如果已设置的当前线程的接口。</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>When this happens, the <ph id="ph1">`errorCode`</ph> parameter is ignored.</source>
          <target state="translated">在此情况下，<ph id="ph1">`errorCode`</ph>参数将被忽略。</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>Some failure HRESULTs map to defined exceptions, whereas others do not.</source>
          <target state="translated">某些失败的 Hresult 映射到定义异常，而有些却不。</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>If the HRESULT maps to a defined exception, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> creates an instance of the exception and throws it.</source>
          <target state="translated">如果 HRESULT 映射到已定义的异常，<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph>创建异常的实例并引发它。</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>Otherwise, it creates an instance of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.COMException&gt;</ph>, initializes the error code field with the HRESULT, and throws that exception.</source>
          <target state="translated">否则，它创建的实例<ph id="ph1">&lt;xref:System.Runtime.InteropServices.COMException&gt;</ph>，初始化错误代码字段，HRESULT，并会引发该异常。</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>When <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> is invoked, it attempts to retrieve extra information regarding the error by using the unmanaged <bpt id="p1">[</bpt>GetErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221032\(v=vs.85\).aspx)</ept> function.</source>
          <target state="translated">当<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph>是调用，它将尝试通过使用非托管检索有关错误的额外信息<bpt id="p1">[</bpt>GetErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221032\(v=vs.85\).aspx)</ept>函数。</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see <bpt id="p1">[</bpt>How to: Map HRESULTs and Exceptions<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</source>
          <target state="translated">从每个 HRESULT 到其.NET Framework 中的相似异常类的映射，请参阅<bpt id="p1">[</bpt>如何： 映射 Hresult 和异常<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>Occasionally, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> might return an exception from a previous COM call.</source>
          <target state="translated">有时，<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph>可能从以前的 COM 调用返回一个异常。</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>In this case, you can use the following workaround and pass <ph id="ph1">`IntPtr(-1)`</ph> as the second parameter (<ph id="ph2">`errorInfo`</ph>):</source>
          <target state="translated">在这种情况下，你可以使用以下解决方法，并将传递<ph id="ph1">`IntPtr(-1)`</ph>第二个参数 (<ph id="ph2">`errorInfo`</ph>):</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>The HRESULT corresponding to the desired exception.</source>
          <target state="translated">与所需异常相对应的 HRESULT。</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>A pointer to the <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface that provides more information about the error.</source>
          <target state="translated">指向 <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> 接口的指针，该接口提供有关错误的详细信息。</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>You can specify <bpt id="p1">&lt;c&gt;</bpt>IntPtr(0)<ept id="p1">&lt;/c&gt;</ept> to use the current <bpt id="p2">[</bpt>IErrorInfo<ept id="p2">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface, or <bpt id="p3">&lt;c&gt;</bpt>IntPtr(-1)<ept id="p3">&lt;/c&gt;</ept> to ignore the current <bpt id="p4">[</bpt>IErrorInfo<ept id="p4">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface and construct the exception just from the error code.</source>
          <target state="translated">可以指定 <bpt id="p1">&lt;c&gt;</bpt>IntPtr(0)<ept id="p1">&lt;/c&gt;</ept> 以使用当前的 <bpt id="p2">[</bpt>IErrorInfo<ept id="p2">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> 接口，或者 <bpt id="p3">&lt;c&gt;</bpt>IntPtr(-1)<ept id="p3">&lt;/c&gt;</ept> 以忽略当前的 <bpt id="p4">[</bpt>IErrorInfo<ept id="p4">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> 接口，并仅从错误代码构造异常。</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>Throws an exception with a specific failure HRESULT, based on the specified <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface.</source>
          <target state="translated">基于指定的 <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> 接口，用特定的失败 HRESULT 引发异常。</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>This method creates an exception object for the specified failure HRESULT.</source>
          <target state="translated">此方法创建指定的失败 HRESULT 的异常对象。</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>If the HRESULT is 0 or positive (a success code), the method returns without creating or throwing an exception.</source>
          <target state="translated">如果 HRESULT 为 0 或正数 （成功代码），该方法将返回而不创建或引发异常。</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> method releases the <ph id="ph2">`errorInfo`</ph> parameter, decreasing the COM reference count of the <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph>方法将释放<ph id="ph2">`errorInfo`</ph>参数，减少 COM 引用的计数<bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept>接口。</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>Note that the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> method returns an exception based on the <bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept> interface of the current thread if one is set.</source>
          <target state="translated">请注意，<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph>方法返回基于异常<bpt id="p1">[</bpt>IErrorInfo<ept id="p1">](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx)</ept>如果已设置的当前线程的接口。</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>When this happens, the <ph id="ph1">`errorCode`</ph> parameter is ignored.</source>
          <target state="translated">在此情况下，<ph id="ph1">`errorCode`</ph>参数将被忽略。</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>Some failure HRESULTs map to defined exceptions, whereas others do not.</source>
          <target state="translated">某些失败的 Hresult 映射到定义异常，而有些却不。</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>If the HRESULT maps to a defined exception, <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph> creates an instance of the exception and throws it.</source>
          <target state="translated">如果 HRESULT 映射到已定义的异常，<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A&gt;</ph>创建异常的实例并引发它。</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>Otherwise, it creates an instance of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.COMException?displayProperty=nameWithType&gt;</ph>, initializes the error code field with the HRESULT, and throws that exception.</source>
          <target state="translated">否则，它创建的实例<ph id="ph1">&lt;xref:System.Runtime.InteropServices.COMException?displayProperty=nameWithType&gt;</ph>，初始化错误代码字段，HRESULT，并会引发该异常。</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>The <ph id="ph1">`errorInfo`</ph> parameter is used to retrieve extra information regarding the error.</source>
          <target state="translated"><ph id="ph1">`errorInfo`</ph>参数用于检索有关错误的额外信息。</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see <bpt id="p1">[</bpt>How to: Map HRESULTs and Exceptions<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>.</source>
          <target state="translated">从每个 HRESULT 到其.NET Framework 中的相似异常类的映射，请参阅<bpt id="p1">[</bpt>如何： 映射 Hresult 和异常<ept id="p1">](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)</ept>。</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)">
          <source>The array that contains the desired element.</source>
          <target state="translated">包含所需元素的数组。</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)">
          <source>The index in the <bpt id="p1">&lt;c&gt;</bpt>arr<ept id="p1">&lt;/c&gt;</ept> parameter of the desired element.</source>
          <target state="translated">所需元素的 <bpt id="p1">&lt;c&gt;</bpt>arr<ept id="p1">&lt;/c&gt;</ept> 参数中的索引。</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)">
          <source>Gets the address of the element at the specified index inside the specified array.</source>
          <target state="translated">获取指定数组中指定索引处的元素的地址。</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)">
          <source>The address of <ph id="ph1">&lt;paramref name="index" /&gt;</ph> inside <ph id="ph2">&lt;paramref name="arr" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="arr" /&gt;</ph> 内的 <ph id="ph1">&lt;paramref name="index" /&gt;</ph> 地址。</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)">
          <source>The array must be pinned using a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle&gt;</ph> before it is passed to this method.</source>
          <target state="translated">必须使用固定数组<ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle&gt;</ph>传递给此方法之前。</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)">
          <source>For maximum performance, this method does not validate the array passed to it; this can result in unexpected behavior.</source>
          <target state="translated">为获得最佳性能，此方法不会验证传递给它; 数组这可能导致意外行为。</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>The type of the array.</source>
          <target state="translated">数组的类型。</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>The array that contains the desired element.</source>
          <target state="translated">包含所需元素的数组。</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>The index of the desired element in the <bpt id="p1">&lt;c&gt;</bpt>arr<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>arr<ept id="p1">&lt;/c&gt;</ept> 数组中所需元素的索引。</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>[Supported in the .NET Framework 4.5.1 and later versions]</source>
          <target state="translated">[在 .NET Framework 4.5.1 和更高版本中受支持]</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>Gets the address of the element at the specified index in an array of a specified type.</source>
          <target state="translated">获取指定类型的数组中指定索引处的元素地址。</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>The address of <ph id="ph1">&lt;paramref name="index" /&gt;</ph> in <ph id="ph2">&lt;paramref name="arr" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="arr" /&gt;</ph> 中的 <ph id="ph1">&lt;paramref name="index" /&gt;</ph> 地址。</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>The array must be pinned by using a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle&gt;</ph> before it is passed to this method.</source>
          <target state="translated">必须通过使用固定数组<ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle&gt;</ph>传递给此方法之前。</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>For maximum performance, this method does not validate the array passed to it; this can result in unexpected behavior.</source>
          <target state="translated">为获得最佳性能，此方法不会验证传递给它; 数组这可能导致意外行为。</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Writes a single byte value to unmanaged memory.</source>
          <target state="translated">将单个字节值写入到非托管内存。</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source>The address in unmanaged memory to write to.</source>
          <target state="translated">非托管内存中要写入的地址。</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source>The value to write.</source>
          <target state="translated">要写入的值。</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source>Writes a single byte value to unmanaged memory.</source>
          <target state="translated">将单个字节值写入到非托管内存。</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> 使你能够直接与非托管的 C 样式字节数组，不用复制整个的非托管的数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到之前设置它的元素值的单独托管数组。</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source>The following example creates a block of unmanaged memory, writes a byte to the unmanaged memory, reads the byte back from unmanaged memory, and then disposes the unmanaged memory.</source>
          <target state="translated">下面的示例创建的非托管内存块、 将一个字节写入的非托管内存、 从非托管内存读取字节，然后释放的非托管的内存。</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 不是识别的格式。</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)">
          <source>The base address in unmanaged memory to write to.</source>
          <target state="translated">非托管内存中要写入的基址。</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">额外的字节偏移量，在写入前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)">
          <source>The value to write.</source>
          <target state="translated">要写入的值。</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)">
          <source>Writes a single byte value to unmanaged memory at a specified offset.</source>
          <target state="translated">按指定偏移量将单字节值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> 使你能够直接与非托管的 C 样式字节数组，不用复制整个的非托管的数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到之前设置它的元素值的单独托管数组。</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadByte%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source>The base address in unmanaged memory of the target object.</source>
          <target state="translated">非托管内存中目标对象的基址。</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">额外的字节偏移量，在写入前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source>The value to write.</source>
          <target state="translated">要写入的值。</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source>Writes a single byte value to unmanaged memory at a specified offset.</source>
          <target state="translated">按指定偏移量将单字节值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteByte%2A&gt;</ph> 使你能够直接与非托管的 C 样式字节数组，不用复制整个的非托管的数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到之前设置它的元素值的单独托管数组。</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 是 <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">此方法不接受 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Writes a 16-bit signed integer value to unmanaged memory.</source>
          <target state="translated">将 16 位带符号整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source>The address in unmanaged memory to write to.</source>
          <target state="translated">非托管内存中要写入的地址。</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source>The value to write.</source>
          <target state="translated">要写入的值。</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source>Writes a character as a 16-bit integer value to unmanaged memory.</source>
          <target state="translated">将一个字符作为 16 位整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> 使你能够直接与不用复制整个的非托管的数组的非托管 16 位有符号数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到之前设置它的元素值的单独托管数组。</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 不是识别的格式。</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source>The address in unmanaged memory to write to.</source>
          <target state="translated">非托管内存中要写入的地址。</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source>The value to write.</source>
          <target state="translated">要写入的值。</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source>Writes a 16-bit integer value to unmanaged memory.</source>
          <target state="translated">将 16 位整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> 使你能够直接与不用复制整个的非托管的数组的非托管 16 位有符号数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到之前设置它的元素值的单独托管数组。</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 不是识别的格式。</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source>The base address in the native heap to write to.</source>
          <target state="translated">本机堆中要写入的基址。</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">额外的字节偏移量，在写入前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source>The value to write.</source>
          <target state="translated">要写入的值。</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source>Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</source>
          <target state="translated">按指定偏移量将 16 位带符号整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> 使你能够直接与不用复制整个的非托管的数组的非托管 16 位有符号数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到之前设置它的元素值的单独托管数组。</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source>The base address in unmanaged memory to write to.</source>
          <target state="translated">非托管内存中要写入的基址。</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">额外的字节偏移量，在写入前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source>The value to write.</source>
          <target state="translated">要写入的值。</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source>Writes a 16-bit signed integer value into unmanaged memory at a specified offset.</source>
          <target state="translated">按指定偏移量将 16 位带符号整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> 使你能够直接与不用复制整个的非托管的数组的非托管 16 位有符号数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到之前设置它的元素值的单独托管数组。</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source>The base address in unmanaged memory of the target object.</source>
          <target state="translated">非托管内存中目标对象的基址。</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">额外的字节偏移量，在写入前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source>The value to write.</source>
          <target state="translated">要写入的值。</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source>Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</source>
          <target state="translated">按指定偏移量将 16 位带符号整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> 使你能够直接与不用复制整个的非托管的数组的非托管 16 位有符号数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到之前设置它的元素值的单独托管数组。</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 是 <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">此方法不接受 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source>The base address in unmanaged memory of the target object.</source>
          <target state="translated">非托管内存中目标对象的基址。</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">额外的字节偏移量，在写入前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source>The value to write.</source>
          <target state="translated">要写入的值。</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source>Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</source>
          <target state="translated">按指定偏移量将 16 位带符号整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A&gt;</ph> 使你能够直接与不用复制整个的非托管的数组的非托管 16 位有符号数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到之前设置它的元素值的单独托管数组。</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 是 <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">此方法不接受 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Writes a 32-bit signed integer value to unmanaged memory.</source>
          <target state="translated">将 32 位带符号整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source>The address in unmanaged memory to write to.</source>
          <target state="translated">非托管内存中要写入的地址。</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source>The value to write.</source>
          <target state="translated">要写入的值。</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source>Writes a 32-bit signed integer value to unmanaged memory.</source>
          <target state="translated">将 32 位带符号整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> 使你能够直接与不用复制整个的非托管的数组的非托管 32 位有符号数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到之前设置它的元素值的单独托管数组。</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 不是识别的格式。</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source>The base address in unmanaged memory to write to.</source>
          <target state="translated">非托管内存中要写入的基址。</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">额外的字节偏移量，在写入前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source>The value to write.</source>
          <target state="translated">要写入的值。</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source>Writes a 32-bit signed integer value into unmanaged memory at a specified offset.</source>
          <target state="translated">按指定偏移量将 32 位带符号整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> 使你能够直接与不用复制整个的非托管的数组的非托管 32 位有符号数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到之前设置它的元素值的单独托管数组。</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source>The base address in unmanaged memory of the target object.</source>
          <target state="translated">非托管内存中目标对象的基址。</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">额外的字节偏移量，在写入前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source>The value to write.</source>
          <target state="translated">要写入的值。</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source>Writes a 32-bit signed integer value to unmanaged memory at a specified offset.</source>
          <target state="translated">按指定偏移量将 32 位带符号整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A&gt;</ph> 使你能够直接与不用复制整个的非托管的数组的非托管 32 位有符号数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到之前设置它的元素值的单独托管数组。</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 是 <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">此方法不接受 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Writes a 64-bit signed integer value to unmanaged memory.</source>
          <target state="translated">将 64 位带符号整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source>The address in unmanaged memory to write to.</source>
          <target state="translated">非托管内存中要写入的地址。</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source>The value to write.</source>
          <target state="translated">要写入的值。</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source>Writes a 64-bit signed integer value to unmanaged memory.</source>
          <target state="translated">将 64 位带符号整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> 使你能够直接与不用复制整个的非托管的数组的非托管 64 位有符号数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到之前设置它的元素值的单独托管数组。</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 不是识别的格式。</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source>The base address in unmanaged memory to write.</source>
          <target state="translated">非托管内存中要写入的基址。</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">额外的字节偏移量，在写入前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source>The value to write.</source>
          <target state="translated">要写入的值。</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source>Writes a 64-bit signed integer value to unmanaged memory at a specified offset.</source>
          <target state="translated">按指定偏移量将 64 位带符号整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> 使你能够直接与不用复制整个的非托管的数组的非托管 64 位有符号数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到之前设置它的元素值的单独托管数组。</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source>The base address in unmanaged memory of the target object.</source>
          <target state="translated">非托管内存中目标对象的基址。</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">额外的字节偏移量，在写入前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source>The value to write.</source>
          <target state="translated">要写入的值。</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source>Writes a 64-bit signed integer value to unmanaged memory at a specified offset.</source>
          <target state="translated">按指定偏移量将 64 位带符号整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A&gt;</ph> 使你能够直接与不用复制整个的非托管的数组的非托管 64 位有符号数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到之前设置它的元素值的单独托管数组。</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 是 <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">此方法不接受 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Writes a processor native-sized integer value to unmanaged memory.</source>
          <target state="translated">将一个处理器本机大小的整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>32-bit integers are written on 32-bit systems, and 64-bit integers are written on 64-bit systems.</source>
          <target state="translated">在 32 位系统上写入 32 位整数，在 64 位系统上写入 64 位整数。</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.Marshal">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source>The address in unmanaged memory to write to.</source>
          <target state="translated">非托管内存中要写入的地址。</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source>The value to write.</source>
          <target state="translated">要写入的值。</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source>Writes a processor native sized integer value into unmanaged memory.</source>
          <target state="translated">将一个处理器本机大小的整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> enables direct interaction with an unmanaged C-style <ph id="ph2">`IntPtr`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> 使你能够直接与非托管的 C 样式的交互<ph id="ph2">`IntPtr`</ph>数组，消除了将整个的非托管的数组复制的开销 (使用<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到之前设置它的元素值的单独托管数组。</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is not a recognized format.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 不是识别的格式。</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 为 <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source>-or-</source>
          <target state="translated">或</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 无效。</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>The base address in unmanaged memory to write to.</source>
          <target state="translated">非托管内存中要写入的基址。</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">额外的字节偏移量，在写入前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>The value to write.</source>
          <target state="translated">要写入的值。</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>Writes a processor native-sized integer value to unmanaged memory at a specified offset.</source>
          <target state="translated">按指定的偏移量将一个处理器本机大小的整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>This method writes a 32 bit integer on 32 bit systems, and a 64 bit integer on 64 bit systems.</source>
          <target state="translated">此方法将在 32 位系统和在 64 位系统上的 64 位整数上写入 32 位整数。</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> enables direct interaction with an unmanaged C-style <ph id="ph2">`IntPtr`</ph> array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> 使你能够直接与非托管的 C 样式的交互<ph id="ph2">`IntPtr`</ph>数组，消除了将整个的非托管的数组复制的开销 (使用<ph id="ph3">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到之前设置它的元素值的单独托管数组。</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>The following example demonstrates how to read and write to an unmanaged array using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> methods.</source>
          <target state="translated">下面的示例演示如何读取和写入到非托管的数组使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A&gt;</ph>和<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source>The base address in unmanaged memory of the target object.</source>
          <target state="translated">非托管内存中目标对象的基址。</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source>An additional byte offset, which is added to the <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> parameter before writing.</source>
          <target state="translated">额外的字节偏移量，在写入前添加到 <bpt id="p1">&lt;c&gt;</bpt>ptr<ept id="p1">&lt;/c&gt;</ept> 参数中。</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source>The value to write.</source>
          <target state="translated">要写入的值。</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source>Writes a processor native sized integer value to unmanaged memory.</source>
          <target state="translated">将一个处理器本机大小的整数值写入非托管内存。</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) to a separate managed array before setting its element values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A&gt;</ph> 使你能够直接与非托管的 C 样式字节数组，不用复制整个的非托管的数组的交互 (使用<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType&gt;</ph>) 到之前设置它的元素值的单独托管数组。</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source>Writing to unaligned memory locations is supported.</source>
          <target state="translated">支持写入未对齐的内存位置。</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source>Base address (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) plus offset byte (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) produces a null or invalid address.</source>
          <target state="translated">基址 (<ph id="ph1">&lt;paramref name="ptr" /&gt;</ph>) 加上偏移字节 (<ph id="ph2">&lt;paramref name="ofs" /&gt;</ph>) 可产生空或无效地址。</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> is an <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="ptr" /&gt;</ph> 是 <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 对象。</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source>This method does not accept <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> parameters.</source>
          <target state="translated">此方法不接受 <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /&gt;</ph> 参数。</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)">
          <source>The address of the <ph id="ph1">&lt;see langword="BSTR" /&gt;</ph> to free.</source>
          <target state="translated">要释放的 <ph id="ph1">&lt;see langword="BSTR" /&gt;</ph> 的地址。</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)">
          <source>Frees a <bpt id="p1">[</bpt>BSTR<ept id="p1">](https://msdn.microsoft.com/library/ms221069.aspx)</ept> pointer that was allocated using the <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" /&gt;</ph> method.</source>
          <target state="translated">释放 <bpt id="p1">[</bpt>BSTR<ept id="p1">](https://msdn.microsoft.com/library/ms221069.aspx)</ept> 指针，该指针是使用 <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" /&gt;</ph> 方法分配的。</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A&gt;</ph> method first sets the contents of the BSTR to zero, and then frees the BSTR.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A&gt;</ph>方法首先设置为零，BSTR 的内容，然后释放的 BSTR。</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)">
          <source>The address of the unmanaged string to free.</source>
          <target state="translated">要释放的非托管字符串的地址。</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)">
          <source>Frees an unmanaged string pointer that was allocated using the <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" /&gt;</ph> method.</source>
          <target state="translated">释放非托管字符串指针，该指针是使用 <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" /&gt;</ph> 方法分配的。</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A&gt;</ph> method first zeros out and then frees unmanaged memory that was allocated using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A&gt;</ph>方法首先零出，然后释放已使用分配的非托管的内存<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A&gt;</ph> method to marshal and decrypt the contents of a <ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph> object to a block of unmanaged memory.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A&gt;</ph>方法进行封送和解密的内容<ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph>到非托管内存块的对象。</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)">
          <source>It then uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A&gt;</ph> method to zero out and dispose the unmanaged block.</source>
          <target state="translated">然后，它使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A&gt;</ph>清空并释放非托管的块的方法。</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)">
          <source>The address of the unmanaged string to free.</source>
          <target state="translated">要释放的非托管字符串的地址。</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)">
          <source>Frees an unmanaged string pointer that was allocated using the <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" /&gt;</ph> method.</source>
          <target state="translated">释放非托管字符串指针，该指针是使用 <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" /&gt;</ph> 方法分配的。</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A&gt;</ph> method first zeros out and then frees unmanaged memory that was allocated using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A&gt;</ph>方法首先零出，然后释放已使用分配的非托管的内存<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)">
          <source>The address of the unmanaged string to free.</source>
          <target state="translated">要释放的非托管字符串的地址。</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)">
          <source>Frees an unmanaged string pointer that was allocated using the <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" /&gt;</ph> method.</source>
          <target state="translated">释放非托管字符串指针，该指针是使用 <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" /&gt;</ph> 方法分配的。</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A&gt;</ph> method first zeros out and then frees unmanaged memory that was allocated using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A&gt;</ph>方法首先零出，然后释放已使用分配的非托管的内存<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A&gt;</ph> method to marshal and decrypt the contents of a <ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph> object to a block of unmanaged memory.</source>
          <target state="translated">下面的示例使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A&gt;</ph>方法进行封送和解密的内容<ph id="ph2">&lt;xref:System.Security.SecureString&gt;</ph>到非托管内存块的对象。</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)">
          <source>It then uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A&gt;</ph> method to zero out and dispose the unmanaged block.</source>
          <target state="translated">然后，它使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A&gt;</ph>清空并释放非托管的块的方法。</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)">
          <source>The address of the unmanaged string to free.</source>
          <target state="translated">要释放的非托管字符串的地址。</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)">
          <source>Frees an unmanaged string pointer that was allocated using the <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" /&gt;</ph> method.</source>
          <target state="translated">释放非托管字符串指针，该指针是使用 <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" /&gt;</ph> 方法分配的。</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A&gt;</ph> method first zeros out and then frees unmanaged memory that was allocated using the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A&gt;</ph>方法首先零出，然后释放已使用分配的非托管的内存<ph id="ph2">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A&gt;</ph>方法。</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A&gt;</ph> method with the unmanaged <ph id="ph2">`LogonUser`</ph> function to perform impersonation with the <ph id="ph3">&lt;xref:System.Security.SecureString&gt;</ph> class.</source>
          <target state="translated">下面的示例演示如何使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A&gt;</ph>与非托管方法<ph id="ph2">`LogonUser`</ph>函数来执行模拟<ph id="ph3">&lt;xref:System.Security.SecureString&gt;</ph>类。</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)">
          <source>The example then uses the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A&gt;</ph> method to zero out and free the unmanaged string reference.</source>
          <target state="translated">然后该示例使用<ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A&gt;</ph>清零并释放非托管的字符串引用的方法。</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">需要完全信任直接调用方。</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">此成员不能由部分受信任或不透明的代码。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>