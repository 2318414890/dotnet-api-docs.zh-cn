<Type Name="CriticalHandle" FullName="System.Runtime.InteropServices.CriticalHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="75db119abc6e44bc32148b4932aafa4b6e380d6e" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36634095" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CriticalHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CriticalHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.CriticalHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CriticalHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class CriticalHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="F#" Value="type CriticalHandle = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="9c6b7-101">Represents a wrapper class for handle resources.</span>
      <span class="sxs-lookup">
        <span data-stu-id="9c6b7-101">Represents a wrapper class for handle resources.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9c6b7-102"><xref:System.Runtime.InteropServices.CriticalHandle>类是类似于<xref:System.Runtime.InteropServices.SafeHandle>类，只不过<xref:System.Runtime.InteropServices.SafeHandle>实现引用计数。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-102">The <xref:System.Runtime.InteropServices.CriticalHandle> class is similar to the <xref:System.Runtime.InteropServices.SafeHandle> class, except that <xref:System.Runtime.InteropServices.SafeHandle> implements reference counting.</span></span> <span data-ttu-id="9c6b7-103">你可以使用<xref:System.Runtime.InteropServices.CriticalHandle>而不是<xref:System.Runtime.InteropServices.SafeHandle>来解决性能问题的详细信息提供必要的同步时有效地自己。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-103">You can use <xref:System.Runtime.InteropServices.CriticalHandle> instead of <xref:System.Runtime.InteropServices.SafeHandle> to address performance considerations when you can provide the necessary synchronization more efficiently yourself.</span></span>  
  
 <span data-ttu-id="9c6b7-104">因为<xref:System.Runtime.InteropServices.CriticalHandle>类不会执行引用计数，但不提供从句柄回收安全攻击的保护。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-104">Because the <xref:System.Runtime.InteropServices.CriticalHandle> class does not perform reference counting, it does not provide protection from handle recycling security attacks.</span></span> <span data-ttu-id="9c6b7-105">由于引用隐式计数算法序列化操作，也会丢失了一定数量的线程安全性。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-105">Because the reference counting algorithm implicitly serializes operations, a certain amount of thread safety is also lost.</span></span> <span data-ttu-id="9c6b7-106">如果调用<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>或<xref:System.Runtime.InteropServices.SafeHandle.Close%2A>方法使用此句柄的操作未在另一个线程上完成时或如果调用<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>或<xref:System.Runtime.InteropServices.SafeHandle.Close%2A>从在同一时间的两个线程，则结果是不确定。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-106">If you call the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method while an operation that is using the handle is outstanding on another thread, or if you call <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> from two threads at the same time, the results are non-deterministic.</span></span> <span data-ttu-id="9c6b7-107"><xref:System.Runtime.InteropServices.CriticalHandle>类仍提供有保证的关键终止<xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>类。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-107">The <xref:System.Runtime.InteropServices.CriticalHandle> class still provides the guaranteed critical finalization provided by the <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> class.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="9c6b7-108">对继承者的完全信任。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9c6b7-108">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="9c6b7-109">此成员不能由部分受信任的代码继承。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9c6b7-109">This member cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">
      <span data-ttu-id="9c6b7-110">需要完全信任直接调用方。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9c6b7-110">requires full trust for the immediate caller.</span>
      </span>
      <span data-ttu-id="9c6b7-111">此类不能由部分受信任的或透明的代码使用。</span>
      <span class="sxs-lookup">
        <span data-stu-id="9c6b7-111">This class cannot be used by partially trusted or transparent code.</span>
      </span>
    </permission>
    <altmember cref="T:System.Runtime.InteropServices.SafeHandle" />
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CriticalHandle (IntPtr invalidHandleValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CriticalHandle(IntPtr invalidHandleValue);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.CriticalHandle : nativeint -&gt; System.Runtime.InteropServices.CriticalHandle" Usage="new System.Runtime.InteropServices.CriticalHandle invalidHandleValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">
          <span data-ttu-id="9c6b7-112">The value of an invalid handle (usually 0 or -1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-112">The value of an invalid handle (usually 0 or -1).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9c6b7-113">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> class with the specified invalid handle value.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-113">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> class with the specified invalid handle value.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="9c6b7-114">The derived class resides in an assembly without unmanaged code access permission.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-114">The derived class resides in an assembly without unmanaged code access permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="9c6b7-115">对继承者的完全信任。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-115">for full trust for inheritors.</span>
          </span>
          <span data-ttu-id="9c6b7-116">此成员不能由部分受信任的代码继承。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-116">This member cannot be inherited by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="9c6b7-117">需要完全信任直接调用方。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-117">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="9c6b7-118">此类不能由部分受信任的或透明的代码使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-118">This class cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="criticalHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9c6b7-119">Marks the handle for releasing and freeing resources.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-119">Marks the handle for releasing and freeing resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9c6b7-120">调用<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>或<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>方法允许资源被释放。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-120">Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="9c6b7-121">与不同<xref:System.Runtime.InteropServices.SafeHandle>类，这将始终会发生直接执行，因为没有任何引用计数，以指示其他线程正在使用此句柄。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-121">Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</span></span> <span data-ttu-id="9c6b7-122">因此，你必须使用同步机制，以确保它是安全地调用<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-122">Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method.</span></span> <span data-ttu-id="9c6b7-123">尽管大多数类使用<xref:System.Runtime.InteropServices.CriticalHandle>类不需要提供了终结器，有时这是必要 （例如，清空文件缓冲区，或编写一些数据回发到内存）。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-123">Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="9c6b7-124">在这种情况下，类可以提供保证之前运行了终结器<xref:System.Runtime.InteropServices.CriticalHandle>重要终结器运行。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-124">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="9c6b7-125">调用<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>或<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>方法完成后使用<xref:System.Runtime.InteropServices.CriticalHandle>对象。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-125">Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="9c6b7-126"><xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>方法使<xref:System.Runtime.InteropServices.CriticalHandle>中不可用状态的对象。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-126">The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.</span></span>  
  
 <span data-ttu-id="9c6b7-127">**请注意**始终调用<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>或<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>在发布到最后一个引用之前<xref:System.Runtime.InteropServices.CriticalHandle>对象。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-127">**Note** Always call <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="9c6b7-128">否则，在垃圾回收器调用 <xref:System.Runtime.InteropServices.CriticalHandle> 对象的 <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> 方法之前，该对象正在使用的资源不会被释放。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-128">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="9c6b7-129">Marks the handle for releasing and freeing resources.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-129">Marks the handle for releasing and freeing resources.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="criticalHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9c6b7-130">Releases all resources used by the <see cref="T:System.Runtime.InteropServices.CriticalHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-130">Releases all resources used by the <see cref="T:System.Runtime.InteropServices.CriticalHandle" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9c6b7-131">调用<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>或<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>方法允许资源被释放。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-131">Calling the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="9c6b7-132">与不同<xref:System.Runtime.InteropServices.SafeHandle>类，这将始终会发生直接执行，因为没有任何引用计数，以指示其他线程正在使用此句柄。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-132">Unlike the <xref:System.Runtime.InteropServices.SafeHandle> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</span></span> <span data-ttu-id="9c6b7-133">因此，你必须使用同步机制，以确保它是安全地调用<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-133">Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method.</span></span> <span data-ttu-id="9c6b7-134">尽管大多数类使用<xref:System.Runtime.InteropServices.CriticalHandle>类不需要提供了终结器，有时这是必要 （例如，清空文件缓冲区，或编写一些数据回发到内存）。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-134">Although most classes that use the <xref:System.Runtime.InteropServices.CriticalHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="9c6b7-135">在这种情况下，类可以提供保证之前运行了终结器<xref:System.Runtime.InteropServices.CriticalHandle>重要终结器运行。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-135">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.CriticalHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="9c6b7-136">调用<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>或<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>方法完成后使用<xref:System.Runtime.InteropServices.CriticalHandle>对象。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-136">Call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="9c6b7-137"><xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>方法使<xref:System.Runtime.InteropServices.CriticalHandle>中不可用状态的对象。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-137">The <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.CriticalHandle> object in an unusable state.</span></span>  
  
 <span data-ttu-id="9c6b7-138">**请注意**始终调用<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>或<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>方法在发布到最后一个引用之前<xref:System.Runtime.InteropServices.CriticalHandle>对象。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-138">**Note** Always call the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.CriticalHandle> object.</span></span> <span data-ttu-id="9c6b7-139">否则，在垃圾回收器调用 <xref:System.Runtime.InteropServices.CriticalHandle> 对象的 <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> 方法之前，该对象正在使用的资源不会被释放。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-139">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.CriticalHandle> object's <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="criticalHandle.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="9c6b7-140">
            <see langword="true" /> for a normal dispose operation; <see langword="false" /> to finalize the handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-140">
              <see langword="true" /> for a normal dispose operation; <see langword="false" /> to finalize the handle.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9c6b7-141">Releases the unmanaged resources used by the <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> class specifying whether to perform a normal dispose operation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-141">Releases the unmanaged resources used by the <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> class specifying whether to perform a normal dispose operation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9c6b7-142">你应永远不会显式调用<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>方法替换`disposing`参数设置为`false`。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-142">You should never explicitly call the <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method with the `disposing` parameter set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~CriticalHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!CriticalHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="criticalHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9c6b7-143">Frees all resources associated with the handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-143">Frees all resources associated with the handle.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9c6b7-144"><xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A>方法是的析构函数<xref:System.Runtime.InteropServices.CriticalHandle>类。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-144">The <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.CriticalHandle> class.</span></span> <span data-ttu-id="9c6b7-145">应用程序代码不应直接调用此方法。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-145">Application code should not call this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.CriticalHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberSignature Language="F#" Value="val mutable handle : nativeint" Usage="System.Runtime.InteropServices.CriticalHandle.handle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9c6b7-146">Specifies the handle to be wrapped.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-146">Specifies the handle to be wrapped.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9c6b7-147">公开不公开句柄 (即，派生类的外部)。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-147">Do not expose the handle publicly (that is, outside of the derived class).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Runtime.InteropServices.CriticalHandle.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9c6b7-148">Gets a value indicating whether the handle is closed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-148">Gets a value indicating whether the handle is closed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9c6b7-149">如果句柄已关闭，则为 <see langword="true" />；否则为 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-149">
              <see langword="true" /> if the handle is closed; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9c6b7-150"><xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A>方法返回一个值，该值指示是否<xref:System.Runtime.InteropServices.CriticalHandle>对象的句柄不再与本机资源相关联。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-150">The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.CriticalHandle> object's handle is no longer associated with a native resource.</span></span> <span data-ttu-id="9c6b7-151">这不同于的定义<xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A>属性，用于计算是否给定句柄是否始终被视为无效。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-151">This differs from the definition of the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid.</span></span> <span data-ttu-id="9c6b7-152"><xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A>方法返回`true`在以下情况下的值：</span><span class="sxs-lookup"><span data-stu-id="9c6b7-152">The <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> method returns a `true` value in the following cases:</span></span>  
  
-   <span data-ttu-id="9c6b7-153"><xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A>调用了方法。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-153">The <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method was called.</span></span>  
  
-   <span data-ttu-id="9c6b7-154"><xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>方法或<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>调用了方法，并且有没有对引用<xref:System.Runtime.InteropServices.CriticalHandle>其他线程上的对象。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-154">The <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.CriticalHandle> object on other threads.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInvalid : bool" Usage="System.Runtime.InteropServices.CriticalHandle.IsInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="9c6b7-155">When overridden in a derived class, gets a value indicating whether the handle value is invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-155">When overridden in a derived class, gets a value indicating whether the handle value is invalid.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="9c6b7-156">
            <see langword="true" /> 如果句柄有效，则为否则为<see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-156">
              <see langword="true" /> if the handle is valid; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9c6b7-157">派生的类必须实现<xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A>属性，以便公共语言运行时能够确定是否需要关键完成。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-157">Derived classes must implement the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required.</span></span> <span data-ttu-id="9c6b7-158">派生的类必须提供一个适合它们支持的句柄的常规类型的实现 （0 或-1 是无效的）。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-158">Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).</span></span> <span data-ttu-id="9c6b7-159">这些类可以然后进一步派生为特定的安全句柄类型。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-159">These classes can then be further derived for specific safe handle types.</span></span>  
  
 <span data-ttu-id="9c6b7-160">与不同<xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A>属性，用于报告是否<xref:System.Runtime.InteropServices.CriticalHandle>对象已完成使用基础句柄，<xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A>属性前者是否给定句柄值是否始终被视为无效。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-160">Unlike the <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.CriticalHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid.</span></span> <span data-ttu-id="9c6b7-161">因此，<xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A>属性始终返回相同的值的任何一个的句柄值。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-161">Therefore, the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> property always returns the same value for any one handle value.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHandle : unit -&gt; bool" Usage="criticalHandle.ReleaseHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9c6b7-162">When overridden in a derived class, executes the code required to free the handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-162">When overridden in a derived class, executes the code required to free the handle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="9c6b7-163">
            <see langword="true" /> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-163">
              <see langword="true" /> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="9c6b7-164">In this case, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-164">In this case, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9c6b7-165"><xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>方法保证只能调用一次，前提是你采用的是正确的同步机制，以确保该只有一个调用<xref:System.Runtime.InteropServices.CriticalHandle.Close%2A>或<xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A>方法由。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-165">The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method is guaranteed to be called only once, provided that you employ proper synchronization mechanisms to ensure that only one call to the <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> method is made.</span></span> <span data-ttu-id="9c6b7-166"><xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>将不调用方法，如果<xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A>或<xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A>属性是`true`。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-166">The <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method will not be called if the <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> or <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> property is `true`.</span></span> <span data-ttu-id="9c6b7-167">实现此方法在你<xref:System.Runtime.InteropServices.CriticalHandle>派生类，以执行释放句柄所需的任何代码。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-167">Implement this method in your <xref:System.Runtime.InteropServices.CriticalHandle> derived classes to execute any code that is required to free the handle.</span></span> <span data-ttu-id="9c6b7-168">因为函数之一<xref:System.Runtime.InteropServices.CriticalHandle>要保证防止资源泄漏中的实现的代码<xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>必须永远不会失败。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-168">Because one of the functions of <xref:System.Runtime.InteropServices.CriticalHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> must never fail.</span></span> <span data-ttu-id="9c6b7-169">垃圾回收器调用<xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>常规终结器已运行的对象进行垃圾回收在相同的时间，并保证的资源来调用和，不会中断时它正在进行后。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-169">The garbage collector calls <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> after normal finalizers have been run for objects that were garbage collected at the same time, and guarantees the resources to invoke it and that it will not be interrupted while it is in progress.</span></span> <span data-ttu-id="9c6b7-170">此方法将准备作为受约束的执行区域 (CER) 中，在实例构造时 （以及其静态确定的调用关系图中的所有方法） 中。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-170">This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).</span></span> <span data-ttu-id="9c6b7-171">尽管这会使线程中止中断，但是你仍必须注意不要引入在重写任何错误路径<xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-171">Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method.</span></span> <span data-ttu-id="9c6b7-172">具体而言，适用<xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>属性设为从调用任何方法<xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-172">In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>.</span></span> <span data-ttu-id="9c6b7-173">在大多数情况下应为此代码：</span><span class="sxs-lookup"><span data-stu-id="9c6b7-173">In most cases this code should be:</span></span>  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 <span data-ttu-id="9c6b7-174">此外，对于简单清理 (例如，调用 Win32 API`CloseHandle`上的文件句柄) 你可以检查单个平台 invoke 调用的返回值。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-174">Additionally, for simple cleanup (for example, calling the Win32 API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call.</span></span> <span data-ttu-id="9c6b7-175">对于复杂清理，可能有大量程序逻辑和许多方法调用，其中一些可能会失败。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-175">For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.</span></span> <span data-ttu-id="9c6b7-176">你必须确保程序逻辑的这种情况下每个具有回退的代码。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-176">You must ensure that your program logic has fallback code for each of those cases.</span></span>  
  
 <span data-ttu-id="9c6b7-177">如果<xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>方法返回`false`出于任何原因，它会生成[releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)托管调试助手。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-177">If the <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> method returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="member this.SetHandle : nativeint -&gt; unit" Usage="criticalHandle.SetHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="9c6b7-178">The pre-existing handle to use.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-178">The pre-existing handle to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="9c6b7-179">Sets the handle to the specified pre-existing handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-179">Sets the handle to the specified pre-existing handle.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9c6b7-180">使用<xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A>方法只有在需要支持预先存在的句柄 （例如，如果结构中返回的句柄），因为.NET Framework COM 互操作的基础结构不支持封送处理结构中。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-180">Use the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling handles in a structure.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberSignature Language="F#" Value="member this.SetHandleAsInvalid : unit -&gt; unit" Usage="criticalHandle.SetHandleAsInvalid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="9c6b7-181">Marks a handle as invalid.</span>
          <span class="sxs-lookup">
            <span data-stu-id="9c6b7-181">Marks a handle as invalid.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9c6b7-182">调用<xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A>方法仅当你知道你句柄无效，并且你想要将其标记为时。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-182">Call the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> method only when you know that your handle is invalid and you want to mark it as such.</span></span> <span data-ttu-id="9c6b7-183">执行此操作不会更改的值<xref:System.Runtime.InteropServices.CriticalHandle.handle>字段; 它仅将标记为无效的句柄。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-183">Doing so does not change the value of the <xref:System.Runtime.InteropServices.CriticalHandle.handle> field; it only marks the handle as invalid.</span></span> <span data-ttu-id="9c6b7-184">然后，句柄可能包含一个潜在的陈旧的值。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-184">The handle might then contain a potentially stale value.</span></span> <span data-ttu-id="9c6b7-185">此调用的效果是，不会释放资源。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-185">The effect of this call is that no attempt is made to free the resources.</span></span>  
  
 <span data-ttu-id="9c6b7-186">与<xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A>方法，请使用<xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A>仅当你需要支持预先存在的句柄。</span><span class="sxs-lookup"><span data-stu-id="9c6b7-186">As with the <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>